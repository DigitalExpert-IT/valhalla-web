function ed(n, e) {
  const t = Object.create(null),
    i = n.split(",")
  for (let r = 0; r < i.length; r++) t[i[r]] = !0
  return e ? r => !!t[r.toLowerCase()] : r => !!t[r]
}
const $S =
    "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt",
  QS = ed($S),
  XS =
    "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
  YS = ed(XS)
function db(n) {
  return !!n || n === ""
}
function Mu(n) {
  if (vt(n)) {
    const e = {}
    for (let t = 0; t < n.length; t++) {
      const i = n[t],
        r = Tn(i) ? KS(i) : Mu(i)
      if (r) for (const s in r) e[s] = r[s]
    }
    return e
  } else {
    if (Tn(n)) return n
    if (In(n)) return n
  }
}
const ZS = /;(?![^(]*\))/g,
  JS = /:(.+)/
function KS(n) {
  const e = {}
  return (
    n.split(ZS).forEach(t => {
      if (t) {
        const i = t.split(JS)
        i.length > 1 && (e[i[0].trim()] = i[1].trim())
      }
    }),
    e
  )
}
function Ps(n) {
  let e = ""
  if (Tn(n)) e = n
  else if (vt(n))
    for (let t = 0; t < n.length; t++) {
      const i = Ps(n[t])
      i && (e += i + " ")
    }
  else if (In(n)) for (const t in n) n[t] && (e += t + " ")
  return e.trim()
}
function pb(n) {
  if (!n) return null
  let { class: e, style: t } = n
  return e && !Tn(e) && (n.class = Ps(e)), t && (n.style = Mu(t)), n
}
function e7(n, e) {
  if (n.length !== e.length) return !1
  let t = !0
  for (let i = 0; t && i < n.length; i++) t = Io(n[i], e[i])
  return t
}
function Io(n, e) {
  if (n === e) return !0
  let t = $y(n),
    i = $y(e)
  if (t || i) return t && i ? n.getTime() === e.getTime() : !1
  if (((t = zA(n)), (i = zA(e)), t || i)) return n === e
  if (((t = vt(n)), (i = vt(e)), t || i)) return t && i ? e7(n, e) : !1
  if (((t = In(n)), (i = In(e)), t || i)) {
    if (!t || !i) return !1
    const r = Object.keys(n).length,
      s = Object.keys(e).length
    if (r !== s) return !1
    for (const o in n) {
      const a = n.hasOwnProperty(o),
        A = e.hasOwnProperty(o)
      if ((a && !A) || (!a && A) || !Io(n[o], e[o])) return !1
    }
  }
  return String(n) === String(e)
}
function td(n, e) {
  return n.findIndex(t => Io(t, e))
}
const vr = n =>
    Tn(n)
      ? n
      : n == null
      ? ""
      : vt(n) || (In(n) && (n.toString === gb || !Et(n.toString)))
      ? JSON.stringify(n, mb, 2)
      : String(n),
  mb = (n, e) =>
    e && e.__v_isRef
      ? mb(n, e.value)
      : Yl(e)
      ? {
          [`Map(${e.size})`]: [...e.entries()].reduce(
            (t, [i, r]) => ((t[`${i} =>`] = r), t),
            {}
          ),
        }
      : Xa(e)
      ? { [`Set(${e.size})`]: [...e.values()] }
      : In(e) && !vt(e) && !yb(e)
      ? String(e)
      : e,
  Jt = {},
  Xl = [],
  kr = () => {},
  t7 = () => !1,
  n7 = /^on[^a-z]/,
  Su = n => n7.test(n),
  yg = n => n.startsWith("onUpdate:"),
  Dn = Object.assign,
  vg = (n, e) => {
    const t = n.indexOf(e)
    t > -1 && n.splice(t, 1)
  },
  i7 = Object.prototype.hasOwnProperty,
  Gt = (n, e) => i7.call(n, e),
  vt = Array.isArray,
  Yl = n => Eu(n) === "[object Map]",
  Xa = n => Eu(n) === "[object Set]",
  $y = n => Eu(n) === "[object Date]",
  Et = n => typeof n == "function",
  Tn = n => typeof n == "string",
  zA = n => typeof n == "symbol",
  In = n => n !== null && typeof n == "object",
  _g = n => In(n) && Et(n.then) && Et(n.catch),
  gb = Object.prototype.toString,
  Eu = n => gb.call(n),
  r7 = n => Eu(n).slice(8, -1),
  yb = n => Eu(n) === "[object Object]",
  xg = n => Tn(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n,
  MA = ed(
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  ),
  nd = n => {
    const e = Object.create(null)
    return t => e[t] || (e[t] = n(t))
  },
  s7 = /-(\w)/g,
  sr = nd(n => n.replace(s7, (e, t) => (t ? t.toUpperCase() : ""))),
  o7 = /\B([A-Z])/g,
  es = nd(n => n.replace(o7, "-$1").toLowerCase()),
  Tu = nd(n => n.charAt(0).toUpperCase() + n.slice(1)),
  SA = nd(n => (n ? `on${Tu(n)}` : "")),
  ac = (n, e) => !Object.is(n, e),
  Zl = (n, e) => {
    for (let t = 0; t < n.length; t++) n[t](e)
  },
  e0 = (n, e, t) => {
    Object.defineProperty(n, e, { configurable: !0, enumerable: !1, value: t })
  },
  Bo = n => {
    const e = parseFloat(n)
    return isNaN(e) ? n : e
  }
let Qy
const a7 = () =>
  Qy ||
  (Qy =
    typeof globalThis != "undefined"
      ? globalThis
      : typeof self != "undefined"
      ? self
      : typeof window != "undefined"
      ? window
      : typeof global != "undefined"
      ? global
      : {})
let Xi
class bg {
  constructor(e = !1) {
    ;(this.active = !0),
      (this.effects = []),
      (this.cleanups = []),
      !e &&
        Xi &&
        ((this.parent = Xi),
        (this.index = (Xi.scopes || (Xi.scopes = [])).push(this) - 1))
  }
  run(e) {
    if (this.active) {
      const t = Xi
      try {
        return (Xi = this), e()
      } finally {
        Xi = t
      }
    }
  }
  on() {
    Xi = this
  }
  off() {
    Xi = this.parent
  }
  stop(e) {
    if (this.active) {
      let t, i
      for (t = 0, i = this.effects.length; t < i; t++) this.effects[t].stop()
      for (t = 0, i = this.cleanups.length; t < i; t++) this.cleanups[t]()
      if (this.scopes)
        for (t = 0, i = this.scopes.length; t < i; t++) this.scopes[t].stop(!0)
      if (this.parent && !e) {
        const r = this.parent.scopes.pop()
        r &&
          r !== this &&
          ((this.parent.scopes[this.index] = r), (r.index = this.index))
      }
      this.active = !1
    }
  }
}
function vb(n) {
  return new bg(n)
}
function _b(n, e = Xi) {
  e && e.active && e.effects.push(n)
}
function l7() {
  return Xi
}
function c7(n) {
  Xi && Xi.cleanups.push(n)
}
const wg = n => {
    const e = new Set(n)
    return (e.w = 0), (e.n = 0), e
  },
  xb = n => (n.w & ko) > 0,
  bb = n => (n.n & ko) > 0,
  A7 = ({ deps: n }) => {
    if (n.length) for (let e = 0; e < n.length; e++) n[e].w |= ko
  },
  u7 = n => {
    const { deps: e } = n
    if (e.length) {
      let t = 0
      for (let i = 0; i < e.length; i++) {
        const r = e[i]
        xb(r) && !bb(r) ? r.delete(n) : (e[t++] = r), (r.w &= ~ko), (r.n &= ~ko)
      }
      e.length = t
    }
  },
  Sm = new WeakMap()
let pA = 0,
  ko = 1
const Em = 30
let Dr
const Ea = Symbol(""),
  Tm = Symbol("")
class Cu {
  constructor(e, t = null, i) {
    ;(this.fn = e),
      (this.scheduler = t),
      (this.active = !0),
      (this.deps = []),
      (this.parent = void 0),
      _b(this, i)
  }
  run() {
    if (!this.active) return this.fn()
    let e = Dr,
      t = To
    for (; e; ) {
      if (e === this) return
      e = e.parent
    }
    try {
      return (
        (this.parent = Dr),
        (Dr = this),
        (To = !0),
        (ko = 1 << ++pA),
        pA <= Em ? A7(this) : Xy(this),
        this.fn()
      )
    } finally {
      pA <= Em && u7(this),
        (ko = 1 << --pA),
        (Dr = this.parent),
        (To = t),
        (this.parent = void 0),
        this.deferStop && this.stop()
    }
  }
  stop() {
    Dr === this
      ? (this.deferStop = !0)
      : this.active &&
        (Xy(this), this.onStop && this.onStop(), (this.active = !1))
  }
}
function Xy(n) {
  const { deps: e } = n
  if (e.length) {
    for (let t = 0; t < e.length; t++) e[t].delete(n)
    e.length = 0
  }
}
function f7(n, e) {
  n.effect && (n = n.effect.fn)
  const t = new Cu(n)
  e && (Dn(t, e), e.scope && _b(t, e.scope)), (!e || !e.lazy) && t.run()
  const i = t.run.bind(t)
  return (i.effect = t), i
}
function h7(n) {
  n.effect.stop()
}
let To = !0
const wb = []
function Ya() {
  wb.push(To), (To = !1)
}
function Za() {
  const n = wb.pop()
  To = n === void 0 ? !0 : n
}
function or(n, e, t) {
  if (To && Dr) {
    let i = Sm.get(n)
    i || Sm.set(n, (i = new Map()))
    let r = i.get(t)
    r || i.set(t, (r = wg())), Mb(r)
  }
}
function Mb(n, e) {
  let t = !1
  pA <= Em ? bb(n) || ((n.n |= ko), (t = !xb(n))) : (t = !n.has(Dr)),
    t && (n.add(Dr), Dr.deps.push(n))
}
function qs(n, e, t, i, r, s) {
  const o = Sm.get(n)
  if (!o) return
  let a = []
  if (e === "clear") a = [...o.values()]
  else if (t === "length" && vt(n))
    o.forEach((A, c) => {
      ;(c === "length" || c >= i) && a.push(A)
    })
  else
    switch ((t !== void 0 && a.push(o.get(t)), e)) {
      case "add":
        vt(n)
          ? xg(t) && a.push(o.get("length"))
          : (a.push(o.get(Ea)), Yl(n) && a.push(o.get(Tm)))
        break
      case "delete":
        vt(n) || (a.push(o.get(Ea)), Yl(n) && a.push(o.get(Tm)))
        break
      case "set":
        Yl(n) && a.push(o.get(Ea))
        break
    }
  if (a.length === 1) a[0] && Cm(a[0])
  else {
    const A = []
    for (const c of a) c && A.push(...c)
    Cm(wg(A))
  }
}
function Cm(n, e) {
  const t = vt(n) ? n : [...n]
  for (const i of t) i.computed && Yy(i)
  for (const i of t) i.computed || Yy(i)
}
function Yy(n, e) {
  ;(n !== Dr || n.allowRecurse) && (n.scheduler ? n.scheduler() : n.run())
}
const d7 = ed("__proto__,__v_isRef,__isVue"),
  Sb = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter(n => n !== "arguments" && n !== "caller")
      .map(n => Symbol[n])
      .filter(zA)
  ),
  p7 = id(),
  m7 = id(!1, !0),
  g7 = id(!0),
  y7 = id(!0, !0),
  Zy = v7()
function v7() {
  const n = {}
  return (
    ["includes", "indexOf", "lastIndexOf"].forEach(e => {
      n[e] = function (...t) {
        const i = Ut(this)
        for (let s = 0, o = this.length; s < o; s++) or(i, "get", s + "")
        const r = i[e](...t)
        return r === -1 || r === !1 ? i[e](...t.map(Ut)) : r
      }
    }),
    ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
      n[e] = function (...t) {
        Ya()
        const i = Ut(this)[e].apply(this, t)
        return Za(), i
      }
    }),
    n
  )
}
function id(n = !1, e = !1) {
  return function (i, r, s) {
    if (r === "__v_isReactive") return !n
    if (r === "__v_isReadonly") return n
    if (r === "__v_isShallow") return e
    if (r === "__v_raw" && s === (n ? (e ? Db : Lb) : e ? Pb : Rb).get(i))
      return i
    const o = vt(i)
    if (!n && o && Gt(Zy, r)) return Reflect.get(Zy, r, s)
    const a = Reflect.get(i, r, s)
    return (zA(r) ? Sb.has(r) : d7(r)) || (n || or(i, "get", r), e)
      ? a
      : Gn(a)
      ? o && xg(r)
        ? a
        : a.value
      : In(a)
      ? n
        ? Sg(a)
        : Or(a)
      : a
  }
}
const _7 = Eb(),
  x7 = Eb(!0)
function Eb(n = !1) {
  return function (t, i, r, s) {
    let o = t[i]
    if (lc(o) && Gn(o) && !Gn(r)) return !1
    if (
      !n &&
      !lc(r) &&
      (t0(r) || ((r = Ut(r)), (o = Ut(o))), !vt(t) && Gn(o) && !Gn(r))
    )
      return (o.value = r), !0
    const a = vt(t) && xg(i) ? Number(i) < t.length : Gt(t, i),
      A = Reflect.set(t, i, r, s)
    return (
      t === Ut(s) && (a ? ac(r, o) && qs(t, "set", i, r) : qs(t, "add", i, r)),
      A
    )
  }
}
function b7(n, e) {
  const t = Gt(n, e)
  n[e]
  const i = Reflect.deleteProperty(n, e)
  return i && t && qs(n, "delete", e, void 0), i
}
function w7(n, e) {
  const t = Reflect.has(n, e)
  return (!zA(e) || !Sb.has(e)) && or(n, "has", e), t
}
function M7(n) {
  return or(n, "iterate", vt(n) ? "length" : Ea), Reflect.ownKeys(n)
}
const Tb = { get: p7, set: _7, deleteProperty: b7, has: w7, ownKeys: M7 },
  Cb = {
    get: g7,
    set(n, e) {
      return !0
    },
    deleteProperty(n, e) {
      return !0
    },
  },
  S7 = Dn({}, Tb, { get: m7, set: x7 }),
  E7 = Dn({}, Cb, { get: y7 }),
  Mg = n => n,
  rd = n => Reflect.getPrototypeOf(n)
function cf(n, e, t = !1, i = !1) {
  n = n.__v_raw
  const r = Ut(n),
    s = Ut(e)
  t || (e !== s && or(r, "get", e), or(r, "get", s))
  const { has: o } = rd(r),
    a = i ? Mg : t ? Tg : HA
  if (o.call(r, e)) return a(n.get(e))
  if (o.call(r, s)) return a(n.get(s))
  n !== r && n.get(e)
}
function Af(n, e = !1) {
  const t = this.__v_raw,
    i = Ut(t),
    r = Ut(n)
  return (
    e || (n !== r && or(i, "has", n), or(i, "has", r)),
    n === r ? t.has(n) : t.has(n) || t.has(r)
  )
}
function uf(n, e = !1) {
  return (
    (n = n.__v_raw), !e && or(Ut(n), "iterate", Ea), Reflect.get(n, "size", n)
  )
}
function Jy(n) {
  n = Ut(n)
  const e = Ut(this)
  return rd(e).has.call(e, n) || (e.add(n), qs(e, "add", n, n)), this
}
function Ky(n, e) {
  e = Ut(e)
  const t = Ut(this),
    { has: i, get: r } = rd(t)
  let s = i.call(t, n)
  s || ((n = Ut(n)), (s = i.call(t, n)))
  const o = r.call(t, n)
  return (
    t.set(n, e), s ? ac(e, o) && qs(t, "set", n, e) : qs(t, "add", n, e), this
  )
}
function ev(n) {
  const e = Ut(this),
    { has: t, get: i } = rd(e)
  let r = t.call(e, n)
  r || ((n = Ut(n)), (r = t.call(e, n))), i && i.call(e, n)
  const s = e.delete(n)
  return r && qs(e, "delete", n, void 0), s
}
function tv() {
  const n = Ut(this),
    e = n.size !== 0,
    t = n.clear()
  return e && qs(n, "clear", void 0, void 0), t
}
function ff(n, e) {
  return function (i, r) {
    const s = this,
      o = s.__v_raw,
      a = Ut(o),
      A = e ? Mg : n ? Tg : HA
    return (
      !n && or(a, "iterate", Ea), o.forEach((c, d) => i.call(r, A(c), A(d), s))
    )
  }
}
function hf(n, e, t) {
  return function (...i) {
    const r = this.__v_raw,
      s = Ut(r),
      o = Yl(s),
      a = n === "entries" || (n === Symbol.iterator && o),
      A = n === "keys" && o,
      c = r[n](...i),
      d = t ? Mg : e ? Tg : HA
    return (
      !e && or(s, "iterate", A ? Tm : Ea),
      {
        next() {
          const { value: p, done: m } = c.next()
          return m
            ? { value: p, done: m }
            : { value: a ? [d(p[0]), d(p[1])] : d(p), done: m }
        },
        [Symbol.iterator]() {
          return this
        },
      }
    )
  }
}
function io(n) {
  return function (...e) {
    return n === "delete" ? !1 : this
  }
}
function T7() {
  const n = {
      get(s) {
        return cf(this, s)
      },
      get size() {
        return uf(this)
      },
      has: Af,
      add: Jy,
      set: Ky,
      delete: ev,
      clear: tv,
      forEach: ff(!1, !1),
    },
    e = {
      get(s) {
        return cf(this, s, !1, !0)
      },
      get size() {
        return uf(this)
      },
      has: Af,
      add: Jy,
      set: Ky,
      delete: ev,
      clear: tv,
      forEach: ff(!1, !0),
    },
    t = {
      get(s) {
        return cf(this, s, !0)
      },
      get size() {
        return uf(this, !0)
      },
      has(s) {
        return Af.call(this, s, !0)
      },
      add: io("add"),
      set: io("set"),
      delete: io("delete"),
      clear: io("clear"),
      forEach: ff(!0, !1),
    },
    i = {
      get(s) {
        return cf(this, s, !0, !0)
      },
      get size() {
        return uf(this, !0)
      },
      has(s) {
        return Af.call(this, s, !0)
      },
      add: io("add"),
      set: io("set"),
      delete: io("delete"),
      clear: io("clear"),
      forEach: ff(!0, !0),
    }
  return (
    ["keys", "values", "entries", Symbol.iterator].forEach(s => {
      ;(n[s] = hf(s, !1, !1)),
        (t[s] = hf(s, !0, !1)),
        (e[s] = hf(s, !1, !0)),
        (i[s] = hf(s, !0, !0))
    }),
    [n, t, e, i]
  )
}
const [C7, R7, P7, L7] = T7()
function sd(n, e) {
  const t = e ? (n ? L7 : P7) : n ? R7 : C7
  return (i, r, s) =>
    r === "__v_isReactive"
      ? !n
      : r === "__v_isReadonly"
      ? n
      : r === "__v_raw"
      ? i
      : Reflect.get(Gt(t, r) && r in i ? t : i, r, s)
}
const D7 = { get: sd(!1, !1) },
  I7 = { get: sd(!1, !0) },
  B7 = { get: sd(!0, !1) },
  k7 = { get: sd(!0, !0) },
  Rb = new WeakMap(),
  Pb = new WeakMap(),
  Lb = new WeakMap(),
  Db = new WeakMap()
function O7(n) {
  switch (n) {
    case "Object":
    case "Array":
      return 1
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2
    default:
      return 0
  }
}
function q7(n) {
  return n.__v_skip || !Object.isExtensible(n) ? 0 : O7(r7(n))
}
function Or(n) {
  return lc(n) ? n : od(n, !1, Tb, D7, Rb)
}
function Ib(n) {
  return od(n, !1, S7, I7, Pb)
}
function Sg(n) {
  return od(n, !0, Cb, B7, Lb)
}
function F7(n) {
  return od(n, !0, E7, k7, Db)
}
function od(n, e, t, i, r) {
  if (!In(n) || (n.__v_raw && !(e && n.__v_isReactive))) return n
  const s = r.get(n)
  if (s) return s
  const o = q7(n)
  if (o === 0) return n
  const a = new Proxy(n, o === 2 ? i : t)
  return r.set(n, a), a
}
function Ta(n) {
  return lc(n) ? Ta(n.__v_raw) : !!(n && n.__v_isReactive)
}
function lc(n) {
  return !!(n && n.__v_isReadonly)
}
function t0(n) {
  return !!(n && n.__v_isShallow)
}
function Eg(n) {
  return Ta(n) || lc(n)
}
function Ut(n) {
  const e = n && n.__v_raw
  return e ? Ut(e) : n
}
function Ru(n) {
  return e0(n, "__v_skip", !0), n
}
const HA = n => (In(n) ? Or(n) : n),
  Tg = n => (In(n) ? Sg(n) : n)
function Cg(n) {
  To && Dr && ((n = Ut(n)), Mb(n.dep || (n.dep = wg())))
}
function ad(n, e) {
  ;(n = Ut(n)), n.dep && Cm(n.dep)
}
function Gn(n) {
  return !!(n && n.__v_isRef === !0)
}
function $n(n) {
  return Bb(n, !1)
}
function n0(n) {
  return Bb(n, !0)
}
function Bb(n, e) {
  return Gn(n) ? n : new N7(n, e)
}
class N7 {
  constructor(e, t) {
    ;(this.__v_isShallow = t),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this._rawValue = t ? e : Ut(e)),
      (this._value = t ? e : HA(e))
  }
  get value() {
    return Cg(this), this._value
  }
  set value(e) {
    ;(e = this.__v_isShallow ? e : Ut(e)),
      ac(e, this._rawValue) &&
        ((this._rawValue = e),
        (this._value = this.__v_isShallow ? e : HA(e)),
        ad(this))
  }
}
function U7(n) {
  ad(n)
}
function Jl(n) {
  return Gn(n) ? n.value : n
}
const z7 = {
  get: (n, e, t) => Jl(Reflect.get(n, e, t)),
  set: (n, e, t, i) => {
    const r = n[e]
    return Gn(r) && !Gn(t) ? ((r.value = t), !0) : Reflect.set(n, e, t, i)
  },
}
function Rg(n) {
  return Ta(n) ? n : new Proxy(n, z7)
}
class H7 {
  constructor(e) {
    ;(this.dep = void 0), (this.__v_isRef = !0)
    const { get: t, set: i } = e(
      () => Cg(this),
      () => ad(this)
    )
    ;(this._get = t), (this._set = i)
  }
  get value() {
    return this._get()
  }
  set value(e) {
    this._set(e)
  }
}
function G7(n) {
  return new H7(n)
}
function V7(n) {
  const e = vt(n) ? new Array(n.length) : {}
  for (const t in n) e[t] = Pg(n, t)
  return e
}
class W7 {
  constructor(e, t, i) {
    ;(this._object = e),
      (this._key = t),
      (this._defaultValue = i),
      (this.__v_isRef = !0)
  }
  get value() {
    const e = this._object[this._key]
    return e === void 0 ? this._defaultValue : e
  }
  set value(e) {
    this._object[this._key] = e
  }
}
function Pg(n, e, t) {
  const i = n[e]
  return Gn(i) ? i : new W7(n, e, t)
}
class j7 {
  constructor(e, t, i, r) {
    ;(this._setter = t),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this._dirty = !0),
      (this.effect = new Cu(e, () => {
        this._dirty || ((this._dirty = !0), ad(this))
      })),
      (this.effect.computed = this),
      (this.effect.active = this._cacheable = !r),
      (this.__v_isReadonly = i)
  }
  get value() {
    const e = Ut(this)
    return (
      Cg(e),
      (e._dirty || !e._cacheable) &&
        ((e._dirty = !1), (e._value = e.effect.run())),
      e._value
    )
  }
  set value(e) {
    this._setter(e)
  }
}
function $7(n, e, t = !1) {
  let i, r
  const s = Et(n)
  return (
    s ? ((i = n), (r = kr)) : ((i = n.get), (r = n.set)),
    new j7(i, r, s || !r, t)
  )
}
const EA = []
function kb(n, ...e) {
  Ya()
  const t = EA.length ? EA[EA.length - 1].component : null,
    i = t && t.appContext.config.warnHandler,
    r = Q7()
  if (i)
    ts(i, t, 11, [
      n + e.join(""),
      t && t.proxy,
      r.map(({ vnode: s }) => `at <${Ew(t, s.type)}>`).join(`
`),
      r,
    ])
  else {
    const s = [`[Vue warn]: ${n}`, ...e]
    r.length &&
      s.push(
        `
`,
        ...X7(r)
      ),
      console.warn(...s)
  }
  Za()
}
function Q7() {
  let n = EA[EA.length - 1]
  if (!n) return []
  const e = []
  for (; n; ) {
    const t = e[0]
    t && t.vnode === n
      ? t.recurseCount++
      : e.push({ vnode: n, recurseCount: 0 })
    const i = n.component && n.component.parent
    n = i && i.vnode
  }
  return e
}
function X7(n) {
  const e = []
  return (
    n.forEach((t, i) => {
      e.push(
        ...(i === 0
          ? []
          : [
              `
`,
            ]),
        ...Y7(t)
      )
    }),
    e
  )
}
function Y7({ vnode: n, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "",
    i = n.component ? n.component.parent == null : !1,
    r = ` at <${Ew(n.component, n.type, i)}`,
    s = ">" + t
  return n.props ? [r, ...Z7(n.props), s] : [r + s]
}
function Z7(n) {
  const e = [],
    t = Object.keys(n)
  return (
    t.slice(0, 3).forEach(i => {
      e.push(...Ob(i, n[i]))
    }),
    t.length > 3 && e.push(" ..."),
    e
  )
}
function Ob(n, e, t) {
  return Tn(e)
    ? ((e = JSON.stringify(e)), t ? e : [`${n}=${e}`])
    : typeof e == "number" || typeof e == "boolean" || e == null
    ? t
      ? e
      : [`${n}=${e}`]
    : Gn(e)
    ? ((e = Ob(n, Ut(e.value), !0)), t ? e : [`${n}=Ref<`, e, ">"])
    : Et(e)
    ? [`${n}=fn${e.name ? `<${e.name}>` : ""}`]
    : ((e = Ut(e)), t ? e : [`${n}=`, e])
}
function ts(n, e, t, i) {
  let r
  try {
    r = i ? n(...i) : n()
  } catch (s) {
    Ja(s, e, t)
  }
  return r
}
function nr(n, e, t, i) {
  if (Et(n)) {
    const s = ts(n, e, t, i)
    return (
      s &&
        _g(s) &&
        s.catch(o => {
          Ja(o, e, t)
        }),
      s
    )
  }
  const r = []
  for (let s = 0; s < n.length; s++) r.push(nr(n[s], e, t, i))
  return r
}
function Ja(n, e, t, i = !0) {
  const r = e ? e.vnode : null
  if (e) {
    let s = e.parent
    const o = e.proxy,
      a = t
    for (; s; ) {
      const c = s.ec
      if (c) {
        for (let d = 0; d < c.length; d++) if (c[d](n, o, a) === !1) return
      }
      s = s.parent
    }
    const A = e.appContext.config.errorHandler
    if (A) {
      ts(A, null, 10, [n, o, a])
      return
    }
  }
  J7(n, t, r, i)
}
function J7(n, e, t, i = !0) {
  console.error(n)
}
let i0 = !1,
  Rm = !1
const er = []
let Ts = 0
const TA = []
let mA = null,
  Ol = 0
const CA = []
let xo = null,
  ql = 0
const qb = Promise.resolve()
let Lg = null,
  Pm = null
function Pu(n) {
  const e = Lg || qb
  return n ? e.then(this ? n.bind(this) : n) : e
}
function K7(n) {
  let e = Ts + 1,
    t = er.length
  for (; e < t; ) {
    const i = (e + t) >>> 1
    GA(er[i]) < n ? (e = i + 1) : (t = i)
  }
  return e
}
function Dg(n) {
  ;(!er.length || !er.includes(n, i0 && n.allowRecurse ? Ts + 1 : Ts)) &&
    n !== Pm &&
    (n.id == null ? er.push(n) : er.splice(K7(n.id), 0, n), Fb())
}
function Fb() {
  !i0 && !Rm && ((Rm = !0), (Lg = qb.then(Ub)))
}
function eE(n) {
  const e = er.indexOf(n)
  e > Ts && er.splice(e, 1)
}
function Nb(n, e, t, i) {
  vt(n)
    ? t.push(...n)
    : (!e || !e.includes(n, n.allowRecurse ? i + 1 : i)) && t.push(n),
    Fb()
}
function tE(n) {
  Nb(n, mA, TA, Ol)
}
function Ig(n) {
  Nb(n, xo, CA, ql)
}
function ld(n, e = null) {
  if (TA.length) {
    for (
      Pm = e, mA = [...new Set(TA)], TA.length = 0, Ol = 0;
      Ol < mA.length;
      Ol++
    )
      mA[Ol]()
    ;(mA = null), (Ol = 0), (Pm = null), ld(n, e)
  }
}
function r0(n) {
  if ((ld(), CA.length)) {
    const e = [...new Set(CA)]
    if (((CA.length = 0), xo)) {
      xo.push(...e)
      return
    }
    for (xo = e, xo.sort((t, i) => GA(t) - GA(i)), ql = 0; ql < xo.length; ql++)
      xo[ql]()
    ;(xo = null), (ql = 0)
  }
}
const GA = n => (n.id == null ? 1 / 0 : n.id)
function Ub(n) {
  ;(Rm = !1), (i0 = !0), ld(n), er.sort((t, i) => GA(t) - GA(i))
  const e = kr
  try {
    for (Ts = 0; Ts < er.length; Ts++) {
      const t = er[Ts]
      t && t.active !== !1 && ts(t, null, 14)
    }
  } finally {
    ;(Ts = 0),
      (er.length = 0),
      r0(),
      (i0 = !1),
      (Lg = null),
      (er.length || TA.length || CA.length) && Ub(n)
  }
}
let Fl,
  df = []
function zb(n, e) {
  var t, i
  ;(Fl = n),
    Fl
      ? ((Fl.enabled = !0),
        df.forEach(({ event: r, args: s }) => Fl.emit(r, ...s)),
        (df = []))
      : typeof window != "undefined" &&
        window.HTMLElement &&
        !(
          !(
            (i =
              (t = window.navigator) === null || t === void 0
                ? void 0
                : t.userAgent) === null || i === void 0
          ) && i.includes("jsdom")
        )
      ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ =
          e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(s => {
          zb(s, e)
        }),
        setTimeout(() => {
          Fl || ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null), (df = []))
        }, 3e3))
      : (df = [])
}
function nE(n, e, ...t) {
  if (n.isUnmounted) return
  const i = n.vnode.props || Jt
  let r = t
  const s = e.startsWith("update:"),
    o = s && e.slice(7)
  if (o && o in i) {
    const d = `${o === "modelValue" ? "model" : o}Modifiers`,
      { number: p, trim: m } = i[d] || Jt
    m && (r = t.map(y => y.trim())), p && (r = t.map(Bo))
  }
  let a,
    A = i[(a = SA(e))] || i[(a = SA(sr(e)))]
  !A && s && (A = i[(a = SA(es(e)))]), A && nr(A, n, 6, r)
  const c = i[a + "Once"]
  if (c) {
    if (!n.emitted) n.emitted = {}
    else if (n.emitted[a]) return
    ;(n.emitted[a] = !0), nr(c, n, 6, r)
  }
}
function Hb(n, e, t = !1) {
  const i = e.emitsCache,
    r = i.get(n)
  if (r !== void 0) return r
  const s = n.emits
  let o = {},
    a = !1
  if (!Et(n)) {
    const A = c => {
      const d = Hb(c, e, !0)
      d && ((a = !0), Dn(o, d))
    }
    !t && e.mixins.length && e.mixins.forEach(A),
      n.extends && A(n.extends),
      n.mixins && n.mixins.forEach(A)
  }
  return !s && !a
    ? (i.set(n, null), null)
    : (vt(s) ? s.forEach(A => (o[A] = null)) : Dn(o, s), i.set(n, o), o)
}
function cd(n, e) {
  return !n || !Su(e)
    ? !1
    : ((e = e.slice(2).replace(/Once$/, "")),
      Gt(n, e[0].toLowerCase() + e.slice(1)) || Gt(n, es(e)) || Gt(n, e))
}
let pi = null,
  Ad = null
function VA(n) {
  const e = pi
  return (pi = n), (Ad = (n && n.type.__scopeId) || null), e
}
function Oc(n) {
  Ad = n
}
function qc() {
  Ad = null
}
const iE = n => Xn
function Xn(n, e = pi, t) {
  if (!e || n._n) return n
  const i = (...r) => {
    i._d && qm(-1)
    const s = VA(e),
      o = n(...r)
    return VA(s), i._d && qm(1), o
  }
  return (i._n = !0), (i._c = !0), (i._d = !0), i
}
function Fh(n) {
  const {
    type: e,
    vnode: t,
    proxy: i,
    withProxy: r,
    props: s,
    propsOptions: [o],
    slots: a,
    attrs: A,
    emit: c,
    render: d,
    renderCache: p,
    data: m,
    setupState: y,
    ctx: x,
    inheritAttrs: S,
  } = n
  let C, M
  const _ = VA(n)
  try {
    if (t.shapeFlag & 4) {
      const T = r || i
      ;(C = Ji(d.call(T, T, p, s, y, m, x))), (M = A)
    } else {
      const T = e
      ;(C = Ji(
        T.length > 1 ? T(s, { attrs: A, slots: a, emit: c }) : T(s, null)
      )),
        (M = e.props ? A : sE(A))
    }
  } catch (T) {
    ;(PA.length = 0), Ja(T, n, 1), (C = At(mi))
  }
  let R = C
  if (M && S !== !1) {
    const T = Object.keys(M),
      { shapeFlag: L } = R
    T.length && L & 7 && (o && T.some(yg) && (M = oE(M, o)), (R = as(R, M)))
  }
  return (
    t.dirs && ((R = as(R)), (R.dirs = R.dirs ? R.dirs.concat(t.dirs) : t.dirs)),
    t.transition && (R.transition = t.transition),
    (C = R),
    VA(_),
    C
  )
}
function rE(n) {
  let e
  for (let t = 0; t < n.length; t++) {
    const i = n[t]
    if (qo(i)) {
      if (i.type !== mi || i.children === "v-if") {
        if (e) return
        e = i
      }
    } else return
  }
  return e
}
const sE = n => {
    let e
    for (const t in n)
      (t === "class" || t === "style" || Su(t)) && ((e || (e = {}))[t] = n[t])
    return e
  },
  oE = (n, e) => {
    const t = {}
    for (const i in n) (!yg(i) || !(i.slice(9) in e)) && (t[i] = n[i])
    return t
  }
function aE(n, e, t) {
  const { props: i, children: r, component: s } = n,
    { props: o, children: a, patchFlag: A } = e,
    c = s.emitsOptions
  if (e.dirs || e.transition) return !0
  if (t && A >= 0) {
    if (A & 1024) return !0
    if (A & 16) return i ? nv(i, o, c) : !!o
    if (A & 8) {
      const d = e.dynamicProps
      for (let p = 0; p < d.length; p++) {
        const m = d[p]
        if (o[m] !== i[m] && !cd(c, m)) return !0
      }
    }
  } else
    return (r || a) && (!a || !a.$stable)
      ? !0
      : i === o
      ? !1
      : i
      ? o
        ? nv(i, o, c)
        : !0
      : !!o
  return !1
}
function nv(n, e, t) {
  const i = Object.keys(e)
  if (i.length !== Object.keys(n).length) return !0
  for (let r = 0; r < i.length; r++) {
    const s = i[r]
    if (e[s] !== n[s] && !cd(t, s)) return !0
  }
  return !1
}
function Bg({ vnode: n, parent: e }, t) {
  for (; e && e.subTree === n; ) ((n = e.vnode).el = t), (e = e.parent)
}
const Gb = n => n.__isSuspense,
  lE = {
    name: "Suspense",
    __isSuspense: !0,
    process(n, e, t, i, r, s, o, a, A, c) {
      n == null ? cE(e, t, i, r, s, o, a, A, c) : AE(n, e, t, i, r, o, a, A, c)
    },
    hydrate: uE,
    create: Og,
    normalize: fE,
  },
  kg = lE
function WA(n, e) {
  const t = n.props && n.props[e]
  Et(t) && t()
}
function cE(n, e, t, i, r, s, o, a, A) {
  const {
      p: c,
      o: { createElement: d },
    } = A,
    p = d("div"),
    m = (n.suspense = Og(n, r, i, e, p, t, s, o, a, A))
  c(null, (m.pendingBranch = n.ssContent), p, null, i, m, s, o),
    m.deps > 0
      ? (WA(n, "onPending"),
        WA(n, "onFallback"),
        c(null, n.ssFallback, e, t, i, null, s, o),
        Kl(m, n.ssFallback))
      : m.resolve()
}
function AE(n, e, t, i, r, s, o, a, { p: A, um: c, o: { createElement: d } }) {
  const p = (e.suspense = n.suspense)
  ;(p.vnode = e), (e.el = n.el)
  const m = e.ssContent,
    y = e.ssFallback,
    { activeBranch: x, pendingBranch: S, isInFallback: C, isHydrating: M } = p
  if (S)
    (p.pendingBranch = m),
      Kr(m, S)
        ? (A(S, m, p.hiddenContainer, null, r, p, s, o, a),
          p.deps <= 0
            ? p.resolve()
            : C && (A(x, y, t, i, r, null, s, o, a), Kl(p, y)))
        : (p.pendingId++,
          M ? ((p.isHydrating = !1), (p.activeBranch = S)) : c(S, r, p),
          (p.deps = 0),
          (p.effects.length = 0),
          (p.hiddenContainer = d("div")),
          C
            ? (A(null, m, p.hiddenContainer, null, r, p, s, o, a),
              p.deps <= 0
                ? p.resolve()
                : (A(x, y, t, i, r, null, s, o, a), Kl(p, y)))
            : x && Kr(m, x)
            ? (A(x, m, t, i, r, p, s, o, a), p.resolve(!0))
            : (A(null, m, p.hiddenContainer, null, r, p, s, o, a),
              p.deps <= 0 && p.resolve()))
  else if (x && Kr(m, x)) A(x, m, t, i, r, p, s, o, a), Kl(p, m)
  else if (
    (WA(e, "onPending"),
    (p.pendingBranch = m),
    p.pendingId++,
    A(null, m, p.hiddenContainer, null, r, p, s, o, a),
    p.deps <= 0)
  )
    p.resolve()
  else {
    const { timeout: _, pendingId: R } = p
    _ > 0
      ? setTimeout(() => {
          p.pendingId === R && p.fallback(y)
        }, _)
      : _ === 0 && p.fallback(y)
  }
}
function Og(n, e, t, i, r, s, o, a, A, c, d = !1) {
  const {
      p,
      m,
      um: y,
      n: x,
      o: { parentNode: S, remove: C },
    } = c,
    M = Bo(n.props && n.props.timeout),
    _ = {
      vnode: n,
      parent: e,
      parentComponent: t,
      isSVG: o,
      container: i,
      hiddenContainer: r,
      anchor: s,
      deps: 0,
      pendingId: 0,
      timeout: typeof M == "number" ? M : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: !0,
      isHydrating: d,
      isUnmounted: !1,
      effects: [],
      resolve(R = !1) {
        const {
          vnode: T,
          activeBranch: L,
          pendingBranch: B,
          pendingId: k,
          effects: O,
          parentComponent: W,
          container: z,
        } = _
        if (_.isHydrating) _.isHydrating = !1
        else if (!R) {
          const G = L && B.transition && B.transition.mode === "out-in"
          G &&
            (L.transition.afterLeave = () => {
              k === _.pendingId && m(B, z, j, 0)
            })
          let { anchor: j } = _
          L && ((j = x(L)), y(L, W, _, !0)), G || m(B, z, j, 0)
        }
        Kl(_, B), (_.pendingBranch = null), (_.isInFallback = !1)
        let P = _.parent,
          N = !1
        for (; P; ) {
          if (P.pendingBranch) {
            P.effects.push(...O), (N = !0)
            break
          }
          P = P.parent
        }
        N || Ig(O), (_.effects = []), WA(T, "onResolve")
      },
      fallback(R) {
        if (!_.pendingBranch) return
        const {
          vnode: T,
          activeBranch: L,
          parentComponent: B,
          container: k,
          isSVG: O,
        } = _
        WA(T, "onFallback")
        const W = x(L),
          z = () => {
            !_.isInFallback || (p(null, R, k, W, B, null, O, a, A), Kl(_, R))
          },
          P = R.transition && R.transition.mode === "out-in"
        P && (L.transition.afterLeave = z),
          (_.isInFallback = !0),
          y(L, B, null, !0),
          P || z()
      },
      move(R, T, L) {
        _.activeBranch && m(_.activeBranch, R, T, L), (_.container = R)
      },
      next() {
        return _.activeBranch && x(_.activeBranch)
      },
      registerDep(R, T) {
        const L = !!_.pendingBranch
        L && _.deps++
        const B = R.vnode.el
        R.asyncDep
          .catch(k => {
            Ja(k, R, 0)
          })
          .then(k => {
            if (R.isUnmounted || _.isUnmounted || _.pendingId !== R.suspenseId)
              return
            R.asyncResolved = !0
            const { vnode: O } = R
            Fm(R, k, !1), B && (O.el = B)
            const W = !B && R.subTree.el
            T(R, O, S(B || R.subTree.el), B ? null : x(R.subTree), _, o, A),
              W && C(W),
              Bg(R, O.el),
              L && --_.deps === 0 && _.resolve()
          })
      },
      unmount(R, T) {
        ;(_.isUnmounted = !0),
          _.activeBranch && y(_.activeBranch, t, R, T),
          _.pendingBranch && y(_.pendingBranch, t, R, T)
      },
    }
  return _
}
function uE(n, e, t, i, r, s, o, a, A) {
  const c = (e.suspense = Og(
      e,
      i,
      t,
      n.parentNode,
      document.createElement("div"),
      null,
      r,
      s,
      o,
      a,
      !0
    )),
    d = A(n, (c.pendingBranch = e.ssContent), t, c, s, o)
  return c.deps === 0 && c.resolve(), d
}
function fE(n) {
  const { shapeFlag: e, children: t } = n,
    i = e & 32
  ;(n.ssContent = iv(i ? t.default : t)),
    (n.ssFallback = i ? iv(t.fallback) : At(mi))
}
function iv(n) {
  let e
  if (Et(n)) {
    const t = Fa && n._c
    t && ((n._d = !1), It()), (n = n()), t && ((n._d = !0), (e = Ui), gw())
  }
  return (
    vt(n) && (n = rE(n)),
    (n = Ji(n)),
    e && !n.dynamicChildren && (n.dynamicChildren = e.filter(t => t !== n)),
    n
  )
}
function Vb(n, e) {
  e && e.pendingBranch
    ? vt(n)
      ? e.effects.push(...n)
      : e.effects.push(n)
    : Ig(n)
}
function Kl(n, e) {
  n.activeBranch = e
  const { vnode: t, parentComponent: i } = n,
    r = (t.el = e.el)
  i && i.subTree === t && ((i.vnode.el = r), Bg(i, r))
}
function Ca(n, e) {
  if (Yn) {
    let t = Yn.provides
    const i = Yn.parent && Yn.parent.provides
    i === t && (t = Yn.provides = Object.create(i)), (t[n] = e)
  }
}
function _r(n, e, t = !1) {
  const i = Yn || pi
  if (i) {
    const r =
      i.parent == null
        ? i.vnode.appContext && i.vnode.appContext.provides
        : i.parent.provides
    if (r && n in r) return r[n]
    if (arguments.length > 1) return t && Et(e) ? e.call(i.proxy) : e
  }
}
function s0(n, e) {
  return Lu(n, null, e)
}
function Wb(n, e) {
  return Lu(n, null, { flush: "post" })
}
function hE(n, e) {
  return Lu(n, null, { flush: "sync" })
}
const rv = {}
function ec(n, e, t) {
  return Lu(n, e, t)
}
function Lu(
  n,
  e,
  { immediate: t, deep: i, flush: r, onTrack: s, onTrigger: o } = Jt
) {
  const a = Yn
  let A,
    c = !1,
    d = !1
  if (
    (Gn(n)
      ? ((A = () => n.value), (c = t0(n)))
      : Ta(n)
      ? ((A = () => n), (i = !0))
      : vt(n)
      ? ((d = !0),
        (c = n.some(M => Ta(M) || t0(M))),
        (A = () =>
          n.map(M => {
            if (Gn(M)) return M.value
            if (Ta(M)) return xa(M)
            if (Et(M)) return ts(M, a, 2)
          })))
      : Et(n)
      ? e
        ? (A = () => ts(n, a, 2))
        : (A = () => {
            if (!(a && a.isUnmounted)) return p && p(), nr(n, a, 3, [m])
          })
      : (A = kr),
    e && i)
  ) {
    const M = A
    A = () => xa(M())
  }
  let p,
    m = M => {
      p = C.onStop = () => {
        ts(M, a, 4)
      }
    }
  if (uc)
    return (m = kr), e ? t && nr(e, a, 3, [A(), d ? [] : void 0, m]) : A(), kr
  let y = d ? [] : rv
  const x = () => {
    if (!!C.active)
      if (e) {
        const M = C.run()
        ;(i || c || (d ? M.some((_, R) => ac(_, y[R])) : ac(M, y))) &&
          (p && p(), nr(e, a, 3, [M, y === rv ? void 0 : y, m]), (y = M))
      } else C.run()
  }
  x.allowRecurse = !!e
  let S
  r === "sync"
    ? (S = x)
    : r === "post"
    ? (S = () => ai(x, a && a.suspense))
    : (S = () => tE(x))
  const C = new Cu(A, S)
  return (
    e
      ? t
        ? x()
        : (y = C.run())
      : r === "post"
      ? ai(C.run.bind(C), a && a.suspense)
      : C.run(),
    () => {
      C.stop(), a && a.scope && vg(a.scope.effects, C)
    }
  )
}
function dE(n, e, t) {
  const i = this.proxy,
    r = Tn(n) ? (n.includes(".") ? jb(i, n) : () => i[n]) : n.bind(i, i)
  let s
  Et(e) ? (s = e) : ((s = e.handler), (t = e))
  const o = Yn
  Fo(this)
  const a = Lu(r, s.bind(i), t)
  return o ? Fo(o) : Co(), a
}
function jb(n, e) {
  const t = e.split(".")
  return () => {
    let i = n
    for (let r = 0; r < t.length && i; r++) i = i[t[r]]
    return i
  }
}
function xa(n, e) {
  if (!In(n) || n.__v_skip || ((e = e || new Set()), e.has(n))) return n
  if ((e.add(n), Gn(n))) xa(n.value, e)
  else if (vt(n)) for (let t = 0; t < n.length; t++) xa(n[t], e)
  else if (Xa(n) || Yl(n))
    n.forEach(t => {
      xa(t, e)
    })
  else if (yb(n)) for (const t in n) xa(n[t], e)
  return n
}
function qg() {
  const n = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: new Map(),
  }
  return (
    Ls(() => {
      n.isMounted = !0
    }),
    Iu(() => {
      n.isUnmounting = !0
    }),
    n
  )
}
const fr = [Function, Array],
  pE = {
    name: "BaseTransition",
    props: {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      onBeforeEnter: fr,
      onEnter: fr,
      onAfterEnter: fr,
      onEnterCancelled: fr,
      onBeforeLeave: fr,
      onLeave: fr,
      onAfterLeave: fr,
      onLeaveCancelled: fr,
      onBeforeAppear: fr,
      onAppear: fr,
      onAfterAppear: fr,
      onAppearCancelled: fr,
    },
    setup(n, { slots: e }) {
      const t = zr(),
        i = qg()
      let r
      return () => {
        const s = e.default && ud(e.default(), !0)
        if (!s || !s.length) return
        let o = s[0]
        if (s.length > 1) {
          for (const S of s)
            if (S.type !== mi) {
              o = S
              break
            }
        }
        const a = Ut(n),
          { mode: A } = a
        if (i.isLeaving) return dp(o)
        const c = sv(o)
        if (!c) return dp(o)
        const d = cc(c, a, i, t)
        qa(c, d)
        const p = t.subTree,
          m = p && sv(p)
        let y = !1
        const { getTransitionKey: x } = c.type
        if (x) {
          const S = x()
          r === void 0 ? (r = S) : S !== r && ((r = S), (y = !0))
        }
        if (m && m.type !== mi && (!Kr(c, m) || y)) {
          const S = cc(m, a, i, t)
          if ((qa(m, S), A === "out-in"))
            return (
              (i.isLeaving = !0),
              (S.afterLeave = () => {
                ;(i.isLeaving = !1), t.update()
              }),
              dp(o)
            )
          A === "in-out" &&
            c.type !== mi &&
            (S.delayLeave = (C, M, _) => {
              const R = $b(i, m)
              ;(R[String(m.key)] = m),
                (C._leaveCb = () => {
                  M(), (C._leaveCb = void 0), delete d.delayedLeave
                }),
                (d.delayedLeave = _)
            })
        }
        return o
      }
    },
  },
  Fg = pE
function $b(n, e) {
  const { leavingVNodes: t } = n
  let i = t.get(e.type)
  return i || ((i = Object.create(null)), t.set(e.type, i)), i
}
function cc(n, e, t, i) {
  const {
      appear: r,
      mode: s,
      persisted: o = !1,
      onBeforeEnter: a,
      onEnter: A,
      onAfterEnter: c,
      onEnterCancelled: d,
      onBeforeLeave: p,
      onLeave: m,
      onAfterLeave: y,
      onLeaveCancelled: x,
      onBeforeAppear: S,
      onAppear: C,
      onAfterAppear: M,
      onAppearCancelled: _,
    } = e,
    R = String(n.key),
    T = $b(t, n),
    L = (O, W) => {
      O && nr(O, i, 9, W)
    },
    B = (O, W) => {
      const z = W[1]
      L(O, W), vt(O) ? O.every(P => P.length <= 1) && z() : O.length <= 1 && z()
    },
    k = {
      mode: s,
      persisted: o,
      beforeEnter(O) {
        let W = a
        if (!t.isMounted)
          if (r) W = S || a
          else return
        O._leaveCb && O._leaveCb(!0)
        const z = T[R]
        z && Kr(n, z) && z.el._leaveCb && z.el._leaveCb(), L(W, [O])
      },
      enter(O) {
        let W = A,
          z = c,
          P = d
        if (!t.isMounted)
          if (r) (W = C || A), (z = M || c), (P = _ || d)
          else return
        let N = !1
        const G = (O._enterCb = j => {
          N ||
            ((N = !0),
            j ? L(P, [O]) : L(z, [O]),
            k.delayedLeave && k.delayedLeave(),
            (O._enterCb = void 0))
        })
        W ? B(W, [O, G]) : G()
      },
      leave(O, W) {
        const z = String(n.key)
        if ((O._enterCb && O._enterCb(!0), t.isUnmounting)) return W()
        L(p, [O])
        let P = !1
        const N = (O._leaveCb = G => {
          P ||
            ((P = !0),
            W(),
            G ? L(x, [O]) : L(y, [O]),
            (O._leaveCb = void 0),
            T[z] === n && delete T[z])
        })
        ;(T[z] = n), m ? B(m, [O, N]) : N()
      },
      clone(O) {
        return cc(O, e, t, i)
      },
    }
  return k
}
function dp(n) {
  if (Du(n)) return (n = as(n)), (n.children = null), n
}
function sv(n) {
  return Du(n) ? (n.children ? n.children[0] : void 0) : n
}
function qa(n, e) {
  n.shapeFlag & 6 && n.component
    ? qa(n.component.subTree, e)
    : n.shapeFlag & 128
    ? ((n.ssContent.transition = e.clone(n.ssContent)),
      (n.ssFallback.transition = e.clone(n.ssFallback)))
    : (n.transition = e)
}
function ud(n, e = !1, t) {
  let i = [],
    r = 0
  for (let s = 0; s < n.length; s++) {
    let o = n[s]
    const a = t == null ? o.key : String(t) + String(o.key != null ? o.key : s)
    o.type === Qn
      ? (o.patchFlag & 128 && r++, (i = i.concat(ud(o.children, e, a))))
      : (e || o.type !== mi) && i.push(a != null ? as(o, { key: a }) : o)
  }
  if (r > 1) for (let s = 0; s < i.length; s++) i[s].patchFlag = -2
  return i
}
function ni(n) {
  return Et(n) ? { setup: n, name: n.name } : n
}
const Ra = n => !!n.type.__asyncLoader
function mE(n) {
  Et(n) && (n = { loader: n })
  const {
    loader: e,
    loadingComponent: t,
    errorComponent: i,
    delay: r = 200,
    timeout: s,
    suspensible: o = !0,
    onError: a,
  } = n
  let A = null,
    c,
    d = 0
  const p = () => (d++, (A = null), m()),
    m = () => {
      let y
      return (
        A ||
        (y = A =
          e()
            .catch(x => {
              if (((x = x instanceof Error ? x : new Error(String(x))), a))
                return new Promise((S, C) => {
                  a(
                    x,
                    () => S(p()),
                    () => C(x),
                    d + 1
                  )
                })
              throw x
            })
            .then(x =>
              y !== A && A
                ? A
                : (x &&
                    (x.__esModule || x[Symbol.toStringTag] === "Module") &&
                    (x = x.default),
                  (c = x),
                  x)
            ))
      )
    }
  return ni({
    name: "AsyncComponentWrapper",
    __asyncLoader: m,
    get __asyncResolved() {
      return c
    },
    setup() {
      const y = Yn
      if (c) return () => pp(c, y)
      const x = _ => {
        ;(A = null), Ja(_, y, 13, !i)
      }
      if ((o && y.suspense) || uc)
        return m()
          .then(_ => () => pp(_, y))
          .catch(_ => (x(_), () => (i ? At(i, { error: _ }) : null)))
      const S = $n(!1),
        C = $n(),
        M = $n(!!r)
      return (
        r &&
          setTimeout(() => {
            M.value = !1
          }, r),
        s != null &&
          setTimeout(() => {
            if (!S.value && !C.value) {
              const _ = new Error(`Async component timed out after ${s}ms.`)
              x(_), (C.value = _)
            }
          }, s),
        m()
          .then(() => {
            ;(S.value = !0),
              y.parent && Du(y.parent.vnode) && Dg(y.parent.update)
          })
          .catch(_ => {
            x(_), (C.value = _)
          }),
        () => {
          if (S.value && c) return pp(c, y)
          if (C.value && i) return At(i, { error: C.value })
          if (t && !M.value) return At(t)
        }
      )
    },
  })
}
function pp(
  n,
  { vnode: { ref: e, props: t, children: i, shapeFlag: r }, parent: s }
) {
  const o = At(n, t, i)
  return (o.ref = e), o
}
const Du = n => n.type.__isKeepAlive,
  gE = {
    name: "KeepAlive",
    __isKeepAlive: !0,
    props: {
      include: [String, RegExp, Array],
      exclude: [String, RegExp, Array],
      max: [String, Number],
    },
    setup(n, { slots: e }) {
      const t = zr(),
        i = t.ctx
      if (!i.renderer)
        return () => {
          const _ = e.default && e.default()
          return _ && _.length === 1 ? _[0] : _
        }
      const r = new Map(),
        s = new Set()
      let o = null
      const a = t.suspense,
        {
          renderer: {
            p: A,
            m: c,
            um: d,
            o: { createElement: p },
          },
        } = i,
        m = p("div")
      ;(i.activate = (_, R, T, L, B) => {
        const k = _.component
        c(_, R, T, 0, a),
          A(k.vnode, _, R, T, k, a, L, _.slotScopeIds, B),
          ai(() => {
            ;(k.isDeactivated = !1), k.a && Zl(k.a)
            const O = _.props && _.props.onVnodeMounted
            O && Fi(O, k.parent, _)
          }, a)
      }),
        (i.deactivate = _ => {
          const R = _.component
          c(_, m, null, 1, a),
            ai(() => {
              R.da && Zl(R.da)
              const T = _.props && _.props.onVnodeUnmounted
              T && Fi(T, R.parent, _), (R.isDeactivated = !0)
            }, a)
        })
      function y(_) {
        mp(_), d(_, t, a, !0)
      }
      function x(_) {
        r.forEach((R, T) => {
          const L = u0(R.type)
          L && (!_ || !_(L)) && S(T)
        })
      }
      function S(_) {
        const R = r.get(_)
        !o || R.type !== o.type ? y(R) : o && mp(o), r.delete(_), s.delete(_)
      }
      ec(
        () => [n.include, n.exclude],
        ([_, R]) => {
          _ && x(T => gA(_, T)), R && x(T => !gA(R, T))
        },
        { flush: "post", deep: !0 }
      )
      let C = null
      const M = () => {
        C != null && r.set(C, gp(t.subTree))
      }
      return (
        Ls(M),
        hd(M),
        Iu(() => {
          r.forEach(_ => {
            const { subTree: R, suspense: T } = t,
              L = gp(R)
            if (_.type === L.type) {
              mp(L)
              const B = L.component.da
              B && ai(B, T)
              return
            }
            y(_)
          })
        }),
        () => {
          if (((C = null), !e.default)) return null
          const _ = e.default(),
            R = _[0]
          if (_.length > 1) return (o = null), _
          if (!qo(R) || (!(R.shapeFlag & 4) && !(R.shapeFlag & 128)))
            return (o = null), R
          let T = gp(R)
          const L = T.type,
            B = u0(Ra(T) ? T.type.__asyncResolved || {} : L),
            { include: k, exclude: O, max: W } = n
          if ((k && (!B || !gA(k, B))) || (O && B && gA(O, B)))
            return (o = T), R
          const z = T.key == null ? L : T.key,
            P = r.get(z)
          return (
            T.el && ((T = as(T)), R.shapeFlag & 128 && (R.ssContent = T)),
            (C = z),
            P
              ? ((T.el = P.el),
                (T.component = P.component),
                T.transition && qa(T, T.transition),
                (T.shapeFlag |= 512),
                s.delete(z),
                s.add(z))
              : (s.add(z),
                W && s.size > parseInt(W, 10) && S(s.values().next().value)),
            (T.shapeFlag |= 256),
            (o = T),
            Gb(R.type) ? R : T
          )
        }
      )
    },
  },
  Qb = gE
function gA(n, e) {
  return vt(n)
    ? n.some(t => gA(t, e))
    : Tn(n)
    ? n.split(",").includes(e)
    : n.test
    ? n.test(e)
    : !1
}
function Xb(n, e) {
  Zb(n, "a", e)
}
function Yb(n, e) {
  Zb(n, "da", e)
}
function Zb(n, e, t = Yn) {
  const i =
    n.__wdc ||
    (n.__wdc = () => {
      let r = t
      for (; r; ) {
        if (r.isDeactivated) return
        r = r.parent
      }
      return n()
    })
  if ((fd(e, i, t), t)) {
    let r = t.parent
    for (; r && r.parent; ) Du(r.parent.vnode) && yE(i, e, t, r), (r = r.parent)
  }
}
function yE(n, e, t, i) {
  const r = fd(e, n, i, !0)
  Oo(() => {
    vg(i[e], r)
  }, t)
}
function mp(n) {
  let e = n.shapeFlag
  e & 256 && (e -= 256), e & 512 && (e -= 512), (n.shapeFlag = e)
}
function gp(n) {
  return n.shapeFlag & 128 ? n.ssContent : n
}
function fd(n, e, t = Yn, i = !1) {
  if (t) {
    const r = t[n] || (t[n] = []),
      s =
        e.__weh ||
        (e.__weh = (...o) => {
          if (t.isUnmounted) return
          Ya(), Fo(t)
          const a = nr(e, t, n, o)
          return Co(), Za(), a
        })
    return i ? r.unshift(s) : r.push(s), s
  }
}
const Xs =
    n =>
    (e, t = Yn) =>
      (!uc || n === "sp") && fd(n, e, t),
  Jb = Xs("bm"),
  Ls = Xs("m"),
  Kb = Xs("bu"),
  hd = Xs("u"),
  Iu = Xs("bum"),
  Oo = Xs("um"),
  ew = Xs("sp"),
  tw = Xs("rtg"),
  nw = Xs("rtc")
function o0(n, e = Yn) {
  fd("ec", n, e)
}
function vE(n, e) {
  const t = pi
  if (t === null) return n
  const i = pd(t) || t.proxy,
    r = n.dirs || (n.dirs = [])
  for (let s = 0; s < e.length; s++) {
    let [o, a, A, c = Jt] = e[s]
    Et(o) && (o = { mounted: o, updated: o }),
      o.deep && xa(a),
      r.push({
        dir: o,
        instance: i,
        value: a,
        oldValue: void 0,
        arg: A,
        modifiers: c,
      })
  }
  return n
}
function Xr(n, e, t, i) {
  const r = n.dirs,
    s = e && e.dirs
  for (let o = 0; o < r.length; o++) {
    const a = r[o]
    s && (a.oldValue = s[o].value)
    let A = a.dir[i]
    A && (Ya(), nr(A, t, 8, [n.el, a, n, e]), Za())
  }
}
const Ng = "components",
  _E = "directives"
function Bu(n, e) {
  return Ug(Ng, n, !0, e) || n
}
const iw = Symbol()
function xE(n) {
  return Tn(n) ? Ug(Ng, n, !1) || n : n || iw
}
function bE(n) {
  return Ug(_E, n)
}
function Ug(n, e, t = !0, i = !1) {
  const r = pi || Yn
  if (r) {
    const s = r.type
    if (n === Ng) {
      const a = u0(s, !1)
      if (a && (a === e || a === sr(e) || a === Tu(sr(e)))) return s
    }
    const o = ov(r[n] || s[n], e) || ov(r.appContext[n], e)
    return !o && i ? s : o
  }
}
function ov(n, e) {
  return n && (n[e] || n[sr(e)] || n[Tu(sr(e))])
}
function zg(n, e, t, i) {
  let r
  const s = t && t[i]
  if (vt(n) || Tn(n)) {
    r = new Array(n.length)
    for (let o = 0, a = n.length; o < a; o++)
      r[o] = e(n[o], o, void 0, s && s[o])
  } else if (typeof n == "number") {
    r = new Array(n)
    for (let o = 0; o < n; o++) r[o] = e(o + 1, o, void 0, s && s[o])
  } else if (In(n))
    if (n[Symbol.iterator])
      r = Array.from(n, (o, a) => e(o, a, void 0, s && s[a]))
    else {
      const o = Object.keys(n)
      r = new Array(o.length)
      for (let a = 0, A = o.length; a < A; a++) {
        const c = o[a]
        r[a] = e(n[c], c, a, s && s[a])
      }
    }
  else r = []
  return t && (t[i] = r), r
}
function wE(n, e) {
  for (let t = 0; t < e.length; t++) {
    const i = e[t]
    if (vt(i)) for (let r = 0; r < i.length; r++) n[i[r].name] = i[r].fn
    else i && (n[i.name] = i.fn)
  }
  return n
}
function rw(n, e, t = {}, i, r) {
  if (pi.isCE || (pi.parent && Ra(pi.parent) && pi.parent.isCE))
    return At("slot", e === "default" ? null : { name: e }, i && i())
  let s = n[e]
  s && s._c && (s._d = !1), It()
  const o = s && sw(s(t)),
    a = Kt(
      Qn,
      { key: t.key || `_${e}` },
      o || (i ? i() : []),
      o && n._ === 1 ? 64 : -2
    )
  return (
    !r && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]),
    s && s._c && (s._d = !0),
    a
  )
}
function sw(n) {
  return n.some(e =>
    qo(e) ? !(e.type === mi || (e.type === Qn && !sw(e.children))) : !0
  )
    ? n
    : null
}
function ME(n) {
  const e = {}
  for (const t in n) e[SA(t)] = n[t]
  return e
}
const Lm = n => (n ? (bw(n) ? pd(n) || n.proxy : Lm(n.parent)) : null),
  a0 = Dn(Object.create(null), {
    $: n => n,
    $el: n => n.vnode.el,
    $data: n => n.data,
    $props: n => n.props,
    $attrs: n => n.attrs,
    $slots: n => n.slots,
    $refs: n => n.refs,
    $parent: n => Lm(n.parent),
    $root: n => Lm(n.root),
    $emit: n => n.emit,
    $options: n => aw(n),
    $forceUpdate: n => n.f || (n.f = () => Dg(n.update)),
    $nextTick: n => n.n || (n.n = Pu.bind(n.proxy)),
    $watch: n => dE.bind(n),
  }),
  Dm = {
    get({ _: n }, e) {
      const {
        ctx: t,
        setupState: i,
        data: r,
        props: s,
        accessCache: o,
        type: a,
        appContext: A,
      } = n
      let c
      if (e[0] !== "$") {
        const y = o[e]
        if (y !== void 0)
          switch (y) {
            case 1:
              return i[e]
            case 2:
              return r[e]
            case 4:
              return t[e]
            case 3:
              return s[e]
          }
        else {
          if (i !== Jt && Gt(i, e)) return (o[e] = 1), i[e]
          if (r !== Jt && Gt(r, e)) return (o[e] = 2), r[e]
          if ((c = n.propsOptions[0]) && Gt(c, e)) return (o[e] = 3), s[e]
          if (t !== Jt && Gt(t, e)) return (o[e] = 4), t[e]
          Im && (o[e] = 0)
        }
      }
      const d = a0[e]
      let p, m
      if (d) return e === "$attrs" && or(n, "get", e), d(n)
      if ((p = a.__cssModules) && (p = p[e])) return p
      if (t !== Jt && Gt(t, e)) return (o[e] = 4), t[e]
      if (((m = A.config.globalProperties), Gt(m, e))) return m[e]
    },
    set({ _: n }, e, t) {
      const { data: i, setupState: r, ctx: s } = n
      return r !== Jt && Gt(r, e)
        ? ((r[e] = t), !0)
        : i !== Jt && Gt(i, e)
        ? ((i[e] = t), !0)
        : Gt(n.props, e) || (e[0] === "$" && e.slice(1) in n)
        ? !1
        : ((s[e] = t), !0)
    },
    has(
      {
        _: {
          data: n,
          setupState: e,
          accessCache: t,
          ctx: i,
          appContext: r,
          propsOptions: s,
        },
      },
      o
    ) {
      let a
      return (
        !!t[o] ||
        (n !== Jt && Gt(n, o)) ||
        (e !== Jt && Gt(e, o)) ||
        ((a = s[0]) && Gt(a, o)) ||
        Gt(i, o) ||
        Gt(a0, o) ||
        Gt(r.config.globalProperties, o)
      )
    },
    defineProperty(n, e, t) {
      return (
        t.get != null
          ? (n._.accessCache[e] = 0)
          : Gt(t, "value") && this.set(n, e, t.value, null),
        Reflect.defineProperty(n, e, t)
      )
    },
  },
  SE = Dn({}, Dm, {
    get(n, e) {
      if (e !== Symbol.unscopables) return Dm.get(n, e, n)
    },
    has(n, e) {
      return e[0] !== "_" && !QS(e)
    },
  })
let Im = !0
function EE(n) {
  const e = aw(n),
    t = n.proxy,
    i = n.ctx
  ;(Im = !1), e.beforeCreate && av(e.beforeCreate, n, "bc")
  const {
    data: r,
    computed: s,
    methods: o,
    watch: a,
    provide: A,
    inject: c,
    created: d,
    beforeMount: p,
    mounted: m,
    beforeUpdate: y,
    updated: x,
    activated: S,
    deactivated: C,
    beforeDestroy: M,
    beforeUnmount: _,
    destroyed: R,
    unmounted: T,
    render: L,
    renderTracked: B,
    renderTriggered: k,
    errorCaptured: O,
    serverPrefetch: W,
    expose: z,
    inheritAttrs: P,
    components: N,
    directives: G,
    filters: j,
  } = e
  if ((c && TE(c, i, null, n.appContext.config.unwrapInjectedRef), o))
    for (const ne in o) {
      const le = o[ne]
      Et(le) && (i[ne] = le.bind(t))
    }
  if (r) {
    const ne = r.call(t, t)
    In(ne) && (n.data = Or(ne))
  }
  if (((Im = !0), s))
    for (const ne in s) {
      const le = s[ne],
        Te = Et(le) ? le.bind(t, t) : Et(le.get) ? le.get.bind(t, t) : kr,
        Ae = !Et(le) && Et(le.set) ? le.set.bind(t) : kr,
        ge = _n({ get: Te, set: Ae })
      Object.defineProperty(i, ne, {
        enumerable: !0,
        configurable: !0,
        get: () => ge.value,
        set: Me => (ge.value = Me),
      })
    }
  if (a) for (const ne in a) ow(a[ne], i, t, ne)
  if (A) {
    const ne = Et(A) ? A.call(t) : A
    Reflect.ownKeys(ne).forEach(le => {
      Ca(le, ne[le])
    })
  }
  d && av(d, n, "c")
  function Y(ne, le) {
    vt(le) ? le.forEach(Te => ne(Te.bind(t))) : le && ne(le.bind(t))
  }
  if (
    (Y(Jb, p),
    Y(Ls, m),
    Y(Kb, y),
    Y(hd, x),
    Y(Xb, S),
    Y(Yb, C),
    Y(o0, O),
    Y(nw, B),
    Y(tw, k),
    Y(Iu, _),
    Y(Oo, T),
    Y(ew, W),
    vt(z))
  )
    if (z.length) {
      const ne = n.exposed || (n.exposed = {})
      z.forEach(le => {
        Object.defineProperty(ne, le, {
          get: () => t[le],
          set: Te => (t[le] = Te),
        })
      })
    } else n.exposed || (n.exposed = {})
  L && n.render === kr && (n.render = L),
    P != null && (n.inheritAttrs = P),
    N && (n.components = N),
    G && (n.directives = G)
}
function TE(n, e, t = kr, i = !1) {
  vt(n) && (n = Bm(n))
  for (const r in n) {
    const s = n[r]
    let o
    In(s)
      ? "default" in s
        ? (o = _r(s.from || r, s.default, !0))
        : (o = _r(s.from || r))
      : (o = _r(s)),
      Gn(o) && i
        ? Object.defineProperty(e, r, {
            enumerable: !0,
            configurable: !0,
            get: () => o.value,
            set: a => (o.value = a),
          })
        : (e[r] = o)
  }
}
function av(n, e, t) {
  nr(vt(n) ? n.map(i => i.bind(e.proxy)) : n.bind(e.proxy), e, t)
}
function ow(n, e, t, i) {
  const r = i.includes(".") ? jb(t, i) : () => t[i]
  if (Tn(n)) {
    const s = e[n]
    Et(s) && ec(r, s)
  } else if (Et(n)) ec(r, n.bind(t))
  else if (In(n))
    if (vt(n)) n.forEach(s => ow(s, e, t, i))
    else {
      const s = Et(n.handler) ? n.handler.bind(t) : e[n.handler]
      Et(s) && ec(r, s, n)
    }
}
function aw(n) {
  const e = n.type,
    { mixins: t, extends: i } = e,
    {
      mixins: r,
      optionsCache: s,
      config: { optionMergeStrategies: o },
    } = n.appContext,
    a = s.get(e)
  let A
  return (
    a
      ? (A = a)
      : !r.length && !t && !i
      ? (A = e)
      : ((A = {}), r.length && r.forEach(c => l0(A, c, o, !0)), l0(A, e, o)),
    s.set(e, A),
    A
  )
}
function l0(n, e, t, i = !1) {
  const { mixins: r, extends: s } = e
  s && l0(n, s, t, !0), r && r.forEach(o => l0(n, o, t, !0))
  for (const o in e)
    if (!(i && o === "expose")) {
      const a = CE[o] || (t && t[o])
      n[o] = a ? a(n[o], e[o]) : e[o]
    }
  return n
}
const CE = {
  data: lv,
  props: fa,
  emits: fa,
  methods: fa,
  computed: fa,
  beforeCreate: wi,
  created: wi,
  beforeMount: wi,
  mounted: wi,
  beforeUpdate: wi,
  updated: wi,
  beforeDestroy: wi,
  beforeUnmount: wi,
  destroyed: wi,
  unmounted: wi,
  activated: wi,
  deactivated: wi,
  errorCaptured: wi,
  serverPrefetch: wi,
  components: fa,
  directives: fa,
  watch: PE,
  provide: lv,
  inject: RE,
}
function lv(n, e) {
  return e
    ? n
      ? function () {
          return Dn(
            Et(n) ? n.call(this, this) : n,
            Et(e) ? e.call(this, this) : e
          )
        }
      : e
    : n
}
function RE(n, e) {
  return fa(Bm(n), Bm(e))
}
function Bm(n) {
  if (vt(n)) {
    const e = {}
    for (let t = 0; t < n.length; t++) e[n[t]] = n[t]
    return e
  }
  return n
}
function wi(n, e) {
  return n ? [...new Set([].concat(n, e))] : e
}
function fa(n, e) {
  return n ? Dn(Dn(Object.create(null), n), e) : e
}
function PE(n, e) {
  if (!n) return e
  if (!e) return n
  const t = Dn(Object.create(null), n)
  for (const i in e) t[i] = wi(n[i], e[i])
  return t
}
function LE(n, e, t, i = !1) {
  const r = {},
    s = {}
  e0(s, dd, 1), (n.propsDefaults = Object.create(null)), lw(n, e, r, s)
  for (const o in n.propsOptions[0]) o in r || (r[o] = void 0)
  t ? (n.props = i ? r : Ib(r)) : n.type.props ? (n.props = r) : (n.props = s),
    (n.attrs = s)
}
function DE(n, e, t, i) {
  const {
      props: r,
      attrs: s,
      vnode: { patchFlag: o },
    } = n,
    a = Ut(r),
    [A] = n.propsOptions
  let c = !1
  if ((i || o > 0) && !(o & 16)) {
    if (o & 8) {
      const d = n.vnode.dynamicProps
      for (let p = 0; p < d.length; p++) {
        let m = d[p]
        if (cd(n.emitsOptions, m)) continue
        const y = e[m]
        if (A)
          if (Gt(s, m)) y !== s[m] && ((s[m] = y), (c = !0))
          else {
            const x = sr(m)
            r[x] = km(A, a, x, y, n, !1)
          }
        else y !== s[m] && ((s[m] = y), (c = !0))
      }
    }
  } else {
    lw(n, e, r, s) && (c = !0)
    let d
    for (const p in a)
      (!e || (!Gt(e, p) && ((d = es(p)) === p || !Gt(e, d)))) &&
        (A
          ? t &&
            (t[p] !== void 0 || t[d] !== void 0) &&
            (r[p] = km(A, a, p, void 0, n, !0))
          : delete r[p])
    if (s !== a)
      for (const p in s) (!e || (!Gt(e, p) && !0)) && (delete s[p], (c = !0))
  }
  c && qs(n, "set", "$attrs")
}
function lw(n, e, t, i) {
  const [r, s] = n.propsOptions
  let o = !1,
    a
  if (e)
    for (let A in e) {
      if (MA(A)) continue
      const c = e[A]
      let d
      r && Gt(r, (d = sr(A)))
        ? !s || !s.includes(d)
          ? (t[d] = c)
          : ((a || (a = {}))[d] = c)
        : cd(n.emitsOptions, A) ||
          ((!(A in i) || c !== i[A]) && ((i[A] = c), (o = !0)))
    }
  if (s) {
    const A = Ut(t),
      c = a || Jt
    for (let d = 0; d < s.length; d++) {
      const p = s[d]
      t[p] = km(r, A, p, c[p], n, !Gt(c, p))
    }
  }
  return o
}
function km(n, e, t, i, r, s) {
  const o = n[t]
  if (o != null) {
    const a = Gt(o, "default")
    if (a && i === void 0) {
      const A = o.default
      if (o.type !== Function && Et(A)) {
        const { propsDefaults: c } = r
        t in c ? (i = c[t]) : (Fo(r), (i = c[t] = A.call(null, e)), Co())
      } else i = A
    }
    o[0] && (s && !a ? (i = !1) : o[1] && (i === "" || i === es(t)) && (i = !0))
  }
  return i
}
function cw(n, e, t = !1) {
  const i = e.propsCache,
    r = i.get(n)
  if (r) return r
  const s = n.props,
    o = {},
    a = []
  let A = !1
  if (!Et(n)) {
    const d = p => {
      A = !0
      const [m, y] = cw(p, e, !0)
      Dn(o, m), y && a.push(...y)
    }
    !t && e.mixins.length && e.mixins.forEach(d),
      n.extends && d(n.extends),
      n.mixins && n.mixins.forEach(d)
  }
  if (!s && !A) return i.set(n, Xl), Xl
  if (vt(s))
    for (let d = 0; d < s.length; d++) {
      const p = sr(s[d])
      cv(p) && (o[p] = Jt)
    }
  else if (s)
    for (const d in s) {
      const p = sr(d)
      if (cv(p)) {
        const m = s[d],
          y = (o[p] = vt(m) || Et(m) ? { type: m } : m)
        if (y) {
          const x = fv(Boolean, y.type),
            S = fv(String, y.type)
          ;(y[0] = x > -1),
            (y[1] = S < 0 || x < S),
            (x > -1 || Gt(y, "default")) && a.push(p)
        }
      }
    }
  const c = [o, a]
  return i.set(n, c), c
}
function cv(n) {
  return n[0] !== "$"
}
function Av(n) {
  const e = n && n.toString().match(/^\s*function (\w+)/)
  return e ? e[1] : n === null ? "null" : ""
}
function uv(n, e) {
  return Av(n) === Av(e)
}
function fv(n, e) {
  return vt(e) ? e.findIndex(t => uv(t, n)) : Et(e) && uv(e, n) ? 0 : -1
}
const Aw = n => n[0] === "_" || n === "$stable",
  Hg = n => (vt(n) ? n.map(Ji) : [Ji(n)]),
  IE = (n, e, t) => {
    if (e._n) return e
    const i = Xn((...r) => Hg(e(...r)), t)
    return (i._c = !1), i
  },
  uw = (n, e, t) => {
    const i = n._ctx
    for (const r in n) {
      if (Aw(r)) continue
      const s = n[r]
      if (Et(s)) e[r] = IE(r, s, i)
      else if (s != null) {
        const o = Hg(s)
        e[r] = () => o
      }
    }
  },
  fw = (n, e) => {
    const t = Hg(e)
    n.slots.default = () => t
  },
  BE = (n, e) => {
    if (n.vnode.shapeFlag & 32) {
      const t = e._
      t ? ((n.slots = Ut(e)), e0(e, "_", t)) : uw(e, (n.slots = {}))
    } else (n.slots = {}), e && fw(n, e)
    e0(n.slots, dd, 1)
  },
  kE = (n, e, t) => {
    const { vnode: i, slots: r } = n
    let s = !0,
      o = Jt
    if (i.shapeFlag & 32) {
      const a = e._
      a
        ? t && a === 1
          ? (s = !1)
          : (Dn(r, e), !t && a === 1 && delete r._)
        : ((s = !e.$stable), uw(e, r)),
        (o = e)
    } else e && (fw(n, e), (o = { default: 1 }))
    if (s) for (const a in r) !Aw(a) && !(a in o) && delete r[a]
  }
function hw() {
  return {
    app: null,
    config: {
      isNativeTag: t7,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {},
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap(),
    propsCache: new WeakMap(),
    emitsCache: new WeakMap(),
  }
}
let OE = 0
function qE(n, e) {
  return function (i, r = null) {
    Et(i) || (i = Object.assign({}, i)), r != null && !In(r) && (r = null)
    const s = hw(),
      o = new Set()
    let a = !1
    const A = (s.app = {
      _uid: OE++,
      _component: i,
      _props: r,
      _container: null,
      _context: s,
      _instance: null,
      version: Pw,
      get config() {
        return s.config
      },
      set config(c) {},
      use(c, ...d) {
        return (
          o.has(c) ||
            (c && Et(c.install)
              ? (o.add(c), c.install(A, ...d))
              : Et(c) && (o.add(c), c(A, ...d))),
          A
        )
      },
      mixin(c) {
        return s.mixins.includes(c) || s.mixins.push(c), A
      },
      component(c, d) {
        return d ? ((s.components[c] = d), A) : s.components[c]
      },
      directive(c, d) {
        return d ? ((s.directives[c] = d), A) : s.directives[c]
      },
      mount(c, d, p) {
        if (!a) {
          const m = At(i, r)
          return (
            (m.appContext = s),
            d && e ? e(m, c) : n(m, c, p),
            (a = !0),
            (A._container = c),
            (c.__vue_app__ = A),
            pd(m.component) || m.component.proxy
          )
        }
      },
      unmount() {
        a && (n(null, A._container), delete A._container.__vue_app__)
      },
      provide(c, d) {
        return (s.provides[c] = d), A
      },
    })
    return A
  }
}
function c0(n, e, t, i, r = !1) {
  if (vt(n)) {
    n.forEach((m, y) => c0(m, e && (vt(e) ? e[y] : e), t, i, r))
    return
  }
  if (Ra(i) && !r) return
  const s = i.shapeFlag & 4 ? pd(i.component) || i.component.proxy : i.el,
    o = r ? null : s,
    { i: a, r: A } = n,
    c = e && e.r,
    d = a.refs === Jt ? (a.refs = {}) : a.refs,
    p = a.setupState
  if (
    (c != null &&
      c !== A &&
      (Tn(c)
        ? ((d[c] = null), Gt(p, c) && (p[c] = null))
        : Gn(c) && (c.value = null)),
    Et(A))
  )
    ts(A, a, 12, [o, d])
  else {
    const m = Tn(A),
      y = Gn(A)
    if (m || y) {
      const x = () => {
        if (n.f) {
          const S = m ? d[A] : A.value
          r
            ? vt(S) && vg(S, s)
            : vt(S)
            ? S.includes(s) || S.push(s)
            : m
            ? ((d[A] = [s]), Gt(p, A) && (p[A] = d[A]))
            : ((A.value = [s]), n.k && (d[n.k] = A.value))
        } else
          m
            ? ((d[A] = o), Gt(p, A) && (p[A] = o))
            : y && ((A.value = o), n.k && (d[n.k] = o))
      }
      o ? ((x.id = -1), ai(x, t)) : x()
    }
  }
}
let ro = !1
const pf = n => /svg/.test(n.namespaceURI) && n.tagName !== "foreignObject",
  mf = n => n.nodeType === 8
function FE(n) {
  const {
      mt: e,
      p: t,
      o: {
        patchProp: i,
        createText: r,
        nextSibling: s,
        parentNode: o,
        remove: a,
        insert: A,
        createComment: c,
      },
    } = n,
    d = (M, _) => {
      if (!_.hasChildNodes()) {
        t(null, M, _), r0(), (_._vnode = M)
        return
      }
      ;(ro = !1),
        p(_.firstChild, M, null, null, null),
        r0(),
        (_._vnode = M),
        ro && console.error("Hydration completed but contains mismatches.")
    },
    p = (M, _, R, T, L, B = !1) => {
      const k = mf(M) && M.data === "[",
        O = () => S(M, _, R, T, L, k),
        { type: W, ref: z, shapeFlag: P, patchFlag: N } = _,
        G = M.nodeType
      ;(_.el = M), N === -2 && ((B = !1), (_.dynamicChildren = null))
      let j = null
      switch (W) {
        case Ac:
          G !== 3
            ? _.children === ""
              ? (A((_.el = r("")), o(M), M), (j = M))
              : (j = O())
            : (M.data !== _.children && ((ro = !0), (M.data = _.children)),
              (j = s(M)))
          break
        case mi:
          G !== 8 || k ? (j = O()) : (j = s(M))
          break
        case Pa:
          if (G !== 1 && G !== 3) j = O()
          else {
            j = M
            const V = !_.children.length
            for (let Y = 0; Y < _.staticCount; Y++)
              V && (_.children += j.nodeType === 1 ? j.outerHTML : j.data),
                Y === _.staticCount - 1 && (_.anchor = j),
                (j = s(j))
            return j
          }
          break
        case Qn:
          k ? (j = x(M, _, R, T, L, B)) : (j = O())
          break
        default:
          if (P & 1)
            G !== 1 || _.type.toLowerCase() !== M.tagName.toLowerCase()
              ? (j = O())
              : (j = m(M, _, R, T, L, B))
          else if (P & 6) {
            _.slotScopeIds = L
            const V = o(M)
            if (
              (e(_, V, null, R, T, pf(V), B),
              (j = k ? C(M) : s(M)),
              j && mf(j) && j.data === "teleport end" && (j = s(j)),
              Ra(_))
            ) {
              let Y
              k
                ? ((Y = At(Qn)),
                  (Y.anchor = j ? j.previousSibling : V.lastChild))
                : (Y = M.nodeType === 3 ? hs("") : At("div")),
                (Y.el = M),
                (_.component.subTree = Y)
            }
          } else
            P & 64
              ? G !== 8
                ? (j = O())
                : (j = _.type.hydrate(M, _, R, T, L, B, n, y))
              : P & 128 &&
                (j = _.type.hydrate(M, _, R, T, pf(o(M)), L, B, n, p))
      }
      return z != null && c0(z, null, T, _), j
    },
    m = (M, _, R, T, L, B) => {
      B = B || !!_.dynamicChildren
      const { type: k, props: O, patchFlag: W, shapeFlag: z, dirs: P } = _,
        N = (k === "input" && P) || k === "option"
      if (N || W !== -1) {
        if ((P && Xr(_, null, R, "created"), O))
          if (N || !B || W & 48)
            for (const j in O)
              ((N && j.endsWith("value")) || (Su(j) && !MA(j))) &&
                i(M, j, null, O[j], !1, void 0, R)
          else O.onClick && i(M, "onClick", null, O.onClick, !1, void 0, R)
        let G
        if (
          ((G = O && O.onVnodeBeforeMount) && Fi(G, R, _),
          P && Xr(_, null, R, "beforeMount"),
          ((G = O && O.onVnodeMounted) || P) &&
            Vb(() => {
              G && Fi(G, R, _), P && Xr(_, null, R, "mounted")
            }, T),
          z & 16 && !(O && (O.innerHTML || O.textContent)))
        ) {
          let j = y(M.firstChild, _, M, R, T, L, B)
          for (; j; ) {
            ro = !0
            const V = j
            ;(j = j.nextSibling), a(V)
          }
        } else
          z & 8 &&
            M.textContent !== _.children &&
            ((ro = !0), (M.textContent = _.children))
      }
      return M.nextSibling
    },
    y = (M, _, R, T, L, B, k) => {
      k = k || !!_.dynamicChildren
      const O = _.children,
        W = O.length
      for (let z = 0; z < W; z++) {
        const P = k ? O[z] : (O[z] = Ji(O[z]))
        if (M) M = p(M, P, T, L, B, k)
        else {
          if (P.type === Ac && !P.children) continue
          ;(ro = !0), t(null, P, R, null, T, L, pf(R), B)
        }
      }
      return M
    },
    x = (M, _, R, T, L, B) => {
      const { slotScopeIds: k } = _
      k && (L = L ? L.concat(k) : k)
      const O = o(M),
        W = y(s(M), _, O, R, T, L, B)
      return W && mf(W) && W.data === "]"
        ? s((_.anchor = W))
        : ((ro = !0), A((_.anchor = c("]")), O, W), W)
    },
    S = (M, _, R, T, L, B) => {
      if (((ro = !0), (_.el = null), B)) {
        const W = C(M)
        for (;;) {
          const z = s(M)
          if (z && z !== W) a(z)
          else break
        }
      }
      const k = s(M),
        O = o(M)
      return a(M), t(null, _, O, k, R, T, pf(O), L), k
    },
    C = M => {
      let _ = 0
      for (; M; )
        if (
          ((M = s(M)), M && mf(M) && (M.data === "[" && _++, M.data === "]"))
        ) {
          if (_ === 0) return s(M)
          _--
        }
      return M
    }
  return [d, p]
}
const ai = Vb
function dw(n) {
  return mw(n)
}
function pw(n) {
  return mw(n, FE)
}
function mw(n, e) {
  const t = a7()
  t.__VUE__ = !0
  const {
      insert: i,
      remove: r,
      patchProp: s,
      createElement: o,
      createText: a,
      createComment: A,
      setText: c,
      setElementText: d,
      parentNode: p,
      nextSibling: m,
      setScopeId: y = kr,
      cloneNode: x,
      insertStaticContent: S,
    } = n,
    C = (
      D,
      q,
      F,
      te = null,
      oe = null,
      ue = null,
      Ee = !1,
      Ce = null,
      Se = !!q.dynamicChildren
    ) => {
      if (D === q) return
      D && !Kr(D, q) && ((te = Be(D)), Ne(D, oe, ue, !0), (D = null)),
        q.patchFlag === -2 && ((Se = !1), (q.dynamicChildren = null))
      const { type: $, ref: Q, shapeFlag: pe } = q
      switch ($) {
        case Ac:
          M(D, q, F, te)
          break
        case mi:
          _(D, q, F, te)
          break
        case Pa:
          D == null && R(q, F, te, Ee)
          break
        case Qn:
          G(D, q, F, te, oe, ue, Ee, Ce, Se)
          break
        default:
          pe & 1
            ? B(D, q, F, te, oe, ue, Ee, Ce, Se)
            : pe & 6
            ? j(D, q, F, te, oe, ue, Ee, Ce, Se)
            : (pe & 64 || pe & 128) &&
              $.process(D, q, F, te, oe, ue, Ee, Ce, Se, je)
      }
      Q != null && oe && c0(Q, D && D.ref, ue, q || D, !q)
    },
    M = (D, q, F, te) => {
      if (D == null) i((q.el = a(q.children)), F, te)
      else {
        const oe = (q.el = D.el)
        q.children !== D.children && c(oe, q.children)
      }
    },
    _ = (D, q, F, te) => {
      D == null ? i((q.el = A(q.children || "")), F, te) : (q.el = D.el)
    },
    R = (D, q, F, te) => {
      ;[D.el, D.anchor] = S(D.children, q, F, te, D.el, D.anchor)
    },
    T = ({ el: D, anchor: q }, F, te) => {
      let oe
      for (; D && D !== q; ) (oe = m(D)), i(D, F, te), (D = oe)
      i(q, F, te)
    },
    L = ({ el: D, anchor: q }) => {
      let F
      for (; D && D !== q; ) (F = m(D)), r(D), (D = F)
      r(q)
    },
    B = (D, q, F, te, oe, ue, Ee, Ce, Se) => {
      ;(Ee = Ee || q.type === "svg"),
        D == null
          ? k(q, F, te, oe, ue, Ee, Ce, Se)
          : z(D, q, oe, ue, Ee, Ce, Se)
    },
    k = (D, q, F, te, oe, ue, Ee, Ce) => {
      let Se, $
      const {
        type: Q,
        props: pe,
        shapeFlag: Re,
        transition: Ue,
        patchFlag: _e,
        dirs: Xe,
      } = D
      if (D.el && x !== void 0 && _e === -1) Se = D.el = x(D.el)
      else {
        if (
          ((Se = D.el = o(D.type, ue, pe && pe.is, pe)),
          Re & 8
            ? d(Se, D.children)
            : Re & 16 &&
              W(
                D.children,
                Se,
                null,
                te,
                oe,
                ue && Q !== "foreignObject",
                Ee,
                Ce
              ),
          Xe && Xr(D, null, te, "created"),
          pe)
        ) {
          for (const be in pe)
            be !== "value" &&
              !MA(be) &&
              s(Se, be, null, pe[be], ue, D.children, te, oe, ve)
          "value" in pe && s(Se, "value", null, pe.value),
            ($ = pe.onVnodeBeforeMount) && Fi($, te, D)
        }
        O(Se, D, D.scopeId, Ee, te)
      }
      Xe && Xr(D, null, te, "beforeMount")
      const se = (!oe || (oe && !oe.pendingBranch)) && Ue && !Ue.persisted
      se && Ue.beforeEnter(Se),
        i(Se, q, F),
        (($ = pe && pe.onVnodeMounted) || se || Xe) &&
          ai(() => {
            $ && Fi($, te, D),
              se && Ue.enter(Se),
              Xe && Xr(D, null, te, "mounted")
          }, oe)
    },
    O = (D, q, F, te, oe) => {
      if ((F && y(D, F), te))
        for (let ue = 0; ue < te.length; ue++) y(D, te[ue])
      if (oe) {
        let ue = oe.subTree
        if (q === ue) {
          const Ee = oe.vnode
          O(D, Ee, Ee.scopeId, Ee.slotScopeIds, oe.parent)
        }
      }
    },
    W = (D, q, F, te, oe, ue, Ee, Ce, Se = 0) => {
      for (let $ = Se; $ < D.length; $++) {
        const Q = (D[$] = Ce ? wo(D[$]) : Ji(D[$]))
        C(null, Q, q, F, te, oe, ue, Ee, Ce)
      }
    },
    z = (D, q, F, te, oe, ue, Ee) => {
      const Ce = (q.el = D.el)
      let { patchFlag: Se, dynamicChildren: $, dirs: Q } = q
      Se |= D.patchFlag & 16
      const pe = D.props || Jt,
        Re = q.props || Jt
      let Ue
      F && na(F, !1),
        (Ue = Re.onVnodeBeforeUpdate) && Fi(Ue, F, q, D),
        Q && Xr(q, D, F, "beforeUpdate"),
        F && na(F, !0)
      const _e = oe && q.type !== "foreignObject"
      if (
        ($
          ? P(D.dynamicChildren, $, Ce, F, te, _e, ue)
          : Ee || Te(D, q, Ce, null, F, te, _e, ue, !1),
        Se > 0)
      ) {
        if (Se & 16) N(Ce, q, pe, Re, F, te, oe)
        else if (
          (Se & 2 &&
            pe.class !== Re.class &&
            s(Ce, "class", null, Re.class, oe),
          Se & 4 && s(Ce, "style", pe.style, Re.style, oe),
          Se & 8)
        ) {
          const Xe = q.dynamicProps
          for (let se = 0; se < Xe.length; se++) {
            const be = Xe[se],
              ze = pe[be],
              at = Re[be]
            ;(at !== ze || be === "value") &&
              s(Ce, be, ze, at, oe, D.children, F, te, ve)
          }
        }
        Se & 1 && D.children !== q.children && d(Ce, q.children)
      } else !Ee && $ == null && N(Ce, q, pe, Re, F, te, oe)
      ;((Ue = Re.onVnodeUpdated) || Q) &&
        ai(() => {
          Ue && Fi(Ue, F, q, D), Q && Xr(q, D, F, "updated")
        }, te)
    },
    P = (D, q, F, te, oe, ue, Ee) => {
      for (let Ce = 0; Ce < q.length; Ce++) {
        const Se = D[Ce],
          $ = q[Ce],
          Q =
            Se.el && (Se.type === Qn || !Kr(Se, $) || Se.shapeFlag & 70)
              ? p(Se.el)
              : F
        C(Se, $, Q, null, te, oe, ue, Ee, !0)
      }
    },
    N = (D, q, F, te, oe, ue, Ee) => {
      if (F !== te) {
        for (const Ce in te) {
          if (MA(Ce)) continue
          const Se = te[Ce],
            $ = F[Ce]
          Se !== $ &&
            Ce !== "value" &&
            s(D, Ce, $, Se, Ee, q.children, oe, ue, ve)
        }
        if (F !== Jt)
          for (const Ce in F)
            !MA(Ce) &&
              !(Ce in te) &&
              s(D, Ce, F[Ce], null, Ee, q.children, oe, ue, ve)
        "value" in te && s(D, "value", F.value, te.value)
      }
    },
    G = (D, q, F, te, oe, ue, Ee, Ce, Se) => {
      const $ = (q.el = D ? D.el : a("")),
        Q = (q.anchor = D ? D.anchor : a(""))
      let { patchFlag: pe, dynamicChildren: Re, slotScopeIds: Ue } = q
      Ue && (Ce = Ce ? Ce.concat(Ue) : Ue),
        D == null
          ? (i($, F, te), i(Q, F, te), W(q.children, F, Q, oe, ue, Ee, Ce, Se))
          : pe > 0 && pe & 64 && Re && D.dynamicChildren
          ? (P(D.dynamicChildren, Re, F, oe, ue, Ee, Ce),
            (q.key != null || (oe && q === oe.subTree)) && Gg(D, q, !0))
          : Te(D, q, F, Q, oe, ue, Ee, Ce, Se)
    },
    j = (D, q, F, te, oe, ue, Ee, Ce, Se) => {
      ;(q.slotScopeIds = Ce),
        D == null
          ? q.shapeFlag & 512
            ? oe.ctx.activate(q, F, te, Ee, Se)
            : V(q, F, te, oe, ue, Ee, Se)
          : Y(D, q, Se)
    },
    V = (D, q, F, te, oe, ue, Ee) => {
      const Ce = (D.component = xw(D, te, oe))
      if ((Du(D) && (Ce.ctx.renderer = je), ww(Ce), Ce.asyncDep)) {
        if ((oe && oe.registerDep(Ce, ne), !D.el)) {
          const Se = (Ce.subTree = At(mi))
          _(null, Se, q, F)
        }
        return
      }
      ne(Ce, D, q, F, oe, ue, Ee)
    },
    Y = (D, q, F) => {
      const te = (q.component = D.component)
      if (aE(D, q, F))
        if (te.asyncDep && !te.asyncResolved) {
          le(te, q, F)
          return
        } else (te.next = q), eE(te.update), te.update()
      else (q.el = D.el), (te.vnode = q)
    },
    ne = (D, q, F, te, oe, ue, Ee) => {
      const Ce = () => {
          if (D.isMounted) {
            let { next: Q, bu: pe, u: Re, parent: Ue, vnode: _e } = D,
              Xe = Q,
              se
            na(D, !1),
              Q ? ((Q.el = _e.el), le(D, Q, Ee)) : (Q = _e),
              pe && Zl(pe),
              (se = Q.props && Q.props.onVnodeBeforeUpdate) &&
                Fi(se, Ue, Q, _e),
              na(D, !0)
            const be = Fh(D),
              ze = D.subTree
            ;(D.subTree = be),
              C(ze, be, p(ze.el), Be(ze), D, oe, ue),
              (Q.el = be.el),
              Xe === null && Bg(D, be.el),
              Re && ai(Re, oe),
              (se = Q.props && Q.props.onVnodeUpdated) &&
                ai(() => Fi(se, Ue, Q, _e), oe)
          } else {
            let Q
            const { el: pe, props: Re } = q,
              { bm: Ue, m: _e, parent: Xe } = D,
              se = Ra(q)
            if (
              (na(D, !1),
              Ue && Zl(Ue),
              !se && (Q = Re && Re.onVnodeBeforeMount) && Fi(Q, Xe, q),
              na(D, !0),
              pe && ye)
            ) {
              const be = () => {
                ;(D.subTree = Fh(D)), ye(pe, D.subTree, D, oe, null)
              }
              se
                ? q.type.__asyncLoader().then(() => !D.isUnmounted && be())
                : be()
            } else {
              const be = (D.subTree = Fh(D))
              C(null, be, F, te, D, oe, ue), (q.el = be.el)
            }
            if ((_e && ai(_e, oe), !se && (Q = Re && Re.onVnodeMounted))) {
              const be = q
              ai(() => Fi(Q, Xe, be), oe)
            }
            ;(q.shapeFlag & 256 ||
              (Xe && Ra(Xe.vnode) && Xe.vnode.shapeFlag & 256)) &&
              D.a &&
              ai(D.a, oe),
              (D.isMounted = !0),
              (q = F = te = null)
          }
        },
        Se = (D.effect = new Cu(Ce, () => Dg($), D.scope)),
        $ = (D.update = () => Se.run())
      ;($.id = D.uid), na(D, !0), $()
    },
    le = (D, q, F) => {
      q.component = D
      const te = D.vnode.props
      ;(D.vnode = q),
        (D.next = null),
        DE(D, q.props, te, F),
        kE(D, q.children, F),
        Ya(),
        ld(void 0, D.update),
        Za()
    },
    Te = (D, q, F, te, oe, ue, Ee, Ce, Se = !1) => {
      const $ = D && D.children,
        Q = D ? D.shapeFlag : 0,
        pe = q.children,
        { patchFlag: Re, shapeFlag: Ue } = q
      if (Re > 0) {
        if (Re & 128) {
          ge($, pe, F, te, oe, ue, Ee, Ce, Se)
          return
        } else if (Re & 256) {
          Ae($, pe, F, te, oe, ue, Ee, Ce, Se)
          return
        }
      }
      Ue & 8
        ? (Q & 16 && ve($, oe, ue), pe !== $ && d(F, pe))
        : Q & 16
        ? Ue & 16
          ? ge($, pe, F, te, oe, ue, Ee, Ce, Se)
          : ve($, oe, ue, !0)
        : (Q & 8 && d(F, ""), Ue & 16 && W(pe, F, te, oe, ue, Ee, Ce, Se))
    },
    Ae = (D, q, F, te, oe, ue, Ee, Ce, Se) => {
      ;(D = D || Xl), (q = q || Xl)
      const $ = D.length,
        Q = q.length,
        pe = Math.min($, Q)
      let Re
      for (Re = 0; Re < pe; Re++) {
        const Ue = (q[Re] = Se ? wo(q[Re]) : Ji(q[Re]))
        C(D[Re], Ue, F, null, oe, ue, Ee, Ce, Se)
      }
      $ > Q ? ve(D, oe, ue, !0, !1, pe) : W(q, F, te, oe, ue, Ee, Ce, Se, pe)
    },
    ge = (D, q, F, te, oe, ue, Ee, Ce, Se) => {
      let $ = 0
      const Q = q.length
      let pe = D.length - 1,
        Re = Q - 1
      for (; $ <= pe && $ <= Re; ) {
        const Ue = D[$],
          _e = (q[$] = Se ? wo(q[$]) : Ji(q[$]))
        if (Kr(Ue, _e)) C(Ue, _e, F, null, oe, ue, Ee, Ce, Se)
        else break
        $++
      }
      for (; $ <= pe && $ <= Re; ) {
        const Ue = D[pe],
          _e = (q[Re] = Se ? wo(q[Re]) : Ji(q[Re]))
        if (Kr(Ue, _e)) C(Ue, _e, F, null, oe, ue, Ee, Ce, Se)
        else break
        pe--, Re--
      }
      if ($ > pe) {
        if ($ <= Re) {
          const Ue = Re + 1,
            _e = Ue < Q ? q[Ue].el : te
          for (; $ <= Re; )
            C(
              null,
              (q[$] = Se ? wo(q[$]) : Ji(q[$])),
              F,
              _e,
              oe,
              ue,
              Ee,
              Ce,
              Se
            ),
              $++
        }
      } else if ($ > Re) for (; $ <= pe; ) Ne(D[$], oe, ue, !0), $++
      else {
        const Ue = $,
          _e = $,
          Xe = new Map()
        for ($ = _e; $ <= Re; $++) {
          const ft = (q[$] = Se ? wo(q[$]) : Ji(q[$]))
          ft.key != null && Xe.set(ft.key, $)
        }
        let se,
          be = 0
        const ze = Re - _e + 1
        let at = !1,
          de = 0
        const it = new Array(ze)
        for ($ = 0; $ < ze; $++) it[$] = 0
        for ($ = Ue; $ <= pe; $++) {
          const ft = D[$]
          if (be >= ze) {
            Ne(ft, oe, ue, !0)
            continue
          }
          let De
          if (ft.key != null) De = Xe.get(ft.key)
          else
            for (se = _e; se <= Re; se++)
              if (it[se - _e] === 0 && Kr(ft, q[se])) {
                De = se
                break
              }
          De === void 0
            ? Ne(ft, oe, ue, !0)
            : ((it[De - _e] = $ + 1),
              De >= de ? (de = De) : (at = !0),
              C(ft, q[De], F, null, oe, ue, Ee, Ce, Se),
              be++)
        }
        const tt = at ? NE(it) : Xl
        for (se = tt.length - 1, $ = ze - 1; $ >= 0; $--) {
          const ft = _e + $,
            De = q[ft],
            ht = ft + 1 < Q ? q[ft + 1].el : te
          it[$] === 0
            ? C(null, De, F, ht, oe, ue, Ee, Ce, Se)
            : at && (se < 0 || $ !== tt[se] ? Me(De, F, ht, 2) : se--)
        }
      }
    },
    Me = (D, q, F, te, oe = null) => {
      const { el: ue, type: Ee, transition: Ce, children: Se, shapeFlag: $ } = D
      if ($ & 6) {
        Me(D.component.subTree, q, F, te)
        return
      }
      if ($ & 128) {
        D.suspense.move(q, F, te)
        return
      }
      if ($ & 64) {
        Ee.move(D, q, F, je)
        return
      }
      if (Ee === Qn) {
        i(ue, q, F)
        for (let pe = 0; pe < Se.length; pe++) Me(Se[pe], q, F, te)
        i(D.anchor, q, F)
        return
      }
      if (Ee === Pa) {
        T(D, q, F)
        return
      }
      if (te !== 2 && $ & 1 && Ce)
        if (te === 0)
          Ce.beforeEnter(ue), i(ue, q, F), ai(() => Ce.enter(ue), oe)
        else {
          const { leave: pe, delayLeave: Re, afterLeave: Ue } = Ce,
            _e = () => i(ue, q, F),
            Xe = () => {
              pe(ue, () => {
                _e(), Ue && Ue()
              })
            }
          Re ? Re(ue, _e, Xe) : Xe()
        }
      else i(ue, q, F)
    },
    Ne = (D, q, F, te = !1, oe = !1) => {
      const {
        type: ue,
        props: Ee,
        ref: Ce,
        children: Se,
        dynamicChildren: $,
        shapeFlag: Q,
        patchFlag: pe,
        dirs: Re,
      } = D
      if ((Ce != null && c0(Ce, null, F, D, !0), Q & 256)) {
        q.ctx.deactivate(D)
        return
      }
      const Ue = Q & 1 && Re,
        _e = !Ra(D)
      let Xe
      if ((_e && (Xe = Ee && Ee.onVnodeBeforeUnmount) && Fi(Xe, q, D), Q & 6))
        Oe(D.component, F, te)
      else {
        if (Q & 128) {
          D.suspense.unmount(F, te)
          return
        }
        Ue && Xr(D, null, q, "beforeUnmount"),
          Q & 64
            ? D.type.remove(D, q, F, oe, je, te)
            : $ && (ue !== Qn || (pe > 0 && pe & 64))
            ? ve($, q, F, !1, !0)
            : ((ue === Qn && pe & 384) || (!oe && Q & 16)) && ve(Se, q, F),
          te && Ze(D)
      }
      ;((_e && (Xe = Ee && Ee.onVnodeUnmounted)) || Ue) &&
        ai(() => {
          Xe && Fi(Xe, q, D), Ue && Xr(D, null, q, "unmounted")
        }, F)
    },
    Ze = D => {
      const { type: q, el: F, anchor: te, transition: oe } = D
      if (q === Qn) {
        K(F, te)
        return
      }
      if (q === Pa) {
        L(D)
        return
      }
      const ue = () => {
        r(F), oe && !oe.persisted && oe.afterLeave && oe.afterLeave()
      }
      if (D.shapeFlag & 1 && oe && !oe.persisted) {
        const { leave: Ee, delayLeave: Ce } = oe,
          Se = () => Ee(F, ue)
        Ce ? Ce(D.el, ue, Se) : Se()
      } else ue()
    },
    K = (D, q) => {
      let F
      for (; D !== q; ) (F = m(D)), r(D), (D = F)
      r(q)
    },
    Oe = (D, q, F) => {
      const { bum: te, scope: oe, update: ue, subTree: Ee, um: Ce } = D
      te && Zl(te),
        oe.stop(),
        ue && ((ue.active = !1), Ne(Ee, D, q, F)),
        Ce && ai(Ce, q),
        ai(() => {
          D.isUnmounted = !0
        }, q),
        q &&
          q.pendingBranch &&
          !q.isUnmounted &&
          D.asyncDep &&
          !D.asyncResolved &&
          D.suspenseId === q.pendingId &&
          (q.deps--, q.deps === 0 && q.resolve())
    },
    ve = (D, q, F, te = !1, oe = !1, ue = 0) => {
      for (let Ee = ue; Ee < D.length; Ee++) Ne(D[Ee], q, F, te, oe)
    },
    Be = D =>
      D.shapeFlag & 6
        ? Be(D.component.subTree)
        : D.shapeFlag & 128
        ? D.suspense.next()
        : m(D.anchor || D.el),
    Fe = (D, q, F) => {
      D == null
        ? q._vnode && Ne(q._vnode, null, null, !0)
        : C(q._vnode || null, D, q, null, null, null, F),
        r0(),
        (q._vnode = D)
    },
    je = {
      p: C,
      um: Ne,
      m: Me,
      r: Ze,
      mt: V,
      mc: W,
      pc: Te,
      pbc: P,
      n: Be,
      o: n,
    }
  let Ge, ye
  return (
    e && ([Ge, ye] = e(je)), { render: Fe, hydrate: Ge, createApp: qE(Fe, Ge) }
  )
}
function na({ effect: n, update: e }, t) {
  n.allowRecurse = e.allowRecurse = t
}
function Gg(n, e, t = !1) {
  const i = n.children,
    r = e.children
  if (vt(i) && vt(r))
    for (let s = 0; s < i.length; s++) {
      const o = i[s]
      let a = r[s]
      a.shapeFlag & 1 &&
        !a.dynamicChildren &&
        ((a.patchFlag <= 0 || a.patchFlag === 32) &&
          ((a = r[s] = wo(r[s])), (a.el = o.el)),
        t || Gg(o, a))
    }
}
function NE(n) {
  const e = n.slice(),
    t = [0]
  let i, r, s, o, a
  const A = n.length
  for (i = 0; i < A; i++) {
    const c = n[i]
    if (c !== 0) {
      if (((r = t[t.length - 1]), n[r] < c)) {
        ;(e[i] = r), t.push(i)
        continue
      }
      for (s = 0, o = t.length - 1; s < o; )
        (a = (s + o) >> 1), n[t[a]] < c ? (s = a + 1) : (o = a)
      c < n[t[s]] && (s > 0 && (e[i] = t[s - 1]), (t[s] = i))
    }
  }
  for (s = t.length, o = t[s - 1]; s-- > 0; ) (t[s] = o), (o = e[o])
  return t
}
const UE = n => n.__isTeleport,
  RA = n => n && (n.disabled || n.disabled === ""),
  hv = n => typeof SVGElement != "undefined" && n instanceof SVGElement,
  Om = (n, e) => {
    const t = n && n.to
    return Tn(t) ? (e ? e(t) : null) : t
  },
  zE = {
    __isTeleport: !0,
    process(n, e, t, i, r, s, o, a, A, c) {
      const {
          mc: d,
          pc: p,
          pbc: m,
          o: { insert: y, querySelector: x, createText: S, createComment: C },
        } = c,
        M = RA(e.props)
      let { shapeFlag: _, children: R, dynamicChildren: T } = e
      if (n == null) {
        const L = (e.el = S("")),
          B = (e.anchor = S(""))
        y(L, t, i), y(B, t, i)
        const k = (e.target = Om(e.props, x)),
          O = (e.targetAnchor = S(""))
        k && (y(O, k), (o = o || hv(k)))
        const W = (z, P) => {
          _ & 16 && d(R, z, P, r, s, o, a, A)
        }
        M ? W(t, B) : k && W(k, O)
      } else {
        e.el = n.el
        const L = (e.anchor = n.anchor),
          B = (e.target = n.target),
          k = (e.targetAnchor = n.targetAnchor),
          O = RA(n.props),
          W = O ? t : B,
          z = O ? L : k
        if (
          ((o = o || hv(B)),
          T
            ? (m(n.dynamicChildren, T, W, r, s, o, a), Gg(n, e, !0))
            : A || p(n, e, W, z, r, s, o, a, !1),
          M)
        )
          O || gf(e, t, L, c, 1)
        else if ((e.props && e.props.to) !== (n.props && n.props.to)) {
          const P = (e.target = Om(e.props, x))
          P && gf(e, P, null, c, 0)
        } else O && gf(e, B, k, c, 1)
      }
    },
    remove(n, e, t, i, { um: r, o: { remove: s } }, o) {
      const {
        shapeFlag: a,
        children: A,
        anchor: c,
        targetAnchor: d,
        target: p,
        props: m,
      } = n
      if ((p && s(d), (o || !RA(m)) && (s(c), a & 16)))
        for (let y = 0; y < A.length; y++) {
          const x = A[y]
          r(x, e, t, !0, !!x.dynamicChildren)
        }
    },
    move: gf,
    hydrate: HE,
  }
function gf(n, e, t, { o: { insert: i }, m: r }, s = 2) {
  s === 0 && i(n.targetAnchor, e, t)
  const { el: o, anchor: a, shapeFlag: A, children: c, props: d } = n,
    p = s === 2
  if ((p && i(o, e, t), (!p || RA(d)) && A & 16))
    for (let m = 0; m < c.length; m++) r(c[m], e, t, 2)
  p && i(a, e, t)
}
function HE(
  n,
  e,
  t,
  i,
  r,
  s,
  { o: { nextSibling: o, parentNode: a, querySelector: A } },
  c
) {
  const d = (e.target = Om(e.props, A))
  if (d) {
    const p = d._lpa || d.firstChild
    if (e.shapeFlag & 16)
      if (RA(e.props))
        (e.anchor = c(o(n), e, a(n), t, i, r, s)), (e.targetAnchor = p)
      else {
        e.anchor = o(n)
        let m = p
        for (; m; )
          if (
            ((m = o(m)), m && m.nodeType === 8 && m.data === "teleport anchor")
          ) {
            ;(e.targetAnchor = m),
              (d._lpa = e.targetAnchor && o(e.targetAnchor))
            break
          }
        c(p, e, d, t, i, r, s)
      }
  }
  return e.anchor && o(e.anchor)
}
const GE = zE,
  Qn = Symbol(void 0),
  Ac = Symbol(void 0),
  mi = Symbol(void 0),
  Pa = Symbol(void 0),
  PA = []
let Ui = null
function It(n = !1) {
  PA.push((Ui = n ? null : []))
}
function gw() {
  PA.pop(), (Ui = PA[PA.length - 1] || null)
}
let Fa = 1
function qm(n) {
  Fa += n
}
function yw(n) {
  return (
    (n.dynamicChildren = Fa > 0 ? Ui || Xl : null),
    gw(),
    Fa > 0 && Ui && Ui.push(n),
    n
  )
}
function qr(n, e, t, i, r, s) {
  return yw(bt(n, e, t, i, r, s, !0))
}
function Kt(n, e, t, i, r) {
  return yw(At(n, e, t, i, r, !0))
}
function qo(n) {
  return n ? n.__v_isVNode === !0 : !1
}
function Kr(n, e) {
  return n.type === e.type && n.key === e.key
}
function VE(n) {}
const dd = "__vInternal",
  vw = ({ key: n }) => (n != null ? n : null),
  Nh = ({ ref: n, ref_key: e, ref_for: t }) =>
    n != null
      ? Tn(n) || Gn(n) || Et(n)
        ? { i: pi, r: n, k: e, f: !!t }
        : n
      : null
function bt(
  n,
  e = null,
  t = null,
  i = 0,
  r = null,
  s = n === Qn ? 0 : 1,
  o = !1,
  a = !1
) {
  const A = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n,
    props: e,
    key: e && vw(e),
    ref: e && Nh(e),
    scopeId: Ad,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: s,
    patchFlag: i,
    dynamicProps: r,
    dynamicChildren: null,
    appContext: null,
  }
  return (
    a
      ? (Wg(A, t), s & 128 && n.normalize(A))
      : t && (A.shapeFlag |= Tn(t) ? 8 : 16),
    Fa > 0 &&
      !o &&
      Ui &&
      (A.patchFlag > 0 || s & 6) &&
      A.patchFlag !== 32 &&
      Ui.push(A),
    A
  )
}
const At = WE
function WE(n, e = null, t = null, i = 0, r = null, s = !1) {
  if (((!n || n === iw) && (n = mi), qo(n))) {
    const a = as(n, e, !0)
    return (
      t && Wg(a, t),
      Fa > 0 &&
        !s &&
        Ui &&
        (a.shapeFlag & 6 ? (Ui[Ui.indexOf(n)] = a) : Ui.push(a)),
      (a.patchFlag |= -2),
      a
    )
  }
  if ((tT(n) && (n = n.__vccOpts), e)) {
    e = Vg(e)
    let { class: a, style: A } = e
    a && !Tn(a) && (e.class = Ps(a)),
      In(A) && (Eg(A) && !vt(A) && (A = Dn({}, A)), (e.style = Mu(A)))
  }
  const o = Tn(n) ? 1 : Gb(n) ? 128 : UE(n) ? 64 : In(n) ? 4 : Et(n) ? 2 : 0
  return bt(n, e, t, i, r, o, s, !0)
}
function Vg(n) {
  return n ? (Eg(n) || dd in n ? Dn({}, n) : n) : null
}
function as(n, e, t = !1) {
  const { props: i, ref: r, patchFlag: s, children: o } = n,
    a = e ? _w(i || {}, e) : i
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n.type,
    props: a,
    key: a && vw(a),
    ref:
      e && e.ref
        ? t && r
          ? vt(r)
            ? r.concat(Nh(e))
            : [r, Nh(e)]
          : Nh(e)
        : r,
    scopeId: n.scopeId,
    slotScopeIds: n.slotScopeIds,
    children: o,
    target: n.target,
    targetAnchor: n.targetAnchor,
    staticCount: n.staticCount,
    shapeFlag: n.shapeFlag,
    patchFlag: e && n.type !== Qn ? (s === -1 ? 16 : s | 16) : s,
    dynamicProps: n.dynamicProps,
    dynamicChildren: n.dynamicChildren,
    appContext: n.appContext,
    dirs: n.dirs,
    transition: n.transition,
    component: n.component,
    suspense: n.suspense,
    ssContent: n.ssContent && as(n.ssContent),
    ssFallback: n.ssFallback && as(n.ssFallback),
    el: n.el,
    anchor: n.anchor,
  }
}
function hs(n = " ", e = 0) {
  return At(Ac, null, n, e)
}
function jE(n, e) {
  const t = At(Pa, null, n)
  return (t.staticCount = e), t
}
function Ss(n = "", e = !1) {
  return e ? (It(), Kt(mi, null, n)) : At(mi, null, n)
}
function Ji(n) {
  return n == null || typeof n == "boolean"
    ? At(mi)
    : vt(n)
    ? At(Qn, null, n.slice())
    : typeof n == "object"
    ? wo(n)
    : At(Ac, null, String(n))
}
function wo(n) {
  return n.el === null || n.memo ? n : as(n)
}
function Wg(n, e) {
  let t = 0
  const { shapeFlag: i } = n
  if (e == null) e = null
  else if (vt(e)) t = 16
  else if (typeof e == "object")
    if (i & 65) {
      const r = e.default
      r && (r._c && (r._d = !1), Wg(n, r()), r._c && (r._d = !0))
      return
    } else {
      t = 32
      const r = e._
      !r && !(dd in e)
        ? (e._ctx = pi)
        : r === 3 &&
          pi &&
          (pi.slots._ === 1 ? (e._ = 1) : ((e._ = 2), (n.patchFlag |= 1024)))
    }
  else
    Et(e)
      ? ((e = { default: e, _ctx: pi }), (t = 32))
      : ((e = String(e)), i & 64 ? ((t = 16), (e = [hs(e)])) : (t = 8))
  ;(n.children = e), (n.shapeFlag |= t)
}
function _w(...n) {
  const e = {}
  for (let t = 0; t < n.length; t++) {
    const i = n[t]
    for (const r in i)
      if (r === "class")
        e.class !== i.class && (e.class = Ps([e.class, i.class]))
      else if (r === "style") e.style = Mu([e.style, i.style])
      else if (Su(r)) {
        const s = e[r],
          o = i[r]
        o &&
          s !== o &&
          !(vt(s) && s.includes(o)) &&
          (e[r] = s ? [].concat(s, o) : o)
      } else r !== "" && (e[r] = i[r])
  }
  return e
}
function Fi(n, e, t, i = null) {
  nr(n, e, 7, [t, i])
}
const $E = hw()
let QE = 0
function xw(n, e, t) {
  const i = n.type,
    r = (e ? e.appContext : n.appContext) || $E,
    s = {
      uid: QE++,
      vnode: n,
      type: i,
      parent: e,
      appContext: r,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new bg(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: e ? e.provides : Object.create(r.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: cw(i, r),
      emitsOptions: Hb(i, r),
      emit: null,
      emitted: null,
      propsDefaults: Jt,
      inheritAttrs: i.inheritAttrs,
      ctx: Jt,
      data: Jt,
      props: Jt,
      attrs: Jt,
      slots: Jt,
      refs: Jt,
      setupState: Jt,
      setupContext: null,
      suspense: t,
      suspenseId: t ? t.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null,
    }
  return (
    (s.ctx = { _: s }),
    (s.root = e ? e.root : s),
    (s.emit = nE.bind(null, s)),
    n.ce && n.ce(s),
    s
  )
}
let Yn = null
const zr = () => Yn || pi,
  Fo = n => {
    ;(Yn = n), n.scope.on()
  },
  Co = () => {
    Yn && Yn.scope.off(), (Yn = null)
  }
function bw(n) {
  return n.vnode.shapeFlag & 4
}
let uc = !1
function ww(n, e = !1) {
  uc = e
  const { props: t, children: i } = n.vnode,
    r = bw(n)
  LE(n, t, r, e), BE(n, i)
  const s = r ? XE(n, e) : void 0
  return (uc = !1), s
}
function XE(n, e) {
  const t = n.type
  ;(n.accessCache = Object.create(null)), (n.proxy = Ru(new Proxy(n.ctx, Dm)))
  const { setup: i } = t
  if (i) {
    const r = (n.setupContext = i.length > 1 ? Sw(n) : null)
    Fo(n), Ya()
    const s = ts(i, n, 0, [n.props, r])
    if ((Za(), Co(), _g(s))) {
      if ((s.then(Co, Co), e))
        return s
          .then(o => {
            Fm(n, o, e)
          })
          .catch(o => {
            Ja(o, n, 0)
          })
      n.asyncDep = s
    } else Fm(n, s, e)
  } else Mw(n, e)
}
function Fm(n, e, t) {
  Et(e)
    ? n.type.__ssrInlineRender
      ? (n.ssrRender = e)
      : (n.render = e)
    : In(e) && (n.setupState = Rg(e)),
    Mw(n, t)
}
let A0, Nm
function YE(n) {
  ;(A0 = n),
    (Nm = e => {
      e.render._rc && (e.withProxy = new Proxy(e.ctx, SE))
    })
}
const ZE = () => !A0
function Mw(n, e, t) {
  const i = n.type
  if (!n.render) {
    if (!e && A0 && !i.render) {
      const r = i.template
      if (r) {
        const { isCustomElement: s, compilerOptions: o } = n.appContext.config,
          { delimiters: a, compilerOptions: A } = i,
          c = Dn(Dn({ isCustomElement: s, delimiters: a }, o), A)
        i.render = A0(r, c)
      }
    }
    ;(n.render = i.render || kr), Nm && Nm(n)
  }
  Fo(n), Ya(), EE(n), Za(), Co()
}
function JE(n) {
  return new Proxy(n.attrs, {
    get(e, t) {
      return or(n, "get", "$attrs"), e[t]
    },
  })
}
function Sw(n) {
  const e = i => {
    n.exposed = i || {}
  }
  let t
  return {
    get attrs() {
      return t || (t = JE(n))
    },
    slots: n.slots,
    emit: n.emit,
    expose: e,
  }
}
function pd(n) {
  if (n.exposed)
    return (
      n.exposeProxy ||
      (n.exposeProxy = new Proxy(Rg(Ru(n.exposed)), {
        get(e, t) {
          if (t in e) return e[t]
          if (t in a0) return a0[t](n)
        },
      }))
    )
}
const KE = /(?:^|[-_])(\w)/g,
  eT = n => n.replace(KE, e => e.toUpperCase()).replace(/[-_]/g, "")
function u0(n, e = !0) {
  return Et(n) ? n.displayName || n.name : n.name || (e && n.__name)
}
function Ew(n, e, t = !1) {
  let i = u0(e)
  if (!i && e.__file) {
    const r = e.__file.match(/([^/\\]+)\.\w+$/)
    r && (i = r[1])
  }
  if (!i && n && n.parent) {
    const r = s => {
      for (const o in s) if (s[o] === e) return o
    }
    i =
      r(n.components || n.parent.type.components) || r(n.appContext.components)
  }
  return i ? eT(i) : t ? "App" : "Anonymous"
}
function tT(n) {
  return Et(n) && "__vccOpts" in n
}
const _n = (n, e) => $7(n, e, uc)
function nT() {
  return null
}
function iT() {
  return null
}
function rT(n) {}
function sT(n, e) {
  return null
}
function oT() {
  return Tw().slots
}
function aT() {
  return Tw().attrs
}
function Tw() {
  const n = zr()
  return n.setupContext || (n.setupContext = Sw(n))
}
function lT(n, e) {
  const t = vt(n) ? n.reduce((i, r) => ((i[r] = {}), i), {}) : n
  for (const i in e) {
    const r = t[i]
    r
      ? vt(r) || Et(r)
        ? (t[i] = { type: r, default: e[i] })
        : (r.default = e[i])
      : r === null && (t[i] = { default: e[i] })
  }
  return t
}
function cT(n, e) {
  const t = {}
  for (const i in n)
    e.includes(i) ||
      Object.defineProperty(t, i, { enumerable: !0, get: () => n[i] })
  return t
}
function AT(n) {
  const e = zr()
  let t = n()
  return (
    Co(),
    _g(t) &&
      (t = t.catch(i => {
        throw (Fo(e), i)
      })),
    [t, () => Fo(e)]
  )
}
function tr(n, e, t) {
  const i = arguments.length
  return i === 2
    ? In(e) && !vt(e)
      ? qo(e)
        ? At(n, null, [e])
        : At(n, e)
      : At(n, null, e)
    : (i > 3
        ? (t = Array.prototype.slice.call(arguments, 2))
        : i === 3 && qo(t) && (t = [t]),
      At(n, e, t))
}
const Cw = Symbol(""),
  uT = () => {
    {
      const n = _r(Cw)
      return (
        n ||
          kb(
            "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
          ),
        n
      )
    }
  }
function fT() {}
function hT(n, e, t, i) {
  const r = t[i]
  if (r && Rw(r, n)) return r
  const s = e()
  return (s.memo = n.slice()), (t[i] = s)
}
function Rw(n, e) {
  const t = n.memo
  if (t.length != e.length) return !1
  for (let i = 0; i < t.length; i++) if (ac(t[i], e[i])) return !1
  return Fa > 0 && Ui && Ui.push(n), !0
}
const Pw = "3.2.37",
  dT = {
    createComponentInstance: xw,
    setupComponent: ww,
    renderComponentRoot: Fh,
    setCurrentRenderingInstance: VA,
    isVNode: qo,
    normalizeVNode: Ji,
  },
  pT = dT,
  mT = null,
  gT = null,
  yT = "http://www.w3.org/2000/svg",
  ga = typeof document != "undefined" ? document : null,
  dv = ga && ga.createElement("template"),
  vT = {
    insert: (n, e, t) => {
      e.insertBefore(n, t || null)
    },
    remove: n => {
      const e = n.parentNode
      e && e.removeChild(n)
    },
    createElement: (n, e, t, i) => {
      const r = e
        ? ga.createElementNS(yT, n)
        : ga.createElement(n, t ? { is: t } : void 0)
      return (
        n === "select" &&
          i &&
          i.multiple != null &&
          r.setAttribute("multiple", i.multiple),
        r
      )
    },
    createText: n => ga.createTextNode(n),
    createComment: n => ga.createComment(n),
    setText: (n, e) => {
      n.nodeValue = e
    },
    setElementText: (n, e) => {
      n.textContent = e
    },
    parentNode: n => n.parentNode,
    nextSibling: n => n.nextSibling,
    querySelector: n => ga.querySelector(n),
    setScopeId(n, e) {
      n.setAttribute(e, "")
    },
    cloneNode(n) {
      const e = n.cloneNode(!0)
      return "_value" in n && (e._value = n._value), e
    },
    insertStaticContent(n, e, t, i, r, s) {
      const o = t ? t.previousSibling : e.lastChild
      if (r && (r === s || r.nextSibling))
        for (
          ;
          e.insertBefore(r.cloneNode(!0), t),
            !(r === s || !(r = r.nextSibling));

        );
      else {
        dv.innerHTML = i ? `<svg>${n}</svg>` : n
        const a = dv.content
        if (i) {
          const A = a.firstChild
          for (; A.firstChild; ) a.appendChild(A.firstChild)
          a.removeChild(A)
        }
        e.insertBefore(a, t)
      }
      return [
        o ? o.nextSibling : e.firstChild,
        t ? t.previousSibling : e.lastChild,
      ]
    },
  }
function _T(n, e, t) {
  const i = n._vtc
  i && (e = (e ? [e, ...i] : [...i]).join(" ")),
    e == null
      ? n.removeAttribute("class")
      : t
      ? n.setAttribute("class", e)
      : (n.className = e)
}
function xT(n, e, t) {
  const i = n.style,
    r = Tn(t)
  if (t && !r) {
    for (const s in t) Um(i, s, t[s])
    if (e && !Tn(e)) for (const s in e) t[s] == null && Um(i, s, "")
  } else {
    const s = i.display
    r ? e !== t && (i.cssText = t) : e && n.removeAttribute("style"),
      "_vod" in n && (i.display = s)
  }
}
const pv = /\s*!important$/
function Um(n, e, t) {
  if (vt(t)) t.forEach(i => Um(n, e, i))
  else if ((t == null && (t = ""), e.startsWith("--"))) n.setProperty(e, t)
  else {
    const i = bT(n, e)
    pv.test(t)
      ? n.setProperty(es(i), t.replace(pv, ""), "important")
      : (n[i] = t)
  }
}
const mv = ["Webkit", "Moz", "ms"],
  yp = {}
function bT(n, e) {
  const t = yp[e]
  if (t) return t
  let i = sr(e)
  if (i !== "filter" && i in n) return (yp[e] = i)
  i = Tu(i)
  for (let r = 0; r < mv.length; r++) {
    const s = mv[r] + i
    if (s in n) return (yp[e] = s)
  }
  return e
}
const gv = "http://www.w3.org/1999/xlink"
function wT(n, e, t, i, r) {
  if (i && e.startsWith("xlink:"))
    t == null
      ? n.removeAttributeNS(gv, e.slice(6, e.length))
      : n.setAttributeNS(gv, e, t)
  else {
    const s = YS(e)
    t == null || (s && !db(t))
      ? n.removeAttribute(e)
      : n.setAttribute(e, s ? "" : t)
  }
}
function MT(n, e, t, i, r, s, o) {
  if (e === "innerHTML" || e === "textContent") {
    i && o(i, r, s), (n[e] = t == null ? "" : t)
    return
  }
  if (e === "value" && n.tagName !== "PROGRESS" && !n.tagName.includes("-")) {
    n._value = t
    const A = t == null ? "" : t
    ;(n.value !== A || n.tagName === "OPTION") && (n.value = A),
      t == null && n.removeAttribute(e)
    return
  }
  let a = !1
  if (t === "" || t == null) {
    const A = typeof n[e]
    A === "boolean"
      ? (t = db(t))
      : t == null && A === "string"
      ? ((t = ""), (a = !0))
      : A === "number" && ((t = 0), (a = !0))
  }
  try {
    n[e] = t
  } catch {}
  a && n.removeAttribute(e)
}
const [Lw, ST] = (() => {
  let n = Date.now,
    e = !1
  if (typeof window != "undefined") {
    Date.now() > document.createEvent("Event").timeStamp &&
      (n = performance.now.bind(performance))
    const t = navigator.userAgent.match(/firefox\/(\d+)/i)
    e = !!(t && Number(t[1]) <= 53)
  }
  return [n, e]
})()
let zm = 0
const ET = Promise.resolve(),
  TT = () => {
    zm = 0
  },
  CT = () => zm || (ET.then(TT), (zm = Lw()))
function Cs(n, e, t, i) {
  n.addEventListener(e, t, i)
}
function RT(n, e, t, i) {
  n.removeEventListener(e, t, i)
}
function PT(n, e, t, i, r = null) {
  const s = n._vei || (n._vei = {}),
    o = s[e]
  if (i && o) o.value = i
  else {
    const [a, A] = LT(e)
    if (i) {
      const c = (s[e] = DT(i, r))
      Cs(n, a, c, A)
    } else o && (RT(n, a, o, A), (s[e] = void 0))
  }
}
const yv = /(?:Once|Passive|Capture)$/
function LT(n) {
  let e
  if (yv.test(n)) {
    e = {}
    let t
    for (; (t = n.match(yv)); )
      (n = n.slice(0, n.length - t[0].length)), (e[t[0].toLowerCase()] = !0)
  }
  return [es(n.slice(2)), e]
}
function DT(n, e) {
  const t = i => {
    const r = i.timeStamp || Lw()
    ;(ST || r >= t.attached - 1) && nr(IT(i, t.value), e, 5, [i])
  }
  return (t.value = n), (t.attached = CT()), t
}
function IT(n, e) {
  if (vt(e)) {
    const t = n.stopImmediatePropagation
    return (
      (n.stopImmediatePropagation = () => {
        t.call(n), (n._stopped = !0)
      }),
      e.map(i => r => !r._stopped && i && i(r))
    )
  } else return e
}
const vv = /^on[a-z]/,
  BT = (n, e, t, i, r = !1, s, o, a, A) => {
    e === "class"
      ? _T(n, i, r)
      : e === "style"
      ? xT(n, t, i)
      : Su(e)
      ? yg(e) || PT(n, e, t, i, o)
      : (
          e[0] === "."
            ? ((e = e.slice(1)), !0)
            : e[0] === "^"
            ? ((e = e.slice(1)), !1)
            : kT(n, e, i, r)
        )
      ? MT(n, e, i, s, o, a, A)
      : (e === "true-value"
          ? (n._trueValue = i)
          : e === "false-value" && (n._falseValue = i),
        wT(n, e, i, r))
  }
function kT(n, e, t, i) {
  return i
    ? !!(
        e === "innerHTML" ||
        e === "textContent" ||
        (e in n && vv.test(e) && Et(t))
      )
    : e === "spellcheck" ||
      e === "draggable" ||
      e === "translate" ||
      e === "form" ||
      (e === "list" && n.tagName === "INPUT") ||
      (e === "type" && n.tagName === "TEXTAREA") ||
      (vv.test(e) && Tn(t))
    ? !1
    : e in n
}
function Dw(n, e) {
  const t = ni(n)
  class i extends md {
    constructor(s) {
      super(t, s, e)
    }
  }
  return (i.def = t), i
}
const OT = n => Dw(n, $w),
  qT = typeof HTMLElement != "undefined" ? HTMLElement : class {}
class md extends qT {
  constructor(e, t = {}, i) {
    super(),
      (this._def = e),
      (this._props = t),
      (this._instance = null),
      (this._connected = !1),
      (this._resolved = !1),
      (this._numberProps = null),
      this.shadowRoot && i
        ? i(this._createVNode(), this.shadowRoot)
        : this.attachShadow({ mode: "open" })
  }
  connectedCallback() {
    ;(this._connected = !0), this._instance || this._resolveDef()
  }
  disconnectedCallback() {
    ;(this._connected = !1),
      Pu(() => {
        this._connected || (jA(null, this.shadowRoot), (this._instance = null))
      })
  }
  _resolveDef() {
    if (this._resolved) return
    this._resolved = !0
    for (let i = 0; i < this.attributes.length; i++)
      this._setAttr(this.attributes[i].name)
    new MutationObserver(i => {
      for (const r of i) this._setAttr(r.attributeName)
    }).observe(this, { attributes: !0 })
    const e = i => {
        const { props: r, styles: s } = i,
          o = !vt(r),
          a = r ? (o ? Object.keys(r) : r) : []
        let A
        if (o)
          for (const c in this._props) {
            const d = r[c]
            ;(d === Number || (d && d.type === Number)) &&
              ((this._props[c] = Bo(this._props[c])),
              ((A || (A = Object.create(null)))[c] = !0))
          }
        this._numberProps = A
        for (const c of Object.keys(this))
          c[0] !== "_" && this._setProp(c, this[c], !0, !1)
        for (const c of a.map(sr))
          Object.defineProperty(this, c, {
            get() {
              return this._getProp(c)
            },
            set(d) {
              this._setProp(c, d)
            },
          })
        this._applyStyles(s), this._update()
      },
      t = this._def.__asyncLoader
    t ? t().then(e) : e(this._def)
  }
  _setAttr(e) {
    let t = this.getAttribute(e)
    this._numberProps && this._numberProps[e] && (t = Bo(t)),
      this._setProp(sr(e), t, !1)
  }
  _getProp(e) {
    return this._props[e]
  }
  _setProp(e, t, i = !0, r = !0) {
    t !== this._props[e] &&
      ((this._props[e] = t),
      r && this._instance && this._update(),
      i &&
        (t === !0
          ? this.setAttribute(es(e), "")
          : typeof t == "string" || typeof t == "number"
          ? this.setAttribute(es(e), t + "")
          : t || this.removeAttribute(es(e))))
  }
  _update() {
    jA(this._createVNode(), this.shadowRoot)
  }
  _createVNode() {
    const e = At(this._def, Dn({}, this._props))
    return (
      this._instance ||
        (e.ce = t => {
          ;(this._instance = t),
            (t.isCE = !0),
            (t.emit = (r, ...s) => {
              this.dispatchEvent(new CustomEvent(r, { detail: s }))
            })
          let i = this
          for (; (i = i && (i.parentNode || i.host)); )
            if (i instanceof md) {
              t.parent = i._instance
              break
            }
        }),
      e
    )
  }
  _applyStyles(e) {
    e &&
      e.forEach(t => {
        const i = document.createElement("style")
        ;(i.textContent = t), this.shadowRoot.appendChild(i)
      })
  }
}
function FT(n = "$style") {
  {
    const e = zr()
    if (!e) return Jt
    const t = e.type.__cssModules
    if (!t) return Jt
    const i = t[n]
    return i || Jt
  }
}
function NT(n) {
  const e = zr()
  if (!e) return
  const t = () => Hm(e.subTree, n(e.proxy))
  Wb(t),
    Ls(() => {
      const i = new MutationObserver(t)
      i.observe(e.subTree.el.parentNode, { childList: !0 }),
        Oo(() => i.disconnect())
    })
}
function Hm(n, e) {
  if (n.shapeFlag & 128) {
    const t = n.suspense
    ;(n = t.activeBranch),
      t.pendingBranch &&
        !t.isHydrating &&
        t.effects.push(() => {
          Hm(t.activeBranch, e)
        })
  }
  for (; n.component; ) n = n.component.subTree
  if (n.shapeFlag & 1 && n.el) _v(n.el, e)
  else if (n.type === Qn) n.children.forEach(t => Hm(t, e))
  else if (n.type === Pa) {
    let { el: t, anchor: i } = n
    for (; t && (_v(t, e), t !== i); ) t = t.nextSibling
  }
}
function _v(n, e) {
  if (n.nodeType === 1) {
    const t = n.style
    for (const i in e) t.setProperty(`--${i}`, e[i])
  }
}
const so = "transition",
  Kc = "animation",
  Fc = (n, { slots: e }) => tr(Fg, Bw(n), e)
Fc.displayName = "Transition"
const Iw = {
    name: String,
    type: String,
    css: { type: Boolean, default: !0 },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String,
  },
  UT = (Fc.props = Dn({}, Fg.props, Iw)),
  ia = (n, e = []) => {
    vt(n) ? n.forEach(t => t(...e)) : n && n(...e)
  },
  xv = n => (n ? (vt(n) ? n.some(e => e.length > 1) : n.length > 1) : !1)
function Bw(n) {
  const e = {}
  for (const N in n) N in Iw || (e[N] = n[N])
  if (n.css === !1) return e
  const {
      name: t = "v",
      type: i,
      duration: r,
      enterFromClass: s = `${t}-enter-from`,
      enterActiveClass: o = `${t}-enter-active`,
      enterToClass: a = `${t}-enter-to`,
      appearFromClass: A = s,
      appearActiveClass: c = o,
      appearToClass: d = a,
      leaveFromClass: p = `${t}-leave-from`,
      leaveActiveClass: m = `${t}-leave-active`,
      leaveToClass: y = `${t}-leave-to`,
    } = n,
    x = zT(r),
    S = x && x[0],
    C = x && x[1],
    {
      onBeforeEnter: M,
      onEnter: _,
      onEnterCancelled: R,
      onLeave: T,
      onLeaveCancelled: L,
      onBeforeAppear: B = M,
      onAppear: k = _,
      onAppearCancelled: O = R,
    } = e,
    W = (N, G, j) => {
      bo(N, G ? d : a), bo(N, G ? c : o), j && j()
    },
    z = (N, G) => {
      ;(N._isLeaving = !1), bo(N, p), bo(N, y), bo(N, m), G && G()
    },
    P = N => (G, j) => {
      const V = N ? k : _,
        Y = () => W(G, N, j)
      ia(V, [G, Y]),
        bv(() => {
          bo(G, N ? A : s), Ms(G, N ? d : a), xv(V) || wv(G, i, S, Y)
        })
    }
  return Dn(e, {
    onBeforeEnter(N) {
      ia(M, [N]), Ms(N, s), Ms(N, o)
    },
    onBeforeAppear(N) {
      ia(B, [N]), Ms(N, A), Ms(N, c)
    },
    onEnter: P(!1),
    onAppear: P(!0),
    onLeave(N, G) {
      N._isLeaving = !0
      const j = () => z(N, G)
      Ms(N, p),
        Ow(),
        Ms(N, m),
        bv(() => {
          !N._isLeaving || (bo(N, p), Ms(N, y), xv(T) || wv(N, i, C, j))
        }),
        ia(T, [N, j])
    },
    onEnterCancelled(N) {
      W(N, !1), ia(R, [N])
    },
    onAppearCancelled(N) {
      W(N, !0), ia(O, [N])
    },
    onLeaveCancelled(N) {
      z(N), ia(L, [N])
    },
  })
}
function zT(n) {
  if (n == null) return null
  if (In(n)) return [vp(n.enter), vp(n.leave)]
  {
    const e = vp(n)
    return [e, e]
  }
}
function vp(n) {
  return Bo(n)
}
function Ms(n, e) {
  e.split(/\s+/).forEach(t => t && n.classList.add(t)),
    (n._vtc || (n._vtc = new Set())).add(e)
}
function bo(n, e) {
  e.split(/\s+/).forEach(i => i && n.classList.remove(i))
  const { _vtc: t } = n
  t && (t.delete(e), t.size || (n._vtc = void 0))
}
function bv(n) {
  requestAnimationFrame(() => {
    requestAnimationFrame(n)
  })
}
let HT = 0
function wv(n, e, t, i) {
  const r = (n._endId = ++HT),
    s = () => {
      r === n._endId && i()
    }
  if (t) return setTimeout(s, t)
  const { type: o, timeout: a, propCount: A } = kw(n, e)
  if (!o) return i()
  const c = o + "end"
  let d = 0
  const p = () => {
      n.removeEventListener(c, m), s()
    },
    m = y => {
      y.target === n && ++d >= A && p()
    }
  setTimeout(() => {
    d < A && p()
  }, a + 1),
    n.addEventListener(c, m)
}
function kw(n, e) {
  const t = window.getComputedStyle(n),
    i = x => (t[x] || "").split(", "),
    r = i(so + "Delay"),
    s = i(so + "Duration"),
    o = Mv(r, s),
    a = i(Kc + "Delay"),
    A = i(Kc + "Duration"),
    c = Mv(a, A)
  let d = null,
    p = 0,
    m = 0
  e === so
    ? o > 0 && ((d = so), (p = o), (m = s.length))
    : e === Kc
    ? c > 0 && ((d = Kc), (p = c), (m = A.length))
    : ((p = Math.max(o, c)),
      (d = p > 0 ? (o > c ? so : Kc) : null),
      (m = d ? (d === so ? s.length : A.length) : 0))
  const y = d === so && /\b(transform|all)(,|$)/.test(t[so + "Property"])
  return { type: d, timeout: p, propCount: m, hasTransform: y }
}
function Mv(n, e) {
  for (; n.length < e.length; ) n = n.concat(n)
  return Math.max(...e.map((t, i) => Sv(t) + Sv(n[i])))
}
function Sv(n) {
  return Number(n.slice(0, -1).replace(",", ".")) * 1e3
}
function Ow() {
  return document.body.offsetHeight
}
const qw = new WeakMap(),
  Fw = new WeakMap(),
  GT = {
    name: "TransitionGroup",
    props: Dn({}, UT, { tag: String, moveClass: String }),
    setup(n, { slots: e }) {
      const t = zr(),
        i = qg()
      let r, s
      return (
        hd(() => {
          if (!r.length) return
          const o = n.moveClass || `${n.name || "v"}-move`
          if (!QT(r[0].el, t.vnode.el, o)) return
          r.forEach(WT), r.forEach(jT)
          const a = r.filter($T)
          Ow(),
            a.forEach(A => {
              const c = A.el,
                d = c.style
              Ms(c, o),
                (d.transform = d.webkitTransform = d.transitionDuration = "")
              const p = (c._moveCb = m => {
                ;(m && m.target !== c) ||
                  ((!m || /transform$/.test(m.propertyName)) &&
                    (c.removeEventListener("transitionend", p),
                    (c._moveCb = null),
                    bo(c, o)))
              })
              c.addEventListener("transitionend", p)
            })
        }),
        () => {
          const o = Ut(n),
            a = Bw(o)
          let A = o.tag || Qn
          ;(r = s), (s = e.default ? ud(e.default()) : [])
          for (let c = 0; c < s.length; c++) {
            const d = s[c]
            d.key != null && qa(d, cc(d, a, i, t))
          }
          if (r)
            for (let c = 0; c < r.length; c++) {
              const d = r[c]
              qa(d, cc(d, a, i, t)), qw.set(d, d.el.getBoundingClientRect())
            }
          return At(A, null, s)
        }
      )
    },
  },
  VT = GT
function WT(n) {
  const e = n.el
  e._moveCb && e._moveCb(), e._enterCb && e._enterCb()
}
function jT(n) {
  Fw.set(n, n.el.getBoundingClientRect())
}
function $T(n) {
  const e = qw.get(n),
    t = Fw.get(n),
    i = e.left - t.left,
    r = e.top - t.top
  if (i || r) {
    const s = n.el.style
    return (
      (s.transform = s.webkitTransform = `translate(${i}px,${r}px)`),
      (s.transitionDuration = "0s"),
      n
    )
  }
}
function QT(n, e, t) {
  const i = n.cloneNode()
  n._vtc &&
    n._vtc.forEach(o => {
      o.split(/\s+/).forEach(a => a && i.classList.remove(a))
    }),
    t.split(/\s+/).forEach(o => o && i.classList.add(o)),
    (i.style.display = "none")
  const r = e.nodeType === 1 ? e : e.parentNode
  r.appendChild(i)
  const { hasTransform: s } = kw(i)
  return r.removeChild(i), s
}
const No = n => {
  const e = n.props["onUpdate:modelValue"] || !1
  return vt(e) ? t => Zl(e, t) : e
}
function XT(n) {
  n.target.composing = !0
}
function Ev(n) {
  const e = n.target
  e.composing && ((e.composing = !1), e.dispatchEvent(new Event("input")))
}
const f0 = {
    created(n, { modifiers: { lazy: e, trim: t, number: i } }, r) {
      n._assign = No(r)
      const s = i || (r.props && r.props.type === "number")
      Cs(n, e ? "change" : "input", o => {
        if (o.target.composing) return
        let a = n.value
        t && (a = a.trim()), s && (a = Bo(a)), n._assign(a)
      }),
        t &&
          Cs(n, "change", () => {
            n.value = n.value.trim()
          }),
        e ||
          (Cs(n, "compositionstart", XT),
          Cs(n, "compositionend", Ev),
          Cs(n, "change", Ev))
    },
    mounted(n, { value: e }) {
      n.value = e == null ? "" : e
    },
    beforeUpdate(
      n,
      { value: e, modifiers: { lazy: t, trim: i, number: r } },
      s
    ) {
      if (
        ((n._assign = No(s)),
        n.composing ||
          (document.activeElement === n &&
            n.type !== "range" &&
            (t ||
              (i && n.value.trim() === e) ||
              ((r || n.type === "number") && Bo(n.value) === e))))
      )
        return
      const o = e == null ? "" : e
      n.value !== o && (n.value = o)
    },
  },
  jg = {
    deep: !0,
    created(n, e, t) {
      ;(n._assign = No(t)),
        Cs(n, "change", () => {
          const i = n._modelValue,
            r = fc(n),
            s = n.checked,
            o = n._assign
          if (vt(i)) {
            const a = td(i, r),
              A = a !== -1
            if (s && !A) o(i.concat(r))
            else if (!s && A) {
              const c = [...i]
              c.splice(a, 1), o(c)
            }
          } else if (Xa(i)) {
            const a = new Set(i)
            s ? a.add(r) : a.delete(r), o(a)
          } else o(Uw(n, s))
        })
    },
    mounted: Tv,
    beforeUpdate(n, e, t) {
      ;(n._assign = No(t)), Tv(n, e, t)
    },
  }
function Tv(n, { value: e, oldValue: t }, i) {
  ;(n._modelValue = e),
    vt(e)
      ? (n.checked = td(e, i.props.value) > -1)
      : Xa(e)
      ? (n.checked = e.has(i.props.value))
      : e !== t && (n.checked = Io(e, Uw(n, !0)))
}
const $g = {
    created(n, { value: e }, t) {
      ;(n.checked = Io(e, t.props.value)),
        (n._assign = No(t)),
        Cs(n, "change", () => {
          n._assign(fc(n))
        })
    },
    beforeUpdate(n, { value: e, oldValue: t }, i) {
      ;(n._assign = No(i)), e !== t && (n.checked = Io(e, i.props.value))
    },
  },
  Nw = {
    deep: !0,
    created(n, { value: e, modifiers: { number: t } }, i) {
      const r = Xa(e)
      Cs(n, "change", () => {
        const s = Array.prototype.filter
          .call(n.options, o => o.selected)
          .map(o => (t ? Bo(fc(o)) : fc(o)))
        n._assign(n.multiple ? (r ? new Set(s) : s) : s[0])
      }),
        (n._assign = No(i))
    },
    mounted(n, { value: e }) {
      Cv(n, e)
    },
    beforeUpdate(n, e, t) {
      n._assign = No(t)
    },
    updated(n, { value: e }) {
      Cv(n, e)
    },
  }
function Cv(n, e) {
  const t = n.multiple
  if (!(t && !vt(e) && !Xa(e))) {
    for (let i = 0, r = n.options.length; i < r; i++) {
      const s = n.options[i],
        o = fc(s)
      if (t) vt(e) ? (s.selected = td(e, o) > -1) : (s.selected = e.has(o))
      else if (Io(fc(s), e)) {
        n.selectedIndex !== i && (n.selectedIndex = i)
        return
      }
    }
    !t && n.selectedIndex !== -1 && (n.selectedIndex = -1)
  }
}
function fc(n) {
  return "_value" in n ? n._value : n.value
}
function Uw(n, e) {
  const t = e ? "_trueValue" : "_falseValue"
  return t in n ? n[t] : e
}
const zw = {
  created(n, e, t) {
    yf(n, e, t, null, "created")
  },
  mounted(n, e, t) {
    yf(n, e, t, null, "mounted")
  },
  beforeUpdate(n, e, t, i) {
    yf(n, e, t, i, "beforeUpdate")
  },
  updated(n, e, t, i) {
    yf(n, e, t, i, "updated")
  },
}
function Hw(n, e) {
  switch (n) {
    case "SELECT":
      return Nw
    case "TEXTAREA":
      return f0
    default:
      switch (e) {
        case "checkbox":
          return jg
        case "radio":
          return $g
        default:
          return f0
      }
  }
}
function yf(n, e, t, i, r) {
  const o = Hw(n.tagName, t.props && t.props.type)[r]
  o && o(n, e, t, i)
}
function YT() {
  ;(f0.getSSRProps = ({ value: n }) => ({ value: n })),
    ($g.getSSRProps = ({ value: n }, e) => {
      if (e.props && Io(e.props.value, n)) return { checked: !0 }
    }),
    (jg.getSSRProps = ({ value: n }, e) => {
      if (vt(n)) {
        if (e.props && td(n, e.props.value) > -1) return { checked: !0 }
      } else if (Xa(n)) {
        if (e.props && n.has(e.props.value)) return { checked: !0 }
      } else if (n) return { checked: !0 }
    }),
    (zw.getSSRProps = (n, e) => {
      if (typeof e.type != "string") return
      const t = Hw(e.type.toUpperCase(), e.props && e.props.type)
      if (t.getSSRProps) return t.getSSRProps(n, e)
    })
}
const ZT = ["ctrl", "shift", "alt", "meta"],
  JT = {
    stop: n => n.stopPropagation(),
    prevent: n => n.preventDefault(),
    self: n => n.target !== n.currentTarget,
    ctrl: n => !n.ctrlKey,
    shift: n => !n.shiftKey,
    alt: n => !n.altKey,
    meta: n => !n.metaKey,
    left: n => "button" in n && n.button !== 0,
    middle: n => "button" in n && n.button !== 1,
    right: n => "button" in n && n.button !== 2,
    exact: (n, e) => ZT.some(t => n[`${t}Key`] && !e.includes(t)),
  },
  KT =
    (n, e) =>
    (t, ...i) => {
      for (let r = 0; r < e.length; r++) {
        const s = JT[e[r]]
        if (s && s(t, e)) return
      }
      return n(t, ...i)
    },
  e9 = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace",
  },
  t9 = (n, e) => t => {
    if (!("key" in t)) return
    const i = es(t.key)
    if (e.some(r => r === i || e9[r] === i)) return n(t)
  },
  Gw = {
    beforeMount(n, { value: e }, { transition: t }) {
      ;(n._vod = n.style.display === "none" ? "" : n.style.display),
        t && e ? t.beforeEnter(n) : eA(n, e)
    },
    mounted(n, { value: e }, { transition: t }) {
      t && e && t.enter(n)
    },
    updated(n, { value: e, oldValue: t }, { transition: i }) {
      !e != !t &&
        (i
          ? e
            ? (i.beforeEnter(n), eA(n, !0), i.enter(n))
            : i.leave(n, () => {
                eA(n, !1)
              })
          : eA(n, e))
    },
    beforeUnmount(n, { value: e }) {
      eA(n, e)
    },
  }
function eA(n, e) {
  n.style.display = e ? n._vod : "none"
}
function n9() {
  Gw.getSSRProps = ({ value: n }) => {
    if (!n) return { style: { display: "none" } }
  }
}
const Vw = Dn({ patchProp: BT }, vT)
let LA,
  Rv = !1
function Ww() {
  return LA || (LA = dw(Vw))
}
function jw() {
  return (LA = Rv ? LA : pw(Vw)), (Rv = !0), LA
}
const jA = (...n) => {
    Ww().render(...n)
  },
  $w = (...n) => {
    jw().hydrate(...n)
  },
  Qw = (...n) => {
    const e = Ww().createApp(...n),
      { mount: t } = e
    return (
      (e.mount = i => {
        const r = Yw(i)
        if (!r) return
        const s = e._component
        !Et(s) && !s.render && !s.template && (s.template = r.innerHTML),
          (r.innerHTML = "")
        const o = t(r, !1, r instanceof SVGElement)
        return (
          r instanceof Element &&
            (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")),
          o
        )
      }),
      e
    )
  },
  Xw = (...n) => {
    const e = jw().createApp(...n),
      { mount: t } = e
    return (
      (e.mount = i => {
        const r = Yw(i)
        if (r) return t(r, !0, r instanceof SVGElement)
      }),
      e
    )
  }
function Yw(n) {
  return Tn(n) ? document.querySelector(n) : n
}
let Pv = !1
const i9 = () => {
    Pv || ((Pv = !0), YT(), n9())
  },
  r9 = () => {}
var s9 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      compile: r9,
      EffectScope: bg,
      ReactiveEffect: Cu,
      customRef: G7,
      effect: f7,
      effectScope: vb,
      getCurrentScope: l7,
      isProxy: Eg,
      isReactive: Ta,
      isReadonly: lc,
      isRef: Gn,
      isShallow: t0,
      markRaw: Ru,
      onScopeDispose: c7,
      proxyRefs: Rg,
      reactive: Or,
      readonly: Sg,
      ref: $n,
      shallowReactive: Ib,
      shallowReadonly: F7,
      shallowRef: n0,
      stop: h7,
      toRaw: Ut,
      toRef: Pg,
      toRefs: V7,
      triggerRef: U7,
      unref: Jl,
      camelize: sr,
      capitalize: Tu,
      normalizeClass: Ps,
      normalizeProps: pb,
      normalizeStyle: Mu,
      toDisplayString: vr,
      toHandlerKey: SA,
      BaseTransition: Fg,
      Comment: mi,
      Fragment: Qn,
      KeepAlive: Qb,
      Static: Pa,
      Suspense: kg,
      Teleport: GE,
      Text: Ac,
      callWithAsyncErrorHandling: nr,
      callWithErrorHandling: ts,
      cloneVNode: as,
      compatUtils: gT,
      computed: _n,
      createBlock: Kt,
      createCommentVNode: Ss,
      createElementBlock: qr,
      createElementVNode: bt,
      createHydrationRenderer: pw,
      createPropsRestProxy: cT,
      createRenderer: dw,
      createSlots: wE,
      createStaticVNode: jE,
      createTextVNode: hs,
      createVNode: At,
      defineAsyncComponent: mE,
      defineComponent: ni,
      defineEmits: iT,
      defineExpose: rT,
      defineProps: nT,
      get devtools() {
        return Fl
      },
      getCurrentInstance: zr,
      getTransitionRawChildren: ud,
      guardReactiveProps: Vg,
      h: tr,
      handleError: Ja,
      initCustomFormatter: fT,
      inject: _r,
      isMemoSame: Rw,
      isRuntimeOnly: ZE,
      isVNode: qo,
      mergeDefaults: lT,
      mergeProps: _w,
      nextTick: Pu,
      onActivated: Xb,
      onBeforeMount: Jb,
      onBeforeUnmount: Iu,
      onBeforeUpdate: Kb,
      onDeactivated: Yb,
      onErrorCaptured: o0,
      onMounted: Ls,
      onRenderTracked: nw,
      onRenderTriggered: tw,
      onServerPrefetch: ew,
      onUnmounted: Oo,
      onUpdated: hd,
      openBlock: It,
      popScopeId: qc,
      provide: Ca,
      pushScopeId: Oc,
      queuePostFlushCb: Ig,
      registerRuntimeCompiler: YE,
      renderList: zg,
      renderSlot: rw,
      resolveComponent: Bu,
      resolveDirective: bE,
      resolveDynamicComponent: xE,
      resolveFilter: mT,
      resolveTransitionHooks: cc,
      setBlockTracking: qm,
      setDevtoolsHook: zb,
      setTransitionHooks: qa,
      ssrContextKey: Cw,
      ssrUtils: pT,
      toHandlers: ME,
      transformVNodeArgs: VE,
      useAttrs: aT,
      useSSRContext: uT,
      useSlots: oT,
      useTransitionState: qg,
      version: Pw,
      warn: kb,
      watch: ec,
      watchEffect: s0,
      watchPostEffect: Wb,
      watchSyncEffect: hE,
      withAsyncContext: AT,
      withCtx: Xn,
      withDefaults: sT,
      withDirectives: vE,
      withMemo: hT,
      withScopeId: iE,
      Transition: Fc,
      TransitionGroup: VT,
      VueElement: md,
      createApp: Qw,
      createSSRApp: Xw,
      defineCustomElement: Dw,
      defineSSRCustomElement: OT,
      hydrate: $w,
      initDirectivesForSSR: i9,
      render: jA,
      useCssModule: FT,
      useCssVars: NT,
      vModelCheckbox: jg,
      vModelDynamic: zw,
      vModelRadio: $g,
      vModelSelect: Nw,
      vModelText: f0,
      vShow: Gw,
      withKeys: t9,
      withModifiers: KT,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
)
const o9 =
    /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/,
  a9 =
    /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  l9 = /^["{[]|^-?[0-9][0-9.]{0,14}$/
function c9(n, e) {
  if (!(n === "__proto__" || n === "constructor")) return e
}
function A9(n) {
  if (typeof n != "string") return n
  const e = n.toLowerCase()
  if (e === "true") return !0
  if (e === "false") return !1
  if (e === "null") return null
  if (e === "nan") return NaN
  if (e === "infinity") return 1 / 0
  if (e !== "undefined") {
    if (!l9.test(n)) return n
    try {
      return o9.test(n) || a9.test(n) ? JSON.parse(n, c9) : JSON.parse(n)
    } catch {
      return n
    }
  }
}
const u9 = /#/g,
  f9 = /&/g,
  h9 = /=/g,
  Zw = /\+/g,
  d9 = /%5B/gi,
  p9 = /%5D/gi,
  m9 = /%5E/gi,
  g9 = /%60/gi,
  y9 = /%7B/gi,
  v9 = /%7C/gi,
  _9 = /%7D/gi,
  x9 = /%20/gi
function b9(n) {
  return encodeURI("" + n)
    .replace(v9, "|")
    .replace(d9, "[")
    .replace(p9, "]")
}
function Gm(n) {
  return b9(n)
    .replace(Zw, "%2B")
    .replace(x9, "+")
    .replace(u9, "%23")
    .replace(f9, "%26")
    .replace(g9, "`")
    .replace(y9, "{")
    .replace(_9, "}")
    .replace(m9, "^")
}
function _p(n) {
  return Gm(n).replace(h9, "%3D")
}
function Jw(n = "") {
  try {
    return decodeURIComponent("" + n)
  } catch {
    return "" + n
  }
}
function w9(n) {
  return Jw(n.replace(Zw, " "))
}
function M9(n = "") {
  const e = {}
  n[0] === "?" && (n = n.substr(1))
  for (const t of n.split("&")) {
    const i = t.match(/([^=]+)=?(.*)/) || []
    if (i.length < 2) continue
    const r = Jw(i[1])
    if (r === "__proto__" || r === "constructor") continue
    const s = w9(i[2] || "")
    e[r]
      ? Array.isArray(e[r])
        ? e[r].push(s)
        : (e[r] = [e[r], s])
      : (e[r] = s)
  }
  return e
}
function S9(n, e) {
  return (
    (typeof e == "number" || typeof e == "boolean") && (e = String(e)),
    e
      ? Array.isArray(e)
        ? e.map(t => `${_p(n)}=${Gm(t)}`).join("&")
        : `${_p(n)}=${Gm(e)}`
      : _p(n)
  )
}
function E9(n) {
  return Object.keys(n)
    .map(e => S9(e, n[e]))
    .join("&")
}
const T9 = /^\w+:(\/\/)?/,
  C9 = /^\/\/[^/]+/
function Kw(n, e = !1) {
  return T9.test(n) || (e && C9.test(n))
}
const R9 = /\/$|\/\?/
function Vm(n = "", e = !1) {
  return e ? R9.test(n) : n.endsWith("/")
}
function e4(n = "", e = !1) {
  if (!e) return (Vm(n) ? n.slice(0, -1) : n) || "/"
  if (!Vm(n, !0)) return n || "/"
  const [t, ...i] = n.split("?")
  return (t.slice(0, -1) || "/") + (i.length ? `?${i.join("?")}` : "")
}
function P9(n = "", e = !1) {
  if (!e) return n.endsWith("/") ? n : n + "/"
  if (Vm(n, !0)) return n || "/"
  const [t, ...i] = n.split("?")
  return t + "/" + (i.length ? `?${i.join("?")}` : "")
}
function L9(n = "") {
  return n.startsWith("/")
}
function D9(n = "") {
  return (L9(n) ? n.substr(1) : n) || "/"
}
function I9(n, e) {
  if (t4(e)) return n
  const t = e4(e)
  return n.startsWith(t) ? n : Qg(t, n)
}
function Lv(n, e) {
  if (t4(e)) return n
  const t = e4(e)
  return n.startsWith(t) ? n.substr(t.length) || "/" : n
}
function B9(n, e) {
  const t = n4(n),
    i = { ...M9(t.search), ...e }
  return (t.search = E9(i)), O9(t)
}
function t4(n) {
  return !n || n === "/"
}
function k9(n) {
  return n && n !== "/"
}
function Qg(n, ...e) {
  let t = n || ""
  for (const i of e.filter(k9)) t = t ? P9(t) + D9(i) : i
  return t
}
function n4(n = "", e) {
  if (!Kw(n, !0)) return e ? n4(e + n) : Dv(n)
  const [t = "", i, r = ""] = (
      n.replace(/\\/g, "/").match(/([^:/]+:)?\/\/([^/@]+@)?(.*)/) || []
    ).splice(1),
    [s = "", o = ""] = (r.match(/([^/?#]*)(.*)?/) || []).splice(1),
    { pathname: a, search: A, hash: c } = Dv(o)
  return {
    protocol: t,
    auth: i ? i.substr(0, i.length - 1) : "",
    host: s,
    pathname: a,
    search: A,
    hash: c,
  }
}
function Dv(n = "") {
  const [e = "", t = "", i = ""] = (
    n.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []
  ).splice(1)
  return { pathname: e, search: t, hash: i }
}
function O9(n) {
  const e =
    n.pathname +
    (n.search ? (n.search.startsWith("?") ? "" : "?") + n.search : "") +
    n.hash
  return n.protocol
    ? n.protocol + "//" + (n.auth ? n.auth + "@" : "") + n.host + e
    : e
}
class q9 extends Error {
  constructor() {
    super(...arguments), (this.name = "FetchError")
  }
}
function F9(n, e, t) {
  let i = ""
  n && t && (i = `${t.status} ${t.statusText} (${n.toString()})`),
    e && (i = `${e.message} (${i})`)
  const r = new q9(i)
  return (
    Object.defineProperty(r, "request", {
      get() {
        return n
      },
    }),
    Object.defineProperty(r, "response", {
      get() {
        return t
      },
    }),
    Object.defineProperty(r, "data", {
      get() {
        return t && t._data
      },
    }),
    r
  )
}
const N9 = new Set(Object.freeze(["PATCH", "POST", "PUT", "DELETE"]))
function Iv(n = "GET") {
  return N9.has(n.toUpperCase())
}
function U9(n) {
  if (n === void 0) return !1
  const e = typeof n
  return e === "string" || e === "number" || e === "boolean" || e === null
    ? !0
    : e !== "object"
    ? !1
    : Array.isArray(n)
    ? !0
    : (n.constructor && n.constructor.name === "Object") ||
      typeof n.toJSON == "function"
}
const z9 = new Set([
    "image/svg",
    "application/xml",
    "application/xhtml",
    "application/html",
  ]),
  H9 = /^application\/(?:[\w!#$%&*`\-.^~]*\+)?json(;.+)?$/i
function G9(n = "") {
  if (!n) return "json"
  const e = n.split(";").shift()
  return H9.test(e)
    ? "json"
    : z9.has(e) || e.startsWith("text/")
    ? "text"
    : "blob"
}
const V9 = new Set([408, 409, 425, 429, 500, 502, 503, 504])
function i4(n) {
  const { fetch: e, Headers: t } = n
  function i(o) {
    if (o.options.retry !== !1) {
      const A =
          typeof o.options.retry == "number"
            ? o.options.retry
            : Iv(o.options.method)
            ? 0
            : 1,
        c = (o.response && o.response.status) || 500
      if (A > 0 && V9.has(c))
        return r(o.request, { ...o.options, retry: A - 1 })
    }
    const a = F9(o.request, o.error, o.response)
    throw (Error.captureStackTrace && Error.captureStackTrace(a, r), a)
  }
  const r = async function (a, A = {}) {
      const c = {
        request: a,
        options: { ...n.defaults, ...A },
        response: void 0,
        error: void 0,
      }
      c.options.onRequest && (await c.options.onRequest(c)),
        typeof c.request == "string" &&
          (c.options.baseURL && (c.request = I9(c.request, c.options.baseURL)),
          c.options.params && (c.request = B9(c.request, c.options.params)),
          c.options.body &&
            Iv(c.options.method) &&
            U9(c.options.body) &&
            ((c.options.body =
              typeof c.options.body == "string"
                ? c.options.body
                : JSON.stringify(c.options.body)),
            (c.options.headers = new t(c.options.headers)),
            c.options.headers.has("content-type") ||
              c.options.headers.set("content-type", "application/json"),
            c.options.headers.has("accept") ||
              c.options.headers.set("accept", "application/json"))),
        (c.response = await e(c.request, c.options).catch(
          async p => (
            (c.error = p),
            c.options.onRequestError && (await c.options.onRequestError(c)),
            i(c)
          )
        ))
      const d =
        (c.options.parseResponse ? "json" : c.options.responseType) ||
        G9(c.response.headers.get("content-type") || "")
      if (d === "json") {
        const p = await c.response.text(),
          m = c.options.parseResponse || A9
        c.response._data = m(p)
      } else c.response._data = await c.response[d]()
      return (
        c.options.onResponse && (await c.options.onResponse(c)),
        c.response.ok ||
          (c.options.onResponseError && (await c.options.onResponseError(c))),
        c.response.ok ? c.response : i(c)
      )
    },
    s = function (a, A) {
      return r(a, A).then(c => c._data)
    }
  return (
    (s.raw = r),
    (s.create = (o = {}) => i4({ ...n, defaults: { ...n.defaults, ...o } })),
    s
  )
}
const r4 = (function () {
    if (typeof globalThis != "undefined") return globalThis
    if (typeof self != "undefined") return self
    if (typeof window != "undefined") return window
    if (typeof global != "undefined") return global
    throw new Error("unable to locate global object")
  })(),
  W9 =
    r4.fetch ||
    (() =>
      Promise.reject(new Error("[ohmyfetch] global.fetch is not supported!"))),
  j9 = r4.Headers,
  $9 = i4({ fetch: W9, Headers: j9 }),
  Q9 = () => {
    var n
    return (
      ((n = window == null ? void 0 : window.__NUXT__) == null
        ? void 0
        : n.config) || {}
    )
  },
  h0 = Q9().app,
  X9 = () => h0.baseURL,
  Y9 = () => h0.buildAssetsDir,
  zt = (...n) => Qg(Z9(), Y9(), ...n),
  Z9 = (...n) => {
    const e = h0.cdnURL || h0.baseURL
    return n.length ? Qg(e, ...n) : e
  }
function Wm(n, e = {}, t) {
  for (const i in n) {
    const r = n[i],
      s = t ? `${t}:${i}` : i
    typeof r == "object" && r !== null
      ? Wm(r, e, s)
      : typeof r == "function" && (e[s] = r)
  }
  return e
}
function J9(n, e) {
  return n.reduce(
    (t, i) => t.then(() => i.apply(void 0, e)),
    Promise.resolve(null)
  )
}
function K9(n, e) {
  return Promise.all(n.map(t => t.apply(void 0, e)))
}
class eC {
  constructor() {
    ;(this._hooks = {}),
      (this._deprecatedHooks = {}),
      (this.hook = this.hook.bind(this)),
      (this.callHook = this.callHook.bind(this)),
      (this.callHookWith = this.callHookWith.bind(this))
  }
  hook(e, t) {
    if (!e || typeof t != "function") return () => {}
    const i = e
    let r
    for (; this._deprecatedHooks[e]; ) {
      const s = this._deprecatedHooks[e]
      typeof s == "string" ? (r = { to: s }) : (r = s), (e = r.to)
    }
    return (
      r &&
        (r.message
          ? console.warn(r.message)
          : console.warn(
              `${i} hook has been deprecated` +
                (r.to ? `, please use ${r.to}` : "")
            )),
      (this._hooks[e] = this._hooks[e] || []),
      this._hooks[e].push(t),
      () => {
        t && (this.removeHook(e, t), (t = null))
      }
    )
  }
  hookOnce(e, t) {
    let i,
      r = (...s) => (i(), (i = null), (r = null), t(...s))
    return (i = this.hook(e, r)), i
  }
  removeHook(e, t) {
    if (this._hooks[e]) {
      const i = this._hooks[e].indexOf(t)
      i !== -1 && this._hooks[e].splice(i, 1),
        this._hooks[e].length === 0 && delete this._hooks[e]
    }
  }
  deprecateHook(e, t) {
    this._deprecatedHooks[e] = t
  }
  deprecateHooks(e) {
    Object.assign(this._deprecatedHooks, e)
  }
  addHooks(e) {
    const t = Wm(e),
      i = Object.keys(t).map(r => this.hook(r, t[r]))
    return () => {
      i.splice(0, i.length).forEach(r => r())
    }
  }
  removeHooks(e) {
    const t = Wm(e)
    for (const i in t) this.removeHook(i, t[i])
  }
  callHook(e, ...t) {
    return J9(this._hooks[e] || [], t)
  }
  callHookParallel(e, ...t) {
    return K9(this._hooks[e] || [], t)
  }
  callHookWith(e, t, ...i) {
    return e(this._hooks[t] || [], i)
  }
}
function tC() {
  return new eC()
}
function nC() {
  let n = null,
    e = !1
  const t = i => {
    if (n && n !== i) throw new Error("Context conflict")
  }
  return {
    use: () => n,
    set: (i, r) => {
      r || t(i), (n = i), (e = !0)
    },
    unset: () => {
      ;(n = null), (e = !1)
    },
    call: (i, r) => {
      t(i), (n = i)
      try {
        return r()
      } finally {
        e || (n = null)
      }
    },
    async callAsync(i, r) {
      n = i
      const s = () => {
          n = i
        },
        o = () => (n === i ? s : void 0)
      Ov.add(o)
      try {
        const a = r()
        return e || (n = null), await a
      } finally {
        Ov.delete(o)
      }
    },
  }
}
function iC() {
  const n = {}
  return {
    get(e) {
      return n[e] || (n[e] = nC()), n[e], n[e]
    },
  }
}
const d0 =
    typeof globalThis != "undefined"
      ? globalThis
      : typeof self != "undefined"
      ? self
      : typeof global != "undefined"
      ? global
      : typeof window != "undefined"
      ? window
      : {},
  Bv = "__unctx__",
  rC = d0[Bv] || (d0[Bv] = iC()),
  sC = n => rC.get(n),
  kv = "__unctx_async_handlers__",
  Ov = d0[kv] || (d0[kv] = new Set())
function yA(n, e = {}) {
  const t = function () {}
  t.prototype.name = n
  const i = {}
  return new Proxy(t, {
    get(r, s) {
      return s === "caller"
        ? null
        : s === "__createMock__"
        ? yA
        : s in e
        ? e[s]
        : (i[s] = i[s] || yA(`${n}.${s.toString()}`))
    },
    apply(r, s, o) {
      return yA(`${n}()`)
    },
    construct(r, s, o) {
      return yA(`[${n}]`)
    },
    enumerate(r) {
      return []
    },
  })
}
var oC = yA("mock")
function vf(n) {
  return console.warn(n), oC
}
const aC = new Set(["store", "spa", "fetchCounters"]),
  lC = new Set([
    "isHMR",
    "base",
    "payload",
    "from",
    "next",
    "error",
    "redirect",
    "redirected",
    "enablePreview",
    "$preview",
    "beforeNuxtRender",
    "beforeSerialize",
  ]),
  cC = new Set(["req", "res", "ssrContext"]),
  AC = ["route", "params", "query"],
  qv = {
    isClient: !0,
    isServer: !1,
    isDev: !1,
    isStatic: void 0,
    target: "server",
    modern: !1,
  },
  uC = n => {
    ;(n._legacyContext = new Proxy(n, {
      get(e, t) {
        if (aC.has(t)) return vf(`Accessing ${t} is not supported in Nuxt 3.`)
        if (lC.has(t))
          return vf(`Accessing ${t} is not yet supported in Nuxt 3.`)
        if (AC.includes(t)) {
          if (!("$router" in n))
            return vf("vue-router is not being used in this project.")
          switch (t) {
            case "route":
              return e.$router.currentRoute.value
            case "params":
            case "query":
              return e.$router.currentRoute.value[t]
          }
        }
        if (t === "$config" || t === "env") return a4()
        if (t in qv) return qv[t]
        if (!cC.has(t))
          return t === "ssrContext"
            ? e._legacyContext
            : e.ssrContext && t in e.ssrContext
            ? e.ssrContext[t]
            : t === "nuxt"
            ? e.payload
            : t === "nuxtState"
            ? e.payload.data
            : t in n.vueApp
            ? n.vueApp[t]
            : t in n
            ? n[t]
            : vf(`Accessing ${t} is not supported in Nuxt3.`)
      },
    })),
      n.hook("app:created", () => {
        const e = new Proxy(n.vueApp, {
          get(t, i) {
            return ["$root", "constructor"].includes(i) ? e : t[i] || n[i]
          },
        })
        window[`$${n.globalName}`] = e
      })
  },
  s4 = sC("nuxt-app"),
  o4 = "__nuxt_plugin"
function fC(n) {
  const e = {
    provide: void 0,
    globalName: "nuxt",
    payload: Or({ data: {}, state: {}, _errors: {}, ...window.__NUXT__ }),
    isHydrating: !0,
    _asyncDataPromises: {},
    ...n,
  }
  ;(e.hooks = tC()),
    (e.hook = e.hooks.hook),
    (e.callHook = e.hooks.callHook),
    (e.provide = (r, s) => {
      const o = "$" + r
      _f(e, o, s), _f(e.vueApp.config.globalProperties, o, s)
    }),
    _f(e.vueApp, "$nuxt", e),
    _f(e.vueApp.config.globalProperties, "$nuxt", e),
    e.ssrContext && (e.ssrContext.nuxt = e)
  const t = Or(e.payload.config),
    i = new Proxy(t, {
      get(r, s) {
        var o
        return s === "public" ? r.public : (o = r[s]) != null ? o : r.public[s]
      },
      set(r, s, o) {
        return s === "public" || s === "app"
          ? !1
          : ((r[s] = o), (r.public[s] = o), !0)
      },
    })
  return e.provide("config", i), e
}
async function hC(n, e) {
  if (typeof e != "function") return
  const { provide: t } = (await ya(n, e, [n])) || {}
  if (t && typeof t == "object") for (const i in t) n.provide(i, t[i])
}
async function dC(n, e) {
  for (const t of e) await hC(n, t)
}
function pC(n) {
  let e = !1
  const t = n.map(i =>
    typeof i != "function"
      ? () => {}
      : mC(i)
      ? ((e = !0), r => i(r._legacyContext, r.provide))
      : i
  )
  return e && t.unshift(uC), t
}
function Nc(n) {
  return (n[o4] = !0), n
}
function mC(n) {
  return !n[o4]
}
function ya(n, e, t) {
  const i = () => (t ? e(...t) : e())
  return s4.set(n), i()
}
function xr() {
  const n = zr()
  if (!n) {
    const e = s4.use()
    if (!e) throw new Error("nuxt instance unavailable")
    return e
  }
  return n.appContext.app.$nuxt
}
function a4() {
  return xr().$config
}
function _f(n, e, t) {
  Object.defineProperty(n, e, { get: () => t })
}
/*!
 * vue-router v4.0.16
 * (c) 2022 Eduardo San Martin Morote
 * @license MIT
 */ const l4 =
    typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol",
  Uc = n => (l4 ? Symbol(n) : "_vr_" + n),
  gC = Uc("rvlm"),
  Fv = Uc("rvd"),
  Xg = Uc("r"),
  c4 = Uc("rl"),
  jm = Uc("rvl"),
  Nl = typeof window != "undefined"
function yC(n) {
  return n.__esModule || (l4 && n[Symbol.toStringTag] === "Module")
}
const cn = Object.assign
function xp(n, e) {
  const t = {}
  for (const i in e) {
    const r = e[i]
    t[i] = Array.isArray(r) ? r.map(n) : n(r)
  }
  return t
}
const DA = () => {},
  vC = /\/$/,
  _C = n => n.replace(vC, "")
function bp(n, e, t = "/") {
  let i,
    r = {},
    s = "",
    o = ""
  const a = e.indexOf("?"),
    A = e.indexOf("#", a > -1 ? a : 0)
  return (
    a > -1 &&
      ((i = e.slice(0, a)),
      (s = e.slice(a + 1, A > -1 ? A : e.length)),
      (r = n(s))),
    A > -1 && ((i = i || e.slice(0, A)), (o = e.slice(A, e.length))),
    (i = MC(i != null ? i : e, t)),
    { fullPath: i + (s && "?") + s + o, path: i, query: r, hash: o }
  )
}
function xC(n, e) {
  const t = e.query ? n(e.query) : ""
  return e.path + (t && "?") + t + (e.hash || "")
}
function Nv(n, e) {
  return !e || !n.toLowerCase().startsWith(e.toLowerCase())
    ? n
    : n.slice(e.length) || "/"
}
function bC(n, e, t) {
  const i = e.matched.length - 1,
    r = t.matched.length - 1
  return (
    i > -1 &&
    i === r &&
    hc(e.matched[i], t.matched[r]) &&
    A4(e.params, t.params) &&
    n(e.query) === n(t.query) &&
    e.hash === t.hash
  )
}
function hc(n, e) {
  return (n.aliasOf || n) === (e.aliasOf || e)
}
function A4(n, e) {
  if (Object.keys(n).length !== Object.keys(e).length) return !1
  for (const t in n) if (!wC(n[t], e[t])) return !1
  return !0
}
function wC(n, e) {
  return Array.isArray(n) ? Uv(n, e) : Array.isArray(e) ? Uv(e, n) : n === e
}
function Uv(n, e) {
  return Array.isArray(e)
    ? n.length === e.length && n.every((t, i) => t === e[i])
    : n.length === 1 && n[0] === e
}
function MC(n, e) {
  if (n.startsWith("/")) return n
  if (!n) return e
  const t = e.split("/"),
    i = n.split("/")
  let r = t.length - 1,
    s,
    o
  for (s = 0; s < i.length; s++)
    if (((o = i[s]), !(r === 1 || o === ".")))
      if (o === "..") r--
      else break
  return (
    t.slice(0, r).join("/") +
    "/" +
    i.slice(s - (s === i.length ? 1 : 0)).join("/")
  )
}
var $A
;(function (n) {
  ;(n.pop = "pop"), (n.push = "push")
})($A || ($A = {}))
var IA
;(function (n) {
  ;(n.back = "back"), (n.forward = "forward"), (n.unknown = "")
})(IA || (IA = {}))
function SC(n) {
  if (!n)
    if (Nl) {
      const e = document.querySelector("base")
      ;(n = (e && e.getAttribute("href")) || "/"),
        (n = n.replace(/^\w+:\/\/[^\/]+/, ""))
    } else n = "/"
  return n[0] !== "/" && n[0] !== "#" && (n = "/" + n), _C(n)
}
const EC = /^[^#]+#/
function TC(n, e) {
  return n.replace(EC, "#") + e
}
function CC(n, e) {
  const t = document.documentElement.getBoundingClientRect(),
    i = n.getBoundingClientRect()
  return {
    behavior: e.behavior,
    left: i.left - t.left - (e.left || 0),
    top: i.top - t.top - (e.top || 0),
  }
}
const gd = () => ({ left: window.pageXOffset, top: window.pageYOffset })
function RC(n) {
  let e
  if ("el" in n) {
    const t = n.el,
      i = typeof t == "string" && t.startsWith("#"),
      r =
        typeof t == "string"
          ? i
            ? document.getElementById(t.slice(1))
            : document.querySelector(t)
          : t
    if (!r) return
    e = CC(r, n)
  } else e = n
  "scrollBehavior" in document.documentElement.style
    ? window.scrollTo(e)
    : window.scrollTo(
        e.left != null ? e.left : window.pageXOffset,
        e.top != null ? e.top : window.pageYOffset
      )
}
function zv(n, e) {
  return (history.state ? history.state.position - e : -1) + n
}
const $m = new Map()
function PC(n, e) {
  $m.set(n, e)
}
function LC(n) {
  const e = $m.get(n)
  return $m.delete(n), e
}
let DC = () => location.protocol + "//" + location.host
function u4(n, e) {
  const { pathname: t, search: i, hash: r } = e,
    s = n.indexOf("#")
  if (s > -1) {
    let a = r.includes(n.slice(s)) ? n.slice(s).length : 1,
      A = r.slice(a)
    return A[0] !== "/" && (A = "/" + A), Nv(A, "")
  }
  return Nv(t, n) + i + r
}
function IC(n, e, t, i) {
  let r = [],
    s = [],
    o = null
  const a = ({ state: m }) => {
    const y = u4(n, location),
      x = t.value,
      S = e.value
    let C = 0
    if (m) {
      if (((t.value = y), (e.value = m), o && o === x)) {
        o = null
        return
      }
      C = S ? m.position - S.position : 0
    } else i(y)
    r.forEach(M => {
      M(t.value, x, {
        delta: C,
        type: $A.pop,
        direction: C ? (C > 0 ? IA.forward : IA.back) : IA.unknown,
      })
    })
  }
  function A() {
    o = t.value
  }
  function c(m) {
    r.push(m)
    const y = () => {
      const x = r.indexOf(m)
      x > -1 && r.splice(x, 1)
    }
    return s.push(y), y
  }
  function d() {
    const { history: m } = window
    !m.state || m.replaceState(cn({}, m.state, { scroll: gd() }), "")
  }
  function p() {
    for (const m of s) m()
    ;(s = []),
      window.removeEventListener("popstate", a),
      window.removeEventListener("beforeunload", d)
  }
  return (
    window.addEventListener("popstate", a),
    window.addEventListener("beforeunload", d),
    { pauseListeners: A, listen: c, destroy: p }
  )
}
function Hv(n, e, t, i = !1, r = !1) {
  return {
    back: n,
    current: e,
    forward: t,
    replaced: i,
    position: window.history.length,
    scroll: r ? gd() : null,
  }
}
function BC(n) {
  const { history: e, location: t } = window,
    i = { value: u4(n, t) },
    r = { value: e.state }
  r.value ||
    s(
      i.value,
      {
        back: null,
        current: i.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null,
      },
      !0
    )
  function s(A, c, d) {
    const p = n.indexOf("#"),
      m =
        p > -1
          ? (t.host && document.querySelector("base") ? n : n.slice(p)) + A
          : DC() + n + A
    try {
      e[d ? "replaceState" : "pushState"](c, "", m), (r.value = c)
    } catch (y) {
      console.error(y), t[d ? "replace" : "assign"](m)
    }
  }
  function o(A, c) {
    const d = cn({}, e.state, Hv(r.value.back, A, r.value.forward, !0), c, {
      position: r.value.position,
    })
    s(A, d, !0), (i.value = A)
  }
  function a(A, c) {
    const d = cn({}, r.value, e.state, { forward: A, scroll: gd() })
    s(d.current, d, !0)
    const p = cn({}, Hv(i.value, A, null), { position: d.position + 1 }, c)
    s(A, p, !1), (i.value = A)
  }
  return { location: i, state: r, push: a, replace: o }
}
function kC(n) {
  n = SC(n)
  const e = BC(n),
    t = IC(n, e.state, e.location, e.replace)
  function i(s, o = !0) {
    o || t.pauseListeners(), history.go(s)
  }
  const r = cn(
    { location: "", base: n, go: i, createHref: TC.bind(null, n) },
    e,
    t
  )
  return (
    Object.defineProperty(r, "location", {
      enumerable: !0,
      get: () => e.location.value,
    }),
    Object.defineProperty(r, "state", {
      enumerable: !0,
      get: () => e.state.value,
    }),
    r
  )
}
function OC(n) {
  return typeof n == "string" || (n && typeof n == "object")
}
function f4(n) {
  return typeof n == "string" || typeof n == "symbol"
}
const oo = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0,
  },
  h4 = Uc("nf")
var Gv
;(function (n) {
  ;(n[(n.aborted = 4)] = "aborted"),
    (n[(n.cancelled = 8)] = "cancelled"),
    (n[(n.duplicated = 16)] = "duplicated")
})(Gv || (Gv = {}))
function dc(n, e) {
  return cn(new Error(), { type: n, [h4]: !0 }, e)
}
function ao(n, e) {
  return n instanceof Error && h4 in n && (e == null || !!(n.type & e))
}
const Vv = "[^/]+?",
  qC = { sensitive: !1, strict: !1, start: !0, end: !0 },
  FC = /[.+*?^${}()[\]/\\]/g
function NC(n, e) {
  const t = cn({}, qC, e),
    i = []
  let r = t.start ? "^" : ""
  const s = []
  for (const c of n) {
    const d = c.length ? [] : [90]
    t.strict && !c.length && (r += "/")
    for (let p = 0; p < c.length; p++) {
      const m = c[p]
      let y = 40 + (t.sensitive ? 0.25 : 0)
      if (m.type === 0)
        p || (r += "/"), (r += m.value.replace(FC, "\\$&")), (y += 40)
      else if (m.type === 1) {
        const { value: x, repeatable: S, optional: C, regexp: M } = m
        s.push({ name: x, repeatable: S, optional: C })
        const _ = M || Vv
        if (_ !== Vv) {
          y += 10
          try {
            new RegExp(`(${_})`)
          } catch (T) {
            throw new Error(
              `Invalid custom RegExp for param "${x}" (${_}): ` + T.message
            )
          }
        }
        let R = S ? `((?:${_})(?:/(?:${_}))*)` : `(${_})`
        p || (R = C && c.length < 2 ? `(?:/${R})` : "/" + R),
          C && (R += "?"),
          (r += R),
          (y += 20),
          C && (y += -8),
          S && (y += -20),
          _ === ".*" && (y += -50)
      }
      d.push(y)
    }
    i.push(d)
  }
  if (t.strict && t.end) {
    const c = i.length - 1
    i[c][i[c].length - 1] += 0.7000000000000001
  }
  t.strict || (r += "/?"), t.end ? (r += "$") : t.strict && (r += "(?:/|$)")
  const o = new RegExp(r, t.sensitive ? "" : "i")
  function a(c) {
    const d = c.match(o),
      p = {}
    if (!d) return null
    for (let m = 1; m < d.length; m++) {
      const y = d[m] || "",
        x = s[m - 1]
      p[x.name] = y && x.repeatable ? y.split("/") : y
    }
    return p
  }
  function A(c) {
    let d = "",
      p = !1
    for (const m of n) {
      ;(!p || !d.endsWith("/")) && (d += "/"), (p = !1)
      for (const y of m)
        if (y.type === 0) d += y.value
        else if (y.type === 1) {
          const { value: x, repeatable: S, optional: C } = y,
            M = x in c ? c[x] : ""
          if (Array.isArray(M) && !S)
            throw new Error(
              `Provided param "${x}" is an array but it is not repeatable (* or + modifiers)`
            )
          const _ = Array.isArray(M) ? M.join("/") : M
          if (!_)
            if (C)
              m.length < 2 &&
                n.length > 1 &&
                (d.endsWith("/") ? (d = d.slice(0, -1)) : (p = !0))
            else throw new Error(`Missing required param "${x}"`)
          d += _
        }
    }
    return d
  }
  return { re: o, score: i, keys: s, parse: a, stringify: A }
}
function UC(n, e) {
  let t = 0
  for (; t < n.length && t < e.length; ) {
    const i = e[t] - n[t]
    if (i) return i
    t++
  }
  return n.length < e.length
    ? n.length === 1 && n[0] === 40 + 40
      ? -1
      : 1
    : n.length > e.length
    ? e.length === 1 && e[0] === 40 + 40
      ? 1
      : -1
    : 0
}
function zC(n, e) {
  let t = 0
  const i = n.score,
    r = e.score
  for (; t < i.length && t < r.length; ) {
    const s = UC(i[t], r[t])
    if (s) return s
    t++
  }
  if (Math.abs(r.length - i.length) === 1) {
    if (Wv(i)) return 1
    if (Wv(r)) return -1
  }
  return r.length - i.length
}
function Wv(n) {
  const e = n[n.length - 1]
  return n.length > 0 && e[e.length - 1] < 0
}
const HC = { type: 0, value: "" },
  GC = /[a-zA-Z0-9_]/
function VC(n) {
  if (!n) return [[]]
  if (n === "/") return [[HC]]
  if (!n.startsWith("/")) throw new Error(`Invalid path "${n}"`)
  function e(y) {
    throw new Error(`ERR (${t})/"${c}": ${y}`)
  }
  let t = 0,
    i = t
  const r = []
  let s
  function o() {
    s && r.push(s), (s = [])
  }
  let a = 0,
    A,
    c = "",
    d = ""
  function p() {
    !c ||
      (t === 0
        ? s.push({ type: 0, value: c })
        : t === 1 || t === 2 || t === 3
        ? (s.length > 1 &&
            (A === "*" || A === "+") &&
            e(
              `A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`
            ),
          s.push({
            type: 1,
            value: c,
            regexp: d,
            repeatable: A === "*" || A === "+",
            optional: A === "*" || A === "?",
          }))
        : e("Invalid state to consume buffer"),
      (c = ""))
  }
  function m() {
    c += A
  }
  for (; a < n.length; ) {
    if (((A = n[a++]), A === "\\" && t !== 2)) {
      ;(i = t), (t = 4)
      continue
    }
    switch (t) {
      case 0:
        A === "/" ? (c && p(), o()) : A === ":" ? (p(), (t = 1)) : m()
        break
      case 4:
        m(), (t = i)
        break
      case 1:
        A === "("
          ? (t = 2)
          : GC.test(A)
          ? m()
          : (p(), (t = 0), A !== "*" && A !== "?" && A !== "+" && a--)
        break
      case 2:
        A === ")"
          ? d[d.length - 1] == "\\"
            ? (d = d.slice(0, -1) + A)
            : (t = 3)
          : (d += A)
        break
      case 3:
        p(), (t = 0), A !== "*" && A !== "?" && A !== "+" && a--, (d = "")
        break
      default:
        e("Unknown state")
        break
    }
  }
  return t === 2 && e(`Unfinished custom RegExp for param "${c}"`), p(), o(), r
}
function WC(n, e, t) {
  const i = NC(VC(n.path), t),
    r = cn(i, { record: n, parent: e, children: [], alias: [] })
  return e && !r.record.aliasOf == !e.record.aliasOf && e.children.push(r), r
}
function jC(n, e) {
  const t = [],
    i = new Map()
  e = $v({ strict: !1, end: !0, sensitive: !1 }, e)
  function r(d) {
    return i.get(d)
  }
  function s(d, p, m) {
    const y = !m,
      x = QC(d)
    x.aliasOf = m && m.record
    const S = $v(e, d),
      C = [x]
    if ("alias" in d) {
      const R = typeof d.alias == "string" ? [d.alias] : d.alias
      for (const T of R)
        C.push(
          cn({}, x, {
            components: m ? m.record.components : x.components,
            path: T,
            aliasOf: m ? m.record : x,
          })
        )
    }
    let M, _
    for (const R of C) {
      const { path: T } = R
      if (p && T[0] !== "/") {
        const L = p.record.path,
          B = L[L.length - 1] === "/" ? "" : "/"
        R.path = p.record.path + (T && B + T)
      }
      if (
        ((M = WC(R, p, S)),
        m
          ? m.alias.push(M)
          : ((_ = _ || M),
            _ !== M && _.alias.push(M),
            y && d.name && !jv(M) && o(d.name)),
        "children" in x)
      ) {
        const L = x.children
        for (let B = 0; B < L.length; B++) s(L[B], M, m && m.children[B])
      }
      ;(m = m || M), A(M)
    }
    return _
      ? () => {
          o(_)
        }
      : DA
  }
  function o(d) {
    if (f4(d)) {
      const p = i.get(d)
      p &&
        (i.delete(d),
        t.splice(t.indexOf(p), 1),
        p.children.forEach(o),
        p.alias.forEach(o))
    } else {
      const p = t.indexOf(d)
      p > -1 &&
        (t.splice(p, 1),
        d.record.name && i.delete(d.record.name),
        d.children.forEach(o),
        d.alias.forEach(o))
    }
  }
  function a() {
    return t
  }
  function A(d) {
    let p = 0
    for (
      ;
      p < t.length &&
      zC(d, t[p]) >= 0 &&
      (d.record.path !== t[p].record.path || !d4(d, t[p]));

    )
      p++
    t.splice(p, 0, d), d.record.name && !jv(d) && i.set(d.record.name, d)
  }
  function c(d, p) {
    let m,
      y = {},
      x,
      S
    if ("name" in d && d.name) {
      if (((m = i.get(d.name)), !m)) throw dc(1, { location: d })
      ;(S = m.record.name),
        (y = cn(
          $C(
            p.params,
            m.keys.filter(_ => !_.optional).map(_ => _.name)
          ),
          d.params
        )),
        (x = m.stringify(y))
    } else if ("path" in d)
      (x = d.path),
        (m = t.find(_ => _.re.test(x))),
        m && ((y = m.parse(x)), (S = m.record.name))
    else {
      if (((m = p.name ? i.get(p.name) : t.find(_ => _.re.test(p.path))), !m))
        throw dc(1, { location: d, currentLocation: p })
      ;(S = m.record.name),
        (y = cn({}, p.params, d.params)),
        (x = m.stringify(y))
    }
    const C = []
    let M = m
    for (; M; ) C.unshift(M.record), (M = M.parent)
    return { name: S, path: x, params: y, matched: C, meta: YC(C) }
  }
  return (
    n.forEach(d => s(d)),
    {
      addRoute: s,
      resolve: c,
      removeRoute: o,
      getRoutes: a,
      getRecordMatcher: r,
    }
  )
}
function $C(n, e) {
  const t = {}
  for (const i of e) i in n && (t[i] = n[i])
  return t
}
function QC(n) {
  return {
    path: n.path,
    redirect: n.redirect,
    name: n.name,
    meta: n.meta || {},
    aliasOf: void 0,
    beforeEnter: n.beforeEnter,
    props: XC(n),
    children: n.children || [],
    instances: {},
    leaveGuards: new Set(),
    updateGuards: new Set(),
    enterCallbacks: {},
    components:
      "components" in n ? n.components || {} : { default: n.component },
  }
}
function XC(n) {
  const e = {},
    t = n.props || !1
  if ("component" in n) e.default = t
  else for (const i in n.components) e[i] = typeof t == "boolean" ? t : t[i]
  return e
}
function jv(n) {
  for (; n; ) {
    if (n.record.aliasOf) return !0
    n = n.parent
  }
  return !1
}
function YC(n) {
  return n.reduce((e, t) => cn(e, t.meta), {})
}
function $v(n, e) {
  const t = {}
  for (const i in n) t[i] = i in e ? e[i] : n[i]
  return t
}
function d4(n, e) {
  return e.children.some(t => t === n || d4(n, t))
}
const p4 = /#/g,
  ZC = /&/g,
  JC = /\//g,
  KC = /=/g,
  eR = /\?/g,
  m4 = /\+/g,
  tR = /%5B/g,
  nR = /%5D/g,
  g4 = /%5E/g,
  iR = /%60/g,
  y4 = /%7B/g,
  rR = /%7C/g,
  v4 = /%7D/g,
  sR = /%20/g
function Yg(n) {
  return encodeURI("" + n)
    .replace(rR, "|")
    .replace(tR, "[")
    .replace(nR, "]")
}
function oR(n) {
  return Yg(n).replace(y4, "{").replace(v4, "}").replace(g4, "^")
}
function Qm(n) {
  return Yg(n)
    .replace(m4, "%2B")
    .replace(sR, "+")
    .replace(p4, "%23")
    .replace(ZC, "%26")
    .replace(iR, "`")
    .replace(y4, "{")
    .replace(v4, "}")
    .replace(g4, "^")
}
function aR(n) {
  return Qm(n).replace(KC, "%3D")
}
function lR(n) {
  return Yg(n).replace(p4, "%23").replace(eR, "%3F")
}
function cR(n) {
  return n == null ? "" : lR(n).replace(JC, "%2F")
}
function p0(n) {
  try {
    return decodeURIComponent("" + n)
  } catch {}
  return "" + n
}
function AR(n) {
  const e = {}
  if (n === "" || n === "?") return e
  const i = (n[0] === "?" ? n.slice(1) : n).split("&")
  for (let r = 0; r < i.length; ++r) {
    const s = i[r].replace(m4, " "),
      o = s.indexOf("="),
      a = p0(o < 0 ? s : s.slice(0, o)),
      A = o < 0 ? null : p0(s.slice(o + 1))
    if (a in e) {
      let c = e[a]
      Array.isArray(c) || (c = e[a] = [c]), c.push(A)
    } else e[a] = A
  }
  return e
}
function Qv(n) {
  let e = ""
  for (let t in n) {
    const i = n[t]
    if (((t = aR(t)), i == null)) {
      i !== void 0 && (e += (e.length ? "&" : "") + t)
      continue
    }
    ;(Array.isArray(i) ? i.map(s => s && Qm(s)) : [i && Qm(i)]).forEach(s => {
      s !== void 0 &&
        ((e += (e.length ? "&" : "") + t), s != null && (e += "=" + s))
    })
  }
  return e
}
function uR(n) {
  const e = {}
  for (const t in n) {
    const i = n[t]
    i !== void 0 &&
      (e[t] = Array.isArray(i)
        ? i.map(r => (r == null ? null : "" + r))
        : i == null
        ? i
        : "" + i)
  }
  return e
}
function tA() {
  let n = []
  function e(i) {
    return (
      n.push(i),
      () => {
        const r = n.indexOf(i)
        r > -1 && n.splice(r, 1)
      }
    )
  }
  function t() {
    n = []
  }
  return { add: e, list: () => n, reset: t }
}
function Mo(n, e, t, i, r) {
  const s = i && (i.enterCallbacks[r] = i.enterCallbacks[r] || [])
  return () =>
    new Promise((o, a) => {
      const A = p => {
          p === !1
            ? a(dc(4, { from: t, to: e }))
            : p instanceof Error
            ? a(p)
            : OC(p)
            ? a(dc(2, { from: e, to: p }))
            : (s &&
                i.enterCallbacks[r] === s &&
                typeof p == "function" &&
                s.push(p),
              o())
        },
        c = n.call(i && i.instances[r], e, t, A)
      let d = Promise.resolve(c)
      n.length < 3 && (d = d.then(A)), d.catch(p => a(p))
    })
}
function wp(n, e, t, i) {
  const r = []
  for (const s of n)
    for (const o in s.components) {
      let a = s.components[o]
      if (!(e !== "beforeRouteEnter" && !s.instances[o]))
        if (fR(a)) {
          const c = (a.__vccOpts || a)[e]
          c && r.push(Mo(c, t, i, s, o))
        } else {
          let A = a()
          r.push(() =>
            A.then(c => {
              if (!c)
                return Promise.reject(
                  new Error(`Couldn't resolve component "${o}" at "${s.path}"`)
                )
              const d = yC(c) ? c.default : c
              s.components[o] = d
              const m = (d.__vccOpts || d)[e]
              return m && Mo(m, t, i, s, o)()
            })
          )
        }
    }
  return r
}
function fR(n) {
  return (
    typeof n == "object" ||
    "displayName" in n ||
    "props" in n ||
    "__vccOpts" in n
  )
}
function Xv(n) {
  const e = _r(Xg),
    t = _r(c4),
    i = _n(() => e.resolve(Jl(n.to))),
    r = _n(() => {
      const { matched: A } = i.value,
        { length: c } = A,
        d = A[c - 1],
        p = t.matched
      if (!d || !p.length) return -1
      const m = p.findIndex(hc.bind(null, d))
      if (m > -1) return m
      const y = Yv(A[c - 2])
      return c > 1 && Yv(d) === y && p[p.length - 1].path !== y
        ? p.findIndex(hc.bind(null, A[c - 2]))
        : m
    }),
    s = _n(() => r.value > -1 && mR(t.params, i.value.params)),
    o = _n(
      () =>
        r.value > -1 &&
        r.value === t.matched.length - 1 &&
        A4(t.params, i.value.params)
    )
  function a(A = {}) {
    return pR(A)
      ? e[Jl(n.replace) ? "replace" : "push"](Jl(n.to)).catch(DA)
      : Promise.resolve()
  }
  return {
    route: i,
    href: _n(() => i.value.href),
    isActive: s,
    isExactActive: o,
    navigate: a,
  }
}
const hR = ni({
    name: "RouterLink",
    compatConfig: { MODE: 3 },
    props: {
      to: { type: [String, Object], required: !0 },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: { type: String, default: "page" },
    },
    useLink: Xv,
    setup(n, { slots: e }) {
      const t = Or(Xv(n)),
        { options: i } = _r(Xg),
        r = _n(() => ({
          [Zv(n.activeClass, i.linkActiveClass, "router-link-active")]:
            t.isActive,
          [Zv(
            n.exactActiveClass,
            i.linkExactActiveClass,
            "router-link-exact-active"
          )]: t.isExactActive,
        }))
      return () => {
        const s = e.default && e.default(t)
        return n.custom
          ? s
          : tr(
              "a",
              {
                "aria-current": t.isExactActive ? n.ariaCurrentValue : null,
                href: t.href,
                onClick: t.navigate,
                class: r.value,
              },
              s
            )
      }
    },
  }),
  dR = hR
function pR(n) {
  if (
    !(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) &&
    !n.defaultPrevented &&
    !(n.button !== void 0 && n.button !== 0)
  ) {
    if (n.currentTarget && n.currentTarget.getAttribute) {
      const e = n.currentTarget.getAttribute("target")
      if (/\b_blank\b/i.test(e)) return
    }
    return n.preventDefault && n.preventDefault(), !0
  }
}
function mR(n, e) {
  for (const t in e) {
    const i = e[t],
      r = n[t]
    if (typeof i == "string") {
      if (i !== r) return !1
    } else if (
      !Array.isArray(r) ||
      r.length !== i.length ||
      i.some((s, o) => s !== r[o])
    )
      return !1
  }
  return !0
}
function Yv(n) {
  return n ? (n.aliasOf ? n.aliasOf.path : n.path) : ""
}
const Zv = (n, e, t) => (n != null ? n : e != null ? e : t),
  gR = ni({
    name: "RouterView",
    inheritAttrs: !1,
    props: { name: { type: String, default: "default" }, route: Object },
    compatConfig: { MODE: 3 },
    setup(n, { attrs: e, slots: t }) {
      const i = _r(jm),
        r = _n(() => n.route || i.value),
        s = _r(Fv, 0),
        o = _n(() => r.value.matched[s])
      Ca(Fv, s + 1), Ca(gC, o), Ca(jm, r)
      const a = $n()
      return (
        ec(
          () => [a.value, o.value, n.name],
          ([A, c, d], [p, m, y]) => {
            c &&
              ((c.instances[d] = A),
              m &&
                m !== c &&
                A &&
                A === p &&
                (c.leaveGuards.size || (c.leaveGuards = m.leaveGuards),
                c.updateGuards.size || (c.updateGuards = m.updateGuards))),
              A &&
                c &&
                (!m || !hc(c, m) || !p) &&
                (c.enterCallbacks[d] || []).forEach(x => x(A))
          },
          { flush: "post" }
        ),
        () => {
          const A = r.value,
            c = o.value,
            d = c && c.components[n.name],
            p = n.name
          if (!d) return Jv(t.default, { Component: d, route: A })
          const m = c.props[n.name],
            y = m
              ? m === !0
                ? A.params
                : typeof m == "function"
                ? m(A)
                : m
              : null,
            S = tr(
              d,
              cn({}, y, e, {
                onVnodeUnmounted: C => {
                  C.component.isUnmounted && (c.instances[p] = null)
                },
                ref: a,
              })
            )
          return Jv(t.default, { Component: S, route: A }) || S
        }
      )
    },
  })
function Jv(n, e) {
  if (!n) return null
  const t = n(e)
  return t.length === 1 ? t[0] : t
}
const _4 = gR
function yR(n) {
  const e = jC(n.routes, n),
    t = n.parseQuery || AR,
    i = n.stringifyQuery || Qv,
    r = n.history,
    s = tA(),
    o = tA(),
    a = tA(),
    A = n0(oo)
  let c = oo
  Nl &&
    n.scrollBehavior &&
    "scrollRestoration" in history &&
    (history.scrollRestoration = "manual")
  const d = xp.bind(null, K => "" + K),
    p = xp.bind(null, cR),
    m = xp.bind(null, p0)
  function y(K, Oe) {
    let ve, Be
    return (
      f4(K) ? ((ve = e.getRecordMatcher(K)), (Be = Oe)) : (Be = K),
      e.addRoute(Be, ve)
    )
  }
  function x(K) {
    const Oe = e.getRecordMatcher(K)
    Oe && e.removeRoute(Oe)
  }
  function S() {
    return e.getRoutes().map(K => K.record)
  }
  function C(K) {
    return !!e.getRecordMatcher(K)
  }
  function M(K, Oe) {
    if (((Oe = cn({}, Oe || A.value)), typeof K == "string")) {
      const ye = bp(t, K, Oe.path),
        D = e.resolve({ path: ye.path }, Oe),
        q = r.createHref(ye.fullPath)
      return cn(ye, D, {
        params: m(D.params),
        hash: p0(ye.hash),
        redirectedFrom: void 0,
        href: q,
      })
    }
    let ve
    if ("path" in K) ve = cn({}, K, { path: bp(t, K.path, Oe.path).path })
    else {
      const ye = cn({}, K.params)
      for (const D in ye) ye[D] == null && delete ye[D]
      ;(ve = cn({}, K, { params: p(K.params) })), (Oe.params = p(Oe.params))
    }
    const Be = e.resolve(ve, Oe),
      Fe = K.hash || ""
    Be.params = d(m(Be.params))
    const je = xC(i, cn({}, K, { hash: oR(Fe), path: Be.path })),
      Ge = r.createHref(je)
    return cn(
      { fullPath: je, hash: Fe, query: i === Qv ? uR(K.query) : K.query || {} },
      Be,
      { redirectedFrom: void 0, href: Ge }
    )
  }
  function _(K) {
    return typeof K == "string" ? bp(t, K, A.value.path) : cn({}, K)
  }
  function R(K, Oe) {
    if (c !== K) return dc(8, { from: Oe, to: K })
  }
  function T(K) {
    return k(K)
  }
  function L(K) {
    return T(cn(_(K), { replace: !0 }))
  }
  function B(K) {
    const Oe = K.matched[K.matched.length - 1]
    if (Oe && Oe.redirect) {
      const { redirect: ve } = Oe
      let Be = typeof ve == "function" ? ve(K) : ve
      return (
        typeof Be == "string" &&
          ((Be =
            Be.includes("?") || Be.includes("#") ? (Be = _(Be)) : { path: Be }),
          (Be.params = {})),
        cn({ query: K.query, hash: K.hash, params: K.params }, Be)
      )
    }
  }
  function k(K, Oe) {
    const ve = (c = M(K)),
      Be = A.value,
      Fe = K.state,
      je = K.force,
      Ge = K.replace === !0,
      ye = B(ve)
    if (ye) return k(cn(_(ye), { state: Fe, force: je, replace: Ge }), Oe || ve)
    const D = ve
    D.redirectedFrom = Oe
    let q
    return (
      !je &&
        bC(i, Be, ve) &&
        ((q = dc(16, { to: D, from: Be })), Ae(Be, Be, !0, !1)),
      (q ? Promise.resolve(q) : W(D, Be))
        .catch(F => (ao(F) ? (ao(F, 2) ? F : Te(F)) : ne(F, D, Be)))
        .then(F => {
          if (F) {
            if (ao(F, 2))
              return k(
                cn(_(F.to), { state: Fe, force: je, replace: Ge }),
                Oe || D
              )
          } else F = P(D, Be, !0, Ge, Fe)
          return z(D, Be, F), F
        })
    )
  }
  function O(K, Oe) {
    const ve = R(K, Oe)
    return ve ? Promise.reject(ve) : Promise.resolve()
  }
  function W(K, Oe) {
    let ve
    const [Be, Fe, je] = vR(K, Oe)
    ve = wp(Be.reverse(), "beforeRouteLeave", K, Oe)
    for (const ye of Be)
      ye.leaveGuards.forEach(D => {
        ve.push(Mo(D, K, Oe))
      })
    const Ge = O.bind(null, K, Oe)
    return (
      ve.push(Ge),
      ul(ve)
        .then(() => {
          ve = []
          for (const ye of s.list()) ve.push(Mo(ye, K, Oe))
          return ve.push(Ge), ul(ve)
        })
        .then(() => {
          ve = wp(Fe, "beforeRouteUpdate", K, Oe)
          for (const ye of Fe)
            ye.updateGuards.forEach(D => {
              ve.push(Mo(D, K, Oe))
            })
          return ve.push(Ge), ul(ve)
        })
        .then(() => {
          ve = []
          for (const ye of K.matched)
            if (ye.beforeEnter && !Oe.matched.includes(ye))
              if (Array.isArray(ye.beforeEnter))
                for (const D of ye.beforeEnter) ve.push(Mo(D, K, Oe))
              else ve.push(Mo(ye.beforeEnter, K, Oe))
          return ve.push(Ge), ul(ve)
        })
        .then(
          () => (
            K.matched.forEach(ye => (ye.enterCallbacks = {})),
            (ve = wp(je, "beforeRouteEnter", K, Oe)),
            ve.push(Ge),
            ul(ve)
          )
        )
        .then(() => {
          ve = []
          for (const ye of o.list()) ve.push(Mo(ye, K, Oe))
          return ve.push(Ge), ul(ve)
        })
        .catch(ye => (ao(ye, 8) ? ye : Promise.reject(ye)))
    )
  }
  function z(K, Oe, ve) {
    for (const Be of a.list()) Be(K, Oe, ve)
  }
  function P(K, Oe, ve, Be, Fe) {
    const je = R(K, Oe)
    if (je) return je
    const Ge = Oe === oo,
      ye = Nl ? history.state : {}
    ve &&
      (Be || Ge
        ? r.replace(K.fullPath, cn({ scroll: Ge && ye && ye.scroll }, Fe))
        : r.push(K.fullPath, Fe)),
      (A.value = K),
      Ae(K, Oe, ve, Ge),
      Te()
  }
  let N
  function G() {
    N ||
      (N = r.listen((K, Oe, ve) => {
        const Be = M(K),
          Fe = B(Be)
        if (Fe) {
          k(cn(Fe, { replace: !0 }), Be).catch(DA)
          return
        }
        c = Be
        const je = A.value
        Nl && PC(zv(je.fullPath, ve.delta), gd()),
          W(Be, je)
            .catch(Ge =>
              ao(Ge, 12)
                ? Ge
                : ao(Ge, 2)
                ? (k(Ge.to, Be)
                    .then(ye => {
                      ao(ye, 20) &&
                        !ve.delta &&
                        ve.type === $A.pop &&
                        r.go(-1, !1)
                    })
                    .catch(DA),
                  Promise.reject())
                : (ve.delta && r.go(-ve.delta, !1), ne(Ge, Be, je))
            )
            .then(Ge => {
              ;(Ge = Ge || P(Be, je, !1)),
                Ge &&
                  (ve.delta
                    ? r.go(-ve.delta, !1)
                    : ve.type === $A.pop && ao(Ge, 20) && r.go(-1, !1)),
                z(Be, je, Ge)
            })
            .catch(DA)
      }))
  }
  let j = tA(),
    V = tA(),
    Y
  function ne(K, Oe, ve) {
    Te(K)
    const Be = V.list()
    return (
      Be.length ? Be.forEach(Fe => Fe(K, Oe, ve)) : console.error(K),
      Promise.reject(K)
    )
  }
  function le() {
    return Y && A.value !== oo
      ? Promise.resolve()
      : new Promise((K, Oe) => {
          j.add([K, Oe])
        })
  }
  function Te(K) {
    return (
      Y ||
        ((Y = !K),
        G(),
        j.list().forEach(([Oe, ve]) => (K ? ve(K) : Oe())),
        j.reset()),
      K
    )
  }
  function Ae(K, Oe, ve, Be) {
    const { scrollBehavior: Fe } = n
    if (!Nl || !Fe) return Promise.resolve()
    const je =
      (!ve && LC(zv(K.fullPath, 0))) ||
      ((Be || !ve) && history.state && history.state.scroll) ||
      null
    return Pu()
      .then(() => Fe(K, Oe, je))
      .then(Ge => Ge && RC(Ge))
      .catch(Ge => ne(Ge, K, Oe))
  }
  const ge = K => r.go(K)
  let Me
  const Ne = new Set()
  return {
    currentRoute: A,
    addRoute: y,
    removeRoute: x,
    hasRoute: C,
    getRoutes: S,
    resolve: M,
    options: n,
    push: T,
    replace: L,
    go: ge,
    back: () => ge(-1),
    forward: () => ge(1),
    beforeEach: s.add,
    beforeResolve: o.add,
    afterEach: a.add,
    onError: V.add,
    isReady: le,
    install(K) {
      const Oe = this
      K.component("RouterLink", dR),
        K.component("RouterView", _4),
        (K.config.globalProperties.$router = Oe),
        Object.defineProperty(K.config.globalProperties, "$route", {
          enumerable: !0,
          get: () => Jl(A),
        }),
        Nl &&
          !Me &&
          A.value === oo &&
          ((Me = !0), T(r.location).catch(Fe => {}))
      const ve = {}
      for (const Fe in oo) ve[Fe] = _n(() => A.value[Fe])
      K.provide(Xg, Oe), K.provide(c4, Or(ve)), K.provide(jm, A)
      const Be = K.unmount
      Ne.add(K),
        (K.unmount = function () {
          Ne.delete(K),
            Ne.size < 1 &&
              ((c = oo),
              N && N(),
              (N = null),
              (A.value = oo),
              (Me = !1),
              (Y = !1)),
            Be()
        })
    },
  }
}
function ul(n) {
  return n.reduce((e, t) => e.then(() => t()), Promise.resolve())
}
function vR(n, e) {
  const t = [],
    i = [],
    r = [],
    s = Math.max(e.matched.length, n.matched.length)
  for (let o = 0; o < s; o++) {
    const a = e.matched[o]
    a && (n.matched.find(c => hc(c, a)) ? i.push(a) : t.push(a))
    const A = n.matched[o]
    A && (e.matched.find(c => hc(c, A)) || r.push(A))
  }
  return [t, i, r]
}
const Xm = (n, e) => {
    const t = xr(),
      i = Pg(t.payload.state, n)
    if (i.value === void 0 && e) {
      const r = e()
      if (Gn(r)) return (t.payload.state[n] = r), r
      i.value = r
    }
    return i
  },
  QA = () => {
    const n = xr()
    return Xm("error", () => n.payload.error)
  },
  Uh = n => {
    const e = xr(),
      t = QA(),
      i = typeof n == "string" ? new Error(n) : n
    return e.callHook("app:error", i), (t.value = t.value || i), i
  },
  _R = async (n = {}) => {
    const e = xr(),
      t = QA()
    e.callHook("app:error:cleared", n),
      n.redirect && (await e.$router.replace(n.redirect)),
      (t.value = null)
  }
class Mp extends Error {
  constructor() {
    super(...arguments),
      (this.statusCode = 500),
      (this.statusMessage = "Internal Server Error")
  }
}
function xR(n) {
  var t
  if (typeof n == "string") return new Mp(n)
  if (n instanceof Mp) return n
  const e = new Mp(
    (t = n.message) != null ? t : n.statusMessage,
    n.cause ? { cause: n.cause } : void 0
  )
  return (
    n.statusCode && (e.statusCode = n.statusCode),
    n.statusMessage && (e.statusMessage = n.statusMessage),
    n.data && (e.data = n.data),
    e
  )
}
const x4 = () => {
    var n
    return (n = xr()) == null ? void 0 : n.$router
  },
  mj = n => n,
  bR = () => {
    try {
      if (xr()._processingMiddleware) return !0
    } catch {
      return !0
    }
    return !1
  },
  gj = (n, e = {}) => {
    if ((n || (n = "/"), bR())) return n
    const t = x4()
    return e.replace ? t.replace(n) : t.push(n)
  },
  wR = (...n) => n.find(e => e !== void 0),
  MR = "noopener noreferrer"
function SR(n) {
  const e = n.componentName || "NuxtLink"
  return ni({
    name: e,
    props: {
      to: { type: [String, Object], default: void 0, required: !1 },
      href: { type: [String, Object], default: void 0, required: !1 },
      target: { type: String, default: void 0, required: !1 },
      rel: { type: String, default: void 0, required: !1 },
      noRel: { type: Boolean, default: void 0, required: !1 },
      activeClass: { type: String, default: void 0, required: !1 },
      exactActiveClass: { type: String, default: void 0, required: !1 },
      replace: { type: Boolean, default: void 0, required: !1 },
      ariaCurrentValue: { type: String, default: void 0, required: !1 },
      external: { type: Boolean, default: void 0, required: !1 },
      custom: { type: Boolean, default: void 0, required: !1 },
    },
    setup(t, { slots: i }) {
      const r = x4(),
        s = _n(() => t.to || t.href || ""),
        o = _n(() =>
          t.external || (t.target && t.target !== "_self")
            ? !0
            : typeof s.value == "object"
            ? !1
            : s.value === "" || Kw(s.value, !0)
        )
      return () => {
        var d, p, m
        if (!o.value)
          return tr(
            Bu("RouterLink"),
            {
              to: s.value,
              activeClass: t.activeClass || n.activeClass,
              exactActiveClass: t.exactActiveClass || n.exactActiveClass,
              replace: t.replace,
              ariaCurrentValue: t.ariaCurrentValue,
            },
            i.default
          )
        const a =
            typeof s.value == "object"
              ? (p = (d = r.resolve(s.value)) == null ? void 0 : d.href) != null
                ? p
                : null
              : s.value || null,
          A = t.target || null,
          c = t.noRel
            ? null
            : wR(t.rel, n.externalRelAttribute, a ? MR : "") || null
        return tr(
          "a",
          { href: a, rel: c, target: A },
          (m = i.default) == null ? void 0 : m.call(i)
        )
      }
    },
  })
}
var pc = SR({ componentName: "NuxtLink" })
function Fs(n) {
  const e = Et(n) ? _n(n) : n
  xr()._useHead(e)
}
const Sp = {}
function ER(n) {
  for (const e in Sp)
    n.vueApp.component(e, Sp[e]), n.vueApp.component("Lazy" + e, Sp[e])
}
var TR = Object.defineProperty,
  Kv = Object.getOwnPropertySymbols,
  CR = Object.prototype.hasOwnProperty,
  RR = Object.prototype.propertyIsEnumerable,
  e_ = (n, e, t) =>
    e in n
      ? TR(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  PR = (n, e) => {
    for (var t in e || (e = {})) CR.call(e, t) && e_(n, t, e[t])
    if (Kv) for (var t of Kv(e)) RR.call(e, t) && e_(n, t, e[t])
    return n
  },
  LR = "usehead",
  t_ = "head:count",
  Ep = "data-head-attrs",
  DR = (n, e, t) => {
    const i = t.createElement(n)
    for (const r of Object.keys(e)) {
      let s = e[r]
      r === "key" ||
        s === !1 ||
        (r === "children" ? (i.textContent = s) : i.setAttribute(r, s))
    }
    return i
  }
function IR(n, e) {
  if (n instanceof HTMLElement && e instanceof HTMLElement) {
    const t = e.getAttribute("nonce")
    if (t && !n.getAttribute("nonce")) {
      const i = e.cloneNode(!0)
      return (
        i.setAttribute("nonce", ""),
        (i.nonce = t),
        t === n.nonce && n.isEqualNode(i)
      )
    }
  }
  return n.isEqualNode(e)
}
var BR = n => {
    const e = ["key", "id", "name", "property"]
    for (const t of e) {
      const i =
        typeof n.getAttribute == "function"
          ? n.hasAttribute(t)
            ? n.getAttribute(t)
            : void 0
          : n[t]
      if (i !== void 0) return { name: t, value: i }
    }
  },
  kR = [
    "title",
    "meta",
    "link",
    "base",
    "style",
    "script",
    "htmlAttrs",
    "bodyAttrs",
  ],
  OR = n => {
    const e = []
    for (const t of Object.keys(n))
      if (n[t] != null) {
        if (t === "title") e.push({ tag: t, props: { children: n[t] } })
        else if (t === "base")
          e.push({ tag: t, props: PR({ key: "default" }, n[t]) })
        else if (kR.includes(t)) {
          const i = n[t]
          Array.isArray(i)
            ? i.forEach(r => {
                e.push({ tag: t, props: r })
              })
            : i && e.push({ tag: t, props: i })
        }
      }
    return e
  },
  n_ = (n, e) => {
    const t = n.getAttribute(Ep)
    if (t) for (const r of t.split(",")) r in e || n.removeAttribute(r)
    const i = []
    for (const r in e) {
      const s = e[r]
      s != null &&
        (s === !1 ? n.removeAttribute(r) : n.setAttribute(r, s), i.push(r))
    }
    i.length ? n.setAttribute(Ep, i.join(",")) : n.removeAttribute(Ep)
  },
  qR = (n = window.document, e, t) => {
    var i
    const r = n.head
    let s = r.querySelector(`meta[name="${t_}"]`)
    const o = s ? Number(s.getAttribute("content")) : 0,
      a = []
    if (s)
      for (
        let c = 0, d = s.previousElementSibling;
        c < o;
        c++, d = (d == null ? void 0 : d.previousElementSibling) || null
      )
        ((i = d == null ? void 0 : d.tagName) == null
          ? void 0
          : i.toLowerCase()) === e && a.push(d)
    else
      (s = n.createElement("meta")),
        s.setAttribute("name", t_),
        s.setAttribute("content", "0"),
        r.append(s)
    let A = t.map(c => DR(c.tag, c.props, n))
    ;(A = A.filter(c => {
      for (let d = 0; d < a.length; d++) {
        const p = a[d]
        if (IR(p, c)) return a.splice(d, 1), !1
      }
      return !0
    })),
      a.forEach(c => {
        var d
        return (d = c.parentNode) == null ? void 0 : d.removeChild(c)
      }),
      A.forEach(c => {
        r.insertBefore(c, s)
      }),
      s.setAttribute("content", "" + (o - a.length + A.length))
  },
  FR = () => {
    let n = [],
      e = new Set()
    const t = {
      install(i) {
        ;(i.config.globalProperties.$head = t), i.provide(LR, t)
      },
      get headTags() {
        const i = []
        return (
          n.forEach(r => {
            OR(r.value).forEach(o => {
              if (o.tag === "meta" || o.tag === "base" || o.tag === "script") {
                const a = BR(o.props)
                if (a) {
                  let A = -1
                  for (let c = 0; c < i.length; c++) {
                    const d = i[c],
                      p = d.props[a.name],
                      m = o.props[a.name]
                    if (d.tag === o.tag && p === m) {
                      A = c
                      break
                    }
                  }
                  A !== -1 && i.splice(A, 1)
                }
              }
              i.push(o)
            })
          }),
          i
        )
      },
      addHeadObjs(i) {
        n.push(i)
      },
      removeHeadObjs(i) {
        n = n.filter(r => r !== i)
      },
      updateDOM(i = window.document) {
        let r,
          s = {},
          o = {}
        const a = {}
        for (const c of t.headTags) {
          if (c.tag === "title") {
            r = c.props.children
            continue
          }
          if (c.tag === "htmlAttrs") {
            Object.assign(s, c.props)
            continue
          }
          if (c.tag === "bodyAttrs") {
            Object.assign(o, c.props)
            continue
          }
          ;(a[c.tag] = a[c.tag] || []), a[c.tag].push(c)
        }
        r !== void 0 && (i.title = r), n_(i.documentElement, s), n_(i.body, o)
        const A = new Set([...Object.keys(a), ...e])
        for (const c of A) qR(i, c, a[c] || [])
        e.clear(), Object.keys(a).forEach(c => e.add(c))
      },
    }
    return t
  }
function Tp(n) {
  return n !== null && typeof n == "object"
}
function Ym(n, e, t = ".", i) {
  if (!Tp(e)) return Ym(n, {}, t, i)
  const r = Object.assign({}, e)
  for (const s in n) {
    if (s === "__proto__" || s === "constructor") continue
    const o = n[s]
    o != null &&
      ((i && i(r, s, o, t)) ||
        (Array.isArray(o) && Array.isArray(r[s])
          ? (r[s] = o.concat(r[s]))
          : Tp(o) && Tp(r[s])
          ? (r[s] = Ym(o, r[s], (t ? `${t}.` : "") + s.toString(), i))
          : (r[s] = o)))
  }
  return r
}
function NR(n) {
  return (...e) => e.reduce((t, i) => Ym(t, i, "", n), {})
}
const UR = NR()
var zR = Nc(n => {
  const e = FR()
  n.vueApp.use(e)
  let t = !1
  n.hooks.hookOnce("app:mounted", () => {
    s0(() => {
      e.updateDOM()
    }),
      (t = !0)
  })
  const i = $n()
  n._useHead = r => {
    const s = $n(r)
    "titleTemplate" in s.value && (i.value = s.value.titleTemplate)
    const o = _n(() => {
      const A = { meta: [] }
      return (
        i.value &&
          "title" in s.value &&
          (A.title =
            typeof i.value == "function"
              ? i.value(s.value.title)
              : i.value.replace(/%s/g, s.value.title)),
        s.value.charset &&
          A.meta.push({ key: "charset", charset: s.value.charset }),
        s.value.viewport &&
          A.meta.push({ name: "viewport", content: s.value.viewport }),
        UR(A, s.value)
      )
    })
    e.addHeadObjs(o),
      t &&
        s0(() => {
          e.updateDOM()
        }),
      zr() &&
        Iu(() => {
          e.removeHeadObjs(o), e.updateDOM()
        })
  }
})
const HR = n =>
    Object.fromEntries(Object.entries(n).filter(([, e]) => e !== void 0)),
  Go = (n, e) => (t, i) => (
    Fs(() => n({ ...HR(t), ...i.attrs }, i)),
    () => {
      var r, s
      return e
        ? (s = (r = i.slots).default) == null
          ? void 0
          : s.call(r)
        : null
    }
  ),
  Ka = {
    accesskey: String,
    autocapitalize: String,
    autofocus: { type: Boolean, default: void 0 },
    class: String,
    contenteditable: { type: Boolean, default: void 0 },
    contextmenu: String,
    dir: String,
    draggable: { type: Boolean, default: void 0 },
    enterkeyhint: String,
    exportparts: String,
    hidden: { type: Boolean, default: void 0 },
    id: String,
    inputmode: String,
    is: String,
    itemid: String,
    itemprop: String,
    itemref: String,
    itemscope: String,
    itemtype: String,
    lang: String,
    nonce: String,
    part: String,
    slot: String,
    spellcheck: { type: Boolean, default: void 0 },
    style: String,
    tabindex: String,
    title: String,
    translate: String,
  },
  GR = ni({
    name: "Script",
    inheritAttrs: !1,
    props: {
      ...Ka,
      async: Boolean,
      crossorigin: { type: [Boolean, String], default: void 0 },
      defer: Boolean,
      integrity: String,
      nomodule: Boolean,
      nonce: String,
      referrerpolicy: String,
      src: String,
      type: String,
      charset: String,
      language: String,
    },
    setup: Go(n => ({ script: [n] })),
  }),
  VR = ni({
    name: "Link",
    inheritAttrs: !1,
    props: {
      ...Ka,
      as: String,
      crossorigin: String,
      disabled: Boolean,
      href: String,
      hreflang: String,
      imagesizes: String,
      imagesrcset: String,
      integrity: String,
      media: String,
      prefetch: { type: Boolean, default: void 0 },
      referrerpolicy: String,
      rel: String,
      sizes: String,
      title: String,
      type: String,
      methods: String,
      target: String,
    },
    setup: Go(n => ({ link: [n] })),
  }),
  WR = ni({
    name: "Base",
    inheritAttrs: !1,
    props: { ...Ka, href: String, target: String },
    setup: Go(n => ({ base: n })),
  }),
  jR = ni({
    name: "Title",
    inheritAttrs: !1,
    setup: Go((n, { slots: e }) => {
      var i, r, s
      return {
        title:
          ((s =
            (r = (i = e.default) == null ? void 0 : i.call(e)) == null
              ? void 0
              : r[0]) == null
            ? void 0
            : s.children) || null,
      }
    }),
  }),
  $R = ni({
    name: "Meta",
    inheritAttrs: !1,
    props: {
      ...Ka,
      charset: String,
      content: String,
      httpEquiv: String,
      name: String,
    },
    setup: Go(n => ({ meta: [n] })),
  }),
  QR = ni({
    name: "Style",
    inheritAttrs: !1,
    props: {
      ...Ka,
      type: String,
      media: String,
      nonce: String,
      title: String,
      scoped: { type: Boolean, default: void 0 },
    },
    setup: Go((n, { slots: e }) => {
      var r, s, o
      const t = { ...n },
        i =
          (o =
            (s = (r = e.default) == null ? void 0 : r.call(e)) == null
              ? void 0
              : s[0]) == null
            ? void 0
            : o.children
      return i && (t.children = i), { style: [t] }
    }),
  }),
  XR = ni({
    name: "Head",
    inheritAttrs: !1,
    setup: (n, e) => () => {
      var t, i
      return (i = (t = e.slots).default) == null ? void 0 : i.call(t)
    },
  }),
  YR = ni({
    name: "Html",
    inheritAttrs: !1,
    props: { ...Ka, manifest: String, version: String, xmlns: String },
    setup: Go(n => ({ htmlAttrs: n }), !0),
  }),
  ZR = ni({
    name: "Body",
    inheritAttrs: !1,
    props: Ka,
    setup: Go(n => ({ bodyAttrs: n }), !0),
  })
var i_ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Script: GR,
        Link: VR,
        Base: WR,
        Title: jR,
        Meta: $R,
        Style: QR,
        Head: XR,
        Html: YR,
        Body: ZR,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  JR = {
    globalMeta: {
      charset: "utf-8",
      viewport: "width=device-width, initial-scale=1",
      meta: [
        { name: "msapplication-TileColor", content: "#ffffff" },
        { name: "theme-color", content: "#ffffff" },
        { name: "title", content: "Helium Pro" },
        {
          name: "description",
          content:
            "Powered by the Helium Blockchain, The People\u2019s Network represents a paradigm shift for decentralized wireless infrastructure.",
        },
        { property: "og:type", content: "website" },
        { property: "og:url", content: "https://heliumpro.io/" },
        { property: "og:title", content: "Helium Pro" },
        {
          property: "og:description",
          content:
            "Powered by the Helium Blockchain, The People\u2019s Network represents a paradigm shift for decentralized wireless infrastructure.",
        },
        { property: "og:image", content: "images/meta/meta-image.jpg" },
        { property: "twitter:card", content: "summary_large_image" },
        { property: "twitter:url", content: "https://heliumpro.io/" },
        { property: "twitter:title", content: "Helium Pro" },
        {
          property: "twitter:description",
          content:
            "Powered by the Helium Blockchain, The People\u2019s Network represents a paradigm shift for decentralized wireless infrastructure.",
        },
        { property: "twitter:image", content: "images/meta/meta-image.jpg" },
      ],
      link: [
        { rel: "preconnect", href: "https://fonts.googleapis.com" },
        {
          rel: "preconnect",
          href: "https://fonts.gstatic.com",
          crossorigin: "",
        },
        {
          rel: "stylesheet",
          href: "https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap",
        },
        {
          rel: "apple-touch-icon",
          sizes: "180x180",
          href: "images/meta/apple-icon-180x180.png",
        },
        {
          rel: "icon",
          type: "image/png",
          sizes: "16x16",
          href: "images/meta/favicon-16x16.png",
        },
        {
          rel: "icon",
          type: "image/png",
          sizes: "32x32",
          href: "images/meta/favicon-32x32.png",
        },
        { rel: "manifest", href: "/site.webmanifest" },
        { rel: "mask-icon", href: "/safari-pinned-tab.svg", color: "#5bbad5" },
      ],
      style: [],
      script: [{ src: "track.js", type: "text/javascript" }],
      title: "Helium Pro",
    },
  }
const KR = {
  created() {
    const n = zr()
    if (!n) return
    const e = n.type
    if (!e || !("head" in e)) return
    const t = xr(),
      i = typeof e.head == "function" ? _n(() => e.head(t)) : e.head
    Fs(i)
  },
}
var eP = Nc(n => {
  Fs(Ru({ title: "", ...JR.globalMeta })), n.vueApp.mixin(KR)
  for (const e in i_) n.vueApp.component(e, i_[e])
})
const tP = (n, e) =>
    e.path
      .replace(/(:\w+)\([^)]+\)/g, "$1")
      .replace(/(:\w+)[?+*]/g, "$1")
      .replace(/:\w+/g, t => {
        var i
        return (
          ((i = n.params[t.slice(1)]) == null ? void 0 : i.toString()) || ""
        )
      }),
  r_ = (n, e) => {
    var r
    const t = e.route.matched.find(
        s => s.components.default === e.Component.type
      ),
      i =
        (r = n != null ? n : t == null ? void 0 : t.meta.key) != null
          ? r
          : tP(e.route, t)
    return typeof i == "function" ? i(e.route) : i
  },
  nP = (n, e) => ({ default: () => (n ? tr(Qb, n === !0 ? {} : n, e) : e) }),
  iP = {
    setup(n, { slots: e }) {
      return () => {
        var t
        return (t = e.default) == null ? void 0 : t.call(e)
      }
    },
  },
  rP = (n, e, t) => ({
    default: () => (e ? tr(n, e === !0 ? {} : e, t) : tr(iP, {}, t)),
  }),
  s_ = Symbol("isNested")
var Cp = ni({
  name: "NuxtPage",
  inheritAttrs: !1,
  props: {
    name: { type: String },
    route: { type: Object },
    pageKey: { type: [Function, String], default: null },
  },
  setup(n, { attrs: e }) {
    const t = xr(),
      i = _r(s_, !1)
    return (
      Ca(s_, !0),
      () =>
        tr(
          _4,
          { name: n.name, route: n.route, ...e },
          {
            default: r => {
              var s
              return (
                r.Component &&
                rP(
                  Fc,
                  (s = r.route.meta.pageTransition) != null ? s : sP,
                  nP(
                    r.route.meta.keepalive,
                    i && t.isHydrating
                      ? tr(r.Component, { key: r_(n.pageKey, r) })
                      : tr(
                          kg,
                          {
                            onPending: () =>
                              t.callHook("page:start", r.Component),
                            onResolve: () =>
                              t.callHook("page:finish", r.Component),
                          },
                          {
                            default: () =>
                              tr(r.Component, { key: r_(n.pageKey, r) }),
                          }
                        )
                  )
                ).default()
              )
            },
          }
        )
    )
  },
})
const sP = { name: "page", mode: "out-in" },
  oP = "modulepreload",
  o_ = {},
  aP = zt(),
  Qi = function (e, t) {
    return !t || t.length === 0
      ? e()
      : Promise.all(
          t.map(i => {
            if (((i = `${aP}${i}`), i in o_)) return
            o_[i] = !0
            const r = i.endsWith(".css"),
              s = r ? '[rel="stylesheet"]' : ""
            if (document.querySelector(`link[href="${i}"]${s}`)) return
            const o = document.createElement("link")
            if (
              ((o.rel = r ? "stylesheet" : oP),
              r || ((o.as = "script"), (o.crossOrigin = "")),
              (o.href = i),
              document.head.appendChild(o),
              r)
            )
              return new Promise((a, A) => {
                o.addEventListener("load", a),
                  o.addEventListener("error", () =>
                    A(new Error(`Unable to preload CSS for ${i}`))
                  )
              })
          })
        ).then(() => e())
  }
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const yd = "137",
  ha = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  da = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  b4 = 0,
  Zm = 1,
  w4 = 2,
  lP = 3,
  cP = 0,
  Zg = 1,
  M4 = 2,
  Ul = 3,
  Na = 0,
  Pn = 1,
  ls = 2,
  Jg = 1,
  AP = 2,
  Ds = 0,
  Ro = 1,
  Jm = 2,
  Km = 3,
  e1 = 4,
  S4 = 5,
  va = 100,
  E4 = 101,
  T4 = 102,
  t1 = 103,
  n1 = 104,
  C4 = 200,
  R4 = 201,
  P4 = 202,
  L4 = 203,
  Kg = 204,
  e2 = 205,
  D4 = 206,
  I4 = 207,
  B4 = 208,
  k4 = 209,
  O4 = 210,
  q4 = 0,
  F4 = 1,
  N4 = 2,
  m0 = 3,
  U4 = 4,
  z4 = 5,
  H4 = 6,
  G4 = 7,
  ku = 0,
  V4 = 1,
  W4 = 2,
  Is = 0,
  j4 = 1,
  $4 = 2,
  Q4 = 3,
  X4 = 4,
  Y4 = 5,
  vd = 300,
  el = 301,
  tl = 302,
  XA = 303,
  YA = 304,
  zc = 306,
  Ou = 307,
  ZA = 1e3,
  ci = 1001,
  JA = 1002,
  On = 1003,
  g0 = 1004,
  uP = 1004,
  y0 = 1005,
  fP = 1005,
  Mn = 1006,
  t2 = 1007,
  hP = 1007,
  nl = 1008,
  dP = 1008,
  Bs = 1009,
  Z4 = 1010,
  J4 = 1011,
  mc = 1012,
  K4 = 1013,
  BA = 1014,
  Rs = 1015,
  La = 1016,
  e5 = 1017,
  t5 = 1018,
  Da = 1020,
  n5 = 1021,
  i5 = 1022,
  Ai = 1023,
  r5 = 1024,
  s5 = 1025,
  Po = 1026,
  Ua = 1027,
  o5 = 1028,
  a5 = 1029,
  l5 = 1030,
  c5 = 1031,
  A5 = 1033,
  zh = 33776,
  Hh = 33777,
  Gh = 33778,
  Vh = 33779,
  i1 = 35840,
  r1 = 35841,
  s1 = 35842,
  o1 = 35843,
  u5 = 36196,
  a1 = 37492,
  l1 = 37496,
  c1 = 37808,
  A1 = 37809,
  u1 = 37810,
  f1 = 37811,
  h1 = 37812,
  d1 = 37813,
  p1 = 37814,
  m1 = 37815,
  g1 = 37816,
  y1 = 37817,
  v1 = 37818,
  _1 = 37819,
  x1 = 37820,
  b1 = 37821,
  w1 = 36492,
  f5 = 2200,
  h5 = 2201,
  d5 = 2202,
  KA = 2300,
  eu = 2301,
  Wh = 2302,
  ba = 2400,
  wa = 2401,
  tu = 2402,
  _d = 2500,
  n2 = 2501,
  i2 = 0,
  p5 = 1,
  M1 = 2,
  Ns = 3e3,
  pn = 3001,
  m5 = 3200,
  g5 = 3201,
  il = 0,
  y5 = 1,
  pP = 0,
  jh = 7680,
  mP = 7681,
  gP = 7682,
  yP = 7683,
  vP = 34055,
  _P = 34056,
  xP = 5386,
  bP = 512,
  wP = 513,
  MP = 514,
  SP = 515,
  EP = 516,
  TP = 517,
  CP = 518,
  v5 = 519,
  gc = 35044,
  yc = 35048,
  RP = 35040,
  PP = 35045,
  LP = 35049,
  DP = 35041,
  IP = 35046,
  BP = 35050,
  kP = 35042,
  OP = "100",
  S1 = "300 es",
  v0 = 1035
class Ys {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {})
    const i = this._listeners
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t)
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1
    const i = this._listeners
    return i[e] !== void 0 && i[e].indexOf(t) !== -1
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return
    const r = this._listeners[e]
    if (r !== void 0) {
      const s = r.indexOf(t)
      s !== -1 && r.splice(s, 1)
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return
    const i = this._listeners[e.type]
    if (i !== void 0) {
      e.target = this
      const r = i.slice(0)
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e)
      e.target = null
    }
  }
}
const oi = []
for (let n = 0; n < 256; n++) oi[n] = (n < 16 ? "0" : "") + n.toString(16)
let xf = 1234567
const Ia = Math.PI / 180,
  nu = 180 / Math.PI
function ir() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0
  return (
    oi[n & 255] +
    oi[(n >> 8) & 255] +
    oi[(n >> 16) & 255] +
    oi[(n >> 24) & 255] +
    "-" +
    oi[e & 255] +
    oi[(e >> 8) & 255] +
    "-" +
    oi[((e >> 16) & 15) | 64] +
    oi[(e >> 24) & 255] +
    "-" +
    oi[(t & 63) | 128] +
    oi[(t >> 8) & 255] +
    "-" +
    oi[(t >> 16) & 255] +
    oi[(t >> 24) & 255] +
    oi[i & 255] +
    oi[(i >> 8) & 255] +
    oi[(i >> 16) & 255] +
    oi[(i >> 24) & 255]
  ).toUpperCase()
}
function li(n, e, t) {
  return Math.max(e, Math.min(t, n))
}
function r2(n, e) {
  return ((n % e) + e) % e
}
function qP(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e)
}
function FP(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0
}
function kA(n, e, t) {
  return (1 - t) * n + t * e
}
function NP(n, e, t, i) {
  return kA(n, e, 1 - Math.exp(-t * i))
}
function UP(n, e = 1) {
  return e - Math.abs(r2(n, e * 2) - e)
}
function zP(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n))
}
function HP(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10))
}
function GP(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1))
}
function VP(n, e) {
  return n + Math.random() * (e - n)
}
function WP(n) {
  return n * (0.5 - Math.random())
}
function jP(n) {
  return (
    n !== void 0 && (xf = n % 2147483647),
    (xf = (xf * 16807) % 2147483647),
    (xf - 1) / 2147483646
  )
}
function $P(n) {
  return n * Ia
}
function QP(n) {
  return n * nu
}
function E1(n) {
  return (n & (n - 1)) === 0 && n !== 0
}
function _5(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}
function x5(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}
function XP(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    A = o(t / 2),
    c = s((e + i) / 2),
    d = o((e + i) / 2),
    p = s((e - i) / 2),
    m = o((e - i) / 2),
    y = s((i - e) / 2),
    x = o((i - e) / 2)
  switch (r) {
    case "XYX":
      n.set(a * d, A * p, A * m, a * c)
      break
    case "YZY":
      n.set(A * m, a * d, A * p, a * c)
      break
    case "ZXZ":
      n.set(A * p, A * m, a * d, a * c)
      break
    case "XZX":
      n.set(a * d, A * x, A * y, a * c)
      break
    case "YXY":
      n.set(A * y, a * d, A * x, a * c)
      break
    case "ZYZ":
      n.set(A * x, A * y, a * d, a * c)
      break
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r
      )
  }
}
var T1 = Object.freeze({
  __proto__: null,
  DEG2RAD: Ia,
  RAD2DEG: nu,
  generateUUID: ir,
  clamp: li,
  euclideanModulo: r2,
  mapLinear: qP,
  inverseLerp: FP,
  lerp: kA,
  damp: NP,
  pingpong: UP,
  smoothstep: zP,
  smootherstep: HP,
  randInt: GP,
  randFloat: VP,
  randFloatSpread: WP,
  seededRandom: jP,
  degToRad: $P,
  radToDeg: QP,
  isPowerOfTwo: E1,
  ceilPowerOfTwo: _5,
  floorPowerOfTwo: x5,
  setQuaternionFromProperEuler: XP,
})
class qe {
  constructor(e = 0, t = 0) {
    ;(this.x = e), (this.y = t)
  }
  get width() {
    return this.x
  }
  set width(e) {
    this.x = e
  }
  get height() {
    return this.y
  }
  set height(e) {
    this.y = e
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this
  }
  setX(e) {
    return (this.x = e), this
  }
  setY(e) {
    return (this.y = e), this
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t
        break
      case 1:
        this.y = t
        break
      default:
        throw new Error("index is out of range: " + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      default:
        throw new Error("index is out of range: " + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y)
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this
  }
  add(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(e, t))
      : ((this.x += e.x), (this.y += e.y), this)
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this
  }
  sub(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(e, t))
      : ((this.x -= e.x), (this.y -= e.y), this)
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    )
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    )
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    )
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    )
  }
  clampLength(e, t) {
    const i = this.length()
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    )
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this
  }
  dot(e) {
    return this.x * e.x + this.y * e.y
  }
  cross(e) {
    return this.x * e.y - this.y * e.x
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e))
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y
    return t * t + i * i
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    )
  }
  equals(e) {
    return e.x === this.x && e.y === this.y
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e
  }
  fromBufferAttribute(e, t, i) {
    return (
      i !== void 0 &&
        console.warn(
          "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      this
    )
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y
    return (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y
  }
}
qe.prototype.isVector2 = !0
class Zn {
  constructor() {
    ;(this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
        )
  }
  set(e, t, i, r, s, o, a, A, c) {
    const d = this.elements
    return (
      (d[0] = e),
      (d[1] = r),
      (d[2] = a),
      (d[3] = t),
      (d[4] = s),
      (d[5] = A),
      (d[6] = i),
      (d[7] = o),
      (d[8] = c),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
  }
  copy(e) {
    const t = this.elements,
      i = e.elements
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    )
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    )
  }
  setFromMatrix4(e) {
    const t = e.elements
    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
  }
  multiply(e) {
    return this.multiplyMatrices(this, e)
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this)
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      A = i[6],
      c = i[1],
      d = i[4],
      p = i[7],
      m = i[2],
      y = i[5],
      x = i[8],
      S = r[0],
      C = r[3],
      M = r[6],
      _ = r[1],
      R = r[4],
      T = r[7],
      L = r[2],
      B = r[5],
      k = r[8]
    return (
      (s[0] = o * S + a * _ + A * L),
      (s[3] = o * C + a * R + A * B),
      (s[6] = o * M + a * T + A * k),
      (s[1] = c * S + d * _ + p * L),
      (s[4] = c * C + d * R + p * B),
      (s[7] = c * M + d * T + p * k),
      (s[2] = m * S + y * _ + x * L),
      (s[5] = m * C + y * R + x * B),
      (s[8] = m * M + y * T + x * k),
      this
    )
  }
  multiplyScalar(e) {
    const t = this.elements
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    )
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      A = e[6],
      c = e[7],
      d = e[8]
    return t * o * d - t * a * c - i * s * d + i * a * A + r * s * c - r * o * A
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      A = e[6],
      c = e[7],
      d = e[8],
      p = d * o - a * c,
      m = a * A - d * s,
      y = c * s - o * A,
      x = t * p + i * m + r * y
    if (x === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
    const S = 1 / x
    return (
      (e[0] = p * S),
      (e[1] = (r * c - d * i) * S),
      (e[2] = (a * i - r * o) * S),
      (e[3] = m * S),
      (e[4] = (d * t - r * A) * S),
      (e[5] = (r * s - a * t) * S),
      (e[6] = y * S),
      (e[7] = (i * A - c * t) * S),
      (e[8] = (o * t - i * s) * S),
      this
    )
  }
  transpose() {
    let e
    const t = this.elements
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    )
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose()
  }
  transposeIntoArray(e) {
    const t = this.elements
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    )
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const A = Math.cos(s),
      c = Math.sin(s)
    return (
      this.set(
        i * A,
        i * c,
        -i * (A * o + c * a) + o + e,
        -r * c,
        r * A,
        -r * (-c * o + A * a) + a + t,
        0,
        0,
        1
      ),
      this
    )
  }
  scale(e, t) {
    const i = this.elements
    return (
      (i[0] *= e),
      (i[3] *= e),
      (i[6] *= e),
      (i[1] *= t),
      (i[4] *= t),
      (i[7] *= t),
      this
    )
  }
  rotate(e) {
    const t = Math.cos(e),
      i = Math.sin(e),
      r = this.elements,
      s = r[0],
      o = r[3],
      a = r[6],
      A = r[1],
      c = r[4],
      d = r[7]
    return (
      (r[0] = t * s + i * A),
      (r[3] = t * o + i * c),
      (r[6] = t * a + i * d),
      (r[1] = -i * s + t * A),
      (r[4] = -i * o + t * c),
      (r[7] = -i * a + t * d),
      this
    )
  }
  translate(e, t) {
    const i = this.elements
    return (
      (i[0] += e * i[2]),
      (i[3] += e * i[5]),
      (i[6] += e * i[8]),
      (i[1] += t * i[2]),
      (i[4] += t * i[5]),
      (i[7] += t * i[8]),
      this
    )
  }
  equals(e) {
    const t = this.elements,
      i = e.elements
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1
    return !0
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t]
    return this
  }
  toArray(e = [], t = 0) {
    const i = this.elements
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    )
  }
  clone() {
    return new this.constructor().fromArray(this.elements)
  }
}
Zn.prototype.isMatrix3 = !0
function b5(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] > 65535) return !0
  return !1
}
const YP = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
}
function zl(n, e) {
  return new YP[n](e)
}
function iu(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
const w5 = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Rr = { h: 0, s: 0, l: 0 },
  bf = { h: 0, s: 0, l: 0 }
function Rp(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  )
}
function tc(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4)
}
function Pp(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055
}
class Ke {
  constructor(e, t, i) {
    return t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
  }
  set(e) {
    return (
      e && e.isColor
        ? this.copy(e)
        : typeof e == "number"
        ? this.setHex(e)
        : typeof e == "string" && this.setStyle(e),
      this
    )
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this
  }
  setHex(e) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      this
    )
  }
  setRGB(e, t, i) {
    return (this.r = e), (this.g = t), (this.b = i), this
  }
  setHSL(e, t, i) {
    if (((e = r2(e, 1)), (t = li(t, 0, 1)), (i = li(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i
    else {
      const r = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        s = 2 * i - r
      ;(this.r = Rp(s, r, e + 1 / 3)),
        (this.g = Rp(s, r, e)),
        (this.b = Rp(s, r, e - 1 / 3))
    }
    return this
  }
  setStyle(e) {
    function t(r) {
      r !== void 0 &&
        parseFloat(r) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        )
    }
    let i
    if ((i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e))) {
      let r
      const s = i[1],
        o = i[2]
      switch (s) {
        case "rgb":
        case "rgba":
          if (
            (r =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(r[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(r[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(r[3], 10)) / 255),
              t(r[4]),
              this
            )
          if (
            (r =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(r[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(r[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(r[3], 10)) / 100),
              t(r[4]),
              this
            )
          break
        case "hsl":
        case "hsla":
          if (
            (r =
              /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          ) {
            const a = parseFloat(r[1]) / 360,
              A = parseInt(r[2], 10) / 100,
              c = parseInt(r[3], 10) / 100
            return t(r[4]), this.setHSL(a, A, c)
          }
          break
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const r = i[1],
        s = r.length
      if (s === 3)
        return (
          (this.r = parseInt(r.charAt(0) + r.charAt(0), 16) / 255),
          (this.g = parseInt(r.charAt(1) + r.charAt(1), 16) / 255),
          (this.b = parseInt(r.charAt(2) + r.charAt(2), 16) / 255),
          this
        )
      if (s === 6)
        return (
          (this.r = parseInt(r.charAt(0) + r.charAt(1), 16) / 255),
          (this.g = parseInt(r.charAt(2) + r.charAt(3), 16) / 255),
          (this.b = parseInt(r.charAt(4) + r.charAt(5), 16) / 255),
          this
        )
    }
    return e && e.length > 0 ? this.setColorName(e) : this
  }
  setColorName(e) {
    const t = w5[e.toLowerCase()]
    return (
      t !== void 0
        ? this.setHex(t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    )
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b)
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this
  }
  copySRGBToLinear(e) {
    return (this.r = tc(e.r)), (this.g = tc(e.g)), (this.b = tc(e.b)), this
  }
  copyLinearToSRGB(e) {
    return (this.r = Pp(e.r)), (this.g = Pp(e.g)), (this.b = Pp(e.b)), this
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this
  }
  getHex() {
    return (
      ((this.r * 255) << 16) ^ ((this.g * 255) << 8) ^ ((this.b * 255) << 0)
    )
  }
  getHexString() {
    return ("000000" + this.getHex().toString(16)).slice(-6)
  }
  getHSL(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = Math.max(t, i, r),
      o = Math.min(t, i, r)
    let a, A
    const c = (o + s) / 2
    if (o === s) (a = 0), (A = 0)
    else {
      const d = s - o
      switch (((A = c <= 0.5 ? d / (s + o) : d / (2 - s - o)), s)) {
        case t:
          a = (i - r) / d + (i < r ? 6 : 0)
          break
        case i:
          a = (r - t) / d + 2
          break
        case r:
          a = (t - i) / d + 4
          break
      }
      a /= 6
    }
    return (e.h = a), (e.s = A), (e.l = c), e
  }
  getStyle() {
    return (
      "rgb(" +
      ((this.r * 255) | 0) +
      "," +
      ((this.g * 255) | 0) +
      "," +
      ((this.b * 255) | 0) +
      ")"
    )
  }
  offsetHSL(e, t, i) {
    return (
      this.getHSL(Rr),
      (Rr.h += e),
      (Rr.s += t),
      (Rr.l += i),
      this.setHSL(Rr.h, Rr.s, Rr.l),
      this
    )
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    )
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    )
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    )
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    )
  }
  lerpHSL(e, t) {
    this.getHSL(Rr), e.getHSL(bf)
    const i = kA(Rr.h, bf.h, t),
      r = kA(Rr.s, bf.s, t),
      s = kA(Rr.l, bf.l, t)
    return this.setHSL(i, r, s), this
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)),
      (this.g = e.getY(t)),
      (this.b = e.getZ(t)),
      e.normalized === !0 &&
        ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
      this
    )
  }
  toJSON() {
    return this.getHex()
  }
}
Ke.NAMES = w5
Ke.prototype.isColor = !0
Ke.prototype.r = 1
Ke.prototype.g = 1
Ke.prototype.b = 1
let fl
class Vo {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement == "undefined")
      return e.src
    let t
    if (e instanceof HTMLCanvasElement) t = e
    else {
      fl === void 0 && (fl = iu("canvas")),
        (fl.width = e.width),
        (fl.height = e.height)
      const i = fl.getContext("2d")
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = fl)
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png")
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement != "undefined" &&
        e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement != "undefined" &&
        e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap != "undefined" && e instanceof ImageBitmap)
    ) {
      const t = iu("canvas")
      ;(t.width = e.width), (t.height = e.height)
      const i = t.getContext("2d")
      i.drawImage(e, 0, 0, e.width, e.height)
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data
      for (let o = 0; o < s.length; o++) s[o] = tc(s[o] / 255) * 255
      return i.putImageData(r, 0, 0), t
    } else if (e.data) {
      const t = e.data.slice(0)
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(tc(t[i] / 255) * 255))
          : (t[i] = tc(t[i]))
      return { data: t, width: e.width, height: e.height }
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      )
  }
}
let ZP = 0
class Vn extends Ys {
  constructor(
    e = Vn.DEFAULT_IMAGE,
    t = Vn.DEFAULT_MAPPING,
    i = ci,
    r = ci,
    s = Mn,
    o = nl,
    a = Ai,
    A = Bs,
    c = 1,
    d = Ns
  ) {
    super(),
      Object.defineProperty(this, "id", { value: ZP++ }),
      (this.uuid = ir()),
      (this.name = ""),
      (this.image = e),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = A),
      (this.offset = new qe(0, 0)),
      (this.repeat = new qe(1, 1)),
      (this.center = new qe(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Zn()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = d),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1)
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.image = e.image),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.encoding = e.encoding),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    )
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string"
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]
    const i = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    }
    if (this.image !== void 0) {
      const r = this.image
      if (
        (r.uuid === void 0 && (r.uuid = ir()),
        !t && e.images[r.uuid] === void 0)
      ) {
        let s
        if (Array.isArray(r)) {
          s = []
          for (let o = 0, a = r.length; o < a; o++)
            r[o].isDataTexture ? s.push(Lp(r[o].image)) : s.push(Lp(r[o]))
        } else s = Lp(r)
        e.images[r.uuid] = { uuid: r.uuid, url: s }
      }
      i.image = r.uuid
    }
    return (
      JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    )
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" })
  }
  transformUv(e) {
    if (this.mapping !== vd) return e
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case ZA:
          e.x = e.x - Math.floor(e.x)
          break
        case ci:
          e.x = e.x < 0 ? 0 : 1
          break
        case JA:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x))
          break
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case ZA:
          e.y = e.y - Math.floor(e.y)
          break
        case ci:
          e.y = e.y < 0 ? 0 : 1
          break
        case JA:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y))
          break
      }
    return this.flipY && (e.y = 1 - e.y), e
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
}
Vn.DEFAULT_IMAGE = void 0
Vn.DEFAULT_MAPPING = vd
Vn.prototype.isTexture = !0
function Lp(n) {
  return (typeof HTMLImageElement != "undefined" &&
    n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement != "undefined" &&
      n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap != "undefined" && n instanceof ImageBitmap)
    ? Vo.getDataURL(n)
    : n.data
    ? {
        data: Array.prototype.slice.call(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
class en {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ;(this.x = e), (this.y = t), (this.z = i), (this.w = r)
  }
  get width() {
    return this.z
  }
  set width(e) {
    this.z = e
  }
  get height() {
    return this.w
  }
  set height(e) {
    this.w = e
  }
  set(e, t, i, r) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this
  }
  setX(e) {
    return (this.x = e), this
  }
  setY(e) {
    return (this.y = e), this
  }
  setZ(e) {
    return (this.z = e), this
  }
  setW(e) {
    return (this.w = e), this
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t
        break
      case 1:
        this.y = t
        break
      case 2:
        this.z = t
        break
      case 3:
        this.w = t
        break
      default:
        throw new Error("index is out of range: " + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      case 3:
        return this.w
      default:
        throw new Error("index is out of range: " + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w)
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    )
  }
  add(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(e, t))
      : ((this.x += e.x),
        (this.y += e.y),
        (this.z += e.z),
        (this.w += e.w),
        this)
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    )
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    )
  }
  sub(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(e, t))
      : ((this.x -= e.x),
        (this.y -= e.y),
        (this.z -= e.z),
        (this.w -= e.w),
        this)
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    )
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    )
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    )
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w)
    const t = Math.sqrt(1 - e.w * e.w)
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    )
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s
    const A = e.elements,
      c = A[0],
      d = A[4],
      p = A[8],
      m = A[1],
      y = A[5],
      x = A[9],
      S = A[2],
      C = A[6],
      M = A[10]
    if (
      Math.abs(d - m) < 0.01 &&
      Math.abs(p - S) < 0.01 &&
      Math.abs(x - C) < 0.01
    ) {
      if (
        Math.abs(d + m) < 0.1 &&
        Math.abs(p + S) < 0.1 &&
        Math.abs(x + C) < 0.1 &&
        Math.abs(c + y + M - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this
      t = Math.PI
      const R = (c + 1) / 2,
        T = (y + 1) / 2,
        L = (M + 1) / 2,
        B = (d + m) / 4,
        k = (p + S) / 4,
        O = (x + C) / 4
      return (
        R > T && R > L
          ? R < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(R)), (r = B / i), (s = k / i))
          : T > L
          ? T < 0.01
            ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
            : ((r = Math.sqrt(T)), (i = B / r), (s = O / r))
          : L < 0.01
          ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
          : ((s = Math.sqrt(L)), (i = k / s), (r = O / s)),
        this.set(i, r, s, t),
        this
      )
    }
    let _ = Math.sqrt((C - x) * (C - x) + (p - S) * (p - S) + (m - d) * (m - d))
    return (
      Math.abs(_) < 0.001 && (_ = 1),
      (this.x = (C - x) / _),
      (this.y = (p - S) / _),
      (this.z = (m - d) / _),
      (this.w = Math.acos((c + y + M - 1) / 2)),
      this
    )
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    )
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    )
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    )
  }
  clampLength(e, t) {
    const i = this.length()
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    )
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    )
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    )
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    )
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    )
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    )
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    )
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    )
  }
  fromBufferAttribute(e, t, i) {
    return (
      i !== void 0 &&
        console.warn(
          "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w
  }
}
en.prototype.isVector4 = !0
class rr extends Ys {
  constructor(e, t, i = {}) {
    super(),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new en(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new en(0, 0, e, t)),
      (this.texture = new Vn(
        void 0,
        i.mapping,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.encoding
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.image = { width: e, height: t, depth: 1 }),
      (this.texture.generateMipmaps =
        i.generateMipmaps !== void 0 ? i.generateMipmaps : !1),
      (this.texture.internalFormat =
        i.internalFormat !== void 0 ? i.internalFormat : null),
      (this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : Mn),
      (this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0),
      (this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1),
      (this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null)
  }
  setTexture(e) {
    ;(e.image = { width: this.width, height: this.height, depth: this.depth }),
      (this.texture = e)
  }
  setSize(e, t, i = 1) {
    ;(this.width !== e || this.height !== t || this.depth !== i) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = i),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return (
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.image = Object.assign({}, e.texture.image)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.depthTexture = e.depthTexture),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" })
  }
}
rr.prototype.isWebGLRenderTarget = !0
class M5 extends rr {
  constructor(e, t, i) {
    super(e, t)
    const r = this.texture
    this.texture = []
    for (let s = 0; s < i; s++) this.texture[s] = r.clone()
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      ;(this.width = e), (this.height = t), (this.depth = i)
      for (let r = 0, s = this.texture.length; r < s; r++)
        (this.texture[r].image.width = e),
          (this.texture[r].image.height = t),
          (this.texture[r].image.depth = i)
      this.dispose()
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.set(0, 0, this.width, this.height),
      this.scissor.set(0, 0, this.width, this.height),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.depthTexture = e.depthTexture),
      (this.texture.length = 0)
    for (let t = 0, i = e.texture.length; t < i; t++)
      this.texture[t] = e.texture[t].clone()
    return this
  }
}
M5.prototype.isWebGLMultipleRenderTargets = !0
class xd extends rr {
  constructor(e, t, i = {}) {
    super(e, t, i),
      (this.samples = 4),
      (this.ignoreDepthForMultisampleCopy =
        i.ignoreDepth !== void 0 ? i.ignoreDepth : !0),
      (this.useRenderToTexture =
        i.useRenderToTexture !== void 0 ? i.useRenderToTexture : !1),
      (this.useRenderbuffer = this.useRenderToTexture === !1)
  }
  copy(e) {
    return (
      super.copy.call(this, e),
      (this.samples = e.samples),
      (this.useRenderToTexture = e.useRenderToTexture),
      (this.useRenderbuffer = e.useRenderbuffer),
      this
    )
  }
}
xd.prototype.isWebGLMultisampleRenderTarget = !0
class Jn {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    ;(this._x = e), (this._y = t), (this._z = i), (this._w = r)
  }
  static slerp(e, t, i, r) {
    return (
      console.warn(
        "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
      ),
      i.slerpQuaternions(e, t, r)
    )
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let A = i[r + 0],
      c = i[r + 1],
      d = i[r + 2],
      p = i[r + 3]
    const m = s[o + 0],
      y = s[o + 1],
      x = s[o + 2],
      S = s[o + 3]
    if (a === 0) {
      ;(e[t + 0] = A), (e[t + 1] = c), (e[t + 2] = d), (e[t + 3] = p)
      return
    }
    if (a === 1) {
      ;(e[t + 0] = m), (e[t + 1] = y), (e[t + 2] = x), (e[t + 3] = S)
      return
    }
    if (p !== S || A !== m || c !== y || d !== x) {
      let C = 1 - a
      const M = A * m + c * y + d * x + p * S,
        _ = M >= 0 ? 1 : -1,
        R = 1 - M * M
      if (R > Number.EPSILON) {
        const L = Math.sqrt(R),
          B = Math.atan2(L, M * _)
        ;(C = Math.sin(C * B) / L), (a = Math.sin(a * B) / L)
      }
      const T = a * _
      if (
        ((A = A * C + m * T),
        (c = c * C + y * T),
        (d = d * C + x * T),
        (p = p * C + S * T),
        C === 1 - a)
      ) {
        const L = 1 / Math.sqrt(A * A + c * c + d * d + p * p)
        ;(A *= L), (c *= L), (d *= L), (p *= L)
      }
    }
    ;(e[t] = A), (e[t + 1] = c), (e[t + 2] = d), (e[t + 3] = p)
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      A = i[r + 1],
      c = i[r + 2],
      d = i[r + 3],
      p = s[o],
      m = s[o + 1],
      y = s[o + 2],
      x = s[o + 3]
    return (
      (e[t] = a * x + d * p + A * y - c * m),
      (e[t + 1] = A * x + d * m + c * p - a * y),
      (e[t + 2] = c * x + d * y + a * m - A * p),
      (e[t + 3] = d * x - a * p - A * m - c * y),
      e
    )
  }
  get x() {
    return this._x
  }
  set x(e) {
    ;(this._x = e), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(e) {
    ;(this._y = e), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(e) {
    ;(this._z = e), this._onChangeCallback()
  }
  get w() {
    return this._w
  }
  set w(e) {
    ;(this._w = e), this._onChangeCallback()
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w)
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    )
  }
  setFromEuler(e, t) {
    if (!(e && e.isEuler))
      throw new Error(
        "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
      )
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      A = Math.sin,
      c = a(i / 2),
      d = a(r / 2),
      p = a(s / 2),
      m = A(i / 2),
      y = A(r / 2),
      x = A(s / 2)
    switch (o) {
      case "XYZ":
        ;(this._x = m * d * p + c * y * x),
          (this._y = c * y * p - m * d * x),
          (this._z = c * d * x + m * y * p),
          (this._w = c * d * p - m * y * x)
        break
      case "YXZ":
        ;(this._x = m * d * p + c * y * x),
          (this._y = c * y * p - m * d * x),
          (this._z = c * d * x - m * y * p),
          (this._w = c * d * p + m * y * x)
        break
      case "ZXY":
        ;(this._x = m * d * p - c * y * x),
          (this._y = c * y * p + m * d * x),
          (this._z = c * d * x + m * y * p),
          (this._w = c * d * p - m * y * x)
        break
      case "ZYX":
        ;(this._x = m * d * p - c * y * x),
          (this._y = c * y * p + m * d * x),
          (this._z = c * d * x - m * y * p),
          (this._w = c * d * p + m * y * x)
        break
      case "YZX":
        ;(this._x = m * d * p + c * y * x),
          (this._y = c * y * p + m * d * x),
          (this._z = c * d * x - m * y * p),
          (this._w = c * d * p - m * y * x)
        break
      case "XZY":
        ;(this._x = m * d * p - c * y * x),
          (this._y = c * y * p - m * d * x),
          (this._z = c * d * x + m * y * p),
          (this._w = c * d * p + m * y * x)
        break
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        )
    }
    return t !== !1 && this._onChangeCallback(), this
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i)
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      A = t[9],
      c = t[2],
      d = t[6],
      p = t[10],
      m = i + a + p
    if (m > 0) {
      const y = 0.5 / Math.sqrt(m + 1)
      ;(this._w = 0.25 / y),
        (this._x = (d - A) * y),
        (this._y = (s - c) * y),
        (this._z = (o - r) * y)
    } else if (i > a && i > p) {
      const y = 2 * Math.sqrt(1 + i - a - p)
      ;(this._w = (d - A) / y),
        (this._x = 0.25 * y),
        (this._y = (r + o) / y),
        (this._z = (s + c) / y)
    } else if (a > p) {
      const y = 2 * Math.sqrt(1 + a - i - p)
      ;(this._w = (s - c) / y),
        (this._x = (r + o) / y),
        (this._y = 0.25 * y),
        (this._z = (A + d) / y)
    } else {
      const y = 2 * Math.sqrt(1 + p - i - a)
      ;(this._w = (o - r) / y),
        (this._x = (s + c) / y),
        (this._y = (A + d) / y),
        (this._z = 0.25 * y)
    }
    return this._onChangeCallback(), this
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    )
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(li(this.dot(e), -1, 1)))
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e)
    if (i === 0) return this
    const r = Math.min(1, t / i)
    return this.slerp(e, r), this
  }
  identity() {
    return this.set(0, 0, 0, 1)
  }
  invert() {
    return this.conjugate()
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    )
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    )
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    )
  }
  normalize() {
    let e = this.length()
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    )
  }
  multiply(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
        ),
        this.multiplyQuaternions(e, t))
      : this.multiplyQuaternions(this, e)
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this)
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      A = t._y,
      c = t._z,
      d = t._w
    return (
      (this._x = i * d + o * a + r * c - s * A),
      (this._y = r * d + o * A + s * a - i * c),
      (this._z = s * d + o * c + i * A - r * a),
      (this._w = o * d - i * a - r * A - s * c),
      this._onChangeCallback(),
      this
    )
  }
  slerp(e, t) {
    if (t === 0) return this
    if (t === 1) return this.copy(e)
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w
    let a = o * e._w + i * e._x + r * e._y + s * e._z
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = i), (this._y = r), (this._z = s), this
    const A = 1 - a * a
    if (A <= Number.EPSILON) {
      const y = 1 - t
      return (
        (this._w = y * o + t * this._w),
        (this._x = y * i + t * this._x),
        (this._y = y * r + t * this._y),
        (this._z = y * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      )
    }
    const c = Math.sqrt(A),
      d = Math.atan2(c, a),
      p = Math.sin((1 - t) * d) / c,
      m = Math.sin(t * d) / c
    return (
      (this._w = o * p + this._w * m),
      (this._x = i * p + this._x * m),
      (this._y = r * p + this._y * m),
      (this._z = s * p + this._z * m),
      this._onChangeCallback(),
      this
    )
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i)
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      i = Math.sqrt(e),
      r = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random()
    return this.set(
      t * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(r)
    )
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    )
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    )
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    )
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this
  }
  _onChangeCallback() {}
}
Jn.prototype.isQuaternion = !0
class X {
  constructor(e = 0, t = 0, i = 0) {
    ;(this.x = e), (this.y = t), (this.z = i)
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    )
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this
  }
  setX(e) {
    return (this.x = e), this
  }
  setY(e) {
    return (this.y = e), this
  }
  setZ(e) {
    return (this.z = e), this
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t
        break
      case 1:
        this.y = t
        break
      case 2:
        this.z = t
        break
      default:
        throw new Error("index is out of range: " + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      default:
        throw new Error("index is out of range: " + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z)
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this
  }
  add(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
        ),
        this.addVectors(e, t))
      : ((this.x += e.x), (this.y += e.y), (this.z += e.z), this)
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    )
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
  }
  sub(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
        ),
        this.subVectors(e, t))
      : ((this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this)
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    )
  }
  multiply(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
        ),
        this.multiplyVectors(e, t))
      : ((this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this)
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    )
  }
  applyEuler(e) {
    return (
      (e && e.isEuler) ||
        console.error(
          "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
        ),
      this.applyQuaternion(a_.setFromEuler(e))
    )
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(a_.setFromAxisAngle(e, t))
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    )
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize()
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15])
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    )
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      A = e.w,
      c = A * t + o * r - a * i,
      d = A * i + a * t - s * r,
      p = A * r + s * i - o * t,
      m = -s * t - o * i - a * r
    return (
      (this.x = c * A + m * -s + d * -a - p * -o),
      (this.y = d * A + m * -o + p * -s - c * -a),
      (this.z = p * A + m * -a + c * -o - d * -s),
      this
    )
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    )
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    )
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    )
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    )
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    )
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    )
  }
  clampLength(e, t) {
    const i = this.length()
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    )
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    )
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    )
  }
  cross(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
        ),
        this.crossVectors(e, t))
      : this.crossVectors(this, e)
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      A = t.z
    return (
      (this.x = r * A - s * a),
      (this.y = s * o - i * A),
      (this.z = i * a - r * o),
      this
    )
  }
  projectOnVector(e) {
    const t = e.lengthSq()
    if (t === 0) return this.set(0, 0, 0)
    const i = e.dot(this) / t
    return this.copy(e).multiplyScalar(i)
  }
  projectOnPlane(e) {
    return Dp.copy(this).projectOnVector(e), this.sub(Dp)
  }
  reflect(e) {
    return this.sub(Dp.copy(e).multiplyScalar(2 * this.dot(e)))
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq())
    if (t === 0) return Math.PI / 2
    const i = this.dot(e) / t
    return Math.acos(li(i, -1, 1))
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e))
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z
    return t * t + i * i + r * r
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    )
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    )
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    )
  }
  setFromMatrixPosition(e) {
    const t = e.elements
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length()
    return (this.x = t), (this.y = i), (this.z = r), this
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4)
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3)
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e
  }
  fromBufferAttribute(e, t, i) {
    return (
      i !== void 0 &&
        console.warn(
          "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
        ),
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    )
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - e ** 2)
    return (
      (this.x = i * Math.cos(t)), (this.y = i * Math.sin(t)), (this.z = e), this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z
  }
}
X.prototype.isVector3 = !0
const Dp = new X(),
  a_ = new Jn()
class Ri {
  constructor(
    e = new X(1 / 0, 1 / 0, 1 / 0),
    t = new X(-1 / 0, -1 / 0, -1 / 0)
  ) {
    ;(this.min = e), (this.max = t)
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this
  }
  setFromArray(e) {
    let t = 1 / 0,
      i = 1 / 0,
      r = 1 / 0,
      s = -1 / 0,
      o = -1 / 0,
      a = -1 / 0
    for (let A = 0, c = e.length; A < c; A += 3) {
      const d = e[A],
        p = e[A + 1],
        m = e[A + 2]
      d < t && (t = d),
        p < i && (i = p),
        m < r && (r = m),
        d > s && (s = d),
        p > o && (o = p),
        m > a && (a = m)
    }
    return this.min.set(t, i, r), this.max.set(s, o, a), this
  }
  setFromBufferAttribute(e) {
    let t = 1 / 0,
      i = 1 / 0,
      r = 1 / 0,
      s = -1 / 0,
      o = -1 / 0,
      a = -1 / 0
    for (let A = 0, c = e.count; A < c; A++) {
      const d = e.getX(A),
        p = e.getY(A),
        m = e.getZ(A)
      d < t && (t = d),
        p < i && (i = p),
        m < r && (r = m),
        d > s && (s = d),
        p > o && (o = p),
        m > a && (a = m)
    }
    return this.min.set(t, i, r), this.max.set(s, o, a), this
  }
  setFromPoints(e) {
    this.makeEmpty()
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t])
    return this
  }
  setFromCenterAndSize(e, t) {
    const i = ra.copy(t).multiplyScalar(0.5)
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    )
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    )
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1)
    const i = e.geometry
    if (i !== void 0)
      if (t && i.attributes != null && i.attributes.position !== void 0) {
        const s = i.attributes.position
        for (let o = 0, a = s.count; o < a; o++)
          ra.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
            this.expandByPoint(ra)
      } else
        i.boundingBox === null && i.computeBoundingBox(),
          Ip.copy(i.boundingBox),
          Ip.applyMatrix4(e.matrixWorld),
          this.union(Ip)
    const r = e.children
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t)
    return this
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    )
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    )
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    )
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    )
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, ra),
      ra.distanceToSquared(e.center) <= e.radius * e.radius
    )
  }
  intersectsPlane(e) {
    let t, i
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    )
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1
    this.getCenter(nA),
      wf.subVectors(this.max, nA),
      hl.subVectors(e.a, nA),
      dl.subVectors(e.b, nA),
      pl.subVectors(e.c, nA),
      lo.subVectors(dl, hl),
      co.subVectors(pl, dl),
      sa.subVectors(hl, pl)
    let t = [
      0,
      -lo.z,
      lo.y,
      0,
      -co.z,
      co.y,
      0,
      -sa.z,
      sa.y,
      lo.z,
      0,
      -lo.x,
      co.z,
      0,
      -co.x,
      sa.z,
      0,
      -sa.x,
      -lo.y,
      lo.x,
      0,
      -co.y,
      co.x,
      0,
      -sa.y,
      sa.x,
      0,
    ]
    return !Bp(t, hl, dl, pl, wf) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Bp(t, hl, dl, pl, wf))
      ? !1
      : (Mf.crossVectors(lo, co),
        (t = [Mf.x, Mf.y, Mf.z]),
        Bp(t, hl, dl, pl, wf))
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max)
  }
  distanceToPoint(e) {
    return ra.copy(e).clamp(this.min, this.max).sub(e).length()
  }
  getBoundingSphere(e) {
    return (
      this.getCenter(e.center), (e.radius = this.getSize(ra).length() * 0.5), e
    )
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    )
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (gs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        gs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        gs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        gs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        gs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        gs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        gs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        gs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(gs),
        this)
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max)
  }
}
Ri.prototype.isBox3 = !0
const gs = [
    new X(),
    new X(),
    new X(),
    new X(),
    new X(),
    new X(),
    new X(),
    new X(),
  ],
  ra = new X(),
  Ip = new Ri(),
  hl = new X(),
  dl = new X(),
  pl = new X(),
  lo = new X(),
  co = new X(),
  sa = new X(),
  nA = new X(),
  wf = new X(),
  Mf = new X(),
  oa = new X()
function Bp(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    oa.fromArray(n, s)
    const a =
        r.x * Math.abs(oa.x) + r.y * Math.abs(oa.y) + r.z * Math.abs(oa.z),
      A = e.dot(oa),
      c = t.dot(oa),
      d = i.dot(oa)
    if (Math.max(-Math.max(A, c, d), Math.min(A, c, d)) > a) return !1
  }
  return !0
}
const JP = new Ri(),
  l_ = new X(),
  Sf = new X(),
  kp = new X()
class ds {
  constructor(e = new X(), t = -1) {
    ;(this.center = e), (this.radius = t)
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this
  }
  setFromPoints(e, t) {
    const i = this.center
    t !== void 0 ? i.copy(t) : JP.setFromPoints(e).getCenter(i)
    let r = 0
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]))
    return (this.radius = Math.sqrt(r)), this
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this
  }
  isEmpty() {
    return this.radius < 0
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius
    return e.center.distanceToSquared(this.center) <= t * t
  }
  intersectsBox(e) {
    return e.intersectsSphere(this)
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e)
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    )
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    )
  }
  translate(e) {
    return this.center.add(e), this
  }
  expandByPoint(e) {
    kp.subVectors(e, this.center)
    const t = kp.lengthSq()
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5
      this.center.add(kp.multiplyScalar(r / i)), (this.radius += r)
    }
    return this
  }
  union(e) {
    return (
      this.center.equals(e.center) === !0
        ? Sf.set(0, 0, 1).multiplyScalar(e.radius)
        : Sf.subVectors(e.center, this.center)
            .normalize()
            .multiplyScalar(e.radius),
      this.expandByPoint(l_.copy(e.center).add(Sf)),
      this.expandByPoint(l_.copy(e.center).sub(Sf)),
      this
    )
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const ys = new X(),
  Op = new X(),
  Ef = new X(),
  Ao = new X(),
  qp = new X(),
  Tf = new X(),
  Fp = new X()
class Wo {
  constructor(e = new X(), t = new X(0, 0, -1)) {
    ;(this.origin = e), (this.direction = t)
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
  }
  at(e, t) {
    return t.copy(this.direction).multiplyScalar(e).add(this.origin)
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this
  }
  recast(e) {
    return this.origin.copy(this.at(e, ys)), this
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin)
    const i = t.dot(this.direction)
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.direction).multiplyScalar(i).add(this.origin)
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e))
  }
  distanceSqToPoint(e) {
    const t = ys.subVectors(e, this.origin).dot(this.direction)
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (ys.copy(this.direction).multiplyScalar(t).add(this.origin),
        ys.distanceToSquared(e))
  }
  distanceSqToSegment(e, t, i, r) {
    Op.copy(e).add(t).multiplyScalar(0.5),
      Ef.copy(t).sub(e).normalize(),
      Ao.copy(this.origin).sub(Op)
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(Ef),
      a = Ao.dot(this.direction),
      A = -Ao.dot(Ef),
      c = Ao.lengthSq(),
      d = Math.abs(1 - o * o)
    let p, m, y, x
    if (d > 0)
      if (((p = o * A - a), (m = o * a - A), (x = s * d), p >= 0))
        if (m >= -x)
          if (m <= x) {
            const S = 1 / d
            ;(p *= S),
              (m *= S),
              (y = p * (p + o * m + 2 * a) + m * (o * p + m + 2 * A) + c)
          } else
            (m = s),
              (p = Math.max(0, -(o * m + a))),
              (y = -p * p + m * (m + 2 * A) + c)
        else
          (m = -s),
            (p = Math.max(0, -(o * m + a))),
            (y = -p * p + m * (m + 2 * A) + c)
      else
        m <= -x
          ? ((p = Math.max(0, -(-o * s + a))),
            (m = p > 0 ? -s : Math.min(Math.max(-s, -A), s)),
            (y = -p * p + m * (m + 2 * A) + c))
          : m <= x
          ? ((p = 0),
            (m = Math.min(Math.max(-s, -A), s)),
            (y = m * (m + 2 * A) + c))
          : ((p = Math.max(0, -(o * s + a))),
            (m = p > 0 ? s : Math.min(Math.max(-s, -A), s)),
            (y = -p * p + m * (m + 2 * A) + c))
    else
      (m = o > 0 ? -s : s),
        (p = Math.max(0, -(o * m + a))),
        (y = -p * p + m * (m + 2 * A) + c)
    return (
      i && i.copy(this.direction).multiplyScalar(p).add(this.origin),
      r && r.copy(Ef).multiplyScalar(m).add(Op),
      y
    )
  }
  intersectSphere(e, t) {
    ys.subVectors(e.center, this.origin)
    const i = ys.dot(this.direction),
      r = ys.dot(ys) - i * i,
      s = e.radius * e.radius
    if (r > s) return null
    const o = Math.sqrt(s - r),
      a = i - o,
      A = i + o
    return a < 0 && A < 0 ? null : a < 0 ? this.at(A, t) : this.at(a, t)
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction)
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null
    const i = -(this.origin.dot(e.normal) + e.constant) / t
    return i >= 0 ? i : null
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e)
    return i === null ? null : this.at(i, t)
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin)
    return t === 0 || e.normal.dot(this.direction) * t < 0
  }
  intersectBox(e, t) {
    let i, r, s, o, a, A
    const c = 1 / this.direction.x,
      d = 1 / this.direction.y,
      p = 1 / this.direction.z,
      m = this.origin
    return (
      c >= 0
        ? ((i = (e.min.x - m.x) * c), (r = (e.max.x - m.x) * c))
        : ((i = (e.max.x - m.x) * c), (r = (e.min.x - m.x) * c)),
      d >= 0
        ? ((s = (e.min.y - m.y) * d), (o = (e.max.y - m.y) * d))
        : ((s = (e.max.y - m.y) * d), (o = (e.min.y - m.y) * d)),
      i > o ||
      s > r ||
      ((s > i || i !== i) && (i = s),
      (o < r || r !== r) && (r = o),
      p >= 0
        ? ((a = (e.min.z - m.z) * p), (A = (e.max.z - m.z) * p))
        : ((a = (e.max.z - m.z) * p), (A = (e.min.z - m.z) * p)),
      i > A || a > r) ||
      ((a > i || i !== i) && (i = a), (A < r || r !== r) && (r = A), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    )
  }
  intersectsBox(e) {
    return this.intersectBox(e, ys) !== null
  }
  intersectTriangle(e, t, i, r, s) {
    qp.subVectors(t, e), Tf.subVectors(i, e), Fp.crossVectors(qp, Tf)
    let o = this.direction.dot(Fp),
      a
    if (o > 0) {
      if (r) return null
      a = 1
    } else if (o < 0) (a = -1), (o = -o)
    else return null
    Ao.subVectors(this.origin, e)
    const A = a * this.direction.dot(Tf.crossVectors(Ao, Tf))
    if (A < 0) return null
    const c = a * this.direction.dot(qp.cross(Ao))
    if (c < 0 || A + c > o) return null
    const d = -a * Ao.dot(Fp)
    return d < 0 ? null : this.at(d / o, s)
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    )
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class mt {
  constructor() {
    ;(this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      arguments.length > 0 &&
        console.error(
          "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
        )
  }
  set(e, t, i, r, s, o, a, A, c, d, p, m, y, x, S, C) {
    const M = this.elements
    return (
      (M[0] = e),
      (M[4] = t),
      (M[8] = i),
      (M[12] = r),
      (M[1] = s),
      (M[5] = o),
      (M[9] = a),
      (M[13] = A),
      (M[2] = c),
      (M[6] = d),
      (M[10] = p),
      (M[14] = m),
      (M[3] = y),
      (M[7] = x),
      (M[11] = S),
      (M[15] = C),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  clone() {
    return new mt().fromArray(this.elements)
  }
  copy(e) {
    const t = this.elements,
      i = e.elements
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    )
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this
  }
  setFromMatrix3(e) {
    const t = e.elements
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    )
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / ml.setFromMatrixColumn(e, 0).length(),
      s = 1 / ml.setFromMatrixColumn(e, 1).length(),
      o = 1 / ml.setFromMatrixColumn(e, 2).length()
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    )
  }
  makeRotationFromEuler(e) {
    ;(e && e.isEuler) ||
      console.error(
        "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
      )
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      A = Math.cos(r),
      c = Math.sin(r),
      d = Math.cos(s),
      p = Math.sin(s)
    if (e.order === "XYZ") {
      const m = o * d,
        y = o * p,
        x = a * d,
        S = a * p
      ;(t[0] = A * d),
        (t[4] = -A * p),
        (t[8] = c),
        (t[1] = y + x * c),
        (t[5] = m - S * c),
        (t[9] = -a * A),
        (t[2] = S - m * c),
        (t[6] = x + y * c),
        (t[10] = o * A)
    } else if (e.order === "YXZ") {
      const m = A * d,
        y = A * p,
        x = c * d,
        S = c * p
      ;(t[0] = m + S * a),
        (t[4] = x * a - y),
        (t[8] = o * c),
        (t[1] = o * p),
        (t[5] = o * d),
        (t[9] = -a),
        (t[2] = y * a - x),
        (t[6] = S + m * a),
        (t[10] = o * A)
    } else if (e.order === "ZXY") {
      const m = A * d,
        y = A * p,
        x = c * d,
        S = c * p
      ;(t[0] = m - S * a),
        (t[4] = -o * p),
        (t[8] = x + y * a),
        (t[1] = y + x * a),
        (t[5] = o * d),
        (t[9] = S - m * a),
        (t[2] = -o * c),
        (t[6] = a),
        (t[10] = o * A)
    } else if (e.order === "ZYX") {
      const m = o * d,
        y = o * p,
        x = a * d,
        S = a * p
      ;(t[0] = A * d),
        (t[4] = x * c - y),
        (t[8] = m * c + S),
        (t[1] = A * p),
        (t[5] = S * c + m),
        (t[9] = y * c - x),
        (t[2] = -c),
        (t[6] = a * A),
        (t[10] = o * A)
    } else if (e.order === "YZX") {
      const m = o * A,
        y = o * c,
        x = a * A,
        S = a * c
      ;(t[0] = A * d),
        (t[4] = S - m * p),
        (t[8] = x * p + y),
        (t[1] = p),
        (t[5] = o * d),
        (t[9] = -a * d),
        (t[2] = -c * d),
        (t[6] = y * p + x),
        (t[10] = m - S * p)
    } else if (e.order === "XZY") {
      const m = o * A,
        y = o * c,
        x = a * A,
        S = a * c
      ;(t[0] = A * d),
        (t[4] = -p),
        (t[8] = c * d),
        (t[1] = m * p + S),
        (t[5] = o * d),
        (t[9] = y * p - x),
        (t[2] = x * p - y),
        (t[6] = a * d),
        (t[10] = S * p + m)
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    )
  }
  makeRotationFromQuaternion(e) {
    return this.compose(KP, e, eL)
  }
  lookAt(e, t, i) {
    const r = this.elements
    return (
      ji.subVectors(e, t),
      ji.lengthSq() === 0 && (ji.z = 1),
      ji.normalize(),
      uo.crossVectors(i, ji),
      uo.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (ji.x += 1e-4) : (ji.z += 1e-4),
        ji.normalize(),
        uo.crossVectors(i, ji)),
      uo.normalize(),
      Cf.crossVectors(ji, uo),
      (r[0] = uo.x),
      (r[4] = Cf.x),
      (r[8] = ji.x),
      (r[1] = uo.y),
      (r[5] = Cf.y),
      (r[9] = ji.y),
      (r[2] = uo.z),
      (r[6] = Cf.z),
      (r[10] = ji.z),
      this
    )
  }
  multiply(e, t) {
    return t !== void 0
      ? (console.warn(
          "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
        ),
        this.multiplyMatrices(e, t))
      : this.multiplyMatrices(this, e)
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this)
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      A = i[8],
      c = i[12],
      d = i[1],
      p = i[5],
      m = i[9],
      y = i[13],
      x = i[2],
      S = i[6],
      C = i[10],
      M = i[14],
      _ = i[3],
      R = i[7],
      T = i[11],
      L = i[15],
      B = r[0],
      k = r[4],
      O = r[8],
      W = r[12],
      z = r[1],
      P = r[5],
      N = r[9],
      G = r[13],
      j = r[2],
      V = r[6],
      Y = r[10],
      ne = r[14],
      le = r[3],
      Te = r[7],
      Ae = r[11],
      ge = r[15]
    return (
      (s[0] = o * B + a * z + A * j + c * le),
      (s[4] = o * k + a * P + A * V + c * Te),
      (s[8] = o * O + a * N + A * Y + c * Ae),
      (s[12] = o * W + a * G + A * ne + c * ge),
      (s[1] = d * B + p * z + m * j + y * le),
      (s[5] = d * k + p * P + m * V + y * Te),
      (s[9] = d * O + p * N + m * Y + y * Ae),
      (s[13] = d * W + p * G + m * ne + y * ge),
      (s[2] = x * B + S * z + C * j + M * le),
      (s[6] = x * k + S * P + C * V + M * Te),
      (s[10] = x * O + S * N + C * Y + M * Ae),
      (s[14] = x * W + S * G + C * ne + M * ge),
      (s[3] = _ * B + R * z + T * j + L * le),
      (s[7] = _ * k + R * P + T * V + L * Te),
      (s[11] = _ * O + R * N + T * Y + L * Ae),
      (s[15] = _ * W + R * G + T * ne + L * ge),
      this
    )
  }
  multiplyScalar(e) {
    const t = this.elements
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    )
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      A = e[9],
      c = e[13],
      d = e[2],
      p = e[6],
      m = e[10],
      y = e[14],
      x = e[3],
      S = e[7],
      C = e[11],
      M = e[15]
    return (
      x *
        (+s * A * p -
          r * c * p -
          s * a * m +
          i * c * m +
          r * a * y -
          i * A * y) +
      S *
        (+t * A * y -
          t * c * m +
          s * o * m -
          r * o * y +
          r * c * d -
          s * A * d) +
      C *
        (+t * c * p -
          t * a * y -
          s * o * p +
          i * o * y +
          s * a * d -
          i * c * d) +
      M *
        (-r * a * d - t * A * p + t * a * m + r * o * p - i * o * m + i * A * d)
    )
  }
  transpose() {
    const e = this.elements
    let t
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    )
  }
  setPosition(e, t, i) {
    const r = this.elements
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    )
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      A = e[6],
      c = e[7],
      d = e[8],
      p = e[9],
      m = e[10],
      y = e[11],
      x = e[12],
      S = e[13],
      C = e[14],
      M = e[15],
      _ = p * C * c - S * m * c + S * A * y - a * C * y - p * A * M + a * m * M,
      R = x * m * c - d * C * c - x * A * y + o * C * y + d * A * M - o * m * M,
      T = d * S * c - x * p * c + x * a * y - o * S * y - d * a * M + o * p * M,
      L = x * p * A - d * S * A - x * a * m + o * S * m + d * a * C - o * p * C,
      B = t * _ + i * R + r * T + s * L
    if (B === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    const k = 1 / B
    return (
      (e[0] = _ * k),
      (e[1] =
        (S * m * s -
          p * C * s -
          S * r * y +
          i * C * y +
          p * r * M -
          i * m * M) *
        k),
      (e[2] =
        (a * C * s -
          S * A * s +
          S * r * c -
          i * C * c -
          a * r * M +
          i * A * M) *
        k),
      (e[3] =
        (p * A * s -
          a * m * s -
          p * r * c +
          i * m * c +
          a * r * y -
          i * A * y) *
        k),
      (e[4] = R * k),
      (e[5] =
        (d * C * s -
          x * m * s +
          x * r * y -
          t * C * y -
          d * r * M +
          t * m * M) *
        k),
      (e[6] =
        (x * A * s -
          o * C * s -
          x * r * c +
          t * C * c +
          o * r * M -
          t * A * M) *
        k),
      (e[7] =
        (o * m * s -
          d * A * s +
          d * r * c -
          t * m * c -
          o * r * y +
          t * A * y) *
        k),
      (e[8] = T * k),
      (e[9] =
        (x * p * s -
          d * S * s -
          x * i * y +
          t * S * y +
          d * i * M -
          t * p * M) *
        k),
      (e[10] =
        (o * S * s -
          x * a * s +
          x * i * c -
          t * S * c -
          o * i * M +
          t * a * M) *
        k),
      (e[11] =
        (d * a * s -
          o * p * s -
          d * i * c +
          t * p * c +
          o * i * y -
          t * a * y) *
        k),
      (e[12] = L * k),
      (e[13] =
        (d * S * r -
          x * p * r +
          x * i * m -
          t * S * m -
          d * i * C +
          t * p * C) *
        k),
      (e[14] =
        (x * a * r -
          o * S * r -
          x * i * A +
          t * S * A +
          o * i * C -
          t * a * C) *
        k),
      (e[15] =
        (o * p * r -
          d * a * r +
          d * i * A -
          t * p * A -
          o * i * m +
          t * a * m) *
        k),
      this
    )
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    )
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]
    return Math.sqrt(Math.max(t, i, r))
  }
  makeTranslation(e, t, i) {
    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e)
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      A = e.z,
      c = s * o,
      d = s * a
    return (
      this.set(
        c * o + i,
        c * a - r * A,
        c * A + r * a,
        0,
        c * a + r * A,
        d * a + i,
        d * A - r * o,
        0,
        c * A - r * a,
        d * A + r * o,
        s * A * A + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      A = t._w,
      c = s + s,
      d = o + o,
      p = a + a,
      m = s * c,
      y = s * d,
      x = s * p,
      S = o * d,
      C = o * p,
      M = a * p,
      _ = A * c,
      R = A * d,
      T = A * p,
      L = i.x,
      B = i.y,
      k = i.z
    return (
      (r[0] = (1 - (S + M)) * L),
      (r[1] = (y + T) * L),
      (r[2] = (x - R) * L),
      (r[3] = 0),
      (r[4] = (y - T) * B),
      (r[5] = (1 - (m + M)) * B),
      (r[6] = (C + _) * B),
      (r[7] = 0),
      (r[8] = (x + R) * k),
      (r[9] = (C - _) * k),
      (r[10] = (1 - (m + S)) * k),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    )
  }
  decompose(e, t, i) {
    const r = this.elements
    let s = ml.set(r[0], r[1], r[2]).length()
    const o = ml.set(r[4], r[5], r[6]).length(),
      a = ml.set(r[8], r[9], r[10]).length()
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Pr.copy(this)
    const c = 1 / s,
      d = 1 / o,
      p = 1 / a
    return (
      (Pr.elements[0] *= c),
      (Pr.elements[1] *= c),
      (Pr.elements[2] *= c),
      (Pr.elements[4] *= d),
      (Pr.elements[5] *= d),
      (Pr.elements[6] *= d),
      (Pr.elements[8] *= p),
      (Pr.elements[9] *= p),
      (Pr.elements[10] *= p),
      t.setFromRotationMatrix(Pr),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    )
  }
  makePerspective(e, t, i, r, s, o) {
    o === void 0 &&
      console.warn(
        "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
      )
    const a = this.elements,
      A = (2 * s) / (t - e),
      c = (2 * s) / (i - r),
      d = (t + e) / (t - e),
      p = (i + r) / (i - r),
      m = -(o + s) / (o - s),
      y = (-2 * o * s) / (o - s)
    return (
      (a[0] = A),
      (a[4] = 0),
      (a[8] = d),
      (a[12] = 0),
      (a[1] = 0),
      (a[5] = c),
      (a[9] = p),
      (a[13] = 0),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = m),
      (a[14] = y),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = -1),
      (a[15] = 0),
      this
    )
  }
  makeOrthographic(e, t, i, r, s, o) {
    const a = this.elements,
      A = 1 / (t - e),
      c = 1 / (i - r),
      d = 1 / (o - s),
      p = (t + e) * A,
      m = (i + r) * c,
      y = (o + s) * d
    return (
      (a[0] = 2 * A),
      (a[4] = 0),
      (a[8] = 0),
      (a[12] = -p),
      (a[1] = 0),
      (a[5] = 2 * c),
      (a[9] = 0),
      (a[13] = -m),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = -2 * d),
      (a[14] = -y),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = 0),
      (a[15] = 1),
      this
    )
  }
  equals(e) {
    const t = this.elements,
      i = e.elements
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1
    return !0
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t]
    return this
  }
  toArray(e = [], t = 0) {
    const i = this.elements
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    )
  }
}
mt.prototype.isMatrix4 = !0
const ml = new X(),
  Pr = new mt(),
  KP = new X(0, 0, 0),
  eL = new X(1, 1, 1),
  uo = new X(),
  Cf = new X(),
  ji = new X(),
  c_ = new mt(),
  A_ = new Jn()
class jo {
  constructor(e = 0, t = 0, i = 0, r = jo.DefaultOrder) {
    ;(this._x = e), (this._y = t), (this._z = i), (this._order = r)
  }
  get x() {
    return this._x
  }
  set x(e) {
    ;(this._x = e), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(e) {
    ;(this._y = e), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(e) {
    ;(this._z = e), this._onChangeCallback()
  }
  get order() {
    return this._order
  }
  set order(e) {
    ;(this._order = e), this._onChangeCallback()
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order)
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      A = r[1],
      c = r[5],
      d = r[9],
      p = r[2],
      m = r[6],
      y = r[10]
    switch (t) {
      case "XYZ":
        ;(this._y = Math.asin(li(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-d, y)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(m, c)), (this._z = 0))
        break
      case "YXZ":
        ;(this._x = Math.asin(-li(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(a, y)), (this._z = Math.atan2(A, c)))
            : ((this._y = Math.atan2(-p, s)), (this._z = 0))
        break
      case "ZXY":
        ;(this._x = Math.asin(li(m, -1, 1))),
          Math.abs(m) < 0.9999999
            ? ((this._y = Math.atan2(-p, y)), (this._z = Math.atan2(-o, c)))
            : ((this._y = 0), (this._z = Math.atan2(A, s)))
        break
      case "ZYX":
        ;(this._y = Math.asin(-li(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._x = Math.atan2(m, y)), (this._z = Math.atan2(A, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, c)))
        break
      case "YZX":
        ;(this._z = Math.asin(li(A, -1, 1))),
          Math.abs(A) < 0.9999999
            ? ((this._x = Math.atan2(-d, c)), (this._y = Math.atan2(-p, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, y)))
        break
      case "XZY":
        ;(this._z = Math.asin(-li(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(m, c)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-d, y)), (this._y = 0))
        break
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        )
    }
    return (this._order = t), i === !0 && this._onChangeCallback(), this
  }
  setFromQuaternion(e, t, i) {
    return (
      c_.makeRotationFromQuaternion(e), this.setFromRotationMatrix(c_, t, i)
    )
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t)
  }
  reorder(e) {
    return A_.setFromEuler(this), this.setFromQuaternion(A_, e)
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    )
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    )
  }
  toVector3(e) {
    return e
      ? e.set(this._x, this._y, this._z)
      : new X(this._x, this._y, this._z)
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this
  }
  _onChangeCallback() {}
}
jo.prototype.isEuler = !0
jo.DefaultOrder = "XYZ"
jo.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]
class bd {
  constructor() {
    this.mask = 1
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0
  }
  enable(e) {
    this.mask |= (1 << e) | 0
  }
  enableAll() {
    this.mask = -1
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0)
  }
  disableAll() {
    this.mask = 0
  }
  test(e) {
    return (this.mask & e.mask) !== 0
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0
  }
}
let tL = 0
const u_ = new X(),
  gl = new Jn(),
  vs = new mt(),
  Rf = new X(),
  iA = new X(),
  nL = new X(),
  iL = new Jn(),
  f_ = new X(1, 0, 0),
  h_ = new X(0, 1, 0),
  d_ = new X(0, 0, 1),
  rL = { type: "added" },
  p_ = { type: "removed" }
class kt extends Ys {
  constructor() {
    super(),
      Object.defineProperty(this, "id", { value: tL++ }),
      (this.uuid = ir()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = kt.DefaultUp.clone())
    const e = new X(),
      t = new jo(),
      i = new Jn(),
      r = new X(1, 1, 1)
    function s() {
      i.setFromEuler(t, !1)
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1)
    }
    t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new mt() },
        normalMatrix: { value: new Zn() },
      }),
      (this.matrix = new mt()),
      (this.matrixWorld = new mt()),
      (this.matrixAutoUpdate = kt.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new bd()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {})
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale)
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t)
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0)
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e)
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e)
  }
  rotateOnAxis(e, t) {
    return gl.setFromAxisAngle(e, t), this.quaternion.multiply(gl), this
  }
  rotateOnWorldAxis(e, t) {
    return gl.setFromAxisAngle(e, t), this.quaternion.premultiply(gl), this
  }
  rotateX(e) {
    return this.rotateOnAxis(f_, e)
  }
  rotateY(e) {
    return this.rotateOnAxis(h_, e)
  }
  rotateZ(e) {
    return this.rotateOnAxis(d_, e)
  }
  translateOnAxis(e, t) {
    return (
      u_.copy(e).applyQuaternion(this.quaternion),
      this.position.add(u_.multiplyScalar(t)),
      this
    )
  }
  translateX(e) {
    return this.translateOnAxis(f_, e)
  }
  translateY(e) {
    return this.translateOnAxis(h_, e)
  }
  translateZ(e) {
    return this.translateOnAxis(d_, e)
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld)
  }
  worldToLocal(e) {
    return e.applyMatrix4(vs.copy(this.matrixWorld).invert())
  }
  lookAt(e, t, i) {
    e.isVector3 ? Rf.copy(e) : Rf.set(e, t, i)
    const r = this.parent
    this.updateWorldMatrix(!0, !1),
      iA.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? vs.lookAt(iA, Rf, this.up)
        : vs.lookAt(Rf, iA, this.up),
      this.quaternion.setFromRotationMatrix(vs),
      r &&
        (vs.extractRotation(r.matrixWorld),
        gl.setFromRotationMatrix(vs),
        this.quaternion.premultiply(gl.invert()))
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t])
      return this
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(rL))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this)
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i])
      return this
    }
    const t = this.children.indexOf(e)
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(p_)),
      this
    )
  }
  removeFromParent() {
    const e = this.parent
    return e !== null && e.remove(this), this
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e]
      ;(t.parent = null), t.dispatchEvent(p_)
    }
    return (this.children.length = 0), this
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      vs.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), vs.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(vs),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    )
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e)
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e)
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t)
      if (o !== void 0) return o
    }
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    )
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(iA, e, nL), e
    )
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(iA, iL, e), e
    )
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1)
    const t = this.matrixWorld.elements
    return e.set(t[8], t[9], t[10]).normalize()
  }
  raycast() {}
  traverse(e) {
    e(this)
    const t = this.children
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e)
  }
  traverseVisible(e) {
    if (this.visible === !1) return
    e(this)
    const t = this.children
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e)
  }
  traverseAncestors(e) {
    const t = this.parent
    t !== null && (e(t), t.traverseAncestors(e))
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0)
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0))
    const t = this.children
    for (let i = 0, r = t.length; i < r; i++) t[i].updateMatrixWorld(e)
  }
  updateWorldMatrix(e, t) {
    const i = this.parent
    if (
      (e === !0 && i !== null && i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const r = this.children
      for (let s = 0, o = r.length; s < o; s++) r[s].updateWorldMatrix(!1, !0)
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {}
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
      }),
      (i.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }))
    const r = {}
    ;(r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON()))
    function s(a, A) {
      return a[A.uuid] === void 0 && (a[A.uuid] = A.toJSON(e)), A.uuid
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          (r.environment = this.environment.toJSON(e).uuid)
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry)
      const a = this.geometry.parameters
      if (a !== void 0 && a.shapes !== void 0) {
        const A = a.shapes
        if (Array.isArray(A))
          for (let c = 0, d = A.length; c < d; c++) {
            const p = A[c]
            s(e.shapes, p)
          }
        else s(e.shapes, A)
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = []
        for (let A = 0, c = this.material.length; A < c; A++)
          a.push(s(e.materials, this.material[A]))
        r.material = a
      } else r.material = s(e.materials, this.material)
    if (this.children.length > 0) {
      r.children = []
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object)
    }
    if (this.animations.length > 0) {
      r.animations = []
      for (let a = 0; a < this.animations.length; a++) {
        const A = this.animations[a]
        r.animations.push(s(e.animations, A))
      }
    }
    if (t) {
      const a = o(e.geometries),
        A = o(e.materials),
        c = o(e.textures),
        d = o(e.images),
        p = o(e.shapes),
        m = o(e.skeletons),
        y = o(e.animations)
      a.length > 0 && (i.geometries = a),
        A.length > 0 && (i.materials = A),
        c.length > 0 && (i.textures = c),
        d.length > 0 && (i.images = d),
        p.length > 0 && (i.shapes = p),
        m.length > 0 && (i.skeletons = m),
        y.length > 0 && (i.animations = y)
    }
    return (i.object = r), i
    function o(a) {
      const A = []
      for (const c in a) {
        const d = a[c]
        delete d.metadata, A.push(d)
      }
      return A
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e)
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i]
        this.add(r.clone())
      }
    return this
  }
}
kt.DefaultUp = new X(0, 1, 0)
kt.DefaultMatrixAutoUpdate = !0
kt.prototype.isObject3D = !0
const Lr = new X(),
  _s = new X(),
  Np = new X(),
  xs = new X(),
  yl = new X(),
  vl = new X(),
  m_ = new X(),
  Up = new X(),
  zp = new X(),
  Hp = new X()
class qn {
  constructor(e = new X(), t = new X(), i = new X()) {
    ;(this.a = e), (this.b = t), (this.c = i)
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), Lr.subVectors(e, t), r.cross(Lr)
    const s = r.lengthSq()
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0)
  }
  static getBarycoord(e, t, i, r, s) {
    Lr.subVectors(r, t), _s.subVectors(i, t), Np.subVectors(e, t)
    const o = Lr.dot(Lr),
      a = Lr.dot(_s),
      A = Lr.dot(Np),
      c = _s.dot(_s),
      d = _s.dot(Np),
      p = o * c - a * a
    if (p === 0) return s.set(-2, -1, -1)
    const m = 1 / p,
      y = (c * A - a * d) * m,
      x = (o * d - a * A) * m
    return s.set(1 - y - x, x, y)
  }
  static containsPoint(e, t, i, r) {
    return (
      this.getBarycoord(e, t, i, r, xs),
      xs.x >= 0 && xs.y >= 0 && xs.x + xs.y <= 1
    )
  }
  static getUV(e, t, i, r, s, o, a, A) {
    return (
      this.getBarycoord(e, t, i, r, xs),
      A.set(0, 0),
      A.addScaledVector(s, xs.x),
      A.addScaledVector(o, xs.y),
      A.addScaledVector(a, xs.z),
      A
    )
  }
  static isFrontFacing(e, t, i, r) {
    return Lr.subVectors(i, t), _s.subVectors(e, t), Lr.cross(_s).dot(r) < 0
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
  }
  getArea() {
    return (
      Lr.subVectors(this.c, this.b),
      _s.subVectors(this.a, this.b),
      Lr.cross(_s).length() * 0.5
    )
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3)
  }
  getNormal(e) {
    return qn.getNormal(this.a, this.b, this.c, e)
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c)
  }
  getBarycoord(e, t) {
    return qn.getBarycoord(e, this.a, this.b, this.c, t)
  }
  getUV(e, t, i, r, s) {
    return qn.getUV(e, this.a, this.b, this.c, t, i, r, s)
  }
  containsPoint(e) {
    return qn.containsPoint(e, this.a, this.b, this.c)
  }
  isFrontFacing(e) {
    return qn.isFrontFacing(this.a, this.b, this.c, e)
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this)
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c
    let o, a
    yl.subVectors(r, i), vl.subVectors(s, i), Up.subVectors(e, i)
    const A = yl.dot(Up),
      c = vl.dot(Up)
    if (A <= 0 && c <= 0) return t.copy(i)
    zp.subVectors(e, r)
    const d = yl.dot(zp),
      p = vl.dot(zp)
    if (d >= 0 && p <= d) return t.copy(r)
    const m = A * p - d * c
    if (m <= 0 && A >= 0 && d <= 0)
      return (o = A / (A - d)), t.copy(i).addScaledVector(yl, o)
    Hp.subVectors(e, s)
    const y = yl.dot(Hp),
      x = vl.dot(Hp)
    if (x >= 0 && y <= x) return t.copy(s)
    const S = y * c - A * x
    if (S <= 0 && c >= 0 && x <= 0)
      return (a = c / (c - x)), t.copy(i).addScaledVector(vl, a)
    const C = d * x - y * p
    if (C <= 0 && p - d >= 0 && y - x >= 0)
      return (
        m_.subVectors(s, r),
        (a = (p - d) / (p - d + (y - x))),
        t.copy(r).addScaledVector(m_, a)
      )
    const M = 1 / (C + S + m)
    return (
      (o = S * M),
      (a = m * M),
      t.copy(i).addScaledVector(yl, o).addScaledVector(vl, a)
    )
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
  }
}
let sL = 0
class ii extends Ys {
  constructor() {
    super(),
      Object.defineProperty(this, "id", { value: sL++ }),
      (this.uuid = ir()),
      (this.name = ""),
      (this.type = "Material"),
      (this.fog = !0),
      (this.blending = Ro),
      (this.side = Na),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = Kg),
      (this.blendDst = e2),
      (this.blendEquation = va),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = m0),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = v5),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = jh),
      (this.stencilZFail = jh),
      (this.stencilZPass = jh),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0)
  }
  get alphaTest() {
    return this._alphaTest
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e)
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString()
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t]
        if (i === void 0) {
          console.warn("THREE.Material: '" + t + "' parameter is undefined.")
          continue
        }
        if (t === "shading") {
          console.warn(
            "THREE." +
              this.type +
              ": .shading has been removed. Use the boolean .flatShading instead."
          ),
            (this.flatShading = i === Jg)
          continue
        }
        const r = this[t]
        if (r === void 0) {
          console.warn(
            "THREE." +
              this.type +
              ": '" +
              t +
              "' is not a property of this material."
          )
          continue
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
          ? r.copy(i)
          : (this[t] = i)
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string"
    t && (e = { textures: {}, images: {} })
    const i = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    }
    ;(i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Ro && (i.blending = this.blending),
      this.side !== Na && (i.side = this.side),
      this.vertexColors && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = this.transparent),
      (i.depthFunc = this.depthFunc),
      (i.depthTest = this.depthTest),
      (i.depthWrite = this.depthWrite),
      (i.colorWrite = this.colorWrite),
      (i.stencilWrite = this.stencilWrite),
      (i.stencilWriteMask = this.stencilWriteMask),
      (i.stencilFunc = this.stencilFunc),
      (i.stencilRef = this.stencilRef),
      (i.stencilFuncMask = this.stencilFuncMask),
      (i.stencilFail = this.stencilFail),
      (i.stencilZFail = this.stencilZFail),
      (i.stencilZPass = this.stencilZPass),
      this.rotation && this.rotation !== 0 && (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth && this.linewidth !== 1 && (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (i.premultipliedAlpha = this.premultipliedAlpha),
      this.wireframe === !0 && (i.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = this.flatShading),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData)
    function r(s) {
      const o = []
      for (const a in s) {
        const A = s[a]
        delete A.metadata, o.push(A)
      }
      return o
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images)
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o)
    }
    return i
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;(this.name = e.name),
      (this.fog = e.fog),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite)
    const t = e.clippingPlanes
    let i = null
    if (t !== null) {
      const r = t.length
      i = new Array(r)
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone()
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" })
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
}
ii.prototype.isMaterial = !0
class Mr extends ii {
  constructor(e) {
    super(),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = ku),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      this
    )
  }
}
Mr.prototype.isMeshBasicMaterial = !0
const dn = new X(),
  Pf = new qe()
class Bt {
  constructor(e, t, i) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      )
    ;(this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i === !0),
      (this.usage = gc),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0)
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setUsage(e) {
    return (this.usage = e), this
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      this
    )
  }
  copyAt(e, t, i) {
    ;(e *= this.itemSize), (i *= t.itemSize)
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r]
    return this
  }
  copyArray(e) {
    return this.array.set(e), this
  }
  copyColorsArray(e) {
    const t = this.array
    let i = 0
    for (let r = 0, s = e.length; r < s; r++) {
      let o = e[r]
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyColorsArray(): color is undefined",
          r
        ),
        (o = new Ke())),
        (t[i++] = o.r),
        (t[i++] = o.g),
        (t[i++] = o.b)
    }
    return this
  }
  copyVector2sArray(e) {
    const t = this.array
    let i = 0
    for (let r = 0, s = e.length; r < s; r++) {
      let o = e[r]
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
          r
        ),
        (o = new qe())),
        (t[i++] = o.x),
        (t[i++] = o.y)
    }
    return this
  }
  copyVector3sArray(e) {
    const t = this.array
    let i = 0
    for (let r = 0, s = e.length; r < s; r++) {
      let o = e[r]
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
          r
        ),
        (o = new X())),
        (t[i++] = o.x),
        (t[i++] = o.y),
        (t[i++] = o.z)
    }
    return this
  }
  copyVector4sArray(e) {
    const t = this.array
    let i = 0
    for (let r = 0, s = e.length; r < s; r++) {
      let o = e[r]
      o === void 0 &&
        (console.warn(
          "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
          r
        ),
        (o = new en())),
        (t[i++] = o.x),
        (t[i++] = o.y),
        (t[i++] = o.z),
        (t[i++] = o.w)
    }
    return this
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        Pf.fromBufferAttribute(this, t),
          Pf.applyMatrix3(e),
          this.setXY(t, Pf.x, Pf.y)
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        dn.fromBufferAttribute(this, t),
          dn.applyMatrix3(e),
          this.setXYZ(t, dn.x, dn.y, dn.z)
    return this
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (dn.x = this.getX(t)),
        (dn.y = this.getY(t)),
        (dn.z = this.getZ(t)),
        dn.applyMatrix4(e),
        this.setXYZ(t, dn.x, dn.y, dn.z)
    return this
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (dn.x = this.getX(t)),
        (dn.y = this.getY(t)),
        (dn.z = this.getZ(t)),
        dn.applyNormalMatrix(e),
        this.setXYZ(t, dn.x, dn.y, dn.z)
    return this
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (dn.x = this.getX(t)),
        (dn.y = this.getY(t)),
        (dn.z = this.getZ(t)),
        dn.transformDirection(e),
        this.setXYZ(t, dn.x, dn.y, dn.z)
    return this
  }
  set(e, t = 0) {
    return this.array.set(e, t), this
  }
  getX(e) {
    return this.array[e * this.itemSize]
  }
  setX(e, t) {
    return (this.array[e * this.itemSize] = t), this
  }
  getY(e) {
    return this.array[e * this.itemSize + 1]
  }
  setY(e, t) {
    return (this.array[e * this.itemSize + 1] = t), this
  }
  getZ(e) {
    return this.array[e * this.itemSize + 2]
  }
  setZ(e, t) {
    return (this.array[e * this.itemSize + 2] = t), this
  }
  getW(e) {
    return this.array[e * this.itemSize + 3]
  }
  setW(e, t) {
    return (this.array[e * this.itemSize + 3] = t), this
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    )
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    )
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    )
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this)
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.prototype.slice.call(this.array),
      normalized: this.normalized,
    }
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== gc && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    )
  }
}
Bt.prototype.isBufferAttribute = !0
class S5 extends Bt {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i)
  }
}
class E5 extends Bt {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i)
  }
}
class T5 extends Bt {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i)
  }
}
class C5 extends Bt {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i)
  }
}
class wd extends Bt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i)
  }
}
class R5 extends Bt {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i)
  }
}
class Md extends Bt {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i)
  }
}
class P5 extends Bt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i)
  }
}
P5.prototype.isFloat16BufferAttribute = !0
class ut extends Bt {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i)
  }
}
class L5 extends Bt {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i)
  }
}
let oL = 0
const hr = new mt(),
  Gp = new kt(),
  _l = new X(),
  $i = new Ri(),
  rA = new Ri(),
  Kn = new X()
class yt extends Ys {
  constructor() {
    super(),
      Object.defineProperty(this, "id", { value: oL++ }),
      (this.uuid = ir()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {})
  }
  getIndex() {
    return this.index
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (b5(e) ? Md : wd)(e, 1))
        : (this.index = e),
      this
    )
  }
  getAttribute(e) {
    return this.attributes[e]
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i })
  }
  clearGroups() {
    this.groups = []
  }
  setDrawRange(e, t) {
    ;(this.drawRange.start = e), (this.drawRange.count = t)
  }
  applyMatrix4(e) {
    const t = this.attributes.position
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0))
    const i = this.attributes.normal
    if (i !== void 0) {
      const s = new Zn().getNormalMatrix(e)
      i.applyNormalMatrix(s), (i.needsUpdate = !0)
    }
    const r = this.attributes.tangent
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    )
  }
  applyQuaternion(e) {
    return hr.makeRotationFromQuaternion(e), this.applyMatrix4(hr), this
  }
  rotateX(e) {
    return hr.makeRotationX(e), this.applyMatrix4(hr), this
  }
  rotateY(e) {
    return hr.makeRotationY(e), this.applyMatrix4(hr), this
  }
  rotateZ(e) {
    return hr.makeRotationZ(e), this.applyMatrix4(hr), this
  }
  translate(e, t, i) {
    return hr.makeTranslation(e, t, i), this.applyMatrix4(hr), this
  }
  scale(e, t, i) {
    return hr.makeScale(e, t, i), this.applyMatrix4(hr), this
  }
  lookAt(e) {
    return Gp.lookAt(e), Gp.updateMatrix(), this.applyMatrix4(Gp.matrix), this
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(_l).negate(),
      this.translate(_l.x, _l.y, _l.z),
      this
    )
  }
  setFromPoints(e) {
    const t = []
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i]
      t.push(s.x, s.y, s.z || 0)
    }
    return this.setAttribute("position", new ut(t, 3)), this
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Ri())
    const e = this.attributes.position,
      t = this.morphAttributes.position
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new X(-1 / 0, -1 / 0, -1 / 0),
          new X(1 / 0, 1 / 0, 1 / 0)
        )
      return
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i]
          $i.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Kn.addVectors(this.boundingBox.min, $i.min),
                this.boundingBox.expandByPoint(Kn),
                Kn.addVectors(this.boundingBox.max, $i.max),
                this.boundingBox.expandByPoint(Kn))
              : (this.boundingBox.expandByPoint($i.min),
                this.boundingBox.expandByPoint($i.max))
        }
    } else this.boundingBox.makeEmpty()
    ;(isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      )
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new ds())
    const e = this.attributes.position,
      t = this.morphAttributes.position
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new X(), 1 / 0)
      return
    }
    if (e) {
      const i = this.boundingSphere.center
      if (($i.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s]
          rA.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Kn.addVectors($i.min, rA.min),
                $i.expandByPoint(Kn),
                Kn.addVectors($i.max, rA.max),
                $i.expandByPoint(Kn))
              : ($i.expandByPoint(rA.min), $i.expandByPoint(rA.max))
        }
      $i.getCenter(i)
      let r = 0
      for (let s = 0, o = e.count; s < o; s++)
        Kn.fromBufferAttribute(e, s), (r = Math.max(r, i.distanceToSquared(Kn)))
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            A = this.morphTargetsRelative
          for (let c = 0, d = a.count; c < d; c++)
            Kn.fromBufferAttribute(a, c),
              A && (_l.fromBufferAttribute(e, c), Kn.add(_l)),
              (r = Math.max(r, i.distanceToSquared(Kn)))
        }
      ;(this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          )
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      )
      return
    }
    const i = e.array,
      r = t.position.array,
      s = t.normal.array,
      o = t.uv.array,
      a = r.length / 3
    t.tangent === void 0 &&
      this.setAttribute("tangent", new Bt(new Float32Array(4 * a), 4))
    const A = t.tangent.array,
      c = [],
      d = []
    for (let z = 0; z < a; z++) (c[z] = new X()), (d[z] = new X())
    const p = new X(),
      m = new X(),
      y = new X(),
      x = new qe(),
      S = new qe(),
      C = new qe(),
      M = new X(),
      _ = new X()
    function R(z, P, N) {
      p.fromArray(r, z * 3),
        m.fromArray(r, P * 3),
        y.fromArray(r, N * 3),
        x.fromArray(o, z * 2),
        S.fromArray(o, P * 2),
        C.fromArray(o, N * 2),
        m.sub(p),
        y.sub(p),
        S.sub(x),
        C.sub(x)
      const G = 1 / (S.x * C.y - C.x * S.y)
      !isFinite(G) ||
        (M.copy(m)
          .multiplyScalar(C.y)
          .addScaledVector(y, -S.y)
          .multiplyScalar(G),
        _.copy(y)
          .multiplyScalar(S.x)
          .addScaledVector(m, -C.x)
          .multiplyScalar(G),
        c[z].add(M),
        c[P].add(M),
        c[N].add(M),
        d[z].add(_),
        d[P].add(_),
        d[N].add(_))
    }
    let T = this.groups
    T.length === 0 && (T = [{ start: 0, count: i.length }])
    for (let z = 0, P = T.length; z < P; ++z) {
      const N = T[z],
        G = N.start,
        j = N.count
      for (let V = G, Y = G + j; V < Y; V += 3) R(i[V + 0], i[V + 1], i[V + 2])
    }
    const L = new X(),
      B = new X(),
      k = new X(),
      O = new X()
    function W(z) {
      k.fromArray(s, z * 3), O.copy(k)
      const P = c[z]
      L.copy(P),
        L.sub(k.multiplyScalar(k.dot(P))).normalize(),
        B.crossVectors(O, P)
      const G = B.dot(d[z]) < 0 ? -1 : 1
      ;(A[z * 4] = L.x),
        (A[z * 4 + 1] = L.y),
        (A[z * 4 + 2] = L.z),
        (A[z * 4 + 3] = G)
    }
    for (let z = 0, P = T.length; z < P; ++z) {
      const N = T[z],
        G = N.start,
        j = N.count
      for (let V = G, Y = G + j; V < Y; V += 3)
        W(i[V + 0]), W(i[V + 1]), W(i[V + 2])
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position")
    if (t !== void 0) {
      let i = this.getAttribute("normal")
      if (i === void 0)
        (i = new Bt(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i)
      else for (let m = 0, y = i.count; m < y; m++) i.setXYZ(m, 0, 0, 0)
      const r = new X(),
        s = new X(),
        o = new X(),
        a = new X(),
        A = new X(),
        c = new X(),
        d = new X(),
        p = new X()
      if (e)
        for (let m = 0, y = e.count; m < y; m += 3) {
          const x = e.getX(m + 0),
            S = e.getX(m + 1),
            C = e.getX(m + 2)
          r.fromBufferAttribute(t, x),
            s.fromBufferAttribute(t, S),
            o.fromBufferAttribute(t, C),
            d.subVectors(o, s),
            p.subVectors(r, s),
            d.cross(p),
            a.fromBufferAttribute(i, x),
            A.fromBufferAttribute(i, S),
            c.fromBufferAttribute(i, C),
            a.add(d),
            A.add(d),
            c.add(d),
            i.setXYZ(x, a.x, a.y, a.z),
            i.setXYZ(S, A.x, A.y, A.z),
            i.setXYZ(C, c.x, c.y, c.z)
        }
      else
        for (let m = 0, y = t.count; m < y; m += 3)
          r.fromBufferAttribute(t, m + 0),
            s.fromBufferAttribute(t, m + 1),
            o.fromBufferAttribute(t, m + 2),
            d.subVectors(o, s),
            p.subVectors(r, s),
            d.cross(p),
            i.setXYZ(m + 0, d.x, d.y, d.z),
            i.setXYZ(m + 1, d.x, d.y, d.z),
            i.setXYZ(m + 2, d.x, d.y, d.z)
      this.normalizeNormals(), (i.needsUpdate = !0)
    }
  }
  merge(e, t) {
    if (!(e && e.isBufferGeometry)) {
      console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
        e
      )
      return
    }
    t === void 0 &&
      ((t = 0),
      console.warn(
        "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
      ))
    const i = this.attributes
    for (const r in i) {
      if (e.attributes[r] === void 0) continue
      const o = i[r].array,
        a = e.attributes[r],
        A = a.array,
        c = a.itemSize * t,
        d = Math.min(A.length, o.length - c)
      for (let p = 0, m = c; p < d; p++, m++) o[m] = A[p]
    }
    return this
  }
  normalizeNormals() {
    const e = this.attributes.normal
    for (let t = 0, i = e.count; t < i; t++)
      Kn.fromBufferAttribute(e, t),
        Kn.normalize(),
        e.setXYZ(t, Kn.x, Kn.y, Kn.z)
  }
  toNonIndexed() {
    function e(a, A) {
      const c = a.array,
        d = a.itemSize,
        p = a.normalized,
        m = new c.constructor(A.length * d)
      let y = 0,
        x = 0
      for (let S = 0, C = A.length; S < C; S++) {
        a.isInterleavedBufferAttribute
          ? (y = A[S] * a.data.stride + a.offset)
          : (y = A[S] * d)
        for (let M = 0; M < d; M++) m[x++] = c[y++]
      }
      return new Bt(m, d, p)
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      )
    const t = new yt(),
      i = this.index.array,
      r = this.attributes
    for (const a in r) {
      const A = r[a],
        c = e(A, i)
      t.setAttribute(a, c)
    }
    const s = this.morphAttributes
    for (const a in s) {
      const A = [],
        c = s[a]
      for (let d = 0, p = c.length; d < p; d++) {
        const m = c[d],
          y = e(m, i)
        A.push(y)
      }
      t.morphAttributes[a] = A
    }
    t.morphTargetsRelative = this.morphTargetsRelative
    const o = this.groups
    for (let a = 0, A = o.length; a < A; a++) {
      const c = o[a]
      t.addGroup(c.start, c.count, c.materialIndex)
    }
    return t
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    }
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const A = this.parameters
      for (const c in A) A[c] !== void 0 && (e[c] = A[c])
      return e
    }
    e.data = { attributes: {} }
    const t = this.index
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      })
    const i = this.attributes
    for (const A in i) {
      const c = i[A]
      e.data.attributes[A] = c.toJSON(e.data)
    }
    const r = {}
    let s = !1
    for (const A in this.morphAttributes) {
      const c = this.morphAttributes[A],
        d = []
      for (let p = 0, m = c.length; p < m; p++) {
        const y = c[p]
        d.push(y.toJSON(e.data))
      }
      d.length > 0 && ((r[A] = d), (s = !0))
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative))
    const o = this.groups
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)))
    const a = this.boundingSphere
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;(this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null)
    const t = {}
    this.name = e.name
    const i = e.index
    i !== null && this.setIndex(i.clone(t))
    const r = e.attributes
    for (const c in r) {
      const d = r[c]
      this.setAttribute(c, d.clone(t))
    }
    const s = e.morphAttributes
    for (const c in s) {
      const d = [],
        p = s[c]
      for (let m = 0, y = p.length; m < y; m++) d.push(p[m].clone(t))
      this.morphAttributes[c] = d
    }
    this.morphTargetsRelative = e.morphTargetsRelative
    const o = e.groups
    for (let c = 0, d = o.length; c < d; c++) {
      const p = o[c]
      this.addGroup(p.start, p.count, p.materialIndex)
    }
    const a = e.boundingBox
    a !== null && (this.boundingBox = a.clone())
    const A = e.boundingSphere
    return (
      A !== null && (this.boundingSphere = A.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      e.parameters !== void 0 &&
        (this.parameters = Object.assign({}, e.parameters)),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" })
  }
}
yt.prototype.isBufferGeometry = !0
const g_ = new mt(),
  xl = new Wo(),
  Vp = new ds(),
  fo = new X(),
  ho = new X(),
  po = new X(),
  Wp = new X(),
  jp = new X(),
  $p = new X(),
  Lf = new X(),
  Df = new X(),
  If = new X(),
  Bf = new qe(),
  kf = new qe(),
  Of = new qe(),
  Qp = new X(),
  qf = new X()
class Xt extends kt {
  constructor(e = new yt(), t = new Mr()) {
    super(),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets()
  }
  copy(e) {
    return (
      super.copy(e),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  updateMorphTargets() {
    const e = this.geometry
    if (e.isBufferGeometry) {
      const t = e.morphAttributes,
        i = Object.keys(t)
      if (i.length > 0) {
        const r = t[i[0]]
        if (r !== void 0) {
          ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
          for (let s = 0, o = r.length; s < o; s++) {
            const a = r[s].name || String(s)
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[a] = s)
          }
        }
      }
    } else {
      const t = e.morphTargets
      t !== void 0 &&
        t.length > 0 &&
        console.error(
          "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        )
    }
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld
    if (
      r === void 0 ||
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Vp.copy(i.boundingSphere),
      Vp.applyMatrix4(s),
      e.ray.intersectsSphere(Vp) === !1) ||
      (g_.copy(s).invert(),
      xl.copy(e.ray).applyMatrix4(g_),
      i.boundingBox !== null && xl.intersectsBox(i.boundingBox) === !1)
    )
      return
    let o
    if (i.isBufferGeometry) {
      const a = i.index,
        A = i.attributes.position,
        c = i.morphAttributes.position,
        d = i.morphTargetsRelative,
        p = i.attributes.uv,
        m = i.attributes.uv2,
        y = i.groups,
        x = i.drawRange
      if (a !== null)
        if (Array.isArray(r))
          for (let S = 0, C = y.length; S < C; S++) {
            const M = y[S],
              _ = r[M.materialIndex],
              R = Math.max(M.start, x.start),
              T = Math.min(
                a.count,
                Math.min(M.start + M.count, x.start + x.count)
              )
            for (let L = R, B = T; L < B; L += 3) {
              const k = a.getX(L),
                O = a.getX(L + 1),
                W = a.getX(L + 2)
              ;(o = Ff(this, _, e, xl, A, c, d, p, m, k, O, W)),
                o &&
                  ((o.faceIndex = Math.floor(L / 3)),
                  (o.face.materialIndex = M.materialIndex),
                  t.push(o))
            }
          }
        else {
          const S = Math.max(0, x.start),
            C = Math.min(a.count, x.start + x.count)
          for (let M = S, _ = C; M < _; M += 3) {
            const R = a.getX(M),
              T = a.getX(M + 1),
              L = a.getX(M + 2)
            ;(o = Ff(this, r, e, xl, A, c, d, p, m, R, T, L)),
              o && ((o.faceIndex = Math.floor(M / 3)), t.push(o))
          }
        }
      else if (A !== void 0)
        if (Array.isArray(r))
          for (let S = 0, C = y.length; S < C; S++) {
            const M = y[S],
              _ = r[M.materialIndex],
              R = Math.max(M.start, x.start),
              T = Math.min(
                A.count,
                Math.min(M.start + M.count, x.start + x.count)
              )
            for (let L = R, B = T; L < B; L += 3) {
              const k = L,
                O = L + 1,
                W = L + 2
              ;(o = Ff(this, _, e, xl, A, c, d, p, m, k, O, W)),
                o &&
                  ((o.faceIndex = Math.floor(L / 3)),
                  (o.face.materialIndex = M.materialIndex),
                  t.push(o))
            }
          }
        else {
          const S = Math.max(0, x.start),
            C = Math.min(A.count, x.start + x.count)
          for (let M = S, _ = C; M < _; M += 3) {
            const R = M,
              T = M + 1,
              L = M + 2
            ;(o = Ff(this, r, e, xl, A, c, d, p, m, R, T, L)),
              o && ((o.faceIndex = Math.floor(M / 3)), t.push(o))
          }
        }
    } else
      i.isGeometry &&
        console.error(
          "THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        )
  }
}
Xt.prototype.isMesh = !0
function aL(n, e, t, i, r, s, o, a) {
  let A
  if (
    (e.side === Pn
      ? (A = i.intersectTriangle(o, s, r, !0, a))
      : (A = i.intersectTriangle(r, s, o, e.side !== ls, a)),
    A === null)
  )
    return null
  qf.copy(a), qf.applyMatrix4(n.matrixWorld)
  const c = t.ray.origin.distanceTo(qf)
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: qf.clone(), object: n }
}
function Ff(n, e, t, i, r, s, o, a, A, c, d, p) {
  fo.fromBufferAttribute(r, c),
    ho.fromBufferAttribute(r, d),
    po.fromBufferAttribute(r, p)
  const m = n.morphTargetInfluences
  if (s && m) {
    Lf.set(0, 0, 0), Df.set(0, 0, 0), If.set(0, 0, 0)
    for (let x = 0, S = s.length; x < S; x++) {
      const C = m[x],
        M = s[x]
      C !== 0 &&
        (Wp.fromBufferAttribute(M, c),
        jp.fromBufferAttribute(M, d),
        $p.fromBufferAttribute(M, p),
        o
          ? (Lf.addScaledVector(Wp, C),
            Df.addScaledVector(jp, C),
            If.addScaledVector($p, C))
          : (Lf.addScaledVector(Wp.sub(fo), C),
            Df.addScaledVector(jp.sub(ho), C),
            If.addScaledVector($p.sub(po), C)))
    }
    fo.add(Lf), ho.add(Df), po.add(If)
  }
  n.isSkinnedMesh &&
    (n.boneTransform(c, fo), n.boneTransform(d, ho), n.boneTransform(p, po))
  const y = aL(n, e, t, i, fo, ho, po, Qp)
  if (y) {
    a &&
      (Bf.fromBufferAttribute(a, c),
      kf.fromBufferAttribute(a, d),
      Of.fromBufferAttribute(a, p),
      (y.uv = qn.getUV(Qp, fo, ho, po, Bf, kf, Of, new qe()))),
      A &&
        (Bf.fromBufferAttribute(A, c),
        kf.fromBufferAttribute(A, d),
        Of.fromBufferAttribute(A, p),
        (y.uv2 = qn.getUV(Qp, fo, ho, po, Bf, kf, Of, new qe())))
    const x = { a: c, b: d, c: p, normal: new X(), materialIndex: 0 }
    qn.getNormal(fo, ho, po, x.normal), (y.face = x)
  }
  return y
}
class Us extends yt {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      })
    const a = this
    ;(r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o))
    const A = [],
      c = [],
      d = [],
      p = []
    let m = 0,
      y = 0
    x("z", "y", "x", -1, -1, i, t, e, o, s, 0),
      x("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
      x("x", "z", "y", 1, 1, e, i, t, r, o, 2),
      x("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
      x("x", "y", "z", 1, -1, e, t, i, r, s, 4),
      x("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
      this.setIndex(A),
      this.setAttribute("position", new ut(c, 3)),
      this.setAttribute("normal", new ut(d, 3)),
      this.setAttribute("uv", new ut(p, 2))
    function x(S, C, M, _, R, T, L, B, k, O, W) {
      const z = T / k,
        P = L / O,
        N = T / 2,
        G = L / 2,
        j = B / 2,
        V = k + 1,
        Y = O + 1
      let ne = 0,
        le = 0
      const Te = new X()
      for (let Ae = 0; Ae < Y; Ae++) {
        const ge = Ae * P - G
        for (let Me = 0; Me < V; Me++) {
          const Ne = Me * z - N
          ;(Te[S] = Ne * _),
            (Te[C] = ge * R),
            (Te[M] = j),
            c.push(Te.x, Te.y, Te.z),
            (Te[S] = 0),
            (Te[C] = 0),
            (Te[M] = B > 0 ? 1 : -1),
            d.push(Te.x, Te.y, Te.z),
            p.push(Me / k),
            p.push(1 - Ae / O),
            (ne += 1)
        }
      }
      for (let Ae = 0; Ae < O; Ae++)
        for (let ge = 0; ge < k; ge++) {
          const Me = m + ge + V * Ae,
            Ne = m + ge + V * (Ae + 1),
            Ze = m + (ge + 1) + V * (Ae + 1),
            K = m + (ge + 1) + V * Ae
          A.push(Me, Ne, K), A.push(Ne, Ze, K), (le += 6)
        }
      a.addGroup(y, le, W), (y += le), (m += ne)
    }
  }
  static fromJSON(e) {
    return new Us(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    )
  }
}
function vc(n) {
  const e = {}
  for (const t in n) {
    e[t] = {}
    for (const i in n[t]) {
      const r = n[t][i]
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? (e[t][i] = r.clone())
        : Array.isArray(r)
        ? (e[t][i] = r.slice())
        : (e[t][i] = r)
    }
  }
  return e
}
function hi(n) {
  const e = {}
  for (let t = 0; t < n.length; t++) {
    const i = vc(n[t])
    for (const r in i) e[r] = i[r]
  }
  return e
}
const s2 = { clone: vc, merge: hi }
var lL = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  cL = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
class ar extends ii {
  constructor(e) {
    super(),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader = lL),
      (this.fragmentShader = cL),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 &&
        (e.attributes !== void 0 &&
          console.error(
            "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
          ),
        this.setValues(e))
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = vc(e.uniforms)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    )
  }
  toJSON(e) {
    const t = super.toJSON(e)
    ;(t.glslVersion = this.glslVersion), (t.uniforms = {})
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value
      o && o.isTexture
        ? (t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[r] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[r] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[r] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[r] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[r] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[r] = { type: "m4", value: o.toArray() })
        : (t.uniforms[r] = { value: o })
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader)
    const i = {}
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0)
    return Object.keys(i).length > 0 && (t.extensions = i), t
  }
}
ar.prototype.isShaderMaterial = !0
class qu extends kt {
  constructor() {
    super(),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new mt()),
      (this.projectionMatrix = new mt()),
      (this.projectionMatrixInverse = new mt())
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      this
    )
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1)
    const t = this.matrixWorld.elements
    return e.set(-t[8], -t[9], -t[10]).normalize()
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
qu.prototype.isCamera = !0
class ei extends qu {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    )
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e
    ;(this.fov = nu * 2 * Math.atan(t)), this.updateProjectionMatrix()
  }
  getFocalLength() {
    const e = Math.tan(Ia * 0.5 * this.fov)
    return (0.5 * this.getFilmHeight()) / e
  }
  getEffectiveFOV() {
    return nu * 2 * Math.atan(Math.tan(Ia * 0.5 * this.fov) / this.zoom)
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1)
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1)
  }
  setViewOffset(e, t, i, r, s, o) {
    ;(this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const e = this.near
    let t = (e * Math.tan(Ia * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r
    const o = this.view
    if (this.view !== null && this.view.enabled) {
      const A = o.fullWidth,
        c = o.fullHeight
      ;(s += (o.offsetX * r) / A),
        (t -= (o.offsetY * i) / c),
        (r *= o.width / A),
        (i *= o.height / c)
    }
    const a = this.filmOffset
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    )
  }
}
ei.prototype.isPerspectiveCamera = !0
const bl = 90,
  wl = 1
class Sd extends kt {
  constructor(e, t, i) {
    if (
      (super(), (this.type = "CubeCamera"), i.isWebGLCubeRenderTarget !== !0)
    ) {
      console.error(
        "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
      )
      return
    }
    this.renderTarget = i
    const r = new ei(bl, wl, e, t)
    ;(r.layers = this.layers),
      r.up.set(0, -1, 0),
      r.lookAt(new X(1, 0, 0)),
      this.add(r)
    const s = new ei(bl, wl, e, t)
    ;(s.layers = this.layers),
      s.up.set(0, -1, 0),
      s.lookAt(new X(-1, 0, 0)),
      this.add(s)
    const o = new ei(bl, wl, e, t)
    ;(o.layers = this.layers),
      o.up.set(0, 0, 1),
      o.lookAt(new X(0, 1, 0)),
      this.add(o)
    const a = new ei(bl, wl, e, t)
    ;(a.layers = this.layers),
      a.up.set(0, 0, -1),
      a.lookAt(new X(0, -1, 0)),
      this.add(a)
    const A = new ei(bl, wl, e, t)
    ;(A.layers = this.layers),
      A.up.set(0, -1, 0),
      A.lookAt(new X(0, 0, 1)),
      this.add(A)
    const c = new ei(bl, wl, e, t)
    ;(c.layers = this.layers),
      c.up.set(0, -1, 0),
      c.lookAt(new X(0, 0, -1)),
      this.add(c)
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld()
    const i = this.renderTarget,
      [r, s, o, a, A, c] = this.children,
      d = e.xr.enabled,
      p = e.getRenderTarget()
    e.xr.enabled = !1
    const m = i.texture.generateMipmaps
    ;(i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0),
      e.render(t, r),
      e.setRenderTarget(i, 1),
      e.render(t, s),
      e.setRenderTarget(i, 2),
      e.render(t, o),
      e.setRenderTarget(i, 3),
      e.render(t, a),
      e.setRenderTarget(i, 4),
      e.render(t, A),
      (i.texture.generateMipmaps = m),
      e.setRenderTarget(i, 5),
      e.render(t, c),
      e.setRenderTarget(p),
      (e.xr.enabled = d),
      (i.texture.needsPMREMUpdate = !0)
  }
}
class Hc extends Vn {
  constructor(e, t, i, r, s, o, a, A, c, d) {
    ;(e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : el),
      super(e, t, i, r, s, o, a, A, c, d),
      (this.flipY = !1)
  }
  get images() {
    return this.image
  }
  set images(e) {
    this.image = e
  }
}
Hc.prototype.isCubeTexture = !0
class Ed extends rr {
  constructor(e, t, i) {
    Number.isInteger(t) &&
      (console.warn(
        "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
      ),
      (t = i)),
      super(e, e, t),
      (t = t || {}),
      (this.texture = new Hc(
        void 0,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.encoding
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Mn)
  }
  fromEquirectangularTexture(e, t) {
    ;(this.texture.type = t.type),
      (this.texture.format = Ai),
      (this.texture.encoding = t.encoding),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter)
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new Us(5, 5, 5),
      s = new ar({
        name: "CubemapFromEquirect",
        uniforms: vc(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: Pn,
        blending: Ds,
      })
    s.uniforms.tEquirect.value = t
    const o = new Xt(r, s),
      a = t.minFilter
    return (
      t.minFilter === nl && (t.minFilter = Mn),
      new Sd(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    )
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget()
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r)
    e.setRenderTarget(s)
  }
}
Ed.prototype.isWebGLCubeRenderTarget = !0
const Xp = new X(),
  AL = new X(),
  uL = new Zn()
class Zr {
  constructor(e = new X(1, 0, 0), t = 0) {
    ;(this.normal = e), (this.constant = t)
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), (this.constant = r), this
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
  }
  setFromCoplanarPoints(e, t, i) {
    const r = Xp.subVectors(i, t).cross(AL.subVectors(e, t)).normalize()
    return this.setFromNormalAndCoplanarPoint(r, e), this
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this
  }
  normalize() {
    const e = 1 / this.normal.length()
    return this.normal.multiplyScalar(e), (this.constant *= e), this
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius
  }
  projectPoint(e, t) {
    return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
  }
  intersectLine(e, t) {
    const i = e.delta(Xp),
      r = this.normal.dot(i)
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null
    const s = -(e.start.dot(this.normal) + this.constant) / r
    return s < 0 || s > 1 ? null : t.copy(i).multiplyScalar(s).add(e.start)
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end)
    return (t < 0 && i > 0) || (i < 0 && t > 0)
  }
  intersectsBox(e) {
    return e.intersectsPlane(this)
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this)
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant)
  }
  applyMatrix4(e, t) {
    const i = t || uL.getNormalMatrix(e),
      r = this.coplanarPoint(Xp).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize()
    return (this.constant = -r.dot(s)), this
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
Zr.prototype.isPlane = !0
const Ml = new ds(),
  Nf = new X()
class Fu {
  constructor(
    e = new Zr(),
    t = new Zr(),
    i = new Zr(),
    r = new Zr(),
    s = new Zr(),
    o = new Zr()
  ) {
    this.planes = [e, t, i, r, s, o]
  }
  set(e, t, i, r, s, o) {
    const a = this.planes
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    )
  }
  copy(e) {
    const t = this.planes
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i])
    return this
  }
  setFromProjectionMatrix(e) {
    const t = this.planes,
      i = e.elements,
      r = i[0],
      s = i[1],
      o = i[2],
      a = i[3],
      A = i[4],
      c = i[5],
      d = i[6],
      p = i[7],
      m = i[8],
      y = i[9],
      x = i[10],
      S = i[11],
      C = i[12],
      M = i[13],
      _ = i[14],
      R = i[15]
    return (
      t[0].setComponents(a - r, p - A, S - m, R - C).normalize(),
      t[1].setComponents(a + r, p + A, S + m, R + C).normalize(),
      t[2].setComponents(a + s, p + c, S + y, R + M).normalize(),
      t[3].setComponents(a - s, p - c, S - y, R - M).normalize(),
      t[4].setComponents(a - o, p - d, S - x, R - _).normalize(),
      t[5].setComponents(a + o, p + d, S + x, R + _).normalize(),
      this
    )
  }
  intersectsObject(e) {
    const t = e.geometry
    return (
      t.boundingSphere === null && t.computeBoundingSphere(),
      Ml.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ml)
    )
  }
  intersectsSprite(e) {
    return (
      Ml.center.set(0, 0, 0),
      (Ml.radius = 0.7071067811865476),
      Ml.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ml)
    )
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1
    return !0
  }
  intersectsBox(e) {
    const t = this.planes
    for (let i = 0; i < 6; i++) {
      const r = t[i]
      if (
        ((Nf.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (Nf.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (Nf.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(Nf) < 0)
      )
        return !1
    }
    return !0
  }
  containsPoint(e) {
    const t = this.planes
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1
    return !0
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
function D5() {
  let n = null,
    e = !1,
    t = null,
    i = null
  function r(s, o) {
    t(s, o), (i = n.requestAnimationFrame(r))
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0))
    },
    stop: function () {
      n.cancelAnimationFrame(i), (e = !1)
    },
    setAnimationLoop: function (s) {
      t = s
    },
    setContext: function (s) {
      n = s
    },
  }
}
function fL(n, e) {
  const t = e.isWebGL2,
    i = new WeakMap()
  function r(c, d) {
    const p = c.array,
      m = c.usage,
      y = n.createBuffer()
    n.bindBuffer(d, y), n.bufferData(d, p, m), c.onUploadCallback()
    let x = 5126
    return (
      p instanceof Float32Array
        ? (x = 5126)
        : p instanceof Float64Array
        ? console.warn(
            "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
          )
        : p instanceof Uint16Array
        ? c.isFloat16BufferAttribute
          ? t
            ? (x = 5131)
            : console.warn(
                "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
              )
          : (x = 5123)
        : p instanceof Int16Array
        ? (x = 5122)
        : p instanceof Uint32Array
        ? (x = 5125)
        : p instanceof Int32Array
        ? (x = 5124)
        : p instanceof Int8Array
        ? (x = 5120)
        : (p instanceof Uint8Array || p instanceof Uint8ClampedArray) &&
          (x = 5121),
      {
        buffer: y,
        type: x,
        bytesPerElement: p.BYTES_PER_ELEMENT,
        version: c.version,
      }
    )
  }
  function s(c, d, p) {
    const m = d.array,
      y = d.updateRange
    n.bindBuffer(p, c),
      y.count === -1
        ? n.bufferSubData(p, 0, m)
        : (t
            ? n.bufferSubData(
                p,
                y.offset * m.BYTES_PER_ELEMENT,
                m,
                y.offset,
                y.count
              )
            : n.bufferSubData(
                p,
                y.offset * m.BYTES_PER_ELEMENT,
                m.subarray(y.offset, y.offset + y.count)
              ),
          (y.count = -1))
  }
  function o(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), i.get(c)
  }
  function a(c) {
    c.isInterleavedBufferAttribute && (c = c.data)
    const d = i.get(c)
    d && (n.deleteBuffer(d.buffer), i.delete(c))
  }
  function A(c, d) {
    if (c.isGLBufferAttribute) {
      const m = i.get(c)
      ;(!m || m.version < c.version) &&
        i.set(c, {
          buffer: c.buffer,
          type: c.type,
          bytesPerElement: c.elementSize,
          version: c.version,
        })
      return
    }
    c.isInterleavedBufferAttribute && (c = c.data)
    const p = i.get(c)
    p === void 0
      ? i.set(c, r(c, d))
      : p.version < c.version && (s(p.buffer, c, d), (p.version = c.version))
  }
  return { get: o, remove: a, update: A }
}
class za extends yt {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      })
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      A = Math.floor(r),
      c = a + 1,
      d = A + 1,
      p = e / a,
      m = t / A,
      y = [],
      x = [],
      S = [],
      C = []
    for (let M = 0; M < d; M++) {
      const _ = M * m - o
      for (let R = 0; R < c; R++) {
        const T = R * p - s
        x.push(T, -_, 0), S.push(0, 0, 1), C.push(R / a), C.push(1 - M / A)
      }
    }
    for (let M = 0; M < A; M++)
      for (let _ = 0; _ < a; _++) {
        const R = _ + c * M,
          T = _ + c * (M + 1),
          L = _ + 1 + c * (M + 1),
          B = _ + 1 + c * M
        y.push(R, T, B), y.push(T, L, B)
      }
    this.setIndex(y),
      this.setAttribute("position", new ut(x, 3)),
      this.setAttribute("normal", new ut(S, 3)),
      this.setAttribute("uv", new ut(C, 2))
  }
  static fromJSON(e) {
    return new za(e.width, e.height, e.widthSegments, e.heightSegments)
  }
}
var hL = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,
  dL = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  pL = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  mL = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  gL = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  yL = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  vL = "vec3 transformed = vec3( position );",
  _L = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  xL = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,
  bL = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  wL = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  ML = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  SL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  EL = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  TL = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  CL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  RL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  PL = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  LL = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,
  DL = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		return texture2D( envMap, uv ).rgb;
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  IL = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  BL = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  kL = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,
  OL = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  qL = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  FL = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  NL = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  UL = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  zL = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  HL = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  GL = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  VL = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  WL = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  jL = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  $L = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  QL = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  XL = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,
  YL = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  ZL = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  JL = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,
  KL = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  eD = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  tD = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  nD = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,
  iD = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  rD = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,
  sD = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,
  oD = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  aD = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  lD = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  cD = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  AD = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  uD = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  fD = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  hD = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  dD = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  pD = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  mD = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  gD = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  yD = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  vD = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  _D = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  xD = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  bD = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  wD = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,
  MD = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  SD = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  ED = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  TD = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  CD = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,
  RD = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  PD = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,
  LD = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,
  DD = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  ID = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,
  BD = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  kD = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  OD = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  qD = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  FD = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  ND = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  UD = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  zD = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  HD = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,
  GD = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  VD = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  WD = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,
  jD = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  $D = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  QD = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  XD = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  YD = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  ZD = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  JD = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,
  KD = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  eI = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,
  tI = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,
  nI = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,
  iI = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,
  rI = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,
  sI = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,
  oI = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`
const aI = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  lI = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  cI = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  AI = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  uI = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  fI = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  hI = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  dI = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  pI = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  mI = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  gI = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  yI = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vI = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  _I = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  xI = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  bI = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  wI = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  MI = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  SI = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  EI = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  TI = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  CI = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  RI = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  PI = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  LI = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  DI = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  II = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  BI = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  kI = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  OI = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  qI = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  FI = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  Ot = {
    alphamap_fragment: hL,
    alphamap_pars_fragment: dL,
    alphatest_fragment: pL,
    alphatest_pars_fragment: mL,
    aomap_fragment: gL,
    aomap_pars_fragment: yL,
    begin_vertex: vL,
    beginnormal_vertex: _L,
    bsdfs: xL,
    bumpmap_pars_fragment: bL,
    clipping_planes_fragment: wL,
    clipping_planes_pars_fragment: ML,
    clipping_planes_pars_vertex: SL,
    clipping_planes_vertex: EL,
    color_fragment: TL,
    color_pars_fragment: CL,
    color_pars_vertex: RL,
    color_vertex: PL,
    common: LL,
    cube_uv_reflection_fragment: DL,
    defaultnormal_vertex: IL,
    displacementmap_pars_vertex: BL,
    displacementmap_vertex: kL,
    emissivemap_fragment: OL,
    emissivemap_pars_fragment: qL,
    encodings_fragment: FL,
    encodings_pars_fragment: NL,
    envmap_fragment: UL,
    envmap_common_pars_fragment: zL,
    envmap_pars_fragment: HL,
    envmap_pars_vertex: GL,
    envmap_physical_pars_fragment: eD,
    envmap_vertex: VL,
    fog_vertex: WL,
    fog_pars_vertex: jL,
    fog_fragment: $L,
    fog_pars_fragment: QL,
    gradientmap_pars_fragment: XL,
    lightmap_fragment: YL,
    lightmap_pars_fragment: ZL,
    lights_lambert_vertex: JL,
    lights_pars_begin: KL,
    lights_toon_fragment: tD,
    lights_toon_pars_fragment: nD,
    lights_phong_fragment: iD,
    lights_phong_pars_fragment: rD,
    lights_physical_fragment: sD,
    lights_physical_pars_fragment: oD,
    lights_fragment_begin: aD,
    lights_fragment_maps: lD,
    lights_fragment_end: cD,
    logdepthbuf_fragment: AD,
    logdepthbuf_pars_fragment: uD,
    logdepthbuf_pars_vertex: fD,
    logdepthbuf_vertex: hD,
    map_fragment: dD,
    map_pars_fragment: pD,
    map_particle_fragment: mD,
    map_particle_pars_fragment: gD,
    metalnessmap_fragment: yD,
    metalnessmap_pars_fragment: vD,
    morphnormal_vertex: _D,
    morphtarget_pars_vertex: xD,
    morphtarget_vertex: bD,
    normal_fragment_begin: wD,
    normal_fragment_maps: MD,
    normal_pars_fragment: SD,
    normal_pars_vertex: ED,
    normal_vertex: TD,
    normalmap_pars_fragment: CD,
    clearcoat_normal_fragment_begin: RD,
    clearcoat_normal_fragment_maps: PD,
    clearcoat_pars_fragment: LD,
    output_fragment: DD,
    packing: ID,
    premultiplied_alpha_fragment: BD,
    project_vertex: kD,
    dithering_fragment: OD,
    dithering_pars_fragment: qD,
    roughnessmap_fragment: FD,
    roughnessmap_pars_fragment: ND,
    shadowmap_pars_fragment: UD,
    shadowmap_pars_vertex: zD,
    shadowmap_vertex: HD,
    shadowmask_pars_fragment: GD,
    skinbase_vertex: VD,
    skinning_pars_vertex: WD,
    skinning_vertex: jD,
    skinnormal_vertex: $D,
    specularmap_fragment: QD,
    specularmap_pars_fragment: XD,
    tonemapping_fragment: YD,
    tonemapping_pars_fragment: ZD,
    transmission_fragment: JD,
    transmission_pars_fragment: KD,
    uv_pars_fragment: eI,
    uv_pars_vertex: tI,
    uv_vertex: nI,
    uv2_pars_fragment: iI,
    uv2_pars_vertex: rI,
    uv2_vertex: sI,
    worldpos_vertex: oI,
    background_vert: aI,
    background_frag: lI,
    cube_vert: cI,
    cube_frag: AI,
    depth_vert: uI,
    depth_frag: fI,
    distanceRGBA_vert: hI,
    distanceRGBA_frag: dI,
    equirect_vert: pI,
    equirect_frag: mI,
    linedashed_vert: gI,
    linedashed_frag: yI,
    meshbasic_vert: vI,
    meshbasic_frag: _I,
    meshlambert_vert: xI,
    meshlambert_frag: bI,
    meshmatcap_vert: wI,
    meshmatcap_frag: MI,
    meshnormal_vert: SI,
    meshnormal_frag: EI,
    meshphong_vert: TI,
    meshphong_frag: CI,
    meshphysical_vert: RI,
    meshphysical_frag: PI,
    meshtoon_vert: LI,
    meshtoon_frag: DI,
    points_vert: II,
    points_frag: BI,
    shadow_vert: kI,
    shadow_frag: OI,
    sprite_vert: qI,
    sprite_frag: FI,
  },
  et = {
    common: {
      diffuse: { value: new Ke(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Zn() },
      uv2Transform: { value: new Zn() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
    specularmap: { specularMap: { value: null } },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
    lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
    emissivemap: { emissiveMap: { value: null } },
    bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new qe(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    roughnessmap: { roughnessMap: { value: null } },
    metalnessmap: { metalnessMap: { value: null } },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Ke(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Ke(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Zn() },
    },
    sprite: {
      diffuse: { value: new Ke(16777215) },
      opacity: { value: 1 },
      center: { value: new qe(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Zn() },
    },
  },
  mr = {
    basic: {
      uniforms: hi([
        et.common,
        et.specularmap,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.fog,
      ]),
      vertexShader: Ot.meshbasic_vert,
      fragmentShader: Ot.meshbasic_frag,
    },
    lambert: {
      uniforms: hi([
        et.common,
        et.specularmap,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.fog,
        et.lights,
        { emissive: { value: new Ke(0) } },
      ]),
      vertexShader: Ot.meshlambert_vert,
      fragmentShader: Ot.meshlambert_frag,
    },
    phong: {
      uniforms: hi([
        et.common,
        et.specularmap,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.fog,
        et.lights,
        {
          emissive: { value: new Ke(0) },
          specular: { value: new Ke(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Ot.meshphong_vert,
      fragmentShader: Ot.meshphong_frag,
    },
    standard: {
      uniforms: hi([
        et.common,
        et.envmap,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.roughnessmap,
        et.metalnessmap,
        et.fog,
        et.lights,
        {
          emissive: { value: new Ke(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Ot.meshphysical_vert,
      fragmentShader: Ot.meshphysical_frag,
    },
    toon: {
      uniforms: hi([
        et.common,
        et.aomap,
        et.lightmap,
        et.emissivemap,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.gradientmap,
        et.fog,
        et.lights,
        { emissive: { value: new Ke(0) } },
      ]),
      vertexShader: Ot.meshtoon_vert,
      fragmentShader: Ot.meshtoon_frag,
    },
    matcap: {
      uniforms: hi([
        et.common,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        et.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Ot.meshmatcap_vert,
      fragmentShader: Ot.meshmatcap_frag,
    },
    points: {
      uniforms: hi([et.points, et.fog]),
      vertexShader: Ot.points_vert,
      fragmentShader: Ot.points_frag,
    },
    dashed: {
      uniforms: hi([
        et.common,
        et.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Ot.linedashed_vert,
      fragmentShader: Ot.linedashed_frag,
    },
    depth: {
      uniforms: hi([et.common, et.displacementmap]),
      vertexShader: Ot.depth_vert,
      fragmentShader: Ot.depth_frag,
    },
    normal: {
      uniforms: hi([
        et.common,
        et.bumpmap,
        et.normalmap,
        et.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Ot.meshnormal_vert,
      fragmentShader: Ot.meshnormal_frag,
    },
    sprite: {
      uniforms: hi([et.sprite, et.fog]),
      vertexShader: Ot.sprite_vert,
      fragmentShader: Ot.sprite_frag,
    },
    background: {
      uniforms: { uvTransform: { value: new Zn() }, t2D: { value: null } },
      vertexShader: Ot.background_vert,
      fragmentShader: Ot.background_frag,
    },
    cube: {
      uniforms: hi([et.envmap, { opacity: { value: 1 } }]),
      vertexShader: Ot.cube_vert,
      fragmentShader: Ot.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ot.equirect_vert,
      fragmentShader: Ot.equirect_frag,
    },
    distanceRGBA: {
      uniforms: hi([
        et.common,
        et.displacementmap,
        {
          referencePosition: { value: new X() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Ot.distanceRGBA_vert,
      fragmentShader: Ot.distanceRGBA_frag,
    },
    shadow: {
      uniforms: hi([
        et.lights,
        et.fog,
        { color: { value: new Ke(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Ot.shadow_vert,
      fragmentShader: Ot.shadow_frag,
    },
  }
mr.physical = {
  uniforms: hi([
    mr.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: new qe(1, 1) },
      clearcoatNormalMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: new Ke(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: new qe() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Ke(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: new Ke(1, 1, 1) },
      specularColorMap: { value: null },
    },
  ]),
  vertexShader: Ot.meshphysical_vert,
  fragmentShader: Ot.meshphysical_frag,
}
function NI(n, e, t, i, r, s) {
  const o = new Ke(0)
  let a = r === !0 ? 0 : 1,
    A,
    c,
    d = null,
    p = 0,
    m = null
  function y(S, C) {
    let M = !1,
      _ = C.isScene === !0 ? C.background : null
    _ && _.isTexture && (_ = e.get(_))
    const R = n.xr,
      T = R.getSession && R.getSession()
    T && T.environmentBlendMode === "additive" && (_ = null),
      _ === null ? x(o, a) : _ && _.isColor && (x(_, 1), (M = !0)),
      (n.autoClear || M) &&
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      _ && (_.isCubeTexture || _.mapping === zc)
        ? (c === void 0 &&
            ((c = new Xt(
              new Us(1, 1, 1),
              new ar({
                name: "BackgroundCubeMaterial",
                uniforms: vc(mr.cube.uniforms),
                vertexShader: mr.cube.vertexShader,
                fragmentShader: mr.cube.fragmentShader,
                side: Pn,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            c.geometry.deleteAttribute("normal"),
            c.geometry.deleteAttribute("uv"),
            (c.onBeforeRender = function (L, B, k) {
              this.matrixWorld.copyPosition(k.matrixWorld)
            }),
            Object.defineProperty(c.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value
              },
            }),
            i.update(c)),
          (c.material.uniforms.envMap.value = _),
          (c.material.uniforms.flipEnvMap.value =
            _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
          (d !== _ || p !== _.version || m !== n.toneMapping) &&
            ((c.material.needsUpdate = !0),
            (d = _),
            (p = _.version),
            (m = n.toneMapping)),
          S.unshift(c, c.geometry, c.material, 0, 0, null))
        : _ &&
          _.isTexture &&
          (A === void 0 &&
            ((A = new Xt(
              new za(2, 2),
              new ar({
                name: "BackgroundMaterial",
                uniforms: vc(mr.background.uniforms),
                vertexShader: mr.background.vertexShader,
                fragmentShader: mr.background.fragmentShader,
                side: Na,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            A.geometry.deleteAttribute("normal"),
            Object.defineProperty(A.material, "map", {
              get: function () {
                return this.uniforms.t2D.value
              },
            }),
            i.update(A)),
          (A.material.uniforms.t2D.value = _),
          _.matrixAutoUpdate === !0 && _.updateMatrix(),
          A.material.uniforms.uvTransform.value.copy(_.matrix),
          (d !== _ || p !== _.version || m !== n.toneMapping) &&
            ((A.material.needsUpdate = !0),
            (d = _),
            (p = _.version),
            (m = n.toneMapping)),
          S.unshift(A, A.geometry, A.material, 0, 0, null))
  }
  function x(S, C) {
    t.buffers.color.setClear(S.r, S.g, S.b, C, s)
  }
  return {
    getClearColor: function () {
      return o
    },
    setClearColor: function (S, C = 1) {
      o.set(S), (a = C), x(o, a)
    },
    getClearAlpha: function () {
      return a
    },
    setClearAlpha: function (S) {
      ;(a = S), x(o, a)
    },
    render: y,
  }
}
function UI(n, e, t, i) {
  const r = n.getParameter(34921),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = i.isWebGL2 || s !== null,
    a = {},
    A = S(null)
  let c = A
  function d(G, j, V, Y, ne) {
    let le = !1
    if (o) {
      const Te = x(Y, V, j)
      c !== Te && ((c = Te), m(c.object)), (le = C(Y, ne)), le && M(Y, ne)
    } else {
      const Te = j.wireframe === !0
      ;(c.geometry !== Y.id || c.program !== V.id || c.wireframe !== Te) &&
        ((c.geometry = Y.id), (c.program = V.id), (c.wireframe = Te), (le = !0))
    }
    G.isInstancedMesh === !0 && (le = !0),
      ne !== null && t.update(ne, 34963),
      le &&
        (k(G, j, V, Y), ne !== null && n.bindBuffer(34963, t.get(ne).buffer))
  }
  function p() {
    return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES()
  }
  function m(G) {
    return i.isWebGL2 ? n.bindVertexArray(G) : s.bindVertexArrayOES(G)
  }
  function y(G) {
    return i.isWebGL2 ? n.deleteVertexArray(G) : s.deleteVertexArrayOES(G)
  }
  function x(G, j, V) {
    const Y = V.wireframe === !0
    let ne = a[G.id]
    ne === void 0 && ((ne = {}), (a[G.id] = ne))
    let le = ne[j.id]
    le === void 0 && ((le = {}), (ne[j.id] = le))
    let Te = le[Y]
    return Te === void 0 && ((Te = S(p())), (le[Y] = Te)), Te
  }
  function S(G) {
    const j = [],
      V = [],
      Y = []
    for (let ne = 0; ne < r; ne++) (j[ne] = 0), (V[ne] = 0), (Y[ne] = 0)
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: j,
      enabledAttributes: V,
      attributeDivisors: Y,
      object: G,
      attributes: {},
      index: null,
    }
  }
  function C(G, j) {
    const V = c.attributes,
      Y = G.attributes
    let ne = 0
    for (const le in Y) {
      const Te = V[le],
        Ae = Y[le]
      if (Te === void 0 || Te.attribute !== Ae || Te.data !== Ae.data) return !0
      ne++
    }
    return c.attributesNum !== ne || c.index !== j
  }
  function M(G, j) {
    const V = {},
      Y = G.attributes
    let ne = 0
    for (const le in Y) {
      const Te = Y[le],
        Ae = {}
      ;(Ae.attribute = Te), Te.data && (Ae.data = Te.data), (V[le] = Ae), ne++
    }
    ;(c.attributes = V), (c.attributesNum = ne), (c.index = j)
  }
  function _() {
    const G = c.newAttributes
    for (let j = 0, V = G.length; j < V; j++) G[j] = 0
  }
  function R(G) {
    T(G, 0)
  }
  function T(G, j) {
    const V = c.newAttributes,
      Y = c.enabledAttributes,
      ne = c.attributeDivisors
    ;(V[G] = 1),
      Y[G] === 0 && (n.enableVertexAttribArray(G), (Y[G] = 1)),
      ne[G] !== j &&
        ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](G, j),
        (ne[G] = j))
  }
  function L() {
    const G = c.newAttributes,
      j = c.enabledAttributes
    for (let V = 0, Y = j.length; V < Y; V++)
      j[V] !== G[V] && (n.disableVertexAttribArray(V), (j[V] = 0))
  }
  function B(G, j, V, Y, ne, le) {
    i.isWebGL2 === !0 && (V === 5124 || V === 5125)
      ? n.vertexAttribIPointer(G, j, V, ne, le)
      : n.vertexAttribPointer(G, j, V, Y, ne, le)
  }
  function k(G, j, V, Y) {
    if (
      i.isWebGL2 === !1 &&
      (G.isInstancedMesh || Y.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return
    _()
    const ne = Y.attributes,
      le = V.getAttributes(),
      Te = j.defaultAttributeValues
    for (const Ae in le) {
      const ge = le[Ae]
      if (ge.location >= 0) {
        let Me = ne[Ae]
        if (
          (Me === void 0 &&
            (Ae === "instanceMatrix" &&
              G.instanceMatrix &&
              (Me = G.instanceMatrix),
            Ae === "instanceColor" &&
              G.instanceColor &&
              (Me = G.instanceColor)),
          Me !== void 0)
        ) {
          const Ne = Me.normalized,
            Ze = Me.itemSize,
            K = t.get(Me)
          if (K === void 0) continue
          const Oe = K.buffer,
            ve = K.type,
            Be = K.bytesPerElement
          if (Me.isInterleavedBufferAttribute) {
            const Fe = Me.data,
              je = Fe.stride,
              Ge = Me.offset
            if (Fe && Fe.isInstancedInterleavedBuffer) {
              for (let ye = 0; ye < ge.locationSize; ye++)
                T(ge.location + ye, Fe.meshPerAttribute)
              G.isInstancedMesh !== !0 &&
                Y._maxInstanceCount === void 0 &&
                (Y._maxInstanceCount = Fe.meshPerAttribute * Fe.count)
            } else
              for (let ye = 0; ye < ge.locationSize; ye++) R(ge.location + ye)
            n.bindBuffer(34962, Oe)
            for (let ye = 0; ye < ge.locationSize; ye++)
              B(
                ge.location + ye,
                Ze / ge.locationSize,
                ve,
                Ne,
                je * Be,
                (Ge + (Ze / ge.locationSize) * ye) * Be
              )
          } else {
            if (Me.isInstancedBufferAttribute) {
              for (let Fe = 0; Fe < ge.locationSize; Fe++)
                T(ge.location + Fe, Me.meshPerAttribute)
              G.isInstancedMesh !== !0 &&
                Y._maxInstanceCount === void 0 &&
                (Y._maxInstanceCount = Me.meshPerAttribute * Me.count)
            } else
              for (let Fe = 0; Fe < ge.locationSize; Fe++) R(ge.location + Fe)
            n.bindBuffer(34962, Oe)
            for (let Fe = 0; Fe < ge.locationSize; Fe++)
              B(
                ge.location + Fe,
                Ze / ge.locationSize,
                ve,
                Ne,
                Ze * Be,
                (Ze / ge.locationSize) * Fe * Be
              )
          }
        } else if (Te !== void 0) {
          const Ne = Te[Ae]
          if (Ne !== void 0)
            switch (Ne.length) {
              case 2:
                n.vertexAttrib2fv(ge.location, Ne)
                break
              case 3:
                n.vertexAttrib3fv(ge.location, Ne)
                break
              case 4:
                n.vertexAttrib4fv(ge.location, Ne)
                break
              default:
                n.vertexAttrib1fv(ge.location, Ne)
            }
        }
      }
    }
    L()
  }
  function O() {
    P()
    for (const G in a) {
      const j = a[G]
      for (const V in j) {
        const Y = j[V]
        for (const ne in Y) y(Y[ne].object), delete Y[ne]
        delete j[V]
      }
      delete a[G]
    }
  }
  function W(G) {
    if (a[G.id] === void 0) return
    const j = a[G.id]
    for (const V in j) {
      const Y = j[V]
      for (const ne in Y) y(Y[ne].object), delete Y[ne]
      delete j[V]
    }
    delete a[G.id]
  }
  function z(G) {
    for (const j in a) {
      const V = a[j]
      if (V[G.id] === void 0) continue
      const Y = V[G.id]
      for (const ne in Y) y(Y[ne].object), delete Y[ne]
      delete V[G.id]
    }
  }
  function P() {
    N(), c !== A && ((c = A), m(c.object))
  }
  function N() {
    ;(A.geometry = null), (A.program = null), (A.wireframe = !1)
  }
  return {
    setup: d,
    reset: P,
    resetDefaultState: N,
    dispose: O,
    releaseStatesOfGeometry: W,
    releaseStatesOfProgram: z,
    initAttributes: _,
    enableAttribute: R,
    disableUnusedAttributes: L,
  }
}
function zI(n, e, t, i) {
  const r = i.isWebGL2
  let s
  function o(c) {
    s = c
  }
  function a(c, d) {
    n.drawArrays(s, c, d), t.update(d, s, 1)
  }
  function A(c, d, p) {
    if (p === 0) return
    let m, y
    if (r) (m = n), (y = "drawArraysInstanced")
    else if (
      ((m = e.get("ANGLE_instanced_arrays")),
      (y = "drawArraysInstancedANGLE"),
      m === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      )
      return
    }
    m[y](s, c, d, p), t.update(d, s, p)
  }
  ;(this.setMode = o), (this.render = a), (this.renderInstances = A)
}
function HI(n, e, t) {
  let i
  function r() {
    if (i !== void 0) return i
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const k = e.get("EXT_texture_filter_anisotropic")
      i = n.getParameter(k.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
    } else i = 0
    return i
  }
  function s(k) {
    if (k === "highp") {
      if (
        n.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        n.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp"
      k = "mediump"
    }
    return k === "mediump" &&
      n.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      n.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp"
  }
  const o =
    (typeof WebGL2RenderingContext != "undefined" &&
      n instanceof WebGL2RenderingContext) ||
    (typeof WebGL2ComputeRenderingContext != "undefined" &&
      n instanceof WebGL2ComputeRenderingContext)
  let a = t.precision !== void 0 ? t.precision : "highp"
  const A = s(a)
  A !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      A,
      "instead."
    ),
    (a = A))
  const c = o || e.has("WEBGL_draw_buffers"),
    d = t.logarithmicDepthBuffer === !0,
    p = n.getParameter(34930),
    m = n.getParameter(35660),
    y = n.getParameter(3379),
    x = n.getParameter(34076),
    S = n.getParameter(34921),
    C = n.getParameter(36347),
    M = n.getParameter(36348),
    _ = n.getParameter(36349),
    R = m > 0,
    T = o || e.has("OES_texture_float"),
    L = R && T,
    B = o ? n.getParameter(36183) : 0
  return {
    isWebGL2: o,
    drawBuffers: c,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: d,
    maxTextures: p,
    maxVertexTextures: m,
    maxTextureSize: y,
    maxCubemapSize: x,
    maxAttributes: S,
    maxVertexUniforms: C,
    maxVaryings: M,
    maxFragmentUniforms: _,
    vertexTextures: R,
    floatFragmentTextures: T,
    floatVertexTextures: L,
    maxSamples: B,
  }
}
function GI(n) {
  const e = this
  let t = null,
    i = 0,
    r = !1,
    s = !1
  const o = new Zr(),
    a = new Zn(),
    A = { value: null, needsUpdate: !1 }
  ;(this.uniform = A),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (p, m, y) {
      const x = p.length !== 0 || m || i !== 0 || r
      return (r = m), (t = d(p, y, 0)), (i = p.length), x
    }),
    (this.beginShadows = function () {
      ;(s = !0), d(null)
    }),
    (this.endShadows = function () {
      ;(s = !1), c()
    }),
    (this.setState = function (p, m, y) {
      const x = p.clippingPlanes,
        S = p.clipIntersection,
        C = p.clipShadows,
        M = n.get(p)
      if (!r || x === null || x.length === 0 || (s && !C)) s ? d(null) : c()
      else {
        const _ = s ? 0 : i,
          R = _ * 4
        let T = M.clippingState || null
        ;(A.value = T), (T = d(x, m, R, y))
        for (let L = 0; L !== R; ++L) T[L] = t[L]
        ;(M.clippingState = T),
          (this.numIntersection = S ? this.numPlanes : 0),
          (this.numPlanes += _)
      }
    })
  function c() {
    A.value !== t && ((A.value = t), (A.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0)
  }
  function d(p, m, y, x) {
    const S = p !== null ? p.length : 0
    let C = null
    if (S !== 0) {
      if (((C = A.value), x !== !0 || C === null)) {
        const M = y + S * 4,
          _ = m.matrixWorldInverse
        a.getNormalMatrix(_),
          (C === null || C.length < M) && (C = new Float32Array(M))
        for (let R = 0, T = y; R !== S; ++R, T += 4)
          o.copy(p[R]).applyMatrix4(_, a),
            o.normal.toArray(C, T),
            (C[T + 3] = o.constant)
      }
      ;(A.value = C), (A.needsUpdate = !0)
    }
    return (e.numPlanes = S), (e.numIntersection = 0), C
  }
}
function VI(n) {
  let e = new WeakMap()
  function t(o, a) {
    return a === XA ? (o.mapping = el) : a === YA && (o.mapping = tl), o
  }
  function i(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const a = o.mapping
      if (a === XA || a === YA)
        if (e.has(o)) {
          const A = e.get(o).texture
          return t(A, o.mapping)
        } else {
          const A = o.image
          if (A && A.height > 0) {
            const c = new Ed(A.height / 2)
            return (
              c.fromEquirectangularTexture(n, o),
              e.set(o, c),
              o.addEventListener("dispose", r),
              t(c.texture, o.mapping)
            )
          } else return null
        }
    }
    return o
  }
  function r(o) {
    const a = o.target
    a.removeEventListener("dispose", r)
    const A = e.get(a)
    A !== void 0 && (e.delete(a), A.dispose())
  }
  function s() {
    e = new WeakMap()
  }
  return { get: i, dispose: s }
}
class Nu extends qu {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix()
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    )
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2
    let s = i - e,
      o = i + e,
      a = r + t,
      A = r - t
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        d = (this.top - this.bottom) / this.view.fullHeight / this.zoom
      ;(s += c * this.view.offsetX),
        (o = s + c * this.view.width),
        (a -= d * this.view.offsetY),
        (A = a - d * this.view.height)
    }
    this.projectionMatrix.makeOrthographic(s, o, a, A, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    )
  }
}
Nu.prototype.isOrthographicCamera = !0
class Gc extends ar {
  constructor(e) {
    super(e), (this.type = "RawShaderMaterial")
  }
}
Gc.prototype.isRawShaderMaterial = !0
const nc = 4,
  Lo = 8,
  Qr = Math.pow(2, Lo),
  I5 = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  B5 = Lo - nc + 1 + I5.length,
  Sl = 20,
  Yp = new Nu(),
  { _lodPlanes: sA, _sizeLods: y_, _sigmas: Uf } = WI(),
  v_ = new Ke()
let Zp = null
const pa = (1 + Math.sqrt(5)) / 2,
  El = 1 / pa,
  __ = [
    new X(1, 1, 1),
    new X(-1, 1, 1),
    new X(1, 1, -1),
    new X(-1, 1, -1),
    new X(0, pa, El),
    new X(0, pa, -El),
    new X(El, 0, pa),
    new X(-El, 0, pa),
    new X(pa, El, 0),
    new X(-pa, El, 0),
  ]
class C1 {
  constructor(e) {
    ;(this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._blurMaterial = jI(Sl)),
      (this._equirectShader = null),
      (this._cubemapShader = null),
      this._compileMaterial(this._blurMaterial)
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    Zp = this._renderer.getRenderTarget()
    const s = this._allocateTargets()
    return (
      this._sceneToCubeUV(e, i, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    )
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t)
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t)
  }
  compileCubemapShader() {
    this._cubemapShader === null &&
      ((this._cubemapShader = w_()), this._compileMaterial(this._cubemapShader))
  }
  compileEquirectangularShader() {
    this._equirectShader === null &&
      ((this._equirectShader = b_()),
      this._compileMaterial(this._equirectShader))
  }
  dispose() {
    this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose(),
      this._cubemapShader !== null && this._cubemapShader.dispose(),
      this._equirectShader !== null && this._equirectShader.dispose()
    for (let e = 0; e < sA.length; e++) sA[e].dispose()
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Zp),
      (e.scissorTest = !1),
      zf(e, 0, 0, e.width, e.height)
  }
  _fromTexture(e, t) {
    Zp = this._renderer.getRenderTarget()
    const i = t || this._allocateTargets(e)
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
  }
  _allocateTargets(e) {
    const t = {
        magFilter: Mn,
        minFilter: Mn,
        generateMipmaps: !1,
        type: La,
        format: Ai,
        encoding: Ns,
        depthBuffer: !1,
      },
      i = x_(t)
    return (
      (i.depthBuffer = !e),
      this._pingPongRenderTarget === null &&
        (this._pingPongRenderTarget = x_(t)),
      i
    )
  }
  _compileMaterial(e) {
    const t = new Xt(sA[0], e)
    this._renderer.compile(t, Yp)
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new ei(90, 1, t, i),
      A = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      d = this._renderer,
      p = d.autoClear,
      m = d.toneMapping
    d.getClearColor(v_), (d.toneMapping = Is), (d.autoClear = !1)
    const y = new Mr({
        name: "PMREM.Background",
        side: Pn,
        depthWrite: !1,
        depthTest: !1,
      }),
      x = new Xt(new Us(), y)
    let S = !1
    const C = e.background
    C
      ? C.isColor && (y.color.copy(C), (e.background = null), (S = !0))
      : (y.color.copy(v_), (S = !0))
    for (let M = 0; M < 6; M++) {
      const _ = M % 3
      _ === 0
        ? (a.up.set(0, A[M], 0), a.lookAt(c[M], 0, 0))
        : _ === 1
        ? (a.up.set(0, 0, A[M]), a.lookAt(0, c[M], 0))
        : (a.up.set(0, A[M], 0), a.lookAt(0, 0, c[M])),
        zf(r, _ * Qr, M > 2 ? Qr : 0, Qr, Qr),
        d.setRenderTarget(r),
        S && d.render(x, a),
        d.render(e, a)
    }
    x.geometry.dispose(),
      x.material.dispose(),
      (d.toneMapping = m),
      (d.autoClear = p),
      (e.background = C)
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === el || e.mapping === tl
    r
      ? (this._cubemapShader === null && (this._cubemapShader = w_()),
        (this._cubemapShader.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectShader === null && (this._equirectShader = b_())
    const s = r ? this._cubemapShader : this._equirectShader,
      o = new Xt(sA[0], s),
      a = s.uniforms
    ;(a.envMap.value = e),
      r || a.texelSize.value.set(1 / e.image.width, 1 / e.image.height),
      zf(t, 0, 0, 3 * Qr, 2 * Qr),
      i.setRenderTarget(t),
      i.render(o, Yp)
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear
    t.autoClear = !1
    for (let r = 1; r < B5; r++) {
      const s = Math.sqrt(Uf[r] * Uf[r] - Uf[r - 1] * Uf[r - 1]),
        o = __[(r - 1) % __.length]
      this._blur(e, r - 1, r, s, o)
    }
    t.autoClear = i
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget
    this._halfBlur(e, o, t, i, r, "latitudinal", s),
      this._halfBlur(o, e, i, i, r, "longitudinal", s)
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const A = this._renderer,
      c = this._blurMaterial
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      )
    const d = 3,
      p = new Xt(sA[r], c),
      m = c.uniforms,
      y = y_[i] - 1,
      x = isFinite(s) ? Math.PI / (2 * y) : (2 * Math.PI) / (2 * Sl - 1),
      S = s / x,
      C = isFinite(s) ? 1 + Math.floor(d * S) : Sl
    C > Sl &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${C} samples when the maximum is set to ${Sl}`
      )
    const M = []
    let _ = 0
    for (let B = 0; B < Sl; ++B) {
      const k = B / S,
        O = Math.exp((-k * k) / 2)
      M.push(O), B === 0 ? (_ += O) : B < C && (_ += 2 * O)
    }
    for (let B = 0; B < M.length; B++) M[B] = M[B] / _
    ;(m.envMap.value = e.texture),
      (m.samples.value = C),
      (m.weights.value = M),
      (m.latitudinal.value = o === "latitudinal"),
      a && (m.poleAxis.value = a),
      (m.dTheta.value = x),
      (m.mipInt.value = Lo - i)
    const R = y_[r],
      T = 3 * Math.max(0, Qr - 2 * R),
      L = (r === 0 ? 0 : 2 * Qr) + 2 * R * (r > Lo - nc ? r - Lo + nc : 0)
    zf(t, T, L, 3 * R, 2 * R), A.setRenderTarget(t), A.render(p, Yp)
  }
}
function WI() {
  const n = [],
    e = [],
    t = []
  let i = Lo
  for (let r = 0; r < B5; r++) {
    const s = Math.pow(2, i)
    e.push(s)
    let o = 1 / s
    r > Lo - nc ? (o = I5[r - Lo + nc - 1]) : r === 0 && (o = 0), t.push(o)
    const a = 1 / (s - 1),
      A = -a / 2,
      c = 1 + a / 2,
      d = [A, A, c, A, c, c, A, A, c, c, A, c],
      p = 6,
      m = 6,
      y = 3,
      x = 2,
      S = 1,
      C = new Float32Array(y * m * p),
      M = new Float32Array(x * m * p),
      _ = new Float32Array(S * m * p)
    for (let T = 0; T < p; T++) {
      const L = ((T % 3) * 2) / 3 - 1,
        B = T > 2 ? 0 : -1,
        k = [
          L,
          B,
          0,
          L + 2 / 3,
          B,
          0,
          L + 2 / 3,
          B + 1,
          0,
          L,
          B,
          0,
          L + 2 / 3,
          B + 1,
          0,
          L,
          B + 1,
          0,
        ]
      C.set(k, y * m * T), M.set(d, x * m * T)
      const O = [T, T, T, T, T, T]
      _.set(O, S * m * T)
    }
    const R = new yt()
    R.setAttribute("position", new Bt(C, y)),
      R.setAttribute("uv", new Bt(M, x)),
      R.setAttribute("faceIndex", new Bt(_, S)),
      n.push(R),
      i > nc && i--
  }
  return { _lodPlanes: n, _sizeLods: e, _sigmas: t }
}
function x_(n) {
  const e = new rr(3 * Qr, 3 * Qr, n)
  return (
    (e.texture.mapping = zc),
    (e.texture.name = "PMREM.cubeUv"),
    (e.scissorTest = !0),
    e
  )
}
function zf(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r)
}
function jI(n) {
  const e = new Float32Array(n),
    t = new X(0, 1, 0)
  return new Gc({
    name: "SphericalGaussianBlur",
    defines: { n },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: e },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: t },
    },
    vertexShader: o2(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Ds,
    depthTest: !1,
    depthWrite: !1,
  })
}
function b_() {
  const n = new qe(1, 1)
  return new Gc({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null }, texelSize: { value: n } },
    vertexShader: o2(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = texture2D ( envMap, uv ).rgb;
				uv.x += texelSize.x;
				vec3 tr = texture2D ( envMap, uv ).rgb;
				uv.y += texelSize.y;
				vec3 br = texture2D ( envMap, uv ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = texture2D ( envMap, uv ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

			}
		`,
    blending: Ds,
    depthTest: !1,
    depthWrite: !1,
  })
}
function w_() {
  return new Gc({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: o2(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Ds,
    depthTest: !1,
    depthWrite: !1,
  })
}
function o2() {
  return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function $I(n) {
  let e = new WeakMap(),
    t = null
  function i(a) {
    if (a && a.isTexture) {
      const A = a.mapping,
        c = A === XA || A === YA,
        d = A === el || A === tl
      if (c || d)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1
          let p = e.get(a)
          return (
            t === null && (t = new C1(n)),
            (p = c ? t.fromEquirectangular(a, p) : t.fromCubemap(a, p)),
            e.set(a, p),
            p.texture
          )
        } else {
          if (e.has(a)) return e.get(a).texture
          {
            const p = a.image
            if ((c && p && p.height > 0) || (d && p && r(p))) {
              t === null && (t = new C1(n))
              const m = c ? t.fromEquirectangular(a) : t.fromCubemap(a)
              return e.set(a, m), a.addEventListener("dispose", s), m.texture
            } else return null
          }
        }
    }
    return a
  }
  function r(a) {
    let A = 0
    const c = 6
    for (let d = 0; d < c; d++) a[d] !== void 0 && A++
    return A === c
  }
  function s(a) {
    const A = a.target
    A.removeEventListener("dispose", s)
    const c = e.get(A)
    c !== void 0 && (e.delete(A), c.dispose())
  }
  function o() {
    ;(e = new WeakMap()), t !== null && (t.dispose(), (t = null))
  }
  return { get: i, dispose: o }
}
function QI(n) {
  const e = {}
  function t(i) {
    if (e[i] !== void 0) return e[i]
    let r
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture")
        break
      case "EXT_texture_filter_anisotropic":
        r =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic")
        break
      case "WEBGL_compressed_texture_s3tc":
        r =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")
        break
      case "WEBGL_compressed_texture_pvrtc":
        r =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc")
        break
      default:
        r = n.getExtension(i)
    }
    return (e[i] = r), r
  }
  return {
    has: function (i) {
      return t(i) !== null
    },
    init: function (i) {
      i.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture")
    },
    get: function (i) {
      const r = t(i)
      return (
        r === null &&
          console.warn(
            "THREE.WebGLRenderer: " + i + " extension not supported."
          ),
        r
      )
    },
  }
}
function XI(n, e, t, i) {
  const r = {},
    s = new WeakMap()
  function o(p) {
    const m = p.target
    m.index !== null && e.remove(m.index)
    for (const x in m.attributes) e.remove(m.attributes[x])
    m.removeEventListener("dispose", o), delete r[m.id]
    const y = s.get(m)
    y && (e.remove(y), s.delete(m)),
      i.releaseStatesOfGeometry(m),
      m.isInstancedBufferGeometry === !0 && delete m._maxInstanceCount,
      t.memory.geometries--
  }
  function a(p, m) {
    return (
      r[m.id] === !0 ||
        (m.addEventListener("dispose", o),
        (r[m.id] = !0),
        t.memory.geometries++),
      m
    )
  }
  function A(p) {
    const m = p.attributes
    for (const x in m) e.update(m[x], 34962)
    const y = p.morphAttributes
    for (const x in y) {
      const S = y[x]
      for (let C = 0, M = S.length; C < M; C++) e.update(S[C], 34962)
    }
  }
  function c(p) {
    const m = [],
      y = p.index,
      x = p.attributes.position
    let S = 0
    if (y !== null) {
      const _ = y.array
      S = y.version
      for (let R = 0, T = _.length; R < T; R += 3) {
        const L = _[R + 0],
          B = _[R + 1],
          k = _[R + 2]
        m.push(L, B, B, k, k, L)
      }
    } else {
      const _ = x.array
      S = x.version
      for (let R = 0, T = _.length / 3 - 1; R < T; R += 3) {
        const L = R + 0,
          B = R + 1,
          k = R + 2
        m.push(L, B, B, k, k, L)
      }
    }
    const C = new (b5(m) ? Md : wd)(m, 1)
    C.version = S
    const M = s.get(p)
    M && e.remove(M), s.set(p, C)
  }
  function d(p) {
    const m = s.get(p)
    if (m) {
      const y = p.index
      y !== null && m.version < y.version && c(p)
    } else c(p)
    return s.get(p)
  }
  return { get: a, update: A, getWireframeAttribute: d }
}
function YI(n, e, t, i) {
  const r = i.isWebGL2
  let s
  function o(m) {
    s = m
  }
  let a, A
  function c(m) {
    ;(a = m.type), (A = m.bytesPerElement)
  }
  function d(m, y) {
    n.drawElements(s, y, a, m * A), t.update(y, s, 1)
  }
  function p(m, y, x) {
    if (x === 0) return
    let S, C
    if (r) (S = n), (C = "drawElementsInstanced")
    else if (
      ((S = e.get("ANGLE_instanced_arrays")),
      (C = "drawElementsInstancedANGLE"),
      S === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      )
      return
    }
    S[C](s, y, a, m * A, x), t.update(y, s, x)
  }
  ;(this.setMode = o),
    (this.setIndex = c),
    (this.render = d),
    (this.renderInstances = p)
}
function ZI(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case 4:
        t.triangles += a * (s / 3)
        break
      case 1:
        t.lines += a * (s / 2)
        break
      case 3:
        t.lines += a * (s - 1)
        break
      case 2:
        t.lines += a * s
        break
      case 0:
        t.points += a * s
        break
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o)
        break
    }
  }
  function r() {
    t.frame++, (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0)
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  }
}
class Td extends Vn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = On),
      (this.minFilter = On),
      (this.wrapR = ci),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
Td.prototype.isDataTexture2DArray = !0
function JI(n, e) {
  return n[0] - e[0]
}
function KI(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1])
}
function M_(n, e) {
  let t = 1
  const i = e.isInterleavedBufferAttribute ? e.data.array : e.array
  i instanceof Int8Array
    ? (t = 127)
    : i instanceof Int16Array
    ? (t = 32767)
    : i instanceof Int32Array
    ? (t = 2147483647)
    : console.error(
        "THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",
        i
      ),
    n.divideScalar(t)
}
function eB(n, e, t) {
  const i = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    o = new X(),
    a = []
  for (let c = 0; c < 8; c++) a[c] = [c, 0]
  function A(c, d, p, m) {
    const y = c.morphTargetInfluences
    if (e.isWebGL2 === !0) {
      const x = d.morphAttributes.position.length
      let S = s.get(d)
      if (S === void 0 || S.count !== x) {
        let N = function () {
          z.dispose(), s.delete(d), d.removeEventListener("dispose", N)
        }
        S !== void 0 && S.texture.dispose()
        const _ = d.morphAttributes.normal !== void 0,
          R = d.morphAttributes.position,
          T = d.morphAttributes.normal || [],
          L = d.attributes.position.count,
          B = _ === !0 ? 2 : 1
        let k = L * B,
          O = 1
        k > e.maxTextureSize &&
          ((O = Math.ceil(k / e.maxTextureSize)), (k = e.maxTextureSize))
        const W = new Float32Array(k * O * 4 * x),
          z = new Td(W, k, O, x)
        ;(z.format = Ai), (z.type = Rs), (z.needsUpdate = !0)
        const P = B * 4
        for (let G = 0; G < x; G++) {
          const j = R[G],
            V = T[G],
            Y = k * O * 4 * G
          for (let ne = 0; ne < j.count; ne++) {
            o.fromBufferAttribute(j, ne), j.normalized === !0 && M_(o, j)
            const le = ne * P
            ;(W[Y + le + 0] = o.x),
              (W[Y + le + 1] = o.y),
              (W[Y + le + 2] = o.z),
              (W[Y + le + 3] = 0),
              _ === !0 &&
                (o.fromBufferAttribute(V, ne),
                V.normalized === !0 && M_(o, V),
                (W[Y + le + 4] = o.x),
                (W[Y + le + 5] = o.y),
                (W[Y + le + 6] = o.z),
                (W[Y + le + 7] = 0))
          }
        }
        ;(S = { count: x, texture: z, size: new qe(k, O) }),
          s.set(d, S),
          d.addEventListener("dispose", N)
      }
      let C = 0
      for (let _ = 0; _ < y.length; _++) C += y[_]
      const M = d.morphTargetsRelative ? 1 : 1 - C
      m.getUniforms().setValue(n, "morphTargetBaseInfluence", M),
        m.getUniforms().setValue(n, "morphTargetInfluences", y),
        m.getUniforms().setValue(n, "morphTargetsTexture", S.texture, t),
        m.getUniforms().setValue(n, "morphTargetsTextureSize", S.size)
    } else {
      const x = y === void 0 ? 0 : y.length
      let S = i[d.id]
      if (S === void 0 || S.length !== x) {
        S = []
        for (let T = 0; T < x; T++) S[T] = [T, 0]
        i[d.id] = S
      }
      for (let T = 0; T < x; T++) {
        const L = S[T]
        ;(L[0] = T), (L[1] = y[T])
      }
      S.sort(KI)
      for (let T = 0; T < 8; T++)
        T < x && S[T][1]
          ? ((a[T][0] = S[T][0]), (a[T][1] = S[T][1]))
          : ((a[T][0] = Number.MAX_SAFE_INTEGER), (a[T][1] = 0))
      a.sort(JI)
      const C = d.morphAttributes.position,
        M = d.morphAttributes.normal
      let _ = 0
      for (let T = 0; T < 8; T++) {
        const L = a[T],
          B = L[0],
          k = L[1]
        B !== Number.MAX_SAFE_INTEGER && k
          ? (C &&
              d.getAttribute("morphTarget" + T) !== C[B] &&
              d.setAttribute("morphTarget" + T, C[B]),
            M &&
              d.getAttribute("morphNormal" + T) !== M[B] &&
              d.setAttribute("morphNormal" + T, M[B]),
            (r[T] = k),
            (_ += k))
          : (C &&
              d.hasAttribute("morphTarget" + T) === !0 &&
              d.deleteAttribute("morphTarget" + T),
            M &&
              d.hasAttribute("morphNormal" + T) === !0 &&
              d.deleteAttribute("morphNormal" + T),
            (r[T] = 0))
      }
      const R = d.morphTargetsRelative ? 1 : 1 - _
      m.getUniforms().setValue(n, "morphTargetBaseInfluence", R),
        m.getUniforms().setValue(n, "morphTargetInfluences", r)
    }
  }
  return { update: A }
}
function tB(n, e, t, i) {
  let r = new WeakMap()
  function s(A) {
    const c = i.render.frame,
      d = A.geometry,
      p = e.get(A, d)
    return (
      r.get(p) !== c && (e.update(p), r.set(p, c)),
      A.isInstancedMesh &&
        (A.hasEventListener("dispose", a) === !1 &&
          A.addEventListener("dispose", a),
        t.update(A.instanceMatrix, 34962),
        A.instanceColor !== null && t.update(A.instanceColor, 34962)),
      p
    )
  }
  function o() {
    r = new WeakMap()
  }
  function a(A) {
    const c = A.target
    c.removeEventListener("dispose", a),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor)
  }
  return { update: s, dispose: o }
}
class a2 extends Vn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = On),
      (this.minFilter = On),
      (this.wrapR = ci),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
a2.prototype.isDataTexture3D = !0
const k5 = new Vn(),
  O5 = new Td(),
  q5 = new a2(),
  F5 = new Hc(),
  S_ = [],
  E_ = [],
  T_ = new Float32Array(16),
  C_ = new Float32Array(9),
  R_ = new Float32Array(4)
function Vc(n, e, t) {
  const i = n[0]
  if (i <= 0 || i > 0) return n
  const r = e * t
  let s = S_[r]
  if ((s === void 0 && ((s = new Float32Array(r)), (S_[r] = s)), e !== 0)) {
    i.toArray(s, 0)
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a)
  }
  return s
}
function Ci(n, e) {
  if (n.length !== e.length) return !1
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1
  return !0
}
function gi(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t]
}
function Cd(n, e) {
  let t = E_[e]
  t === void 0 && ((t = new Int32Array(e)), (E_[e] = t))
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit()
  return t
}
function nB(n, e) {
  const t = this.cache
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e))
}
function iB(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y))
  else {
    if (Ci(t, e)) return
    n.uniform2fv(this.addr, e), gi(t, e)
  }
}
function rB(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z))
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b))
  else {
    if (Ci(t, e)) return
    n.uniform3fv(this.addr, e), gi(t, e)
  }
}
function sB(n, e) {
  const t = this.cache
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w))
  else {
    if (Ci(t, e)) return
    n.uniform4fv(this.addr, e), gi(t, e)
  }
}
function oB(n, e) {
  const t = this.cache,
    i = e.elements
  if (i === void 0) {
    if (Ci(t, e)) return
    n.uniformMatrix2fv(this.addr, !1, e), gi(t, e)
  } else {
    if (Ci(t, i)) return
    R_.set(i), n.uniformMatrix2fv(this.addr, !1, R_), gi(t, i)
  }
}
function aB(n, e) {
  const t = this.cache,
    i = e.elements
  if (i === void 0) {
    if (Ci(t, e)) return
    n.uniformMatrix3fv(this.addr, !1, e), gi(t, e)
  } else {
    if (Ci(t, i)) return
    C_.set(i), n.uniformMatrix3fv(this.addr, !1, C_), gi(t, i)
  }
}
function lB(n, e) {
  const t = this.cache,
    i = e.elements
  if (i === void 0) {
    if (Ci(t, e)) return
    n.uniformMatrix4fv(this.addr, !1, e), gi(t, e)
  } else {
    if (Ci(t, i)) return
    T_.set(i), n.uniformMatrix4fv(this.addr, !1, T_), gi(t, i)
  }
}
function cB(n, e) {
  const t = this.cache
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e))
}
function AB(n, e) {
  const t = this.cache
  Ci(t, e) || (n.uniform2iv(this.addr, e), gi(t, e))
}
function uB(n, e) {
  const t = this.cache
  Ci(t, e) || (n.uniform3iv(this.addr, e), gi(t, e))
}
function fB(n, e) {
  const t = this.cache
  Ci(t, e) || (n.uniform4iv(this.addr, e), gi(t, e))
}
function hB(n, e) {
  const t = this.cache
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e))
}
function dB(n, e) {
  const t = this.cache
  Ci(t, e) || (n.uniform2uiv(this.addr, e), gi(t, e))
}
function pB(n, e) {
  const t = this.cache
  Ci(t, e) || (n.uniform3uiv(this.addr, e), gi(t, e))
}
function mB(n, e) {
  const t = this.cache
  Ci(t, e) || (n.uniform4uiv(this.addr, e), gi(t, e))
}
function gB(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.safeSetTexture2D(e || k5, r)
}
function yB(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || q5, r)
}
function vB(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.safeSetTextureCube(e || F5, r)
}
function _B(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit()
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || O5, r)
}
function xB(n) {
  switch (n) {
    case 5126:
      return nB
    case 35664:
      return iB
    case 35665:
      return rB
    case 35666:
      return sB
    case 35674:
      return oB
    case 35675:
      return aB
    case 35676:
      return lB
    case 5124:
    case 35670:
      return cB
    case 35667:
    case 35671:
      return AB
    case 35668:
    case 35672:
      return uB
    case 35669:
    case 35673:
      return fB
    case 5125:
      return hB
    case 36294:
      return dB
    case 36295:
      return pB
    case 36296:
      return mB
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return gB
    case 35679:
    case 36299:
    case 36307:
      return yB
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return vB
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return _B
  }
}
function bB(n, e) {
  n.uniform1fv(this.addr, e)
}
function wB(n, e) {
  const t = Vc(e, this.size, 2)
  n.uniform2fv(this.addr, t)
}
function MB(n, e) {
  const t = Vc(e, this.size, 3)
  n.uniform3fv(this.addr, t)
}
function SB(n, e) {
  const t = Vc(e, this.size, 4)
  n.uniform4fv(this.addr, t)
}
function EB(n, e) {
  const t = Vc(e, this.size, 4)
  n.uniformMatrix2fv(this.addr, !1, t)
}
function TB(n, e) {
  const t = Vc(e, this.size, 9)
  n.uniformMatrix3fv(this.addr, !1, t)
}
function CB(n, e) {
  const t = Vc(e, this.size, 16)
  n.uniformMatrix4fv(this.addr, !1, t)
}
function RB(n, e) {
  n.uniform1iv(this.addr, e)
}
function PB(n, e) {
  n.uniform2iv(this.addr, e)
}
function LB(n, e) {
  n.uniform3iv(this.addr, e)
}
function DB(n, e) {
  n.uniform4iv(this.addr, e)
}
function IB(n, e) {
  n.uniform1uiv(this.addr, e)
}
function BB(n, e) {
  n.uniform2uiv(this.addr, e)
}
function kB(n, e) {
  n.uniform3uiv(this.addr, e)
}
function OB(n, e) {
  n.uniform4uiv(this.addr, e)
}
function qB(n, e, t) {
  const i = e.length,
    r = Cd(t, i)
  n.uniform1iv(this.addr, r)
  for (let s = 0; s !== i; ++s) t.safeSetTexture2D(e[s] || k5, r[s])
}
function FB(n, e, t) {
  const i = e.length,
    r = Cd(t, i)
  n.uniform1iv(this.addr, r)
  for (let s = 0; s !== i; ++s) t.setTexture3D(e[s] || q5, r[s])
}
function NB(n, e, t) {
  const i = e.length,
    r = Cd(t, i)
  n.uniform1iv(this.addr, r)
  for (let s = 0; s !== i; ++s) t.safeSetTextureCube(e[s] || F5, r[s])
}
function UB(n, e, t) {
  const i = e.length,
    r = Cd(t, i)
  n.uniform1iv(this.addr, r)
  for (let s = 0; s !== i; ++s) t.setTexture2DArray(e[s] || O5, r[s])
}
function zB(n) {
  switch (n) {
    case 5126:
      return bB
    case 35664:
      return wB
    case 35665:
      return MB
    case 35666:
      return SB
    case 35674:
      return EB
    case 35675:
      return TB
    case 35676:
      return CB
    case 5124:
    case 35670:
      return RB
    case 35667:
    case 35671:
      return PB
    case 35668:
    case 35672:
      return LB
    case 35669:
    case 35673:
      return DB
    case 5125:
      return IB
    case 36294:
      return BB
    case 36295:
      return kB
    case 36296:
      return OB
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return qB
    case 35679:
    case 36299:
    case 36307:
      return FB
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return NB
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return UB
  }
}
function HB(n, e, t) {
  ;(this.id = n),
    (this.addr = t),
    (this.cache = []),
    (this.setValue = xB(e.type))
}
function N5(n, e, t) {
  ;(this.id = n),
    (this.addr = t),
    (this.cache = []),
    (this.size = e.size),
    (this.setValue = zB(e.type))
}
N5.prototype.updateCache = function (n) {
  const e = this.cache
  n instanceof Float32Array &&
    e.length !== n.length &&
    (this.cache = new Float32Array(n.length)),
    gi(e, n)
}
function U5(n) {
  ;(this.id = n), (this.seq = []), (this.map = {})
}
U5.prototype.setValue = function (n, e, t) {
  const i = this.seq
  for (let r = 0, s = i.length; r !== s; ++r) {
    const o = i[r]
    o.setValue(n, e[o.id], t)
  }
}
const Jp = /(\w+)(\])?(\[|\.)?/g
function P_(n, e) {
  n.seq.push(e), (n.map[e.id] = e)
}
function GB(n, e, t) {
  const i = n.name,
    r = i.length
  for (Jp.lastIndex = 0; ; ) {
    const s = Jp.exec(i),
      o = Jp.lastIndex
    let a = s[1]
    const A = s[2] === "]",
      c = s[3]
    if ((A && (a = a | 0), c === void 0 || (c === "[" && o + 2 === r))) {
      P_(t, c === void 0 ? new HB(a, n, e) : new N5(a, n, e))
      break
    } else {
      let p = t.map[a]
      p === void 0 && ((p = new U5(a)), P_(t, p)), (t = p)
    }
  }
}
function Do(n, e) {
  ;(this.seq = []), (this.map = {})
  const t = n.getProgramParameter(e, 35718)
  for (let i = 0; i < t; ++i) {
    const r = n.getActiveUniform(e, i),
      s = n.getUniformLocation(e, r.name)
    GB(r, s, this)
  }
}
Do.prototype.setValue = function (n, e, t, i) {
  const r = this.map[e]
  r !== void 0 && r.setValue(n, t, i)
}
Do.prototype.setOptional = function (n, e, t) {
  const i = e[t]
  i !== void 0 && this.setValue(n, t, i)
}
Do.upload = function (n, e, t, i) {
  for (let r = 0, s = e.length; r !== s; ++r) {
    const o = e[r],
      a = t[o.id]
    a.needsUpdate !== !1 && o.setValue(n, a.value, i)
  }
}
Do.seqWithValue = function (n, e) {
  const t = []
  for (let i = 0, r = n.length; i !== r; ++i) {
    const s = n[i]
    s.id in e && t.push(s)
  }
  return t
}
function L_(n, e, t) {
  const i = n.createShader(e)
  return n.shaderSource(i, t), n.compileShader(i), i
}
let VB = 0
function WB(n) {
  const e = n.split(`
`)
  for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t]
  return e.join(`
`)
}
function jB(n) {
  switch (n) {
    case Ns:
      return ["Linear", "( value )"]
    case pn:
      return ["sRGB", "( value )"]
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", n),
        ["Linear", "( value )"]
      )
  }
}
function D_(n, e, t) {
  const i = n.getShaderParameter(e, 35713),
    r = n.getShaderInfoLog(e).trim()
  return i && r === ""
    ? ""
    : t.toUpperCase() +
        `

` +
        r +
        `

` +
        WB(n.getShaderSource(e))
}
function $B(n, e) {
  const t = jB(e)
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }"
}
function QB(n, e) {
  let t
  switch (e) {
    case j4:
      t = "Linear"
      break
    case $4:
      t = "Reinhard"
      break
    case Q4:
      t = "OptimizedCineon"
      break
    case X4:
      t = "ACESFilmic"
      break
    case Y4:
      t = "Custom"
      break
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear")
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  )
}
function XB(n) {
  return [
    n.extensionDerivatives ||
    n.envMapCubeUV ||
    n.bumpMap ||
    n.tangentSpaceNormalMap ||
    n.clearcoatNormalMap ||
    n.flatShading ||
    n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
    n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
    n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(vA).join(`
`)
}
function YB(n) {
  const e = []
  for (const t in n) {
    const i = n[t]
    i !== !1 && e.push("#define " + t + " " + i)
  }
  return e.join(`
`)
}
function ZB(n, e) {
  const t = {},
    i = n.getProgramParameter(e, 35721)
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name
    let a = 1
    s.type === 35674 && (a = 2),
      s.type === 35675 && (a = 3),
      s.type === 35676 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      })
  }
  return t
}
function vA(n) {
  return n !== ""
}
function I_(n, e) {
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function B_(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    )
}
const JB = /^[ \t]*#include +<([\w\d./]+)>/gm
function R1(n) {
  return n.replace(JB, KB)
}
function KB(n, e) {
  const t = Ot[e]
  if (t === void 0) throw new Error("Can not resolve #include <" + e + ">")
  return R1(t)
}
const ek =
    /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
  tk =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
function k_(n) {
  return n.replace(tk, z5).replace(ek, nk)
}
function nk(n, e, t, i) {
  return (
    console.warn(
      "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
    ),
    z5(n, e, t, i)
  )
}
function z5(n, e, t, i) {
  let r = ""
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s)
  return r
}
function O_(n) {
  let e =
    "precision " +
    n.precision +
    ` float;
precision ` +
    n.precision +
    " int;"
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  )
}
function ik(n) {
  let e = "SHADOWMAP_TYPE_BASIC"
  return (
    n.shadowMapType === Zg
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === M4
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === Ul && (e = "SHADOWMAP_TYPE_VSM"),
    e
  )
}
function rk(n) {
  let e = "ENVMAP_TYPE_CUBE"
  if (n.envMap)
    switch (n.envMapMode) {
      case el:
      case tl:
        e = "ENVMAP_TYPE_CUBE"
        break
      case zc:
      case Ou:
        e = "ENVMAP_TYPE_CUBE_UV"
        break
    }
  return e
}
function sk(n) {
  let e = "ENVMAP_MODE_REFLECTION"
  if (n.envMap)
    switch (n.envMapMode) {
      case tl:
      case Ou:
        e = "ENVMAP_MODE_REFRACTION"
        break
    }
  return e
}
function ok(n) {
  let e = "ENVMAP_BLENDING_NONE"
  if (n.envMap)
    switch (n.combine) {
      case ku:
        e = "ENVMAP_BLENDING_MULTIPLY"
        break
      case V4:
        e = "ENVMAP_BLENDING_MIX"
        break
      case W4:
        e = "ENVMAP_BLENDING_ADD"
        break
    }
  return e
}
function ak(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines
  let o = t.vertexShader,
    a = t.fragmentShader
  const A = ik(t),
    c = rk(t),
    d = sk(t),
    p = ok(t),
    m = t.isWebGL2 ? "" : XB(t),
    y = YB(s),
    x = r.createProgram()
  let S,
    C,
    M = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : ""
  t.isRawShaderMaterial
    ? ((S = [y].filter(vA).join(`
`)),
      S.length > 0 &&
        (S += `
`),
      (C = [m, y].filter(vA).join(`
`)),
      C.length > 0 &&
        (C += `
`))
    : ((S = [
        O_(t),
        "#define SHADER_NAME " + t.shaderName,
        y,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define MAX_BONES " + t.maxBones,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + d : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        t.normalMap && t.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.displacementMap && t.supportsVertexTextures
          ? "#define USE_DISPLACEMENTMAP"
          : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.useVertexTexture ? "#define BONE_TEXTURE" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphTargets && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        t.morphTargets && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + A : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(vA).join(`
`)),
      (C = [
        m,
        O_(t),
        "#define SHADER_NAME " + t.shaderName,
        y,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + d : "",
        t.envMap ? "#define " + p : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMap && t.objectSpaceNormalMap
          ? "#define OBJECTSPACE_NORMALMAP"
          : "",
        t.normalMap && t.tangentSpaceNormalMap
          ? "#define TANGENTSPACE_NORMALMAP"
          : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        t.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs ? "#define USE_UV" : "",
        t.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + A : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        (t.extensionShaderTextureLOD || t.envMap) &&
        t.rendererExtensionShaderTextureLod
          ? "#define TEXTURE_LOD_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Is ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Is ? Ot.tonemapping_pars_fragment : "",
        t.toneMapping !== Is ? QB("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.transparent ? "" : "#define OPAQUE",
        Ot.encodings_pars_fragment,
        $B("linearToOutputTexel", t.outputEncoding),
        t.depthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(vA).join(`
`))),
    (o = R1(o)),
    (o = I_(o, t)),
    (o = B_(o, t)),
    (a = R1(a)),
    (a = I_(a, t)),
    (a = B_(a, t)),
    (o = k_(o)),
    (a = k_(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((M = `#version 300 es
`),
      (S =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        S),
      (C =
        [
          "#define varying in",
          t.glslVersion === S1
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === S1 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        C))
  const _ = M + S + o,
    R = M + C + a,
    T = L_(r, 35633, _),
    L = L_(r, 35632, R)
  if (
    (r.attachShader(x, T),
    r.attachShader(x, L),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(x, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(x, 0, "position"),
    r.linkProgram(x),
    n.debug.checkShaderErrors)
  ) {
    const O = r.getProgramInfoLog(x).trim(),
      W = r.getShaderInfoLog(T).trim(),
      z = r.getShaderInfoLog(L).trim()
    let P = !0,
      N = !0
    if (r.getProgramParameter(x, 35714) === !1) {
      P = !1
      const G = D_(r, T, "vertex"),
        j = D_(r, L, "fragment")
      console.error(
        "THREE.WebGLProgram: Shader Error " +
          r.getError() +
          " - VALIDATE_STATUS " +
          r.getProgramParameter(x, 35715) +
          `

Program Info Log: ` +
          O +
          `
` +
          G +
          `
` +
          j
      )
    } else
      O !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", O)
        : (W === "" || z === "") && (N = !1)
    N &&
      (this.diagnostics = {
        runnable: P,
        programLog: O,
        vertexShader: { log: W, prefix: S },
        fragmentShader: { log: z, prefix: C },
      })
  }
  r.deleteShader(T), r.deleteShader(L)
  let B
  this.getUniforms = function () {
    return B === void 0 && (B = new Do(r, x)), B
  }
  let k
  return (
    (this.getAttributes = function () {
      return k === void 0 && (k = ZB(r, x)), k
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(x),
        (this.program = void 0)
    }),
    (this.name = t.shaderName),
    (this.id = VB++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = x),
    (this.vertexShader = T),
    (this.fragmentShader = L),
    this
  )
}
let lk = 0
class ck {
  constructor() {
    ;(this.shaderCache = new Map()), (this.materialCache = new Map())
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e)
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    )
  }
  remove(e) {
    const t = this.materialCache.get(e)
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i)
    return this.materialCache.delete(e), this
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear()
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache
    return t.has(e) === !1 && t.set(e, new Set()), t.get(e)
  }
  _getShaderStage(e) {
    const t = this.shaderCache
    if (t.has(e) === !1) {
      const i = new Ak()
      t.set(e, i)
    }
    return t.get(e)
  }
}
class Ak {
  constructor() {
    ;(this.id = lk++), (this.usedTimes = 0)
  }
}
function uk(n, e, t, i, r, s, o) {
  const a = new bd(),
    A = new ck(),
    c = [],
    d = r.isWebGL2,
    p = r.logarithmicDepthBuffer,
    m = r.floatVertexTextures,
    y = r.maxVertexUniforms,
    x = r.vertexTextures
  let S = r.precision
  const C = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  }
  function M(P) {
    const G = P.skeleton.bones
    if (m) return 1024
    {
      const V = Math.floor((y - 20) / 4),
        Y = Math.min(V, G.length)
      return Y < G.length
        ? (console.warn(
            "THREE.WebGLRenderer: Skeleton has " +
              G.length +
              " bones. This GPU supports " +
              Y +
              "."
          ),
          0)
        : Y
    }
  }
  function _(P, N, G, j, V) {
    const Y = j.fog,
      ne = P.isMeshStandardMaterial ? j.environment : null,
      le = (P.isMeshStandardMaterial ? t : e).get(P.envMap || ne),
      Te = C[P.type],
      Ae = V.isSkinnedMesh ? M(V) : 0
    P.precision !== null &&
      ((S = r.getMaxPrecision(P.precision)),
      S !== P.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          P.precision,
          "not supported, using",
          S,
          "instead."
        ))
    let ge, Me, Ne, Ze
    if (Te) {
      const Fe = mr[Te]
      ;(ge = Fe.vertexShader), (Me = Fe.fragmentShader)
    } else
      (ge = P.vertexShader),
        (Me = P.fragmentShader),
        A.update(P),
        (Ne = A.getVertexShaderID(P)),
        (Ze = A.getFragmentShaderID(P))
    const K = n.getRenderTarget(),
      Oe = P.alphaTest > 0,
      ve = P.clearcoat > 0
    return {
      isWebGL2: d,
      shaderID: Te,
      shaderName: P.type,
      vertexShader: ge,
      fragmentShader: Me,
      defines: P.defines,
      customVertexShaderID: Ne,
      customFragmentShaderID: Ze,
      isRawShaderMaterial: P.isRawShaderMaterial === !0,
      glslVersion: P.glslVersion,
      precision: S,
      instancing: V.isInstancedMesh === !0,
      instancingColor: V.isInstancedMesh === !0 && V.instanceColor !== null,
      supportsVertexTextures: x,
      outputEncoding:
        K === null
          ? n.outputEncoding
          : K.isXRRenderTarget === !0
          ? K.texture.encoding
          : Ns,
      map: !!P.map,
      matcap: !!P.matcap,
      envMap: !!le,
      envMapMode: le && le.mapping,
      envMapCubeUV: !!le && (le.mapping === zc || le.mapping === Ou),
      lightMap: !!P.lightMap,
      aoMap: !!P.aoMap,
      emissiveMap: !!P.emissiveMap,
      bumpMap: !!P.bumpMap,
      normalMap: !!P.normalMap,
      objectSpaceNormalMap: P.normalMapType === y5,
      tangentSpaceNormalMap: P.normalMapType === il,
      decodeVideoTexture:
        !!P.map && P.map.isVideoTexture === !0 && P.map.encoding === pn,
      clearcoat: ve,
      clearcoatMap: ve && !!P.clearcoatMap,
      clearcoatRoughnessMap: ve && !!P.clearcoatRoughnessMap,
      clearcoatNormalMap: ve && !!P.clearcoatNormalMap,
      displacementMap: !!P.displacementMap,
      roughnessMap: !!P.roughnessMap,
      metalnessMap: !!P.metalnessMap,
      specularMap: !!P.specularMap,
      specularIntensityMap: !!P.specularIntensityMap,
      specularColorMap: !!P.specularColorMap,
      transparent: P.transparent,
      alphaMap: !!P.alphaMap,
      alphaTest: Oe,
      gradientMap: !!P.gradientMap,
      sheen: P.sheen > 0,
      sheenColorMap: !!P.sheenColorMap,
      sheenRoughnessMap: !!P.sheenRoughnessMap,
      transmission: P.transmission > 0,
      transmissionMap: !!P.transmissionMap,
      thicknessMap: !!P.thicknessMap,
      combine: P.combine,
      vertexTangents:
        !!P.normalMap && !!V.geometry && !!V.geometry.attributes.tangent,
      vertexColors: P.vertexColors,
      vertexAlphas:
        P.vertexColors === !0 &&
        !!V.geometry &&
        !!V.geometry.attributes.color &&
        V.geometry.attributes.color.itemSize === 4,
      vertexUvs:
        !!P.map ||
        !!P.bumpMap ||
        !!P.normalMap ||
        !!P.specularMap ||
        !!P.alphaMap ||
        !!P.emissiveMap ||
        !!P.roughnessMap ||
        !!P.metalnessMap ||
        !!P.clearcoatMap ||
        !!P.clearcoatRoughnessMap ||
        !!P.clearcoatNormalMap ||
        !!P.displacementMap ||
        !!P.transmissionMap ||
        !!P.thicknessMap ||
        !!P.specularIntensityMap ||
        !!P.specularColorMap ||
        !!P.sheenColorMap ||
        !!P.sheenRoughnessMap,
      uvsVertexOnly:
        !(
          !!P.map ||
          !!P.bumpMap ||
          !!P.normalMap ||
          !!P.specularMap ||
          !!P.alphaMap ||
          !!P.emissiveMap ||
          !!P.roughnessMap ||
          !!P.metalnessMap ||
          !!P.clearcoatNormalMap ||
          P.transmission > 0 ||
          !!P.transmissionMap ||
          !!P.thicknessMap ||
          !!P.specularIntensityMap ||
          !!P.specularColorMap ||
          P.sheen > 0 ||
          !!P.sheenColorMap ||
          !!P.sheenRoughnessMap
        ) && !!P.displacementMap,
      fog: !!Y,
      useFog: P.fog,
      fogExp2: Y && Y.isFogExp2,
      flatShading: !!P.flatShading,
      sizeAttenuation: P.sizeAttenuation,
      logarithmicDepthBuffer: p,
      skinning: V.isSkinnedMesh === !0 && Ae > 0,
      maxBones: Ae,
      useVertexTexture: m,
      morphTargets: !!V.geometry && !!V.geometry.morphAttributes.position,
      morphNormals: !!V.geometry && !!V.geometry.morphAttributes.normal,
      morphTargetsCount:
        !!V.geometry && !!V.geometry.morphAttributes.position
          ? V.geometry.morphAttributes.position.length
          : 0,
      numDirLights: N.directional.length,
      numPointLights: N.point.length,
      numSpotLights: N.spot.length,
      numRectAreaLights: N.rectArea.length,
      numHemiLights: N.hemi.length,
      numDirLightShadows: N.directionalShadowMap.length,
      numPointLightShadows: N.pointShadowMap.length,
      numSpotLightShadows: N.spotShadowMap.length,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: P.dithering,
      shadowMapEnabled: n.shadowMap.enabled && G.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: P.toneMapped ? n.toneMapping : Is,
      physicallyCorrectLights: n.physicallyCorrectLights,
      premultipliedAlpha: P.premultipliedAlpha,
      doubleSided: P.side === ls,
      flipSided: P.side === Pn,
      depthPacking: P.depthPacking !== void 0 ? P.depthPacking : !1,
      index0AttributeName: P.index0AttributeName,
      extensionDerivatives: P.extensions && P.extensions.derivatives,
      extensionFragDepth: P.extensions && P.extensions.fragDepth,
      extensionDrawBuffers: P.extensions && P.extensions.drawBuffers,
      extensionShaderTextureLOD: P.extensions && P.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
      customProgramCacheKey: P.customProgramCacheKey(),
    }
  }
  function R(P) {
    const N = []
    if (
      (P.shaderID
        ? N.push(P.shaderID)
        : (N.push(P.customVertexShaderID), N.push(P.customFragmentShaderID)),
      P.defines !== void 0)
    )
      for (const G in P.defines) N.push(G), N.push(P.defines[G])
    return (
      P.isRawShaderMaterial === !1 &&
        (T(N, P), L(N, P), N.push(n.outputEncoding)),
      N.push(P.customProgramCacheKey),
      N.join()
    )
  }
  function T(P, N) {
    P.push(N.precision),
      P.push(N.outputEncoding),
      P.push(N.envMapMode),
      P.push(N.combine),
      P.push(N.vertexUvs),
      P.push(N.fogExp2),
      P.push(N.sizeAttenuation),
      P.push(N.maxBones),
      P.push(N.morphTargetsCount),
      P.push(N.numDirLights),
      P.push(N.numPointLights),
      P.push(N.numSpotLights),
      P.push(N.numHemiLights),
      P.push(N.numRectAreaLights),
      P.push(N.numDirLightShadows),
      P.push(N.numPointLightShadows),
      P.push(N.numSpotLightShadows),
      P.push(N.shadowMapType),
      P.push(N.toneMapping),
      P.push(N.numClippingPlanes),
      P.push(N.numClipIntersection)
  }
  function L(P, N) {
    a.disableAll(),
      N.isWebGL2 && a.enable(0),
      N.supportsVertexTextures && a.enable(1),
      N.instancing && a.enable(2),
      N.instancingColor && a.enable(3),
      N.map && a.enable(4),
      N.matcap && a.enable(5),
      N.envMap && a.enable(6),
      N.envMapCubeUV && a.enable(7),
      N.lightMap && a.enable(8),
      N.aoMap && a.enable(9),
      N.emissiveMap && a.enable(10),
      N.bumpMap && a.enable(11),
      N.normalMap && a.enable(12),
      N.objectSpaceNormalMap && a.enable(13),
      N.tangentSpaceNormalMap && a.enable(14),
      N.clearcoat && a.enable(15),
      N.clearcoatMap && a.enable(16),
      N.clearcoatRoughnessMap && a.enable(17),
      N.clearcoatNormalMap && a.enable(18),
      N.displacementMap && a.enable(19),
      N.specularMap && a.enable(20),
      N.roughnessMap && a.enable(21),
      N.metalnessMap && a.enable(22),
      N.gradientMap && a.enable(23),
      N.alphaMap && a.enable(24),
      N.alphaTest && a.enable(25),
      N.vertexColors && a.enable(26),
      N.vertexAlphas && a.enable(27),
      N.vertexUvs && a.enable(28),
      N.vertexTangents && a.enable(29),
      N.uvsVertexOnly && a.enable(30),
      N.fog && a.enable(31),
      P.push(a.mask),
      a.disableAll(),
      N.useFog && a.enable(0),
      N.flatShading && a.enable(1),
      N.logarithmicDepthBuffer && a.enable(2),
      N.skinning && a.enable(3),
      N.useVertexTexture && a.enable(4),
      N.morphTargets && a.enable(5),
      N.morphNormals && a.enable(6),
      N.premultipliedAlpha && a.enable(7),
      N.shadowMapEnabled && a.enable(8),
      N.physicallyCorrectLights && a.enable(9),
      N.doubleSided && a.enable(10),
      N.flipSided && a.enable(11),
      N.depthPacking && a.enable(12),
      N.dithering && a.enable(13),
      N.specularIntensityMap && a.enable(14),
      N.specularColorMap && a.enable(15),
      N.transmission && a.enable(16),
      N.transmissionMap && a.enable(17),
      N.thicknessMap && a.enable(18),
      N.sheen && a.enable(19),
      N.sheenColorMap && a.enable(20),
      N.sheenRoughnessMap && a.enable(21),
      N.decodeVideoTexture && a.enable(22),
      N.transparent && a.enable(23),
      P.push(a.mask)
  }
  function B(P) {
    const N = C[P.type]
    let G
    if (N) {
      const j = mr[N]
      G = s2.clone(j.uniforms)
    } else G = P.uniforms
    return G
  }
  function k(P, N) {
    let G
    for (let j = 0, V = c.length; j < V; j++) {
      const Y = c[j]
      if (Y.cacheKey === N) {
        ;(G = Y), ++G.usedTimes
        break
      }
    }
    return G === void 0 && ((G = new ak(n, N, P, s)), c.push(G)), G
  }
  function O(P) {
    if (--P.usedTimes === 0) {
      const N = c.indexOf(P)
      ;(c[N] = c[c.length - 1]), c.pop(), P.destroy()
    }
  }
  function W(P) {
    A.remove(P)
  }
  function z() {
    A.dispose()
  }
  return {
    getParameters: _,
    getProgramCacheKey: R,
    getUniforms: B,
    acquireProgram: k,
    releaseProgram: O,
    releaseShaderCache: W,
    programs: c,
    dispose: z,
  }
}
function fk() {
  let n = new WeakMap()
  function e(s) {
    let o = n.get(s)
    return o === void 0 && ((o = {}), n.set(s, o)), o
  }
  function t(s) {
    n.delete(s)
  }
  function i(s, o, a) {
    n.get(s)[o] = a
  }
  function r() {
    n = new WeakMap()
  }
  return { get: e, remove: t, update: i, dispose: r }
}
function hk(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id
}
function q_(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id
}
function F_() {
  const n = []
  let e = 0
  const t = [],
    i = [],
    r = []
  function s() {
    ;(e = 0), (t.length = 0), (i.length = 0), (r.length = 0)
  }
  function o(p, m, y, x, S, C) {
    let M = n[e]
    return (
      M === void 0
        ? ((M = {
            id: p.id,
            object: p,
            geometry: m,
            material: y,
            groupOrder: x,
            renderOrder: p.renderOrder,
            z: S,
            group: C,
          }),
          (n[e] = M))
        : ((M.id = p.id),
          (M.object = p),
          (M.geometry = m),
          (M.material = y),
          (M.groupOrder = x),
          (M.renderOrder = p.renderOrder),
          (M.z = S),
          (M.group = C)),
      e++,
      M
    )
  }
  function a(p, m, y, x, S, C) {
    const M = o(p, m, y, x, S, C)
    y.transmission > 0
      ? i.push(M)
      : y.transparent === !0
      ? r.push(M)
      : t.push(M)
  }
  function A(p, m, y, x, S, C) {
    const M = o(p, m, y, x, S, C)
    y.transmission > 0
      ? i.unshift(M)
      : y.transparent === !0
      ? r.unshift(M)
      : t.unshift(M)
  }
  function c(p, m) {
    t.length > 1 && t.sort(p || hk),
      i.length > 1 && i.sort(m || q_),
      r.length > 1 && r.sort(m || q_)
  }
  function d() {
    for (let p = e, m = n.length; p < m; p++) {
      const y = n[p]
      if (y.id === null) break
      ;(y.id = null),
        (y.object = null),
        (y.geometry = null),
        (y.material = null),
        (y.group = null)
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: A,
    finish: d,
    sort: c,
  }
}
function dk() {
  let n = new WeakMap()
  function e(i, r) {
    let s
    return (
      n.has(i) === !1
        ? ((s = new F_()), n.set(i, [s]))
        : r >= n.get(i).length
        ? ((s = new F_()), n.get(i).push(s))
        : (s = n.get(i)[r]),
      s
    )
  }
  function t() {
    n = new WeakMap()
  }
  return { get: e, dispose: t }
}
function pk() {
  const n = {}
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id]
      let t
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new X(), color: new Ke() }
          break
        case "SpotLight":
          t = {
            position: new X(),
            direction: new X(),
            color: new Ke(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          }
          break
        case "PointLight":
          t = { position: new X(), color: new Ke(), distance: 0, decay: 0 }
          break
        case "HemisphereLight":
          t = { direction: new X(), skyColor: new Ke(), groundColor: new Ke() }
          break
        case "RectAreaLight":
          t = {
            color: new Ke(),
            position: new X(),
            halfWidth: new X(),
            halfHeight: new X(),
          }
          break
      }
      return (n[e.id] = t), t
    },
  }
}
function mk() {
  const n = {}
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id]
      let t
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe(),
          }
          break
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe(),
          }
          break
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new qe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          }
          break
      }
      return (n[e.id] = t), t
    },
  }
}
let gk = 0
function yk(n, e) {
  return (e.castShadow ? 1 : 0) - (n.castShadow ? 1 : 0)
}
function vk(n, e) {
  const t = new pk(),
    i = mk(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
    }
  for (let d = 0; d < 9; d++) r.probe.push(new X())
  const s = new X(),
    o = new mt(),
    a = new mt()
  function A(d, p) {
    let m = 0,
      y = 0,
      x = 0
    for (let W = 0; W < 9; W++) r.probe[W].set(0, 0, 0)
    let S = 0,
      C = 0,
      M = 0,
      _ = 0,
      R = 0,
      T = 0,
      L = 0,
      B = 0
    d.sort(yk)
    const k = p !== !0 ? Math.PI : 1
    for (let W = 0, z = d.length; W < z; W++) {
      const P = d[W],
        N = P.color,
        G = P.intensity,
        j = P.distance,
        V = P.shadow && P.shadow.map ? P.shadow.map.texture : null
      if (P.isAmbientLight)
        (m += N.r * G * k), (y += N.g * G * k), (x += N.b * G * k)
      else if (P.isLightProbe)
        for (let Y = 0; Y < 9; Y++)
          r.probe[Y].addScaledVector(P.sh.coefficients[Y], G)
      else if (P.isDirectionalLight) {
        const Y = t.get(P)
        if (
          (Y.color.copy(P.color).multiplyScalar(P.intensity * k), P.castShadow)
        ) {
          const ne = P.shadow,
            le = i.get(P)
          ;(le.shadowBias = ne.bias),
            (le.shadowNormalBias = ne.normalBias),
            (le.shadowRadius = ne.radius),
            (le.shadowMapSize = ne.mapSize),
            (r.directionalShadow[S] = le),
            (r.directionalShadowMap[S] = V),
            (r.directionalShadowMatrix[S] = P.shadow.matrix),
            T++
        }
        ;(r.directional[S] = Y), S++
      } else if (P.isSpotLight) {
        const Y = t.get(P)
        if (
          (Y.position.setFromMatrixPosition(P.matrixWorld),
          Y.color.copy(N).multiplyScalar(G * k),
          (Y.distance = j),
          (Y.coneCos = Math.cos(P.angle)),
          (Y.penumbraCos = Math.cos(P.angle * (1 - P.penumbra))),
          (Y.decay = P.decay),
          P.castShadow)
        ) {
          const ne = P.shadow,
            le = i.get(P)
          ;(le.shadowBias = ne.bias),
            (le.shadowNormalBias = ne.normalBias),
            (le.shadowRadius = ne.radius),
            (le.shadowMapSize = ne.mapSize),
            (r.spotShadow[M] = le),
            (r.spotShadowMap[M] = V),
            (r.spotShadowMatrix[M] = P.shadow.matrix),
            B++
        }
        ;(r.spot[M] = Y), M++
      } else if (P.isRectAreaLight) {
        const Y = t.get(P)
        Y.color.copy(N).multiplyScalar(G),
          Y.halfWidth.set(P.width * 0.5, 0, 0),
          Y.halfHeight.set(0, P.height * 0.5, 0),
          (r.rectArea[_] = Y),
          _++
      } else if (P.isPointLight) {
        const Y = t.get(P)
        if (
          (Y.color.copy(P.color).multiplyScalar(P.intensity * k),
          (Y.distance = P.distance),
          (Y.decay = P.decay),
          P.castShadow)
        ) {
          const ne = P.shadow,
            le = i.get(P)
          ;(le.shadowBias = ne.bias),
            (le.shadowNormalBias = ne.normalBias),
            (le.shadowRadius = ne.radius),
            (le.shadowMapSize = ne.mapSize),
            (le.shadowCameraNear = ne.camera.near),
            (le.shadowCameraFar = ne.camera.far),
            (r.pointShadow[C] = le),
            (r.pointShadowMap[C] = V),
            (r.pointShadowMatrix[C] = P.shadow.matrix),
            L++
        }
        ;(r.point[C] = Y), C++
      } else if (P.isHemisphereLight) {
        const Y = t.get(P)
        Y.skyColor.copy(P.color).multiplyScalar(G * k),
          Y.groundColor.copy(P.groundColor).multiplyScalar(G * k),
          (r.hemi[R] = Y),
          R++
      }
    }
    _ > 0 &&
      (e.isWebGL2 || n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = et.LTC_FLOAT_1), (r.rectAreaLTC2 = et.LTC_FLOAT_2))
        : n.has("OES_texture_half_float_linear") === !0
        ? ((r.rectAreaLTC1 = et.LTC_HALF_1), (r.rectAreaLTC2 = et.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (r.ambient[0] = m),
      (r.ambient[1] = y),
      (r.ambient[2] = x)
    const O = r.hash
    ;(O.directionalLength !== S ||
      O.pointLength !== C ||
      O.spotLength !== M ||
      O.rectAreaLength !== _ ||
      O.hemiLength !== R ||
      O.numDirectionalShadows !== T ||
      O.numPointShadows !== L ||
      O.numSpotShadows !== B) &&
      ((r.directional.length = S),
      (r.spot.length = M),
      (r.rectArea.length = _),
      (r.point.length = C),
      (r.hemi.length = R),
      (r.directionalShadow.length = T),
      (r.directionalShadowMap.length = T),
      (r.pointShadow.length = L),
      (r.pointShadowMap.length = L),
      (r.spotShadow.length = B),
      (r.spotShadowMap.length = B),
      (r.directionalShadowMatrix.length = T),
      (r.pointShadowMatrix.length = L),
      (r.spotShadowMatrix.length = B),
      (O.directionalLength = S),
      (O.pointLength = C),
      (O.spotLength = M),
      (O.rectAreaLength = _),
      (O.hemiLength = R),
      (O.numDirectionalShadows = T),
      (O.numPointShadows = L),
      (O.numSpotShadows = B),
      (r.version = gk++))
  }
  function c(d, p) {
    let m = 0,
      y = 0,
      x = 0,
      S = 0,
      C = 0
    const M = p.matrixWorldInverse
    for (let _ = 0, R = d.length; _ < R; _++) {
      const T = d[_]
      if (T.isDirectionalLight) {
        const L = r.directional[m]
        L.direction.setFromMatrixPosition(T.matrixWorld),
          s.setFromMatrixPosition(T.target.matrixWorld),
          L.direction.sub(s),
          L.direction.transformDirection(M),
          m++
      } else if (T.isSpotLight) {
        const L = r.spot[x]
        L.position.setFromMatrixPosition(T.matrixWorld),
          L.position.applyMatrix4(M),
          L.direction.setFromMatrixPosition(T.matrixWorld),
          s.setFromMatrixPosition(T.target.matrixWorld),
          L.direction.sub(s),
          L.direction.transformDirection(M),
          x++
      } else if (T.isRectAreaLight) {
        const L = r.rectArea[S]
        L.position.setFromMatrixPosition(T.matrixWorld),
          L.position.applyMatrix4(M),
          a.identity(),
          o.copy(T.matrixWorld),
          o.premultiply(M),
          a.extractRotation(o),
          L.halfWidth.set(T.width * 0.5, 0, 0),
          L.halfHeight.set(0, T.height * 0.5, 0),
          L.halfWidth.applyMatrix4(a),
          L.halfHeight.applyMatrix4(a),
          S++
      } else if (T.isPointLight) {
        const L = r.point[y]
        L.position.setFromMatrixPosition(T.matrixWorld),
          L.position.applyMatrix4(M),
          y++
      } else if (T.isHemisphereLight) {
        const L = r.hemi[C]
        L.direction.setFromMatrixPosition(T.matrixWorld),
          L.direction.transformDirection(M),
          L.direction.normalize(),
          C++
      }
    }
  }
  return { setup: A, setupView: c, state: r }
}
function N_(n, e) {
  const t = new vk(n, e),
    i = [],
    r = []
  function s() {
    ;(i.length = 0), (r.length = 0)
  }
  function o(p) {
    i.push(p)
  }
  function a(p) {
    r.push(p)
  }
  function A(p) {
    t.setup(i, p)
  }
  function c(p) {
    t.setupView(i, p)
  }
  return {
    init: s,
    state: { lightsArray: i, shadowsArray: r, lights: t },
    setupLights: A,
    setupLightsView: c,
    pushLight: o,
    pushShadow: a,
  }
}
function _k(n, e) {
  let t = new WeakMap()
  function i(s, o = 0) {
    let a
    return (
      t.has(s) === !1
        ? ((a = new N_(n, e)), t.set(s, [a]))
        : o >= t.get(s).length
        ? ((a = new N_(n, e)), t.get(s).push(a))
        : (a = t.get(s)[o]),
      a
    )
  }
  function r() {
    t = new WeakMap()
  }
  return { get: i, dispose: r }
}
class Rd extends ii {
  constructor(e) {
    super(),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = m5),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    )
  }
}
Rd.prototype.isMeshDepthMaterial = !0
class Pd extends ii {
  constructor(e) {
    super(),
      (this.type = "MeshDistanceMaterial"),
      (this.referencePosition = new X()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.referencePosition.copy(e.referencePosition),
      (this.nearDistance = e.nearDistance),
      (this.farDistance = e.farDistance),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    )
  }
}
Pd.prototype.isMeshDistanceMaterial = !0
const xk = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  bk = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`
function H5(n, e, t) {
  let i = new Fu()
  const r = new qe(),
    s = new qe(),
    o = new en(),
    a = new Rd({ depthPacking: g5 }),
    A = new Pd(),
    c = {},
    d = t.maxTextureSize,
    p = { 0: Pn, 1: Na, 2: ls },
    m = new ar({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new qe() },
        radius: { value: 4 },
      },
      vertexShader: xk,
      fragmentShader: bk,
    }),
    y = m.clone()
  y.defines.HORIZONTAL_PASS = 1
  const x = new yt()
  x.setAttribute(
    "position",
    new Bt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  )
  const S = new Xt(x, m),
    C = this
  ;(this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Zg),
    (this.render = function (T, L, B) {
      if (
        C.enabled === !1 ||
        (C.autoUpdate === !1 && C.needsUpdate === !1) ||
        T.length === 0
      )
        return
      const k = n.getRenderTarget(),
        O = n.getActiveCubeFace(),
        W = n.getActiveMipmapLevel(),
        z = n.state
      z.setBlending(Ds),
        z.buffers.color.setClear(1, 1, 1, 1),
        z.buffers.depth.setTest(!0),
        z.setScissorTest(!1)
      for (let P = 0, N = T.length; P < N; P++) {
        const G = T[P],
          j = G.shadow
        if (j === void 0) {
          console.warn("THREE.WebGLShadowMap:", G, "has no shadow.")
          continue
        }
        if (j.autoUpdate === !1 && j.needsUpdate === !1) continue
        r.copy(j.mapSize)
        const V = j.getFrameExtents()
        if (
          (r.multiply(V),
          s.copy(j.mapSize),
          (r.x > d || r.y > d) &&
            (r.x > d &&
              ((s.x = Math.floor(d / V.x)),
              (r.x = s.x * V.x),
              (j.mapSize.x = s.x)),
            r.y > d &&
              ((s.y = Math.floor(d / V.y)),
              (r.y = s.y * V.y),
              (j.mapSize.y = s.y))),
          j.map === null && !j.isPointLightShadow && this.type === Ul)
        ) {
          const ne = { minFilter: Mn, magFilter: Mn, format: Ai }
          ;(j.map = new rr(r.x, r.y, ne)),
            (j.map.texture.name = G.name + ".shadowMap"),
            (j.mapPass = new rr(r.x, r.y, ne)),
            j.camera.updateProjectionMatrix()
        }
        if (j.map === null) {
          const ne = { minFilter: On, magFilter: On, format: Ai }
          ;(j.map = new rr(r.x, r.y, ne)),
            (j.map.texture.name = G.name + ".shadowMap"),
            j.camera.updateProjectionMatrix()
        }
        n.setRenderTarget(j.map), n.clear()
        const Y = j.getViewportCount()
        for (let ne = 0; ne < Y; ne++) {
          const le = j.getViewport(ne)
          o.set(s.x * le.x, s.y * le.y, s.x * le.z, s.y * le.w),
            z.viewport(o),
            j.updateMatrices(G, ne),
            (i = j.getFrustum()),
            R(L, B, j.camera, G, this.type)
        }
        !j.isPointLightShadow && this.type === Ul && M(j, B),
          (j.needsUpdate = !1)
      }
      ;(C.needsUpdate = !1), n.setRenderTarget(k, O, W)
    })
  function M(T, L) {
    const B = e.update(S)
    m.defines.VSM_SAMPLES !== T.blurSamples &&
      ((m.defines.VSM_SAMPLES = T.blurSamples),
      (y.defines.VSM_SAMPLES = T.blurSamples),
      (m.needsUpdate = !0),
      (y.needsUpdate = !0)),
      (m.uniforms.shadow_pass.value = T.map.texture),
      (m.uniforms.resolution.value = T.mapSize),
      (m.uniforms.radius.value = T.radius),
      n.setRenderTarget(T.mapPass),
      n.clear(),
      n.renderBufferDirect(L, null, B, m, S, null),
      (y.uniforms.shadow_pass.value = T.mapPass.texture),
      (y.uniforms.resolution.value = T.mapSize),
      (y.uniforms.radius.value = T.radius),
      n.setRenderTarget(T.map),
      n.clear(),
      n.renderBufferDirect(L, null, B, y, S, null)
  }
  function _(T, L, B, k, O, W, z) {
    let P = null
    const N =
      k.isPointLight === !0 ? T.customDistanceMaterial : T.customDepthMaterial
    if (
      (N !== void 0 ? (P = N) : (P = k.isPointLight === !0 ? A : a),
      (n.localClippingEnabled &&
        B.clipShadows === !0 &&
        B.clippingPlanes.length !== 0) ||
        (B.displacementMap && B.displacementScale !== 0) ||
        (B.alphaMap && B.alphaTest > 0))
    ) {
      const G = P.uuid,
        j = B.uuid
      let V = c[G]
      V === void 0 && ((V = {}), (c[G] = V))
      let Y = V[j]
      Y === void 0 && ((Y = P.clone()), (V[j] = Y)), (P = Y)
    }
    return (
      (P.visible = B.visible),
      (P.wireframe = B.wireframe),
      z === Ul
        ? (P.side = B.shadowSide !== null ? B.shadowSide : B.side)
        : (P.side = B.shadowSide !== null ? B.shadowSide : p[B.side]),
      (P.alphaMap = B.alphaMap),
      (P.alphaTest = B.alphaTest),
      (P.clipShadows = B.clipShadows),
      (P.clippingPlanes = B.clippingPlanes),
      (P.clipIntersection = B.clipIntersection),
      (P.displacementMap = B.displacementMap),
      (P.displacementScale = B.displacementScale),
      (P.displacementBias = B.displacementBias),
      (P.wireframeLinewidth = B.wireframeLinewidth),
      (P.linewidth = B.linewidth),
      k.isPointLight === !0 &&
        P.isMeshDistanceMaterial === !0 &&
        (P.referencePosition.setFromMatrixPosition(k.matrixWorld),
        (P.nearDistance = O),
        (P.farDistance = W)),
      P
    )
  }
  function R(T, L, B, k, O) {
    if (T.visible === !1) return
    if (
      T.layers.test(L.layers) &&
      (T.isMesh || T.isLine || T.isPoints) &&
      (T.castShadow || (T.receiveShadow && O === Ul)) &&
      (!T.frustumCulled || i.intersectsObject(T))
    ) {
      T.modelViewMatrix.multiplyMatrices(B.matrixWorldInverse, T.matrixWorld)
      const P = e.update(T),
        N = T.material
      if (Array.isArray(N)) {
        const G = P.groups
        for (let j = 0, V = G.length; j < V; j++) {
          const Y = G[j],
            ne = N[Y.materialIndex]
          if (ne && ne.visible) {
            const le = _(T, P, ne, k, B.near, B.far, O)
            n.renderBufferDirect(B, null, P, le, T, Y)
          }
        }
      } else if (N.visible) {
        const G = _(T, P, N, k, B.near, B.far, O)
        n.renderBufferDirect(B, null, P, G, T, null)
      }
    }
    const z = T.children
    for (let P = 0, N = z.length; P < N; P++) R(z[P], L, B, k, O)
  }
}
function wk(n, e, t) {
  const i = t.isWebGL2
  function r() {
    let de = !1
    const it = new en()
    let tt = null
    const ft = new en(0, 0, 0, 0)
    return {
      setMask: function (De) {
        tt !== De && !de && (n.colorMask(De, De, De, De), (tt = De))
      },
      setLocked: function (De) {
        de = De
      },
      setClear: function (De, ht, Ft, an, vi) {
        vi === !0 && ((De *= an), (ht *= an), (Ft *= an)),
          it.set(De, ht, Ft, an),
          ft.equals(it) === !1 && (n.clearColor(De, ht, Ft, an), ft.copy(it))
      },
      reset: function () {
        ;(de = !1), (tt = null), ft.set(-1, 0, 0, 0)
      },
    }
  }
  function s() {
    let de = !1,
      it = null,
      tt = null,
      ft = null
    return {
      setTest: function (De) {
        De ? K(2929) : Oe(2929)
      },
      setMask: function (De) {
        it !== De && !de && (n.depthMask(De), (it = De))
      },
      setFunc: function (De) {
        if (tt !== De) {
          if (De)
            switch (De) {
              case q4:
                n.depthFunc(512)
                break
              case F4:
                n.depthFunc(519)
                break
              case N4:
                n.depthFunc(513)
                break
              case m0:
                n.depthFunc(515)
                break
              case U4:
                n.depthFunc(514)
                break
              case z4:
                n.depthFunc(518)
                break
              case H4:
                n.depthFunc(516)
                break
              case G4:
                n.depthFunc(517)
                break
              default:
                n.depthFunc(515)
            }
          else n.depthFunc(515)
          tt = De
        }
      },
      setLocked: function (De) {
        de = De
      },
      setClear: function (De) {
        ft !== De && (n.clearDepth(De), (ft = De))
      },
      reset: function () {
        ;(de = !1), (it = null), (tt = null), (ft = null)
      },
    }
  }
  function o() {
    let de = !1,
      it = null,
      tt = null,
      ft = null,
      De = null,
      ht = null,
      Ft = null,
      an = null,
      vi = null
    return {
      setTest: function (yn) {
        de || (yn ? K(2960) : Oe(2960))
      },
      setMask: function (yn) {
        it !== yn && !de && (n.stencilMask(yn), (it = yn))
      },
      setFunc: function (yn, We, Er) {
        ;(tt !== yn || ft !== We || De !== Er) &&
          (n.stencilFunc(yn, We, Er), (tt = yn), (ft = We), (De = Er))
      },
      setOp: function (yn, We, Er) {
        ;(ht !== yn || Ft !== We || an !== Er) &&
          (n.stencilOp(yn, We, Er), (ht = yn), (Ft = We), (an = Er))
      },
      setLocked: function (yn) {
        de = yn
      },
      setClear: function (yn) {
        vi !== yn && (n.clearStencil(yn), (vi = yn))
      },
      reset: function () {
        ;(de = !1),
          (it = null),
          (tt = null),
          (ft = null),
          (De = null),
          (ht = null),
          (Ft = null),
          (an = null),
          (vi = null)
      },
    }
  }
  const a = new r(),
    A = new s(),
    c = new o()
  let d = {},
    p = {},
    m = new WeakMap(),
    y = [],
    x = null,
    S = !1,
    C = null,
    M = null,
    _ = null,
    R = null,
    T = null,
    L = null,
    B = null,
    k = !1,
    O = null,
    W = null,
    z = null,
    P = null,
    N = null
  const G = n.getParameter(35661)
  let j = !1,
    V = 0
  const Y = n.getParameter(7938)
  Y.indexOf("WebGL") !== -1
    ? ((V = parseFloat(/^WebGL (\d)/.exec(Y)[1])), (j = V >= 1))
    : Y.indexOf("OpenGL ES") !== -1 &&
      ((V = parseFloat(/^OpenGL ES (\d)/.exec(Y)[1])), (j = V >= 2))
  let ne = null,
    le = {}
  const Te = n.getParameter(3088),
    Ae = n.getParameter(2978),
    ge = new en().fromArray(Te),
    Me = new en().fromArray(Ae)
  function Ne(de, it, tt) {
    const ft = new Uint8Array(4),
      De = n.createTexture()
    n.bindTexture(de, De),
      n.texParameteri(de, 10241, 9728),
      n.texParameteri(de, 10240, 9728)
    for (let ht = 0; ht < tt; ht++)
      n.texImage2D(it + ht, 0, 6408, 1, 1, 0, 6408, 5121, ft)
    return De
  }
  const Ze = {}
  ;(Ze[3553] = Ne(3553, 3553, 1)),
    (Ze[34067] = Ne(34067, 34069, 6)),
    a.setClear(0, 0, 0, 1),
    A.setClear(1),
    c.setClear(0),
    K(2929),
    A.setFunc(m0),
    q(!1),
    F(Zm),
    K(2884),
    ye(Ds)
  function K(de) {
    d[de] !== !0 && (n.enable(de), (d[de] = !0))
  }
  function Oe(de) {
    d[de] !== !1 && (n.disable(de), (d[de] = !1))
  }
  function ve(de, it) {
    return p[de] !== it
      ? (n.bindFramebuffer(de, it),
        (p[de] = it),
        i && (de === 36009 && (p[36160] = it), de === 36160 && (p[36009] = it)),
        !0)
      : !1
  }
  function Be(de, it) {
    let tt = y,
      ft = !1
    if (de)
      if (
        ((tt = m.get(it)),
        tt === void 0 && ((tt = []), m.set(it, tt)),
        de.isWebGLMultipleRenderTargets)
      ) {
        const De = de.texture
        if (tt.length !== De.length || tt[0] !== 36064) {
          for (let ht = 0, Ft = De.length; ht < Ft; ht++) tt[ht] = 36064 + ht
          ;(tt.length = De.length), (ft = !0)
        }
      } else tt[0] !== 36064 && ((tt[0] = 36064), (ft = !0))
    else tt[0] !== 1029 && ((tt[0] = 1029), (ft = !0))
    ft &&
      (t.isWebGL2
        ? n.drawBuffers(tt)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(tt))
  }
  function Fe(de) {
    return x !== de ? (n.useProgram(de), (x = de), !0) : !1
  }
  const je = { [va]: 32774, [E4]: 32778, [T4]: 32779 }
  if (i) (je[t1] = 32775), (je[n1] = 32776)
  else {
    const de = e.get("EXT_blend_minmax")
    de !== null && ((je[t1] = de.MIN_EXT), (je[n1] = de.MAX_EXT))
  }
  const Ge = {
    [C4]: 0,
    [R4]: 1,
    [P4]: 768,
    [Kg]: 770,
    [O4]: 776,
    [B4]: 774,
    [D4]: 772,
    [L4]: 769,
    [e2]: 771,
    [k4]: 775,
    [I4]: 773,
  }
  function ye(de, it, tt, ft, De, ht, Ft, an) {
    if (de === Ds) {
      S === !0 && (Oe(3042), (S = !1))
      return
    }
    if ((S === !1 && (K(3042), (S = !0)), de !== S4)) {
      if (de !== C || an !== k) {
        if (
          ((M !== va || T !== va) &&
            (n.blendEquation(32774), (M = va), (T = va)),
          an)
        )
          switch (de) {
            case Ro:
              n.blendFuncSeparate(1, 771, 1, 771)
              break
            case Jm:
              n.blendFunc(1, 1)
              break
            case Km:
              n.blendFuncSeparate(0, 769, 0, 1)
              break
            case e1:
              n.blendFuncSeparate(0, 768, 0, 770)
              break
            default:
              console.error("THREE.WebGLState: Invalid blending: ", de)
              break
          }
        else
          switch (de) {
            case Ro:
              n.blendFuncSeparate(770, 771, 1, 771)
              break
            case Jm:
              n.blendFunc(770, 1)
              break
            case Km:
              n.blendFuncSeparate(0, 769, 0, 1)
              break
            case e1:
              n.blendFunc(0, 768)
              break
            default:
              console.error("THREE.WebGLState: Invalid blending: ", de)
              break
          }
        ;(_ = null), (R = null), (L = null), (B = null), (C = de), (k = an)
      }
      return
    }
    ;(De = De || it),
      (ht = ht || tt),
      (Ft = Ft || ft),
      (it !== M || De !== T) &&
        (n.blendEquationSeparate(je[it], je[De]), (M = it), (T = De)),
      (tt !== _ || ft !== R || ht !== L || Ft !== B) &&
        (n.blendFuncSeparate(Ge[tt], Ge[ft], Ge[ht], Ge[Ft]),
        (_ = tt),
        (R = ft),
        (L = ht),
        (B = Ft)),
      (C = de),
      (k = null)
  }
  function D(de, it) {
    de.side === ls ? Oe(2884) : K(2884)
    let tt = de.side === Pn
    it && (tt = !tt),
      q(tt),
      de.blending === Ro && de.transparent === !1
        ? ye(Ds)
        : ye(
            de.blending,
            de.blendEquation,
            de.blendSrc,
            de.blendDst,
            de.blendEquationAlpha,
            de.blendSrcAlpha,
            de.blendDstAlpha,
            de.premultipliedAlpha
          ),
      A.setFunc(de.depthFunc),
      A.setTest(de.depthTest),
      A.setMask(de.depthWrite),
      a.setMask(de.colorWrite)
    const ft = de.stencilWrite
    c.setTest(ft),
      ft &&
        (c.setMask(de.stencilWriteMask),
        c.setFunc(de.stencilFunc, de.stencilRef, de.stencilFuncMask),
        c.setOp(de.stencilFail, de.stencilZFail, de.stencilZPass)),
      oe(de.polygonOffset, de.polygonOffsetFactor, de.polygonOffsetUnits),
      de.alphaToCoverage === !0 ? K(32926) : Oe(32926)
  }
  function q(de) {
    O !== de && (de ? n.frontFace(2304) : n.frontFace(2305), (O = de))
  }
  function F(de) {
    de !== b4
      ? (K(2884),
        de !== W &&
          (de === Zm
            ? n.cullFace(1029)
            : de === w4
            ? n.cullFace(1028)
            : n.cullFace(1032)))
      : Oe(2884),
      (W = de)
  }
  function te(de) {
    de !== z && (j && n.lineWidth(de), (z = de))
  }
  function oe(de, it, tt) {
    de
      ? (K(32823),
        (P !== it || N !== tt) && (n.polygonOffset(it, tt), (P = it), (N = tt)))
      : Oe(32823)
  }
  function ue(de) {
    de ? K(3089) : Oe(3089)
  }
  function Ee(de) {
    de === void 0 && (de = 33984 + G - 1),
      ne !== de && (n.activeTexture(de), (ne = de))
  }
  function Ce(de, it) {
    ne === null && Ee()
    let tt = le[ne]
    tt === void 0 && ((tt = { type: void 0, texture: void 0 }), (le[ne] = tt)),
      (tt.type !== de || tt.texture !== it) &&
        (n.bindTexture(de, it || Ze[de]), (tt.type = de), (tt.texture = it))
  }
  function Se() {
    const de = le[ne]
    de !== void 0 &&
      de.type !== void 0 &&
      (n.bindTexture(de.type, null), (de.type = void 0), (de.texture = void 0))
  }
  function $() {
    try {
      n.compressedTexImage2D.apply(n, arguments)
    } catch (de) {
      console.error("THREE.WebGLState:", de)
    }
  }
  function Q() {
    try {
      n.texSubImage2D.apply(n, arguments)
    } catch (de) {
      console.error("THREE.WebGLState:", de)
    }
  }
  function pe() {
    try {
      n.texSubImage3D.apply(n, arguments)
    } catch (de) {
      console.error("THREE.WebGLState:", de)
    }
  }
  function Re() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments)
    } catch (de) {
      console.error("THREE.WebGLState:", de)
    }
  }
  function Ue() {
    try {
      n.texStorage2D.apply(n, arguments)
    } catch (de) {
      console.error("THREE.WebGLState:", de)
    }
  }
  function _e() {
    try {
      n.texStorage3D.apply(n, arguments)
    } catch (de) {
      console.error("THREE.WebGLState:", de)
    }
  }
  function Xe() {
    try {
      n.texImage2D.apply(n, arguments)
    } catch (de) {
      console.error("THREE.WebGLState:", de)
    }
  }
  function se() {
    try {
      n.texImage3D.apply(n, arguments)
    } catch (de) {
      console.error("THREE.WebGLState:", de)
    }
  }
  function be(de) {
    ge.equals(de) === !1 && (n.scissor(de.x, de.y, de.z, de.w), ge.copy(de))
  }
  function ze(de) {
    Me.equals(de) === !1 && (n.viewport(de.x, de.y, de.z, de.w), Me.copy(de))
  }
  function at() {
    n.disable(3042),
      n.disable(2884),
      n.disable(2929),
      n.disable(32823),
      n.disable(3089),
      n.disable(2960),
      n.disable(32926),
      n.blendEquation(32774),
      n.blendFunc(1, 0),
      n.blendFuncSeparate(1, 0, 1, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(513),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(519, 0, 4294967295),
      n.stencilOp(7680, 7680, 7680),
      n.clearStencil(0),
      n.cullFace(1029),
      n.frontFace(2305),
      n.polygonOffset(0, 0),
      n.activeTexture(33984),
      n.bindFramebuffer(36160, null),
      i === !0 &&
        (n.bindFramebuffer(36009, null), n.bindFramebuffer(36008, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (d = {}),
      (ne = null),
      (le = {}),
      (p = {}),
      (m = new WeakMap()),
      (y = []),
      (x = null),
      (S = !1),
      (C = null),
      (M = null),
      (_ = null),
      (R = null),
      (T = null),
      (L = null),
      (B = null),
      (k = !1),
      (O = null),
      (W = null),
      (z = null),
      (P = null),
      (N = null),
      ge.set(0, 0, n.canvas.width, n.canvas.height),
      Me.set(0, 0, n.canvas.width, n.canvas.height),
      a.reset(),
      A.reset(),
      c.reset()
  }
  return {
    buffers: { color: a, depth: A, stencil: c },
    enable: K,
    disable: Oe,
    bindFramebuffer: ve,
    drawBuffers: Be,
    useProgram: Fe,
    setBlending: ye,
    setMaterial: D,
    setFlipSided: q,
    setCullFace: F,
    setLineWidth: te,
    setPolygonOffset: oe,
    setScissorTest: ue,
    activeTexture: Ee,
    bindTexture: Ce,
    unbindTexture: Se,
    compressedTexImage2D: $,
    texImage2D: Xe,
    texImage3D: se,
    texStorage2D: Ue,
    texStorage3D: _e,
    texSubImage2D: Q,
    texSubImage3D: pe,
    compressedTexSubImage2D: Re,
    scissor: be,
    viewport: ze,
    reset: at,
  }
}
function Mk(n, e, t, i, r, s, o) {
  const a = r.isWebGL2,
    A = r.maxTextures,
    c = r.maxCubemapSize,
    d = r.maxTextureSize,
    p = r.maxSamples,
    y = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : void 0,
    x = new WeakMap()
  let S,
    C = !1
  try {
    C =
      typeof OffscreenCanvas != "undefined" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null
  } catch {}
  function M($, Q) {
    return C ? new OffscreenCanvas($, Q) : iu("canvas")
  }
  function _($, Q, pe, Re) {
    let Ue = 1
    if (
      (($.width > Re || $.height > Re) &&
        (Ue = Re / Math.max($.width, $.height)),
      Ue < 1 || Q === !0)
    )
      if (
        (typeof HTMLImageElement != "undefined" &&
          $ instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement != "undefined" &&
          $ instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap != "undefined" && $ instanceof ImageBitmap)
      ) {
        const _e = Q ? x5 : Math.floor,
          Xe = _e(Ue * $.width),
          se = _e(Ue * $.height)
        S === void 0 && (S = M(Xe, se))
        const be = pe ? M(Xe, se) : S
        return (
          (be.width = Xe),
          (be.height = se),
          be.getContext("2d").drawImage($, 0, 0, Xe, se),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              $.width +
              "x" +
              $.height +
              ") to (" +
              Xe +
              "x" +
              se +
              ")."
          ),
          be
        )
      } else
        return (
          "data" in $ &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                $.width +
                "x" +
                $.height +
                ")."
            ),
          $
        )
    return $
  }
  function R($) {
    return E1($.width) && E1($.height)
  }
  function T($) {
    return a
      ? !1
      : $.wrapS !== ci ||
          $.wrapT !== ci ||
          ($.minFilter !== On && $.minFilter !== Mn)
  }
  function L($, Q) {
    return $.generateMipmaps && Q && $.minFilter !== On && $.minFilter !== Mn
  }
  function B($) {
    n.generateMipmap($)
  }
  function k($, Q, pe, Re, Ue = !1) {
    if (a === !1) return Q
    if ($ !== null) {
      if (n[$] !== void 0) return n[$]
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          $ +
          "'"
      )
    }
    let _e = Q
    return (
      Q === 6403 &&
        (pe === 5126 && (_e = 33326),
        pe === 5131 && (_e = 33325),
        pe === 5121 && (_e = 33321)),
      Q === 33319 &&
        (pe === 5126 && (_e = 33328),
        pe === 5131 && (_e = 33327),
        pe === 5121 && (_e = 33323)),
      Q === 6408 &&
        (pe === 5126 && (_e = 34836),
        pe === 5131 && (_e = 34842),
        pe === 5121 && (_e = Re === pn && Ue === !1 ? 35907 : 32856),
        pe === 32819 && (_e = 32854),
        pe === 32820 && (_e = 32855)),
      (_e === 33325 ||
        _e === 33326 ||
        _e === 33327 ||
        _e === 33328 ||
        _e === 34842 ||
        _e === 34836) &&
        e.get("EXT_color_buffer_float"),
      _e
    )
  }
  function O($, Q, pe) {
    return L($, pe) === !0 ||
      ($.isFramebufferTexture && $.minFilter !== On && $.minFilter !== Mn)
      ? Math.log2(Math.max(Q.width, Q.height)) + 1
      : $.mipmaps !== void 0 && $.mipmaps.length > 0
      ? $.mipmaps.length
      : $.isCompressedTexture && Array.isArray($.image)
      ? Q.mipmaps.length
      : 1
  }
  function W($) {
    return $ === On || $ === g0 || $ === y0 ? 9728 : 9729
  }
  function z($) {
    const Q = $.target
    Q.removeEventListener("dispose", z),
      N(Q),
      Q.isVideoTexture && x.delete(Q),
      o.memory.textures--
  }
  function P($) {
    const Q = $.target
    Q.removeEventListener("dispose", P), G(Q)
  }
  function N($) {
    const Q = i.get($)
    Q.__webglInit !== void 0 && (n.deleteTexture(Q.__webglTexture), i.remove($))
  }
  function G($) {
    const Q = $.texture,
      pe = i.get($),
      Re = i.get(Q)
    if (!!$) {
      if (
        (Re.__webglTexture !== void 0 &&
          (n.deleteTexture(Re.__webglTexture), o.memory.textures--),
        $.depthTexture && $.depthTexture.dispose(),
        $.isWebGLCubeRenderTarget)
      )
        for (let Ue = 0; Ue < 6; Ue++)
          n.deleteFramebuffer(pe.__webglFramebuffer[Ue]),
            pe.__webglDepthbuffer &&
              n.deleteRenderbuffer(pe.__webglDepthbuffer[Ue])
      else
        n.deleteFramebuffer(pe.__webglFramebuffer),
          pe.__webglDepthbuffer && n.deleteRenderbuffer(pe.__webglDepthbuffer),
          pe.__webglMultisampledFramebuffer &&
            n.deleteFramebuffer(pe.__webglMultisampledFramebuffer),
          pe.__webglColorRenderbuffer &&
            n.deleteRenderbuffer(pe.__webglColorRenderbuffer),
          pe.__webglDepthRenderbuffer &&
            n.deleteRenderbuffer(pe.__webglDepthRenderbuffer)
      if ($.isWebGLMultipleRenderTargets)
        for (let Ue = 0, _e = Q.length; Ue < _e; Ue++) {
          const Xe = i.get(Q[Ue])
          Xe.__webglTexture &&
            (n.deleteTexture(Xe.__webglTexture), o.memory.textures--),
            i.remove(Q[Ue])
        }
      i.remove(Q), i.remove($)
    }
  }
  let j = 0
  function V() {
    j = 0
  }
  function Y() {
    const $ = j
    return (
      $ >= A &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            $ +
            " texture units while this GPU supports only " +
            A
        ),
      (j += 1),
      $
    )
  }
  function ne($, Q) {
    const pe = i.get($)
    if (
      ($.isVideoTexture && te($), $.version > 0 && pe.__version !== $.version)
    ) {
      const Re = $.image
      if (Re === void 0)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is undefined"
        )
      else if (Re.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        )
      else {
        K(pe, $, Q)
        return
      }
    }
    t.activeTexture(33984 + Q), t.bindTexture(3553, pe.__webglTexture)
  }
  function le($, Q) {
    const pe = i.get($)
    if ($.version > 0 && pe.__version !== $.version) {
      K(pe, $, Q)
      return
    }
    t.activeTexture(33984 + Q), t.bindTexture(35866, pe.__webglTexture)
  }
  function Te($, Q) {
    const pe = i.get($)
    if ($.version > 0 && pe.__version !== $.version) {
      K(pe, $, Q)
      return
    }
    t.activeTexture(33984 + Q), t.bindTexture(32879, pe.__webglTexture)
  }
  function Ae($, Q) {
    const pe = i.get($)
    if ($.version > 0 && pe.__version !== $.version) {
      Oe(pe, $, Q)
      return
    }
    t.activeTexture(33984 + Q), t.bindTexture(34067, pe.__webglTexture)
  }
  const ge = { [ZA]: 10497, [ci]: 33071, [JA]: 33648 },
    Me = {
      [On]: 9728,
      [g0]: 9984,
      [y0]: 9986,
      [Mn]: 9729,
      [t2]: 9985,
      [nl]: 9987,
    }
  function Ne($, Q, pe) {
    if (
      (pe
        ? (n.texParameteri($, 10242, ge[Q.wrapS]),
          n.texParameteri($, 10243, ge[Q.wrapT]),
          ($ === 32879 || $ === 35866) &&
            n.texParameteri($, 32882, ge[Q.wrapR]),
          n.texParameteri($, 10240, Me[Q.magFilter]),
          n.texParameteri($, 10241, Me[Q.minFilter]))
        : (n.texParameteri($, 10242, 33071),
          n.texParameteri($, 10243, 33071),
          ($ === 32879 || $ === 35866) && n.texParameteri($, 32882, 33071),
          (Q.wrapS !== ci || Q.wrapT !== ci) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          n.texParameteri($, 10240, W(Q.magFilter)),
          n.texParameteri($, 10241, W(Q.minFilter)),
          Q.minFilter !== On &&
            Q.minFilter !== Mn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const Re = e.get("EXT_texture_filter_anisotropic")
      if (
        (Q.type === Rs && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          Q.type === La &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return
      ;(Q.anisotropy > 1 || i.get(Q).__currentAnisotropy) &&
        (n.texParameterf(
          $,
          Re.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(Q.anisotropy, r.getMaxAnisotropy())
        ),
        (i.get(Q).__currentAnisotropy = Q.anisotropy))
    }
  }
  function Ze($, Q) {
    $.__webglInit === void 0 &&
      (($.__webglInit = !0),
      Q.addEventListener("dispose", z),
      ($.__webglTexture = n.createTexture()),
      o.memory.textures++)
  }
  function K($, Q, pe) {
    let Re = 3553
    Q.isDataTexture2DArray && (Re = 35866),
      Q.isDataTexture3D && (Re = 32879),
      Ze($, Q),
      t.activeTexture(33984 + pe),
      t.bindTexture(Re, $.__webglTexture),
      n.pixelStorei(37440, Q.flipY),
      n.pixelStorei(37441, Q.premultiplyAlpha),
      n.pixelStorei(3317, Q.unpackAlignment),
      n.pixelStorei(37443, 0)
    const Ue = T(Q) && R(Q.image) === !1
    let _e = _(Q.image, Ue, !1, d)
    _e = oe(Q, _e)
    const Xe = R(_e) || a,
      se = s.convert(Q.format, Q.encoding)
    let be = s.convert(Q.type),
      ze = k(Q.internalFormat, se, be, Q.encoding, Q.isVideoTexture)
    Ne(Re, Q, Xe)
    let at
    const de = Q.mipmaps,
      it = a && Q.isVideoTexture !== !0,
      tt = $.__version === void 0,
      ft = O(Q, _e, Xe)
    if (Q.isDepthTexture)
      (ze = 6402),
        a
          ? Q.type === Rs
            ? (ze = 36012)
            : Q.type === BA
            ? (ze = 33190)
            : Q.type === Da
            ? (ze = 35056)
            : (ze = 33189)
          : Q.type === Rs &&
            console.error(
              "WebGLRenderer: Floating point depth texture requires WebGL2."
            ),
        Q.format === Po &&
          ze === 6402 &&
          Q.type !== mc &&
          Q.type !== BA &&
          (console.warn(
            "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
          ),
          (Q.type = mc),
          (be = s.convert(Q.type))),
        Q.format === Ua &&
          ze === 6402 &&
          ((ze = 34041),
          Q.type !== Da &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
            ),
            (Q.type = Da),
            (be = s.convert(Q.type)))),
        it && tt
          ? t.texStorage2D(3553, 1, ze, _e.width, _e.height)
          : t.texImage2D(3553, 0, ze, _e.width, _e.height, 0, se, be, null)
    else if (Q.isDataTexture)
      if (de.length > 0 && Xe) {
        it && tt && t.texStorage2D(3553, ft, ze, de[0].width, de[0].height)
        for (let De = 0, ht = de.length; De < ht; De++)
          (at = de[De]),
            it
              ? t.texSubImage2D(
                  3553,
                  0,
                  0,
                  0,
                  at.width,
                  at.height,
                  se,
                  be,
                  at.data
                )
              : t.texImage2D(
                  3553,
                  De,
                  ze,
                  at.width,
                  at.height,
                  0,
                  se,
                  be,
                  at.data
                )
        Q.generateMipmaps = !1
      } else
        it
          ? (tt && t.texStorage2D(3553, ft, ze, _e.width, _e.height),
            t.texSubImage2D(
              3553,
              0,
              0,
              0,
              _e.width,
              _e.height,
              se,
              be,
              _e.data
            ))
          : t.texImage2D(3553, 0, ze, _e.width, _e.height, 0, se, be, _e.data)
    else if (Q.isCompressedTexture) {
      it && tt && t.texStorage2D(3553, ft, ze, de[0].width, de[0].height)
      for (let De = 0, ht = de.length; De < ht; De++)
        (at = de[De]),
          Q.format !== Ai
            ? se !== null
              ? it
                ? t.compressedTexSubImage2D(
                    3553,
                    De,
                    0,
                    0,
                    at.width,
                    at.height,
                    se,
                    at.data
                  )
                : t.compressedTexImage2D(
                    3553,
                    De,
                    ze,
                    at.width,
                    at.height,
                    0,
                    at.data
                  )
              : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                )
            : it
            ? t.texSubImage2D(
                3553,
                De,
                0,
                0,
                at.width,
                at.height,
                se,
                be,
                at.data
              )
            : t.texImage2D(
                3553,
                De,
                ze,
                at.width,
                at.height,
                0,
                se,
                be,
                at.data
              )
    } else if (Q.isDataTexture2DArray)
      it
        ? (tt && t.texStorage3D(35866, ft, ze, _e.width, _e.height, _e.depth),
          t.texSubImage3D(
            35866,
            0,
            0,
            0,
            0,
            _e.width,
            _e.height,
            _e.depth,
            se,
            be,
            _e.data
          ))
        : t.texImage3D(
            35866,
            0,
            ze,
            _e.width,
            _e.height,
            _e.depth,
            0,
            se,
            be,
            _e.data
          )
    else if (Q.isDataTexture3D)
      it
        ? (tt && t.texStorage3D(32879, ft, ze, _e.width, _e.height, _e.depth),
          t.texSubImage3D(
            32879,
            0,
            0,
            0,
            0,
            _e.width,
            _e.height,
            _e.depth,
            se,
            be,
            _e.data
          ))
        : t.texImage3D(
            32879,
            0,
            ze,
            _e.width,
            _e.height,
            _e.depth,
            0,
            se,
            be,
            _e.data
          )
    else if (Q.isFramebufferTexture)
      it && tt
        ? t.texStorage2D(3553, ft, ze, _e.width, _e.height)
        : t.texImage2D(3553, 0, ze, _e.width, _e.height, 0, se, be, null)
    else if (de.length > 0 && Xe) {
      it && tt && t.texStorage2D(3553, ft, ze, de[0].width, de[0].height)
      for (let De = 0, ht = de.length; De < ht; De++)
        (at = de[De]),
          it
            ? t.texSubImage2D(3553, De, 0, 0, se, be, at)
            : t.texImage2D(3553, De, ze, se, be, at)
      Q.generateMipmaps = !1
    } else
      it
        ? (tt && t.texStorage2D(3553, ft, ze, _e.width, _e.height),
          t.texSubImage2D(3553, 0, 0, 0, se, be, _e))
        : t.texImage2D(3553, 0, ze, se, be, _e)
    L(Q, Xe) && B(Re), ($.__version = Q.version), Q.onUpdate && Q.onUpdate(Q)
  }
  function Oe($, Q, pe) {
    if (Q.image.length !== 6) return
    Ze($, Q),
      t.activeTexture(33984 + pe),
      t.bindTexture(34067, $.__webglTexture),
      n.pixelStorei(37440, Q.flipY),
      n.pixelStorei(37441, Q.premultiplyAlpha),
      n.pixelStorei(3317, Q.unpackAlignment),
      n.pixelStorei(37443, 0)
    const Re = Q && (Q.isCompressedTexture || Q.image[0].isCompressedTexture),
      Ue = Q.image[0] && Q.image[0].isDataTexture,
      _e = []
    for (let De = 0; De < 6; De++)
      !Re && !Ue
        ? (_e[De] = _(Q.image[De], !1, !0, c))
        : (_e[De] = Ue ? Q.image[De].image : Q.image[De]),
        (_e[De] = oe(Q, _e[De]))
    const Xe = _e[0],
      se = R(Xe) || a,
      be = s.convert(Q.format, Q.encoding),
      ze = s.convert(Q.type),
      at = k(Q.internalFormat, be, ze, Q.encoding),
      de = a && Q.isVideoTexture !== !0,
      it = $.__version === void 0
    let tt = O(Q, Xe, se)
    Ne(34067, Q, se)
    let ft
    if (Re) {
      de && it && t.texStorage2D(34067, tt, at, Xe.width, Xe.height)
      for (let De = 0; De < 6; De++) {
        ft = _e[De].mipmaps
        for (let ht = 0; ht < ft.length; ht++) {
          const Ft = ft[ht]
          Q.format !== Ai
            ? be !== null
              ? de
                ? t.compressedTexSubImage2D(
                    34069 + De,
                    ht,
                    0,
                    0,
                    Ft.width,
                    Ft.height,
                    be,
                    Ft.data
                  )
                : t.compressedTexImage2D(
                    34069 + De,
                    ht,
                    at,
                    Ft.width,
                    Ft.height,
                    0,
                    Ft.data
                  )
              : console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                )
            : de
            ? t.texSubImage2D(
                34069 + De,
                ht,
                0,
                0,
                Ft.width,
                Ft.height,
                be,
                ze,
                Ft.data
              )
            : t.texImage2D(
                34069 + De,
                ht,
                at,
                Ft.width,
                Ft.height,
                0,
                be,
                ze,
                Ft.data
              )
        }
      }
    } else {
      ;(ft = Q.mipmaps),
        de &&
          it &&
          (ft.length > 0 && tt++,
          t.texStorage2D(34067, tt, at, _e[0].width, _e[0].height))
      for (let De = 0; De < 6; De++)
        if (Ue) {
          de
            ? t.texSubImage2D(
                34069 + De,
                0,
                0,
                0,
                _e[De].width,
                _e[De].height,
                be,
                ze,
                _e[De].data
              )
            : t.texImage2D(
                34069 + De,
                0,
                at,
                _e[De].width,
                _e[De].height,
                0,
                be,
                ze,
                _e[De].data
              )
          for (let ht = 0; ht < ft.length; ht++) {
            const an = ft[ht].image[De].image
            de
              ? t.texSubImage2D(
                  34069 + De,
                  ht + 1,
                  0,
                  0,
                  an.width,
                  an.height,
                  be,
                  ze,
                  an.data
                )
              : t.texImage2D(
                  34069 + De,
                  ht + 1,
                  at,
                  an.width,
                  an.height,
                  0,
                  be,
                  ze,
                  an.data
                )
          }
        } else {
          de
            ? t.texSubImage2D(34069 + De, 0, 0, 0, be, ze, _e[De])
            : t.texImage2D(34069 + De, 0, at, be, ze, _e[De])
          for (let ht = 0; ht < ft.length; ht++) {
            const Ft = ft[ht]
            de
              ? t.texSubImage2D(34069 + De, ht + 1, 0, 0, be, ze, Ft.image[De])
              : t.texImage2D(34069 + De, ht + 1, at, be, ze, Ft.image[De])
          }
        }
    }
    L(Q, se) && B(34067), ($.__version = Q.version), Q.onUpdate && Q.onUpdate(Q)
  }
  function ve($, Q, pe, Re, Ue) {
    const _e = s.convert(pe.format, pe.encoding),
      Xe = s.convert(pe.type),
      se = k(pe.internalFormat, _e, Xe, pe.encoding)
    i.get(Q).__hasExternalTextures ||
      (Ue === 32879 || Ue === 35866
        ? t.texImage3D(Ue, 0, se, Q.width, Q.height, Q.depth, 0, _e, Xe, null)
        : t.texImage2D(Ue, 0, se, Q.width, Q.height, 0, _e, Xe, null)),
      t.bindFramebuffer(36160, $),
      Q.useRenderToTexture
        ? y.framebufferTexture2DMultisampleEXT(
            36160,
            Re,
            Ue,
            i.get(pe).__webglTexture,
            0,
            F(Q)
          )
        : n.framebufferTexture2D(36160, Re, Ue, i.get(pe).__webglTexture, 0),
      t.bindFramebuffer(36160, null)
  }
  function Be($, Q, pe) {
    if ((n.bindRenderbuffer(36161, $), Q.depthBuffer && !Q.stencilBuffer)) {
      let Re = 33189
      if (pe || Q.useRenderToTexture) {
        const Ue = Q.depthTexture
        Ue &&
          Ue.isDepthTexture &&
          (Ue.type === Rs ? (Re = 36012) : Ue.type === BA && (Re = 33190))
        const _e = F(Q)
        Q.useRenderToTexture
          ? y.renderbufferStorageMultisampleEXT(
              36161,
              _e,
              Re,
              Q.width,
              Q.height
            )
          : n.renderbufferStorageMultisample(36161, _e, Re, Q.width, Q.height)
      } else n.renderbufferStorage(36161, Re, Q.width, Q.height)
      n.framebufferRenderbuffer(36160, 36096, 36161, $)
    } else if (Q.depthBuffer && Q.stencilBuffer) {
      const Re = F(Q)
      pe && Q.useRenderbuffer
        ? n.renderbufferStorageMultisample(36161, Re, 35056, Q.width, Q.height)
        : Q.useRenderToTexture
        ? y.renderbufferStorageMultisampleEXT(
            36161,
            Re,
            35056,
            Q.width,
            Q.height
          )
        : n.renderbufferStorage(36161, 34041, Q.width, Q.height),
        n.framebufferRenderbuffer(36160, 33306, 36161, $)
    } else {
      const Re =
          Q.isWebGLMultipleRenderTargets === !0 ? Q.texture[0] : Q.texture,
        Ue = s.convert(Re.format, Re.encoding),
        _e = s.convert(Re.type),
        Xe = k(Re.internalFormat, Ue, _e, Re.encoding),
        se = F(Q)
      pe && Q.useRenderbuffer
        ? n.renderbufferStorageMultisample(36161, se, Xe, Q.width, Q.height)
        : Q.useRenderToTexture
        ? y.renderbufferStorageMultisampleEXT(36161, se, Xe, Q.width, Q.height)
        : n.renderbufferStorage(36161, Xe, Q.width, Q.height)
    }
    n.bindRenderbuffer(36161, null)
  }
  function Fe($, Q) {
    if (Q && Q.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported")
    if (
      (t.bindFramebuffer(36160, $),
      !(Q.depthTexture && Q.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      )
    ;(!i.get(Q.depthTexture).__webglTexture ||
      Q.depthTexture.image.width !== Q.width ||
      Q.depthTexture.image.height !== Q.height) &&
      ((Q.depthTexture.image.width = Q.width),
      (Q.depthTexture.image.height = Q.height),
      (Q.depthTexture.needsUpdate = !0)),
      ne(Q.depthTexture, 0)
    const Re = i.get(Q.depthTexture).__webglTexture,
      Ue = F(Q)
    if (Q.depthTexture.format === Po)
      Q.useRenderToTexture
        ? y.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, Re, 0, Ue)
        : n.framebufferTexture2D(36160, 36096, 3553, Re, 0)
    else if (Q.depthTexture.format === Ua)
      Q.useRenderToTexture
        ? y.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, Re, 0, Ue)
        : n.framebufferTexture2D(36160, 33306, 3553, Re, 0)
    else throw new Error("Unknown depthTexture format")
  }
  function je($) {
    const Q = i.get($),
      pe = $.isWebGLCubeRenderTarget === !0
    if ($.depthTexture && !Q.__autoAllocateDepthBuffer) {
      if (pe)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        )
      Fe(Q.__webglFramebuffer, $)
    } else if (pe) {
      Q.__webglDepthbuffer = []
      for (let Re = 0; Re < 6; Re++)
        t.bindFramebuffer(36160, Q.__webglFramebuffer[Re]),
          (Q.__webglDepthbuffer[Re] = n.createRenderbuffer()),
          Be(Q.__webglDepthbuffer[Re], $, !1)
    } else
      t.bindFramebuffer(36160, Q.__webglFramebuffer),
        (Q.__webglDepthbuffer = n.createRenderbuffer()),
        Be(Q.__webglDepthbuffer, $, !1)
    t.bindFramebuffer(36160, null)
  }
  function Ge($, Q, pe) {
    const Re = i.get($)
    Q !== void 0 && ve(Re.__webglFramebuffer, $, $.texture, 36064, 3553),
      pe !== void 0 && je($)
  }
  function ye($) {
    const Q = $.texture,
      pe = i.get($),
      Re = i.get(Q)
    $.addEventListener("dispose", P),
      $.isWebGLMultipleRenderTargets !== !0 &&
        (Re.__webglTexture === void 0 &&
          (Re.__webglTexture = n.createTexture()),
        (Re.__version = Q.version),
        o.memory.textures++)
    const Ue = $.isWebGLCubeRenderTarget === !0,
      _e = $.isWebGLMultipleRenderTargets === !0,
      Xe = Q.isDataTexture3D || Q.isDataTexture2DArray,
      se = R($) || a
    if (Ue) {
      pe.__webglFramebuffer = []
      for (let be = 0; be < 6; be++)
        pe.__webglFramebuffer[be] = n.createFramebuffer()
    } else if (((pe.__webglFramebuffer = n.createFramebuffer()), _e))
      if (r.drawBuffers) {
        const be = $.texture
        for (let ze = 0, at = be.length; ze < at; ze++) {
          const de = i.get(be[ze])
          de.__webglTexture === void 0 &&
            ((de.__webglTexture = n.createTexture()), o.memory.textures++)
        }
      } else
        console.warn(
          "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
        )
    else if ($.useRenderbuffer)
      if (a) {
        ;(pe.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (pe.__webglColorRenderbuffer = n.createRenderbuffer()),
          n.bindRenderbuffer(36161, pe.__webglColorRenderbuffer)
        const be = s.convert(Q.format, Q.encoding),
          ze = s.convert(Q.type),
          at = k(Q.internalFormat, be, ze, Q.encoding),
          de = F($)
        n.renderbufferStorageMultisample(36161, de, at, $.width, $.height),
          t.bindFramebuffer(36160, pe.__webglMultisampledFramebuffer),
          n.framebufferRenderbuffer(
            36160,
            36064,
            36161,
            pe.__webglColorRenderbuffer
          ),
          n.bindRenderbuffer(36161, null),
          $.depthBuffer &&
            ((pe.__webglDepthRenderbuffer = n.createRenderbuffer()),
            Be(pe.__webglDepthRenderbuffer, $, !0)),
          t.bindFramebuffer(36160, null)
      } else
        console.warn(
          "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
        )
    if (Ue) {
      t.bindTexture(34067, Re.__webglTexture), Ne(34067, Q, se)
      for (let be = 0; be < 6; be++)
        ve(pe.__webglFramebuffer[be], $, Q, 36064, 34069 + be)
      L(Q, se) && B(34067), t.unbindTexture()
    } else if (_e) {
      const be = $.texture
      for (let ze = 0, at = be.length; ze < at; ze++) {
        const de = be[ze],
          it = i.get(de)
        t.bindTexture(3553, it.__webglTexture),
          Ne(3553, de, se),
          ve(pe.__webglFramebuffer, $, de, 36064 + ze, 3553),
          L(de, se) && B(3553)
      }
      t.unbindTexture()
    } else {
      let be = 3553
      Xe &&
        (a
          ? (be = Q.isDataTexture3D ? 32879 : 35866)
          : console.warn(
              "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
            )),
        t.bindTexture(be, Re.__webglTexture),
        Ne(be, Q, se),
        ve(pe.__webglFramebuffer, $, Q, 36064, be),
        L(Q, se) && B(be),
        t.unbindTexture()
    }
    $.depthBuffer && je($)
  }
  function D($) {
    const Q = R($) || a,
      pe = $.isWebGLMultipleRenderTargets === !0 ? $.texture : [$.texture]
    for (let Re = 0, Ue = pe.length; Re < Ue; Re++) {
      const _e = pe[Re]
      if (L(_e, Q)) {
        const Xe = $.isWebGLCubeRenderTarget ? 34067 : 3553,
          se = i.get(_e).__webglTexture
        t.bindTexture(Xe, se), B(Xe), t.unbindTexture()
      }
    }
  }
  function q($) {
    if ($.useRenderbuffer)
      if (a) {
        const Q = $.width,
          pe = $.height
        let Re = 16384
        const Ue = [36064],
          _e = $.stencilBuffer ? 33306 : 36096
        $.depthBuffer && Ue.push(_e),
          $.ignoreDepthForMultisampleCopy ||
            ($.depthBuffer && (Re |= 256), $.stencilBuffer && (Re |= 1024))
        const Xe = i.get($)
        t.bindFramebuffer(36008, Xe.__webglMultisampledFramebuffer),
          t.bindFramebuffer(36009, Xe.__webglFramebuffer),
          $.ignoreDepthForMultisampleCopy &&
            (n.invalidateFramebuffer(36008, [_e]),
            n.invalidateFramebuffer(36009, [_e])),
          n.blitFramebuffer(0, 0, Q, pe, 0, 0, Q, pe, Re, 9728),
          n.invalidateFramebuffer(36008, Ue),
          t.bindFramebuffer(36008, null),
          t.bindFramebuffer(36009, Xe.__webglMultisampledFramebuffer)
      } else
        console.warn(
          "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
        )
  }
  function F($) {
    return a && ($.useRenderbuffer || $.useRenderToTexture)
      ? Math.min(p, $.samples)
      : 0
  }
  function te($) {
    const Q = o.render.frame
    x.get($) !== Q && (x.set($, Q), $.update())
  }
  function oe($, Q) {
    const pe = $.encoding,
      Re = $.format,
      Ue = $.type
    return (
      $.isCompressedTexture === !0 ||
        $.isVideoTexture === !0 ||
        $.format === v0 ||
        (pe !== Ns &&
          (pe === pn
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && Re === Ai
                ? (($.format = v0),
                  ($.minFilter = Mn),
                  ($.generateMipmaps = !1))
                : (Q = Vo.sRGBToLinear(Q))
              : (Re !== Ai || Ue !== Bs) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture encoding:",
                pe
              ))),
      Q
    )
  }
  let ue = !1,
    Ee = !1
  function Ce($, Q) {
    $ &&
      $.isWebGLRenderTarget &&
      (ue === !1 &&
        (console.warn(
          "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
        ),
        (ue = !0)),
      ($ = $.texture)),
      ne($, Q)
  }
  function Se($, Q) {
    $ &&
      $.isWebGLCubeRenderTarget &&
      (Ee === !1 &&
        (console.warn(
          "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
        ),
        (Ee = !0)),
      ($ = $.texture)),
      Ae($, Q)
  }
  ;(this.allocateTextureUnit = Y),
    (this.resetTextureUnits = V),
    (this.setTexture2D = ne),
    (this.setTexture2DArray = le),
    (this.setTexture3D = Te),
    (this.setTextureCube = Ae),
    (this.rebindTextures = Ge),
    (this.setupRenderTarget = ye),
    (this.updateRenderTargetMipmap = D),
    (this.updateMultisampleRenderTarget = q),
    (this.setupDepthRenderbuffer = je),
    (this.setupFrameBufferTexture = ve),
    (this.safeSetTexture2D = Ce),
    (this.safeSetTextureCube = Se)
}
function G5(n, e, t) {
  const i = t.isWebGL2
  function r(s, o = null) {
    let a
    if (s === Bs) return 5121
    if (s === e5) return 32819
    if (s === t5) return 32820
    if (s === Z4) return 5120
    if (s === J4) return 5122
    if (s === mc) return 5123
    if (s === K4) return 5124
    if (s === BA) return 5125
    if (s === Rs) return 5126
    if (s === La)
      return i
        ? 5131
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null)
    if (s === n5) return 6406
    if (s === Ai) return 6408
    if (s === r5) return 6409
    if (s === s5) return 6410
    if (s === Po) return 6402
    if (s === Ua) return 34041
    if (s === o5) return 6403
    if (s === i5)
      return (
        console.warn(
          "THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"
        ),
        6408
      )
    if (s === v0)
      return (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null
    if (s === a5) return 36244
    if (s === l5) return 33319
    if (s === c5) return 33320
    if (s === A5) return 36249
    if (s === zh || s === Hh || s === Gh || s === Vh)
      if (o === pn)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (s === zh) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT
          if (s === Hh) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
          if (s === Gh) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
          if (s === Vh) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } else return null
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (s === zh) return a.COMPRESSED_RGB_S3TC_DXT1_EXT
        if (s === Hh) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT
        if (s === Gh) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT
        if (s === Vh) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } else return null
    if (s === i1 || s === r1 || s === s1 || s === o1)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (s === i1) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        if (s === r1) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
        if (s === s1) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        if (s === o1) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
      } else return null
    if (s === u5)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      )
    if (s === a1 || s === l1)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (s === a1)
          return o === pn ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2
        if (s === l1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC
      } else return null
    if (
      s === c1 ||
      s === A1 ||
      s === u1 ||
      s === f1 ||
      s === h1 ||
      s === d1 ||
      s === p1 ||
      s === m1 ||
      s === g1 ||
      s === y1 ||
      s === v1 ||
      s === _1 ||
      s === x1 ||
      s === b1
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (s === c1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR
        if (s === A1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR
        if (s === u1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR
        if (s === f1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR
        if (s === h1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR
        if (s === d1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR
        if (s === p1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR
        if (s === m1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR
        if (s === g1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR
        if (s === y1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR
        if (s === v1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR
        if (s === _1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR
        if (s === x1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR
        if (s === b1)
          return o === pn
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR
      } else return null
    if (s === w1)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (s === w1)
          return o === pn
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT
      } else return null
    if (s === Da)
      return i
        ? 34042
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
  }
  return { convert: r }
}
class l2 extends ei {
  constructor(e = []) {
    super(), (this.cameras = e)
  }
}
l2.prototype.isArrayCamera = !0
class zi extends kt {
  constructor() {
    super(), (this.type = "Group")
  }
}
zi.prototype.isGroup = !0
const Sk = { type: "move" }
class Kp {
  constructor() {
    ;(this._targetRay = null), (this._grip = null), (this._hand = null)
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new zi()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    )
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new zi()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new X()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new X())),
      this._targetRay
    )
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new zi()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new X()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new X())),
      this._grip
    )
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    )
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    )
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null
    const a = this._targetRay,
      A = this._grip,
      c = this._hand
    if (e && t.session.visibilityState !== "visible-blurred")
      if (
        (a !== null &&
          ((r = t.getPose(e.targetRaySpace, i)),
          r !== null &&
            (a.matrix.fromArray(r.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            r.linearVelocity
              ? ((a.hasLinearVelocity = !0),
                a.linearVelocity.copy(r.linearVelocity))
              : (a.hasLinearVelocity = !1),
            r.angularVelocity
              ? ((a.hasAngularVelocity = !0),
                a.angularVelocity.copy(r.angularVelocity))
              : (a.hasAngularVelocity = !1),
            this.dispatchEvent(Sk))),
        c && e.hand)
      ) {
        o = !0
        for (const S of e.hand.values()) {
          const C = t.getJointPose(S, i)
          if (c.joints[S.jointName] === void 0) {
            const _ = new zi()
            ;(_.matrixAutoUpdate = !1),
              (_.visible = !1),
              (c.joints[S.jointName] = _),
              c.add(_)
          }
          const M = c.joints[S.jointName]
          C !== null &&
            (M.matrix.fromArray(C.transform.matrix),
            M.matrix.decompose(M.position, M.rotation, M.scale),
            (M.jointRadius = C.radius)),
            (M.visible = C !== null)
        }
        const d = c.joints["index-finger-tip"],
          p = c.joints["thumb-tip"],
          m = d.position.distanceTo(p.position),
          y = 0.02,
          x = 0.005
        c.inputState.pinching && m > y + x
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            m <= y - x &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }))
      } else
        A !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (A.matrix.fromArray(s.transform.matrix),
            A.matrix.decompose(A.position, A.rotation, A.scale),
            s.linearVelocity
              ? ((A.hasLinearVelocity = !0),
                A.linearVelocity.copy(s.linearVelocity))
              : (A.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((A.hasAngularVelocity = !0),
                A.angularVelocity.copy(s.angularVelocity))
              : (A.hasAngularVelocity = !1)))
    return (
      a !== null && (a.visible = r !== null),
      A !== null && (A.visible = s !== null),
      c !== null && (c.visible = o !== null),
      this
    )
  }
}
class _0 extends Vn {
  constructor(e, t, i, r, s, o, a, A, c, d) {
    if (((d = d !== void 0 ? d : Po), d !== Po && d !== Ua))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      )
    i === void 0 && d === Po && (i = mc),
      i === void 0 && d === Ua && (i = Da),
      super(null, r, s, o, a, A, d, i, c),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : On),
      (this.minFilter = A !== void 0 ? A : On),
      (this.flipY = !1),
      (this.generateMipmaps = !1)
  }
}
_0.prototype.isDepthTexture = !0
class Ek extends Ys {
  constructor(e, t) {
    super()
    const i = this
    let r = null,
      s = 1,
      o = null,
      a = "local-floor"
    const A = e.extensions.has("WEBGL_multisampled_render_to_texture")
    let c = null,
      d = null,
      p = null,
      m = null,
      y = !1,
      x = null
    const S = t.getContextAttributes()
    let C = null,
      M = null
    const _ = [],
      R = new Map(),
      T = new ei()
    T.layers.enable(1), (T.viewport = new en())
    const L = new ei()
    L.layers.enable(2), (L.viewport = new en())
    const B = [T, L],
      k = new l2()
    k.layers.enable(1), k.layers.enable(2)
    let O = null,
      W = null
    ;(this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (Ae) {
        let ge = _[Ae]
        return (
          ge === void 0 && ((ge = new Kp()), (_[Ae] = ge)),
          ge.getTargetRaySpace()
        )
      }),
      (this.getControllerGrip = function (Ae) {
        let ge = _[Ae]
        return (
          ge === void 0 && ((ge = new Kp()), (_[Ae] = ge)), ge.getGripSpace()
        )
      }),
      (this.getHand = function (Ae) {
        let ge = _[Ae]
        return (
          ge === void 0 && ((ge = new Kp()), (_[Ae] = ge)), ge.getHandSpace()
        )
      })
    function z(Ae) {
      const ge = R.get(Ae.inputSource)
      ge && ge.dispatchEvent({ type: Ae.type, data: Ae.inputSource })
    }
    function P() {
      R.forEach(function (Ae, ge) {
        Ae.disconnect(ge)
      }),
        R.clear(),
        (O = null),
        (W = null),
        e.setRenderTarget(C),
        (m = null),
        (p = null),
        (d = null),
        (r = null),
        (M = null),
        Te.stop(),
        (i.isPresenting = !1),
        i.dispatchEvent({ type: "sessionend" })
    }
    ;(this.setFramebufferScaleFactor = function (Ae) {
      ;(s = Ae),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          )
    }),
      (this.setReferenceSpaceType = function (Ae) {
        ;(a = Ae),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            )
      }),
      (this.getReferenceSpace = function () {
        return o
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : m
      }),
      (this.getBinding = function () {
        return d
      }),
      (this.getFrame = function () {
        return x
      }),
      (this.getSession = function () {
        return r
      }),
      (this.setSession = async function (Ae) {
        if (((r = Ae), r !== null)) {
          if (
            ((C = e.getRenderTarget()),
            r.addEventListener("select", z),
            r.addEventListener("selectstart", z),
            r.addEventListener("selectend", z),
            r.addEventListener("squeeze", z),
            r.addEventListener("squeezestart", z),
            r.addEventListener("squeezeend", z),
            r.addEventListener("end", P),
            r.addEventListener("inputsourceschange", N),
            S.xrCompatible !== !0 && (await t.makeXRCompatible()),
            r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const ge = {
              antialias: r.renderState.layers === void 0 ? S.antialias : !0,
              alpha: S.alpha,
              depth: S.depth,
              stencil: S.stencil,
              framebufferScaleFactor: s,
            }
            ;(m = new XRWebGLLayer(r, t, ge)),
              r.updateRenderState({ baseLayer: m }),
              (M = new rr(m.framebufferWidth, m.framebufferHeight, {
                format: Ai,
                type: Bs,
                encoding: e.outputEncoding,
              }))
          } else {
            y = S.antialias
            let ge = null,
              Me = null,
              Ne = null
            S.depth &&
              ((Ne = S.stencil ? 35056 : 33190),
              (ge = S.stencil ? Ua : Po),
              (Me = S.stencil ? Da : mc))
            const Ze = {
              colorFormat: e.outputEncoding === pn ? 35907 : 32856,
              depthFormat: Ne,
              scaleFactor: s,
            }
            ;(d = new XRWebGLBinding(r, t)),
              (p = d.createProjectionLayer(Ze)),
              r.updateRenderState({ layers: [p] }),
              y
                ? (M = new xd(p.textureWidth, p.textureHeight, {
                    format: Ai,
                    type: Bs,
                    depthTexture: new _0(
                      p.textureWidth,
                      p.textureHeight,
                      Me,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      ge
                    ),
                    stencilBuffer: S.stencil,
                    ignoreDepth: p.ignoreDepthValues,
                    useRenderToTexture: A,
                    encoding: e.outputEncoding,
                  }))
                : (M = new rr(p.textureWidth, p.textureHeight, {
                    format: Ai,
                    type: Bs,
                    depthTexture: new _0(
                      p.textureWidth,
                      p.textureHeight,
                      Me,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      ge
                    ),
                    stencilBuffer: S.stencil,
                    ignoreDepth: p.ignoreDepthValues,
                    encoding: e.outputEncoding,
                  }))
          }
          ;(M.isXRRenderTarget = !0),
            this.setFoveation(1),
            (o = await r.requestReferenceSpace(a)),
            Te.setContext(r),
            Te.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" })
        }
      })
    function N(Ae) {
      const ge = r.inputSources
      for (let Me = 0; Me < _.length; Me++) R.set(ge[Me], _[Me])
      for (let Me = 0; Me < Ae.removed.length; Me++) {
        const Ne = Ae.removed[Me],
          Ze = R.get(Ne)
        Ze &&
          (Ze.dispatchEvent({ type: "disconnected", data: Ne }), R.delete(Ne))
      }
      for (let Me = 0; Me < Ae.added.length; Me++) {
        const Ne = Ae.added[Me],
          Ze = R.get(Ne)
        Ze && Ze.dispatchEvent({ type: "connected", data: Ne })
      }
    }
    const G = new X(),
      j = new X()
    function V(Ae, ge, Me) {
      G.setFromMatrixPosition(ge.matrixWorld),
        j.setFromMatrixPosition(Me.matrixWorld)
      const Ne = G.distanceTo(j),
        Ze = ge.projectionMatrix.elements,
        K = Me.projectionMatrix.elements,
        Oe = Ze[14] / (Ze[10] - 1),
        ve = Ze[14] / (Ze[10] + 1),
        Be = (Ze[9] + 1) / Ze[5],
        Fe = (Ze[9] - 1) / Ze[5],
        je = (Ze[8] - 1) / Ze[0],
        Ge = (K[8] + 1) / K[0],
        ye = Oe * je,
        D = Oe * Ge,
        q = Ne / (-je + Ge),
        F = q * -je
      ge.matrixWorld.decompose(Ae.position, Ae.quaternion, Ae.scale),
        Ae.translateX(F),
        Ae.translateZ(q),
        Ae.matrixWorld.compose(Ae.position, Ae.quaternion, Ae.scale),
        Ae.matrixWorldInverse.copy(Ae.matrixWorld).invert()
      const te = Oe + q,
        oe = ve + q,
        ue = ye - F,
        Ee = D + (Ne - F),
        Ce = ((Be * ve) / oe) * te,
        Se = ((Fe * ve) / oe) * te
      Ae.projectionMatrix.makePerspective(ue, Ee, Ce, Se, te, oe)
    }
    function Y(Ae, ge) {
      ge === null
        ? Ae.matrixWorld.copy(Ae.matrix)
        : Ae.matrixWorld.multiplyMatrices(ge.matrixWorld, Ae.matrix),
        Ae.matrixWorldInverse.copy(Ae.matrixWorld).invert()
    }
    ;(this.updateCamera = function (Ae) {
      if (r === null) return
      ;(k.near = L.near = T.near = Ae.near),
        (k.far = L.far = T.far = Ae.far),
        (O !== k.near || W !== k.far) &&
          (r.updateRenderState({ depthNear: k.near, depthFar: k.far }),
          (O = k.near),
          (W = k.far))
      const ge = Ae.parent,
        Me = k.cameras
      Y(k, ge)
      for (let Ze = 0; Ze < Me.length; Ze++) Y(Me[Ze], ge)
      k.matrixWorld.decompose(k.position, k.quaternion, k.scale),
        Ae.position.copy(k.position),
        Ae.quaternion.copy(k.quaternion),
        Ae.scale.copy(k.scale),
        Ae.matrix.copy(k.matrix),
        Ae.matrixWorld.copy(k.matrixWorld)
      const Ne = Ae.children
      for (let Ze = 0, K = Ne.length; Ze < K; Ze++) Ne[Ze].updateMatrixWorld(!0)
      Me.length === 2 ? V(k, T, L) : k.projectionMatrix.copy(T.projectionMatrix)
    }),
      (this.getCamera = function () {
        return k
      }),
      (this.getFoveation = function () {
        if (p !== null) return p.fixedFoveation
        if (m !== null) return m.fixedFoveation
      }),
      (this.setFoveation = function (Ae) {
        p !== null && (p.fixedFoveation = Ae),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = Ae)
      })
    let ne = null
    function le(Ae, ge) {
      if (((c = ge.getViewerPose(o)), (x = ge), c !== null)) {
        const Ne = c.views
        m !== null &&
          (e.setRenderTargetFramebuffer(M, m.framebuffer), e.setRenderTarget(M))
        let Ze = !1
        Ne.length !== k.cameras.length && ((k.cameras.length = 0), (Ze = !0))
        for (let K = 0; K < Ne.length; K++) {
          const Oe = Ne[K]
          let ve = null
          if (m !== null) ve = m.getViewport(Oe)
          else {
            const Fe = d.getViewSubImage(p, Oe)
            ;(ve = Fe.viewport),
              K === 0 &&
                (e.setRenderTargetTextures(
                  M,
                  Fe.colorTexture,
                  p.ignoreDepthValues ? void 0 : Fe.depthStencilTexture
                ),
                e.setRenderTarget(M))
          }
          const Be = B[K]
          Be.matrix.fromArray(Oe.transform.matrix),
            Be.projectionMatrix.fromArray(Oe.projectionMatrix),
            Be.viewport.set(ve.x, ve.y, ve.width, ve.height),
            K === 0 && k.matrix.copy(Be.matrix),
            Ze === !0 && k.cameras.push(Be)
        }
      }
      const Me = r.inputSources
      for (let Ne = 0; Ne < _.length; Ne++) {
        const Ze = _[Ne],
          K = Me[Ne]
        Ze.update(K, ge, o)
      }
      ne && ne(Ae, ge), (x = null)
    }
    const Te = new D5()
    Te.setAnimationLoop(le),
      (this.setAnimationLoop = function (Ae) {
        ne = Ae
      }),
      (this.dispose = function () {})
  }
}
function Tk(n) {
  function e(M, _) {
    M.fogColor.value.copy(_.color),
      _.isFog
        ? ((M.fogNear.value = _.near), (M.fogFar.value = _.far))
        : _.isFogExp2 && (M.fogDensity.value = _.density)
  }
  function t(M, _, R, T, L) {
    _.isMeshBasicMaterial
      ? i(M, _)
      : _.isMeshLambertMaterial
      ? (i(M, _), A(M, _))
      : _.isMeshToonMaterial
      ? (i(M, _), d(M, _))
      : _.isMeshPhongMaterial
      ? (i(M, _), c(M, _))
      : _.isMeshStandardMaterial
      ? (i(M, _), _.isMeshPhysicalMaterial ? m(M, _, L) : p(M, _))
      : _.isMeshMatcapMaterial
      ? (i(M, _), y(M, _))
      : _.isMeshDepthMaterial
      ? (i(M, _), x(M, _))
      : _.isMeshDistanceMaterial
      ? (i(M, _), S(M, _))
      : _.isMeshNormalMaterial
      ? (i(M, _), C(M, _))
      : _.isLineBasicMaterial
      ? (r(M, _), _.isLineDashedMaterial && s(M, _))
      : _.isPointsMaterial
      ? o(M, _, R, T)
      : _.isSpriteMaterial
      ? a(M, _)
      : _.isShadowMaterial
      ? (M.color.value.copy(_.color), (M.opacity.value = _.opacity))
      : _.isShaderMaterial && (_.uniformsNeedUpdate = !1)
  }
  function i(M, _) {
    ;(M.opacity.value = _.opacity),
      _.color && M.diffuse.value.copy(_.color),
      _.emissive &&
        M.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity),
      _.map && (M.map.value = _.map),
      _.alphaMap && (M.alphaMap.value = _.alphaMap),
      _.specularMap && (M.specularMap.value = _.specularMap),
      _.alphaTest > 0 && (M.alphaTest.value = _.alphaTest)
    const R = n.get(_).envMap
    R &&
      ((M.envMap.value = R),
      (M.flipEnvMap.value =
        R.isCubeTexture && R.isRenderTargetTexture === !1 ? -1 : 1),
      (M.reflectivity.value = _.reflectivity),
      (M.ior.value = _.ior),
      (M.refractionRatio.value = _.refractionRatio)),
      _.lightMap &&
        ((M.lightMap.value = _.lightMap),
        (M.lightMapIntensity.value = _.lightMapIntensity)),
      _.aoMap &&
        ((M.aoMap.value = _.aoMap), (M.aoMapIntensity.value = _.aoMapIntensity))
    let T
    _.map
      ? (T = _.map)
      : _.specularMap
      ? (T = _.specularMap)
      : _.displacementMap
      ? (T = _.displacementMap)
      : _.normalMap
      ? (T = _.normalMap)
      : _.bumpMap
      ? (T = _.bumpMap)
      : _.roughnessMap
      ? (T = _.roughnessMap)
      : _.metalnessMap
      ? (T = _.metalnessMap)
      : _.alphaMap
      ? (T = _.alphaMap)
      : _.emissiveMap
      ? (T = _.emissiveMap)
      : _.clearcoatMap
      ? (T = _.clearcoatMap)
      : _.clearcoatNormalMap
      ? (T = _.clearcoatNormalMap)
      : _.clearcoatRoughnessMap
      ? (T = _.clearcoatRoughnessMap)
      : _.specularIntensityMap
      ? (T = _.specularIntensityMap)
      : _.specularColorMap
      ? (T = _.specularColorMap)
      : _.transmissionMap
      ? (T = _.transmissionMap)
      : _.thicknessMap
      ? (T = _.thicknessMap)
      : _.sheenColorMap
      ? (T = _.sheenColorMap)
      : _.sheenRoughnessMap && (T = _.sheenRoughnessMap),
      T !== void 0 &&
        (T.isWebGLRenderTarget && (T = T.texture),
        T.matrixAutoUpdate === !0 && T.updateMatrix(),
        M.uvTransform.value.copy(T.matrix))
    let L
    _.aoMap ? (L = _.aoMap) : _.lightMap && (L = _.lightMap),
      L !== void 0 &&
        (L.isWebGLRenderTarget && (L = L.texture),
        L.matrixAutoUpdate === !0 && L.updateMatrix(),
        M.uv2Transform.value.copy(L.matrix))
  }
  function r(M, _) {
    M.diffuse.value.copy(_.color), (M.opacity.value = _.opacity)
  }
  function s(M, _) {
    ;(M.dashSize.value = _.dashSize),
      (M.totalSize.value = _.dashSize + _.gapSize),
      (M.scale.value = _.scale)
  }
  function o(M, _, R, T) {
    M.diffuse.value.copy(_.color),
      (M.opacity.value = _.opacity),
      (M.size.value = _.size * R),
      (M.scale.value = T * 0.5),
      _.map && (M.map.value = _.map),
      _.alphaMap && (M.alphaMap.value = _.alphaMap),
      _.alphaTest > 0 && (M.alphaTest.value = _.alphaTest)
    let L
    _.map ? (L = _.map) : _.alphaMap && (L = _.alphaMap),
      L !== void 0 &&
        (L.matrixAutoUpdate === !0 && L.updateMatrix(),
        M.uvTransform.value.copy(L.matrix))
  }
  function a(M, _) {
    M.diffuse.value.copy(_.color),
      (M.opacity.value = _.opacity),
      (M.rotation.value = _.rotation),
      _.map && (M.map.value = _.map),
      _.alphaMap && (M.alphaMap.value = _.alphaMap),
      _.alphaTest > 0 && (M.alphaTest.value = _.alphaTest)
    let R
    _.map ? (R = _.map) : _.alphaMap && (R = _.alphaMap),
      R !== void 0 &&
        (R.matrixAutoUpdate === !0 && R.updateMatrix(),
        M.uvTransform.value.copy(R.matrix))
  }
  function A(M, _) {
    _.emissiveMap && (M.emissiveMap.value = _.emissiveMap)
  }
  function c(M, _) {
    M.specular.value.copy(_.specular),
      (M.shininess.value = Math.max(_.shininess, 1e-4)),
      _.emissiveMap && (M.emissiveMap.value = _.emissiveMap),
      _.bumpMap &&
        ((M.bumpMap.value = _.bumpMap),
        (M.bumpScale.value = _.bumpScale),
        _.side === Pn && (M.bumpScale.value *= -1)),
      _.normalMap &&
        ((M.normalMap.value = _.normalMap),
        M.normalScale.value.copy(_.normalScale),
        _.side === Pn && M.normalScale.value.negate()),
      _.displacementMap &&
        ((M.displacementMap.value = _.displacementMap),
        (M.displacementScale.value = _.displacementScale),
        (M.displacementBias.value = _.displacementBias))
  }
  function d(M, _) {
    _.gradientMap && (M.gradientMap.value = _.gradientMap),
      _.emissiveMap && (M.emissiveMap.value = _.emissiveMap),
      _.bumpMap &&
        ((M.bumpMap.value = _.bumpMap),
        (M.bumpScale.value = _.bumpScale),
        _.side === Pn && (M.bumpScale.value *= -1)),
      _.normalMap &&
        ((M.normalMap.value = _.normalMap),
        M.normalScale.value.copy(_.normalScale),
        _.side === Pn && M.normalScale.value.negate()),
      _.displacementMap &&
        ((M.displacementMap.value = _.displacementMap),
        (M.displacementScale.value = _.displacementScale),
        (M.displacementBias.value = _.displacementBias))
  }
  function p(M, _) {
    ;(M.roughness.value = _.roughness),
      (M.metalness.value = _.metalness),
      _.roughnessMap && (M.roughnessMap.value = _.roughnessMap),
      _.metalnessMap && (M.metalnessMap.value = _.metalnessMap),
      _.emissiveMap && (M.emissiveMap.value = _.emissiveMap),
      _.bumpMap &&
        ((M.bumpMap.value = _.bumpMap),
        (M.bumpScale.value = _.bumpScale),
        _.side === Pn && (M.bumpScale.value *= -1)),
      _.normalMap &&
        ((M.normalMap.value = _.normalMap),
        M.normalScale.value.copy(_.normalScale),
        _.side === Pn && M.normalScale.value.negate()),
      _.displacementMap &&
        ((M.displacementMap.value = _.displacementMap),
        (M.displacementScale.value = _.displacementScale),
        (M.displacementBias.value = _.displacementBias)),
      n.get(_).envMap && (M.envMapIntensity.value = _.envMapIntensity)
  }
  function m(M, _, R) {
    p(M, _),
      (M.ior.value = _.ior),
      _.sheen > 0 &&
        (M.sheenColor.value.copy(_.sheenColor).multiplyScalar(_.sheen),
        (M.sheenRoughness.value = _.sheenRoughness),
        _.sheenColorMap && (M.sheenColorMap.value = _.sheenColorMap),
        _.sheenRoughnessMap &&
          (M.sheenRoughnessMap.value = _.sheenRoughnessMap)),
      _.clearcoat > 0 &&
        ((M.clearcoat.value = _.clearcoat),
        (M.clearcoatRoughness.value = _.clearcoatRoughness),
        _.clearcoatMap && (M.clearcoatMap.value = _.clearcoatMap),
        _.clearcoatRoughnessMap &&
          (M.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap),
        _.clearcoatNormalMap &&
          (M.clearcoatNormalScale.value.copy(_.clearcoatNormalScale),
          (M.clearcoatNormalMap.value = _.clearcoatNormalMap),
          _.side === Pn && M.clearcoatNormalScale.value.negate())),
      _.transmission > 0 &&
        ((M.transmission.value = _.transmission),
        (M.transmissionSamplerMap.value = R.texture),
        M.transmissionSamplerSize.value.set(R.width, R.height),
        _.transmissionMap && (M.transmissionMap.value = _.transmissionMap),
        (M.thickness.value = _.thickness),
        _.thicknessMap && (M.thicknessMap.value = _.thicknessMap),
        (M.attenuationDistance.value = _.attenuationDistance),
        M.attenuationColor.value.copy(_.attenuationColor)),
      (M.specularIntensity.value = _.specularIntensity),
      M.specularColor.value.copy(_.specularColor),
      _.specularIntensityMap &&
        (M.specularIntensityMap.value = _.specularIntensityMap),
      _.specularColorMap && (M.specularColorMap.value = _.specularColorMap)
  }
  function y(M, _) {
    _.matcap && (M.matcap.value = _.matcap),
      _.bumpMap &&
        ((M.bumpMap.value = _.bumpMap),
        (M.bumpScale.value = _.bumpScale),
        _.side === Pn && (M.bumpScale.value *= -1)),
      _.normalMap &&
        ((M.normalMap.value = _.normalMap),
        M.normalScale.value.copy(_.normalScale),
        _.side === Pn && M.normalScale.value.negate()),
      _.displacementMap &&
        ((M.displacementMap.value = _.displacementMap),
        (M.displacementScale.value = _.displacementScale),
        (M.displacementBias.value = _.displacementBias))
  }
  function x(M, _) {
    _.displacementMap &&
      ((M.displacementMap.value = _.displacementMap),
      (M.displacementScale.value = _.displacementScale),
      (M.displacementBias.value = _.displacementBias))
  }
  function S(M, _) {
    _.displacementMap &&
      ((M.displacementMap.value = _.displacementMap),
      (M.displacementScale.value = _.displacementScale),
      (M.displacementBias.value = _.displacementBias)),
      M.referencePosition.value.copy(_.referencePosition),
      (M.nearDistance.value = _.nearDistance),
      (M.farDistance.value = _.farDistance)
  }
  function C(M, _) {
    _.bumpMap &&
      ((M.bumpMap.value = _.bumpMap),
      (M.bumpScale.value = _.bumpScale),
      _.side === Pn && (M.bumpScale.value *= -1)),
      _.normalMap &&
        ((M.normalMap.value = _.normalMap),
        M.normalScale.value.copy(_.normalScale),
        _.side === Pn && M.normalScale.value.negate()),
      _.displacementMap &&
        ((M.displacementMap.value = _.displacementMap),
        (M.displacementScale.value = _.displacementScale),
        (M.displacementBias.value = _.displacementBias))
  }
  return { refreshFogUniforms: e, refreshMaterialUniforms: t }
}
function Ck() {
  const n = iu("canvas")
  return (n.style.display = "block"), n
}
function rn(n = {}) {
  const e = n.canvas !== void 0 ? n.canvas : Ck(),
    t = n.context !== void 0 ? n.context : null,
    i = n.alpha !== void 0 ? n.alpha : !1,
    r = n.depth !== void 0 ? n.depth : !0,
    s = n.stencil !== void 0 ? n.stencil : !0,
    o = n.antialias !== void 0 ? n.antialias : !1,
    a = n.premultipliedAlpha !== void 0 ? n.premultipliedAlpha : !0,
    A = n.preserveDrawingBuffer !== void 0 ? n.preserveDrawingBuffer : !1,
    c = n.powerPreference !== void 0 ? n.powerPreference : "default",
    d =
      n.failIfMajorPerformanceCaveat !== void 0
        ? n.failIfMajorPerformanceCaveat
        : !1
  let p = null,
    m = null
  const y = [],
    x = []
  ;(this.domElement = e),
    (this.debug = { checkShaderErrors: !0 }),
    (this.autoClear = !0),
    (this.autoClearColor = !0),
    (this.autoClearDepth = !0),
    (this.autoClearStencil = !0),
    (this.sortObjects = !0),
    (this.clippingPlanes = []),
    (this.localClippingEnabled = !1),
    (this.outputEncoding = Ns),
    (this.physicallyCorrectLights = !1),
    (this.toneMapping = Is),
    (this.toneMappingExposure = 1)
  const S = this
  let C = !1,
    M = 0,
    _ = 0,
    R = null,
    T = -1,
    L = null
  const B = new en(),
    k = new en()
  let O = null,
    W = e.width,
    z = e.height,
    P = 1,
    N = null,
    G = null
  const j = new en(0, 0, W, z),
    V = new en(0, 0, W, z)
  let Y = !1
  const ne = new Fu()
  let le = !1,
    Te = !1,
    Ae = null
  const ge = new mt(),
    Me = new X(),
    Ne = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: !0,
    }
  function Ze() {
    return R === null ? P : 1
  }
  let K = t
  function Oe(ee, xe) {
    for (let Le = 0; Le < ee.length; Le++) {
      const J = ee[Le],
        ae = e.getContext(J, xe)
      if (ae !== null) return ae
    }
    return null
  }
  try {
    const ee = {
      alpha: !0,
      depth: r,
      stencil: s,
      antialias: o,
      premultipliedAlpha: a,
      preserveDrawingBuffer: A,
      powerPreference: c,
      failIfMajorPerformanceCaveat: d,
    }
    if (
      ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${yd}`),
      e.addEventListener("webglcontextlost", at, !1),
      e.addEventListener("webglcontextrestored", de, !1),
      K === null)
    ) {
      const xe = ["webgl2", "webgl", "experimental-webgl"]
      if (
        (S.isWebGL1Renderer === !0 && xe.shift(), (K = Oe(xe, ee)), K === null)
      )
        throw Oe(xe)
          ? new Error(
              "Error creating WebGL context with your selected attributes."
            )
          : new Error("Error creating WebGL context.")
    }
    K.getShaderPrecisionFormat === void 0 &&
      (K.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 }
      })
  } catch (ee) {
    throw (console.error("THREE.WebGLRenderer: " + ee.message), ee)
  }
  let ve,
    Be,
    Fe,
    je,
    Ge,
    ye,
    D,
    q,
    F,
    te,
    oe,
    ue,
    Ee,
    Ce,
    Se,
    $,
    Q,
    pe,
    Re,
    Ue,
    _e,
    Xe,
    se
  function be() {
    ;(ve = new QI(K)),
      (Be = new HI(K, ve, n)),
      ve.init(Be),
      (Xe = new G5(K, ve, Be)),
      (Fe = new wk(K, ve, Be)),
      (je = new ZI()),
      (Ge = new fk()),
      (ye = new Mk(K, ve, Fe, Ge, Be, Xe, je)),
      (D = new VI(S)),
      (q = new $I(S)),
      (F = new fL(K, Be)),
      (se = new UI(K, ve, F, Be)),
      (te = new XI(K, F, je, se)),
      (oe = new tB(K, te, F, je)),
      (Re = new eB(K, Be, ye)),
      ($ = new GI(Ge)),
      (ue = new uk(S, D, q, ve, Be, se, $)),
      (Ee = new Tk(Ge)),
      (Ce = new dk()),
      (Se = new _k(ve, Be)),
      (pe = new NI(S, D, Fe, oe, i, a)),
      (Q = new H5(S, oe, Be)),
      (Ue = new zI(K, ve, je, Be)),
      (_e = new YI(K, ve, je, Be)),
      (je.programs = ue.programs),
      (S.capabilities = Be),
      (S.extensions = ve),
      (S.properties = Ge),
      (S.renderLists = Ce),
      (S.shadowMap = Q),
      (S.state = Fe),
      (S.info = je)
  }
  be()
  const ze = new Ek(S, K)
  ;(this.xr = ze),
    (this.getContext = function () {
      return K
    }),
    (this.getContextAttributes = function () {
      return K.getContextAttributes()
    }),
    (this.forceContextLoss = function () {
      const ee = ve.get("WEBGL_lose_context")
      ee && ee.loseContext()
    }),
    (this.forceContextRestore = function () {
      const ee = ve.get("WEBGL_lose_context")
      ee && ee.restoreContext()
    }),
    (this.getPixelRatio = function () {
      return P
    }),
    (this.setPixelRatio = function (ee) {
      ee !== void 0 && ((P = ee), this.setSize(W, z, !1))
    }),
    (this.getSize = function (ee) {
      return ee.set(W, z)
    }),
    (this.setSize = function (ee, xe, Le) {
      if (ze.isPresenting) {
        console.warn(
          "THREE.WebGLRenderer: Can't change size while VR device is presenting."
        )
        return
      }
      ;(W = ee),
        (z = xe),
        (e.width = Math.floor(ee * P)),
        (e.height = Math.floor(xe * P)),
        Le !== !1 &&
          ((e.style.width = ee + "px"), (e.style.height = xe + "px")),
        this.setViewport(0, 0, ee, xe)
    }),
    (this.getDrawingBufferSize = function (ee) {
      return ee.set(W * P, z * P).floor()
    }),
    (this.setDrawingBufferSize = function (ee, xe, Le) {
      ;(W = ee),
        (z = xe),
        (P = Le),
        (e.width = Math.floor(ee * Le)),
        (e.height = Math.floor(xe * Le)),
        this.setViewport(0, 0, ee, xe)
    }),
    (this.getCurrentViewport = function (ee) {
      return ee.copy(B)
    }),
    (this.getViewport = function (ee) {
      return ee.copy(j)
    }),
    (this.setViewport = function (ee, xe, Le, J) {
      ee.isVector4 ? j.set(ee.x, ee.y, ee.z, ee.w) : j.set(ee, xe, Le, J),
        Fe.viewport(B.copy(j).multiplyScalar(P).floor())
    }),
    (this.getScissor = function (ee) {
      return ee.copy(V)
    }),
    (this.setScissor = function (ee, xe, Le, J) {
      ee.isVector4 ? V.set(ee.x, ee.y, ee.z, ee.w) : V.set(ee, xe, Le, J),
        Fe.scissor(k.copy(V).multiplyScalar(P).floor())
    }),
    (this.getScissorTest = function () {
      return Y
    }),
    (this.setScissorTest = function (ee) {
      Fe.setScissorTest((Y = ee))
    }),
    (this.setOpaqueSort = function (ee) {
      N = ee
    }),
    (this.setTransparentSort = function (ee) {
      G = ee
    }),
    (this.getClearColor = function (ee) {
      return ee.copy(pe.getClearColor())
    }),
    (this.setClearColor = function () {
      pe.setClearColor.apply(pe, arguments)
    }),
    (this.getClearAlpha = function () {
      return pe.getClearAlpha()
    }),
    (this.setClearAlpha = function () {
      pe.setClearAlpha.apply(pe, arguments)
    }),
    (this.clear = function (ee, xe, Le) {
      let J = 0
      ;(ee === void 0 || ee) && (J |= 16384),
        (xe === void 0 || xe) && (J |= 256),
        (Le === void 0 || Le) && (J |= 1024),
        K.clear(J)
    }),
    (this.clearColor = function () {
      this.clear(!0, !1, !1)
    }),
    (this.clearDepth = function () {
      this.clear(!1, !0, !1)
    }),
    (this.clearStencil = function () {
      this.clear(!1, !1, !0)
    }),
    (this.dispose = function () {
      e.removeEventListener("webglcontextlost", at, !1),
        e.removeEventListener("webglcontextrestored", de, !1),
        Ce.dispose(),
        Se.dispose(),
        Ge.dispose(),
        D.dispose(),
        q.dispose(),
        oe.dispose(),
        se.dispose(),
        ue.dispose(),
        ze.dispose(),
        ze.removeEventListener("sessionstart", Ft),
        ze.removeEventListener("sessionend", an),
        Ae && (Ae.dispose(), (Ae = null)),
        vi.stop()
    })
  function at(ee) {
    ee.preventDefault(),
      console.log("THREE.WebGLRenderer: Context Lost."),
      (C = !0)
  }
  function de() {
    console.log("THREE.WebGLRenderer: Context Restored."), (C = !1)
    const ee = je.autoReset,
      xe = Q.enabled,
      Le = Q.autoUpdate,
      J = Q.needsUpdate,
      ae = Q.type
    be(),
      (je.autoReset = ee),
      (Q.enabled = xe),
      (Q.autoUpdate = Le),
      (Q.needsUpdate = J),
      (Q.type = ae)
  }
  function it(ee) {
    const xe = ee.target
    xe.removeEventListener("dispose", it), tt(xe)
  }
  function tt(ee) {
    ft(ee), Ge.remove(ee)
  }
  function ft(ee) {
    const xe = Ge.get(ee).programs
    xe !== void 0 &&
      (xe.forEach(function (Le) {
        ue.releaseProgram(Le)
      }),
      ee.isShaderMaterial && ue.releaseShaderCache(ee))
  }
  ;(this.renderBufferDirect = function (ee, xe, Le, J, ae, ke) {
    xe === null && (xe = Ne)
    const Ve = ae.isMesh && ae.matrixWorld.determinant() < 0,
      u = Zu(ee, xe, Le, J, ae)
    Fe.setMaterial(J, Ve)
    let Z = Le.index
    const gt = Le.attributes.position
    if (Z === null) {
      if (gt === void 0 || gt.count === 0) return
    } else if (Z.count === 0) return
    let pt = 1
    J.wireframe === !0 && ((Z = te.getWireframeAttribute(Le)), (pt = 2)),
      se.setup(ae, J, u, Le, Z)
    let lt,
      _t = Ue
    Z !== null && ((lt = F.get(Z)), (_t = _e), _t.setIndex(lt))
    const ln = Z !== null ? Z.count : gt.count,
      Nt = Le.drawRange.start * pt,
      dt = Le.drawRange.count * pt,
      tn = ke !== null ? ke.start * pt : 0,
      sn = ke !== null ? ke.count * pt : 1 / 0,
      _i = Math.max(Nt, tn),
      Js = Math.min(ln, Nt + dt, tn + sn) - 1,
      bn = Math.max(0, Js - _i + 1)
    if (bn !== 0) {
      if (ae.isMesh)
        J.wireframe === !0
          ? (Fe.setLineWidth(J.wireframeLinewidth * Ze()), _t.setMode(1))
          : _t.setMode(4)
      else if (ae.isLine) {
        let Di = J.linewidth
        Di === void 0 && (Di = 1),
          Fe.setLineWidth(Di * Ze()),
          ae.isLineSegments
            ? _t.setMode(1)
            : ae.isLineLoop
            ? _t.setMode(2)
            : _t.setMode(3)
      } else ae.isPoints ? _t.setMode(0) : ae.isSprite && _t.setMode(4)
      if (ae.isInstancedMesh) _t.renderInstances(_i, bn, ae.count)
      else if (Le.isInstancedBufferGeometry) {
        const Di = Math.min(Le.instanceCount, Le._maxInstanceCount)
        _t.renderInstances(_i, bn, Di)
      } else _t.render(_i, bn)
    }
  }),
    (this.compile = function (ee, xe) {
      ;(m = Se.get(ee)),
        m.init(),
        x.push(m),
        ee.traverseVisible(function (Le) {
          Le.isLight &&
            Le.layers.test(xe.layers) &&
            (m.pushLight(Le), Le.castShadow && m.pushShadow(Le))
        }),
        m.setupLights(S.physicallyCorrectLights),
        ee.traverse(function (Le) {
          const J = Le.material
          if (J)
            if (Array.isArray(J))
              for (let ae = 0; ae < J.length; ae++) {
                const ke = J[ae]
                $c(ke, ee, Le)
              }
            else $c(J, ee, Le)
        }),
        x.pop(),
        (m = null)
    })
  let De = null
  function ht(ee) {
    De && De(ee)
  }
  function Ft() {
    vi.stop()
  }
  function an() {
    vi.start()
  }
  const vi = new D5()
  vi.setAnimationLoop(ht),
    typeof window != "undefined" && vi.setContext(window),
    (this.setAnimationLoop = function (ee) {
      ;(De = ee), ze.setAnimationLoop(ee), ee === null ? vi.stop() : vi.start()
    }),
    ze.addEventListener("sessionstart", Ft),
    ze.addEventListener("sessionend", an),
    (this.render = function (ee, xe) {
      if (xe !== void 0 && xe.isCamera !== !0) {
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
        )
        return
      }
      if (C === !0) return
      ee.autoUpdate === !0 && ee.updateMatrixWorld(),
        xe.parent === null && xe.updateMatrixWorld(),
        ze.enabled === !0 &&
          ze.isPresenting === !0 &&
          (ze.cameraAutoUpdate === !0 && ze.updateCamera(xe),
          (xe = ze.getCamera())),
        ee.isScene === !0 && ee.onBeforeRender(S, ee, xe, R),
        (m = Se.get(ee, x.length)),
        m.init(),
        x.push(m),
        ge.multiplyMatrices(xe.projectionMatrix, xe.matrixWorldInverse),
        ne.setFromProjectionMatrix(ge),
        (Te = this.localClippingEnabled),
        (le = $.init(this.clippingPlanes, Te, xe)),
        (p = Ce.get(ee, y.length)),
        p.init(),
        y.push(p),
        yn(ee, xe, 0, S.sortObjects),
        p.finish(),
        S.sortObjects === !0 && p.sort(N, G),
        le === !0 && $.beginShadows()
      const Le = m.state.shadowsArray
      if (
        (Q.render(Le, ee, xe),
        le === !0 && $.endShadows(),
        this.info.autoReset === !0 && this.info.reset(),
        pe.render(p, ee),
        m.setupLights(S.physicallyCorrectLights),
        xe.isArrayCamera)
      ) {
        const J = xe.cameras
        for (let ae = 0, ke = J.length; ae < ke; ae++) {
          const Ve = J[ae]
          We(p, ee, Ve, Ve.viewport)
        }
      } else We(p, ee, xe)
      R !== null &&
        (ye.updateMultisampleRenderTarget(R), ye.updateRenderTargetMipmap(R)),
        ee.isScene === !0 && ee.onAfterRender(S, ee, xe),
        Fe.buffers.depth.setTest(!0),
        Fe.buffers.depth.setMask(!0),
        Fe.buffers.color.setMask(!0),
        Fe.setPolygonOffset(!1),
        se.resetDefaultState(),
        (T = -1),
        (L = null),
        x.pop(),
        x.length > 0 ? (m = x[x.length - 1]) : (m = null),
        y.pop(),
        y.length > 0 ? (p = y[y.length - 1]) : (p = null)
    })
  function yn(ee, xe, Le, J) {
    if (ee.visible === !1) return
    if (ee.layers.test(xe.layers)) {
      if (ee.isGroup) Le = ee.renderOrder
      else if (ee.isLOD) ee.autoUpdate === !0 && ee.update(xe)
      else if (ee.isLight) m.pushLight(ee), ee.castShadow && m.pushShadow(ee)
      else if (ee.isSprite) {
        if (!ee.frustumCulled || ne.intersectsSprite(ee)) {
          J && Me.setFromMatrixPosition(ee.matrixWorld).applyMatrix4(ge)
          const Ve = oe.update(ee),
            u = ee.material
          u.visible && p.push(ee, Ve, u, Le, Me.z, null)
        }
      } else if (
        (ee.isMesh || ee.isLine || ee.isPoints) &&
        (ee.isSkinnedMesh &&
          ee.skeleton.frame !== je.render.frame &&
          (ee.skeleton.update(), (ee.skeleton.frame = je.render.frame)),
        !ee.frustumCulled || ne.intersectsObject(ee))
      ) {
        J && Me.setFromMatrixPosition(ee.matrixWorld).applyMatrix4(ge)
        const Ve = oe.update(ee),
          u = ee.material
        if (Array.isArray(u)) {
          const Z = Ve.groups
          for (let gt = 0, pt = Z.length; gt < pt; gt++) {
            const lt = Z[gt],
              _t = u[lt.materialIndex]
            _t && _t.visible && p.push(ee, Ve, _t, Le, Me.z, lt)
          }
        } else u.visible && p.push(ee, Ve, u, Le, Me.z, null)
      }
    }
    const ke = ee.children
    for (let Ve = 0, u = ke.length; Ve < u; Ve++) yn(ke[Ve], xe, Le, J)
  }
  function We(ee, xe, Le, J) {
    const ae = ee.opaque,
      ke = ee.transmissive,
      Ve = ee.transparent
    m.setupLightsView(Le),
      ke.length > 0 && Er(ae, xe, Le),
      J && Fe.viewport(B.copy(J)),
      ae.length > 0 && Xo(ae, xe, Le),
      ke.length > 0 && Xo(ke, xe, Le),
      Ve.length > 0 && Xo(Ve, xe, Le)
  }
  function Er(ee, xe, Le) {
    if (Ae === null) {
      const Ve = o === !0 && Be.isWebGL2 === !0 ? xd : rr
      Ae = new Ve(1024, 1024, {
        generateMipmaps: !0,
        type: Xe.convert(La) !== null ? La : Bs,
        minFilter: nl,
        magFilter: On,
        wrapS: ci,
        wrapT: ci,
        useRenderToTexture: ve.has("WEBGL_multisampled_render_to_texture"),
      })
    }
    const J = S.getRenderTarget()
    S.setRenderTarget(Ae), S.clear()
    const ae = S.toneMapping
    ;(S.toneMapping = Is),
      Xo(ee, xe, Le),
      (S.toneMapping = ae),
      ye.updateMultisampleRenderTarget(Ae),
      ye.updateRenderTargetMipmap(Ae),
      S.setRenderTarget(J)
  }
  function Xo(ee, xe, Le) {
    const J = xe.isScene === !0 ? xe.overrideMaterial : null
    for (let ae = 0, ke = ee.length; ae < ke; ae++) {
      const Ve = ee[ae],
        u = Ve.object,
        Z = Ve.geometry,
        gt = J === null ? Ve.material : J,
        pt = Ve.group
      u.layers.test(Le.layers) && Kd(u, xe, Le, Z, gt, pt)
    }
  }
  function Kd(ee, xe, Le, J, ae, ke) {
    ee.onBeforeRender(S, xe, Le, J, ae, ke),
      ee.modelViewMatrix.multiplyMatrices(
        Le.matrixWorldInverse,
        ee.matrixWorld
      ),
      ee.normalMatrix.getNormalMatrix(ee.modelViewMatrix),
      ae.onBeforeRender(S, xe, Le, J, ee, ke),
      ae.transparent === !0 && ae.side === ls
        ? ((ae.side = Pn),
          (ae.needsUpdate = !0),
          S.renderBufferDirect(Le, xe, J, ae, ee, ke),
          (ae.side = Na),
          (ae.needsUpdate = !0),
          S.renderBufferDirect(Le, xe, J, ae, ee, ke),
          (ae.side = ls))
        : S.renderBufferDirect(Le, xe, J, ae, ee, ke),
      ee.onAfterRender(S, xe, Le, J, ae, ke)
  }
  function $c(ee, xe, Le) {
    xe.isScene !== !0 && (xe = Ne)
    const J = Ge.get(ee),
      ae = m.state.lights,
      ke = m.state.shadowsArray,
      Ve = ae.state.version,
      u = ue.getParameters(ee, ae.state, ke, xe, Le),
      Z = ue.getProgramCacheKey(u)
    let gt = J.programs
    ;(J.environment = ee.isMeshStandardMaterial ? xe.environment : null),
      (J.fog = xe.fog),
      (J.envMap = (ee.isMeshStandardMaterial ? q : D).get(
        ee.envMap || J.environment
      )),
      gt === void 0 &&
        (ee.addEventListener("dispose", it),
        (gt = new Map()),
        (J.programs = gt))
    let pt = gt.get(Z)
    if (pt !== void 0) {
      if (J.currentProgram === pt && J.lightsStateVersion === Ve)
        return al(ee, u), pt
    } else
      (u.uniforms = ue.getUniforms(ee)),
        ee.onBuild(Le, u, S),
        ee.onBeforeCompile(u, S),
        (pt = ue.acquireProgram(u, Z)),
        gt.set(Z, pt),
        (J.uniforms = u.uniforms)
    const lt = J.uniforms
    ;((!ee.isShaderMaterial && !ee.isRawShaderMaterial) ||
      ee.clipping === !0) &&
      (lt.clippingPlanes = $.uniform),
      al(ee, u),
      (J.needsLights = Ku(ee)),
      (J.lightsStateVersion = Ve),
      J.needsLights &&
        ((lt.ambientLightColor.value = ae.state.ambient),
        (lt.lightProbe.value = ae.state.probe),
        (lt.directionalLights.value = ae.state.directional),
        (lt.directionalLightShadows.value = ae.state.directionalShadow),
        (lt.spotLights.value = ae.state.spot),
        (lt.spotLightShadows.value = ae.state.spotShadow),
        (lt.rectAreaLights.value = ae.state.rectArea),
        (lt.ltc_1.value = ae.state.rectAreaLTC1),
        (lt.ltc_2.value = ae.state.rectAreaLTC2),
        (lt.pointLights.value = ae.state.point),
        (lt.pointLightShadows.value = ae.state.pointShadow),
        (lt.hemisphereLights.value = ae.state.hemi),
        (lt.directionalShadowMap.value = ae.state.directionalShadowMap),
        (lt.directionalShadowMatrix.value = ae.state.directionalShadowMatrix),
        (lt.spotShadowMap.value = ae.state.spotShadowMap),
        (lt.spotShadowMatrix.value = ae.state.spotShadowMatrix),
        (lt.pointShadowMap.value = ae.state.pointShadowMap),
        (lt.pointShadowMatrix.value = ae.state.pointShadowMatrix))
    const _t = pt.getUniforms(),
      ln = Do.seqWithValue(_t.seq, lt)
    return (J.currentProgram = pt), (J.uniformsList = ln), pt
  }
  function al(ee, xe) {
    const Le = Ge.get(ee)
    ;(Le.outputEncoding = xe.outputEncoding),
      (Le.instancing = xe.instancing),
      (Le.skinning = xe.skinning),
      (Le.morphTargets = xe.morphTargets),
      (Le.morphNormals = xe.morphNormals),
      (Le.morphTargetsCount = xe.morphTargetsCount),
      (Le.numClippingPlanes = xe.numClippingPlanes),
      (Le.numIntersection = xe.numClipIntersection),
      (Le.vertexAlphas = xe.vertexAlphas),
      (Le.vertexTangents = xe.vertexTangents),
      (Le.toneMapping = xe.toneMapping)
  }
  function Zu(ee, xe, Le, J, ae) {
    xe.isScene !== !0 && (xe = Ne), ye.resetTextureUnits()
    const ke = xe.fog,
      Ve = J.isMeshStandardMaterial ? xe.environment : null,
      u =
        R === null
          ? S.outputEncoding
          : R.isXRRenderTarget === !0
          ? R.texture.encoding
          : Ns,
      Z = (J.isMeshStandardMaterial ? q : D).get(J.envMap || Ve),
      gt =
        J.vertexColors === !0 &&
        !!Le.attributes.color &&
        Le.attributes.color.itemSize === 4,
      pt = !!J.normalMap && !!Le.attributes.tangent,
      lt = !!Le.morphAttributes.position,
      _t = !!Le.morphAttributes.normal,
      ln = Le.morphAttributes.position ? Le.morphAttributes.position.length : 0,
      Nt = J.toneMapped ? S.toneMapping : Is,
      dt = Ge.get(J),
      tn = m.state.lights
    if (le === !0 && (Te === !0 || ee !== L)) {
      const Wn = ee === L && J.id === T
      $.setState(J, ee, Wn)
    }
    let sn = !1
    J.version === dt.__version
      ? ((dt.needsLights && dt.lightsStateVersion !== tn.state.version) ||
          dt.outputEncoding !== u ||
          (ae.isInstancedMesh && dt.instancing === !1) ||
          (!ae.isInstancedMesh && dt.instancing === !0) ||
          (ae.isSkinnedMesh && dt.skinning === !1) ||
          (!ae.isSkinnedMesh && dt.skinning === !0) ||
          dt.envMap !== Z ||
          (J.fog && dt.fog !== ke) ||
          (dt.numClippingPlanes !== void 0 &&
            (dt.numClippingPlanes !== $.numPlanes ||
              dt.numIntersection !== $.numIntersection)) ||
          dt.vertexAlphas !== gt ||
          dt.vertexTangents !== pt ||
          dt.morphTargets !== lt ||
          dt.morphNormals !== _t ||
          dt.toneMapping !== Nt ||
          (Be.isWebGL2 === !0 && dt.morphTargetsCount !== ln)) &&
        (sn = !0)
      : ((sn = !0), (dt.__version = J.version))
    let _i = dt.currentProgram
    sn === !0 && (_i = $c(J, xe, ae))
    let Js = !1,
      bn = !1,
      Di = !1
    const un = _i.getUniforms(),
      Yo = dt.uniforms
    if (
      (Fe.useProgram(_i.program) && ((Js = !0), (bn = !0), (Di = !0)),
      J.id !== T && ((T = J.id), (bn = !0)),
      Js || L !== ee)
    ) {
      if (
        (un.setValue(K, "projectionMatrix", ee.projectionMatrix),
        Be.logarithmicDepthBuffer &&
          un.setValue(
            K,
            "logDepthBufFC",
            2 / (Math.log(ee.far + 1) / Math.LN2)
          ),
        L !== ee && ((L = ee), (bn = !0), (Di = !0)),
        J.isShaderMaterial ||
          J.isMeshPhongMaterial ||
          J.isMeshToonMaterial ||
          J.isMeshStandardMaterial ||
          J.envMap)
      ) {
        const Wn = un.map.cameraPosition
        Wn !== void 0 &&
          Wn.setValue(K, Me.setFromMatrixPosition(ee.matrixWorld))
      }
      ;(J.isMeshPhongMaterial ||
        J.isMeshToonMaterial ||
        J.isMeshLambertMaterial ||
        J.isMeshBasicMaterial ||
        J.isMeshStandardMaterial ||
        J.isShaderMaterial) &&
        un.setValue(K, "isOrthographic", ee.isOrthographicCamera === !0),
        (J.isMeshPhongMaterial ||
          J.isMeshToonMaterial ||
          J.isMeshLambertMaterial ||
          J.isMeshBasicMaterial ||
          J.isMeshStandardMaterial ||
          J.isShaderMaterial ||
          J.isShadowMaterial ||
          ae.isSkinnedMesh) &&
          un.setValue(K, "viewMatrix", ee.matrixWorldInverse)
    }
    if (ae.isSkinnedMesh) {
      un.setOptional(K, ae, "bindMatrix"),
        un.setOptional(K, ae, "bindMatrixInverse")
      const Wn = ae.skeleton
      Wn &&
        (Be.floatVertexTextures
          ? (Wn.boneTexture === null && Wn.computeBoneTexture(),
            un.setValue(K, "boneTexture", Wn.boneTexture, ye),
            un.setValue(K, "boneTextureSize", Wn.boneTextureSize))
          : un.setOptional(K, Wn, "boneMatrices"))
    }
    return (
      !!Le &&
        (Le.morphAttributes.position !== void 0 ||
          Le.morphAttributes.normal !== void 0) &&
        Re.update(ae, Le, J, _i),
      (bn || dt.receiveShadow !== ae.receiveShadow) &&
        ((dt.receiveShadow = ae.receiveShadow),
        un.setValue(K, "receiveShadow", ae.receiveShadow)),
      bn &&
        (un.setValue(K, "toneMappingExposure", S.toneMappingExposure),
        dt.needsLights && Ju(Yo, Di),
        ke && J.fog && Ee.refreshFogUniforms(Yo, ke),
        Ee.refreshMaterialUniforms(Yo, J, P, z, Ae),
        Do.upload(K, dt.uniformsList, Yo, ye)),
      J.isShaderMaterial &&
        J.uniformsNeedUpdate === !0 &&
        (Do.upload(K, dt.uniformsList, Yo, ye), (J.uniformsNeedUpdate = !1)),
      J.isSpriteMaterial && un.setValue(K, "center", ae.center),
      un.setValue(K, "modelViewMatrix", ae.modelViewMatrix),
      un.setValue(K, "normalMatrix", ae.normalMatrix),
      un.setValue(K, "modelMatrix", ae.matrixWorld),
      _i
    )
  }
  function Ju(ee, xe) {
    ;(ee.ambientLightColor.needsUpdate = xe),
      (ee.lightProbe.needsUpdate = xe),
      (ee.directionalLights.needsUpdate = xe),
      (ee.directionalLightShadows.needsUpdate = xe),
      (ee.pointLights.needsUpdate = xe),
      (ee.pointLightShadows.needsUpdate = xe),
      (ee.spotLights.needsUpdate = xe),
      (ee.spotLightShadows.needsUpdate = xe),
      (ee.rectAreaLights.needsUpdate = xe),
      (ee.hemisphereLights.needsUpdate = xe)
  }
  function Ku(ee) {
    return (
      ee.isMeshLambertMaterial ||
      ee.isMeshToonMaterial ||
      ee.isMeshPhongMaterial ||
      ee.isMeshStandardMaterial ||
      ee.isShadowMaterial ||
      (ee.isShaderMaterial && ee.lights === !0)
    )
  }
  ;(this.getActiveCubeFace = function () {
    return M
  }),
    (this.getActiveMipmapLevel = function () {
      return _
    }),
    (this.getRenderTarget = function () {
      return R
    }),
    (this.setRenderTargetTextures = function (ee, xe, Le) {
      ;(Ge.get(ee.texture).__webglTexture = xe),
        (Ge.get(ee.depthTexture).__webglTexture = Le)
      const J = Ge.get(ee)
      ;(J.__hasExternalTextures = !0),
        J.__hasExternalTextures &&
          ((J.__autoAllocateDepthBuffer = Le === void 0),
          J.__autoAllocateDepthBuffer ||
            (ee.useRenderToTexture &&
              (console.warn(
                "render-to-texture extension was disabled because an external texture was provided"
              ),
              (ee.useRenderToTexture = !1),
              (ee.useRenderbuffer = !0))))
    }),
    (this.setRenderTargetFramebuffer = function (ee, xe) {
      const Le = Ge.get(ee)
      ;(Le.__webglFramebuffer = xe),
        (Le.__useDefaultFramebuffer = xe === void 0)
    }),
    (this.setRenderTarget = function (ee, xe = 0, Le = 0) {
      ;(R = ee), (M = xe), (_ = Le)
      let J = !0
      if (ee) {
        const Z = Ge.get(ee)
        Z.__useDefaultFramebuffer !== void 0
          ? (Fe.bindFramebuffer(36160, null), (J = !1))
          : Z.__webglFramebuffer === void 0
          ? ye.setupRenderTarget(ee)
          : Z.__hasExternalTextures &&
            ye.rebindTextures(
              ee,
              Ge.get(ee.texture).__webglTexture,
              Ge.get(ee.depthTexture).__webglTexture
            )
      }
      let ae = null,
        ke = !1,
        Ve = !1
      if (ee) {
        const Z = ee.texture
        ;(Z.isDataTexture3D || Z.isDataTexture2DArray) && (Ve = !0)
        const gt = Ge.get(ee).__webglFramebuffer
        ee.isWebGLCubeRenderTarget
          ? ((ae = gt[xe]), (ke = !0))
          : ee.useRenderbuffer
          ? (ae = Ge.get(ee).__webglMultisampledFramebuffer)
          : (ae = gt),
          B.copy(ee.viewport),
          k.copy(ee.scissor),
          (O = ee.scissorTest)
      } else
        B.copy(j).multiplyScalar(P).floor(),
          k.copy(V).multiplyScalar(P).floor(),
          (O = Y)
      if (
        (Fe.bindFramebuffer(36160, ae) &&
          Be.drawBuffers &&
          J &&
          Fe.drawBuffers(ee, ae),
        Fe.viewport(B),
        Fe.scissor(k),
        Fe.setScissorTest(O),
        ke)
      ) {
        const Z = Ge.get(ee.texture)
        K.framebufferTexture2D(36160, 36064, 34069 + xe, Z.__webglTexture, Le)
      } else if (Ve) {
        const Z = Ge.get(ee.texture),
          gt = xe || 0
        K.framebufferTextureLayer(36160, 36064, Z.__webglTexture, Le || 0, gt)
      }
      T = -1
    }),
    (this.readRenderTargetPixels = function (ee, xe, Le, J, ae, ke, Ve) {
      if (!(ee && ee.isWebGLRenderTarget)) {
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
        )
        return
      }
      let u = Ge.get(ee).__webglFramebuffer
      if ((ee.isWebGLCubeRenderTarget && Ve !== void 0 && (u = u[Ve]), u)) {
        Fe.bindFramebuffer(36160, u)
        try {
          const Z = ee.texture,
            gt = Z.format,
            pt = Z.type
          if (gt !== Ai && Xe.convert(gt) !== K.getParameter(35739)) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
            )
            return
          }
          const lt =
            pt === La &&
            (ve.has("EXT_color_buffer_half_float") ||
              (Be.isWebGL2 && ve.has("EXT_color_buffer_float")))
          if (
            pt !== Bs &&
            Xe.convert(pt) !== K.getParameter(35738) &&
            !(
              pt === Rs &&
              (Be.isWebGL2 ||
                ve.has("OES_texture_float") ||
                ve.has("WEBGL_color_buffer_float"))
            ) &&
            !lt
          ) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
            )
            return
          }
          K.checkFramebufferStatus(36160) === 36053
            ? xe >= 0 &&
              xe <= ee.width - J &&
              Le >= 0 &&
              Le <= ee.height - ae &&
              K.readPixels(xe, Le, J, ae, Xe.convert(gt), Xe.convert(pt), ke)
            : console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
              )
        } finally {
          const Z = R !== null ? Ge.get(R).__webglFramebuffer : null
          Fe.bindFramebuffer(36160, Z)
        }
      }
    }),
    (this.copyFramebufferToTexture = function (ee, xe, Le = 0) {
      if (xe.isFramebufferTexture !== !0) {
        console.error(
          "THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture."
        )
        return
      }
      const J = Math.pow(2, -Le),
        ae = Math.floor(xe.image.width * J),
        ke = Math.floor(xe.image.height * J)
      ye.setTexture2D(xe, 0),
        K.copyTexSubImage2D(3553, Le, 0, 0, ee.x, ee.y, ae, ke),
        Fe.unbindTexture()
    }),
    (this.copyTextureToTexture = function (ee, xe, Le, J = 0) {
      const ae = xe.image.width,
        ke = xe.image.height,
        Ve = Xe.convert(Le.format),
        u = Xe.convert(Le.type)
      ye.setTexture2D(Le, 0),
        K.pixelStorei(37440, Le.flipY),
        K.pixelStorei(37441, Le.premultiplyAlpha),
        K.pixelStorei(3317, Le.unpackAlignment),
        xe.isDataTexture
          ? K.texSubImage2D(3553, J, ee.x, ee.y, ae, ke, Ve, u, xe.image.data)
          : xe.isCompressedTexture
          ? K.compressedTexSubImage2D(
              3553,
              J,
              ee.x,
              ee.y,
              xe.mipmaps[0].width,
              xe.mipmaps[0].height,
              Ve,
              xe.mipmaps[0].data
            )
          : K.texSubImage2D(3553, J, ee.x, ee.y, Ve, u, xe.image),
        J === 0 && Le.generateMipmaps && K.generateMipmap(3553),
        Fe.unbindTexture()
    }),
    (this.copyTextureToTexture3D = function (ee, xe, Le, J, ae = 0) {
      if (S.isWebGL1Renderer) {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
        )
        return
      }
      const ke = ee.max.x - ee.min.x + 1,
        Ve = ee.max.y - ee.min.y + 1,
        u = ee.max.z - ee.min.z + 1,
        Z = Xe.convert(J.format),
        gt = Xe.convert(J.type)
      let pt
      if (J.isDataTexture3D) ye.setTexture3D(J, 0), (pt = 32879)
      else if (J.isDataTexture2DArray) ye.setTexture2DArray(J, 0), (pt = 35866)
      else {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
        )
        return
      }
      K.pixelStorei(37440, J.flipY),
        K.pixelStorei(37441, J.premultiplyAlpha),
        K.pixelStorei(3317, J.unpackAlignment)
      const lt = K.getParameter(3314),
        _t = K.getParameter(32878),
        ln = K.getParameter(3316),
        Nt = K.getParameter(3315),
        dt = K.getParameter(32877),
        tn = Le.isCompressedTexture ? Le.mipmaps[0] : Le.image
      K.pixelStorei(3314, tn.width),
        K.pixelStorei(32878, tn.height),
        K.pixelStorei(3316, ee.min.x),
        K.pixelStorei(3315, ee.min.y),
        K.pixelStorei(32877, ee.min.z),
        Le.isDataTexture || Le.isDataTexture3D
          ? K.texSubImage3D(pt, ae, xe.x, xe.y, xe.z, ke, Ve, u, Z, gt, tn.data)
          : Le.isCompressedTexture
          ? (console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
            ),
            K.compressedTexSubImage3D(
              pt,
              ae,
              xe.x,
              xe.y,
              xe.z,
              ke,
              Ve,
              u,
              Z,
              tn.data
            ))
          : K.texSubImage3D(pt, ae, xe.x, xe.y, xe.z, ke, Ve, u, Z, gt, tn),
        K.pixelStorei(3314, lt),
        K.pixelStorei(32878, _t),
        K.pixelStorei(3316, ln),
        K.pixelStorei(3315, Nt),
        K.pixelStorei(32877, dt),
        ae === 0 && J.generateMipmaps && K.generateMipmap(pt),
        Fe.unbindTexture()
    }),
    (this.initTexture = function (ee) {
      ye.setTexture2D(ee, 0), Fe.unbindTexture()
    }),
    (this.resetState = function () {
      ;(M = 0), (_ = 0), (R = null), Fe.reset(), se.reset()
    }),
    typeof __THREE_DEVTOOLS__ != "undefined" &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this })
      )
}
rn.prototype.isWebGLRenderer = !0
class V5 extends rn {}
V5.prototype.isWebGL1Renderer = !0
class Uu {
  constructor(e, t = 25e-5) {
    ;(this.name = ""), (this.color = new Ke(e)), (this.density = t)
  }
  clone() {
    return new Uu(this.color, this.density)
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density,
    }
  }
}
Uu.prototype.isFogExp2 = !0
class zu {
  constructor(e, t = 1, i = 1e3) {
    ;(this.name = ""), (this.color = new Ke(e)), (this.near = t), (this.far = i)
  }
  clone() {
    return new zu(this.color, this.near, this.far)
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    }
  }
}
zu.prototype.isFog = !0
class Ld extends kt {
  constructor() {
    super(),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0),
      typeof __THREE_DEVTOOLS__ != "undefined" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        )
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.autoUpdate = e.autoUpdate),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    )
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), t
  }
}
Ld.prototype.isScene = !0
class $o {
  constructor(e, t) {
    ;(this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = gc),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = ir())
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setUsage(e) {
    return (this.usage = e), this
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    )
  }
  copyAt(e, t, i) {
    ;(e *= this.stride), (i *= t.stride)
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r]
    return this
  }
  set(e, t = 0) {
    return this.array.set(e, t), this
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ir()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer)
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride)
    return i.setUsage(this.usage), i
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ir()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    )
  }
}
$o.prototype.isInterleavedBuffer = !0
const Bn = new X()
class Fr {
  constructor(e, t, i, r = !1) {
    ;(this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r === !0)
  }
  get count() {
    return this.data.count
  }
  get array() {
    return this.data.array
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      (Bn.x = this.getX(t)),
        (Bn.y = this.getY(t)),
        (Bn.z = this.getZ(t)),
        Bn.applyMatrix4(e),
        this.setXYZ(t, Bn.x, Bn.y, Bn.z)
    return this
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (Bn.x = this.getX(t)),
        (Bn.y = this.getY(t)),
        (Bn.z = this.getZ(t)),
        Bn.applyNormalMatrix(e),
        this.setXYZ(t, Bn.x, Bn.y, Bn.z)
    return this
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      (Bn.x = this.getX(t)),
        (Bn.y = this.getY(t)),
        (Bn.z = this.getZ(t)),
        Bn.transformDirection(e),
        this.setXYZ(t, Bn.x, Bn.y, Bn.z)
    return this
  }
  setX(e, t) {
    return (this.data.array[e * this.data.stride + this.offset] = t), this
  }
  setY(e, t) {
    return (this.data.array[e * this.data.stride + this.offset + 1] = t), this
  }
  setZ(e, t) {
    return (this.data.array[e * this.data.stride + this.offset + 2] = t), this
  }
  setW(e, t) {
    return (this.data.array[e * this.data.stride + this.offset + 3] = t), this
  }
  getX(e) {
    return this.data.array[e * this.data.stride + this.offset]
  }
  getY(e) {
    return this.data.array[e * this.data.stride + this.offset + 1]
  }
  getZ(e) {
    return this.data.array[e * this.data.stride + this.offset + 2]
  }
  getW(e) {
    return this.data.array[e * this.data.stride + this.offset + 3]
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    )
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    )
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    )
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
      )
      const t = []
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
      }
      return new Bt(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      )
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Fr(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      )
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
      )
      const t = []
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s])
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      }
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      )
  }
}
Fr.prototype.isInterleavedBufferAttribute = !0
class Dd extends ii {
  constructor(e) {
    super(),
      (this.type = "SpriteMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      this
    )
  }
}
Dd.prototype.isSpriteMaterial = !0
let Tl
const oA = new X(),
  Cl = new X(),
  Rl = new X(),
  Pl = new qe(),
  aA = new qe(),
  W5 = new mt(),
  Hf = new X(),
  lA = new X(),
  Gf = new X(),
  U_ = new qe(),
  em = new qe(),
  z_ = new qe()
class Id extends kt {
  constructor(e) {
    if ((super(), (this.type = "Sprite"), Tl === void 0)) {
      Tl = new yt()
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        i = new $o(t, 5)
      Tl.setIndex([0, 1, 2, 0, 2, 3]),
        Tl.setAttribute("position", new Fr(i, 3, 0, !1)),
        Tl.setAttribute("uv", new Fr(i, 2, 3, !1))
    }
    ;(this.geometry = Tl),
      (this.material = e !== void 0 ? e : new Dd()),
      (this.center = new qe(0.5, 0.5))
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Cl.setFromMatrixScale(this.matrixWorld),
      W5.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      Rl.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Cl.multiplyScalar(-Rl.z)
    const i = this.material.rotation
    let r, s
    i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)))
    const o = this.center
    Vf(Hf.set(-0.5, -0.5, 0), Rl, o, Cl, r, s),
      Vf(lA.set(0.5, -0.5, 0), Rl, o, Cl, r, s),
      Vf(Gf.set(0.5, 0.5, 0), Rl, o, Cl, r, s),
      U_.set(0, 0),
      em.set(1, 0),
      z_.set(1, 1)
    let a = e.ray.intersectTriangle(Hf, lA, Gf, !1, oA)
    if (
      a === null &&
      (Vf(lA.set(-0.5, 0.5, 0), Rl, o, Cl, r, s),
      em.set(0, 1),
      (a = e.ray.intersectTriangle(Hf, Gf, lA, !1, oA)),
      a === null)
    )
      return
    const A = e.ray.origin.distanceTo(oA)
    A < e.near ||
      A > e.far ||
      t.push({
        distance: A,
        point: oA.clone(),
        uv: qn.getUV(oA, Hf, lA, Gf, U_, em, z_, new qe()),
        face: null,
        object: this,
      })
  }
  copy(e) {
    return (
      super.copy(e),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    )
  }
}
Id.prototype.isSprite = !0
function Vf(n, e, t, i, r, s) {
  Pl.subVectors(n, t).addScalar(0.5).multiply(i),
    r !== void 0
      ? ((aA.x = s * Pl.x - r * Pl.y), (aA.y = r * Pl.x + s * Pl.y))
      : aA.copy(Pl),
    n.copy(e),
    (n.x += aA.x),
    (n.y += aA.y),
    n.applyMatrix4(W5)
}
const Wf = new X(),
  H_ = new X()
class j5 extends kt {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0)
  }
  copy(e) {
    super.copy(e, !1)
    const t = e.levels
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i]
      this.addLevel(s.object.clone(), s.distance)
    }
    return (this.autoUpdate = e.autoUpdate), this
  }
  addLevel(e, t = 0) {
    t = Math.abs(t)
    const i = this.levels
    let r
    for (r = 0; r < i.length && !(t < i[r].distance); r++);
    return i.splice(r, 0, { distance: t, object: e }), this.add(e), this
  }
  getCurrentLevel() {
    return this._currentLevel
  }
  getObjectForDistance(e) {
    const t = this.levels
    if (t.length > 0) {
      let i, r
      for (i = 1, r = t.length; i < r && !(e < t[i].distance); i++);
      return t[i - 1].object
    }
    return null
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Wf.setFromMatrixPosition(this.matrixWorld)
      const r = e.ray.origin.distanceTo(Wf)
      this.getObjectForDistance(r).raycast(e, t)
    }
  }
  update(e) {
    const t = this.levels
    if (t.length > 1) {
      Wf.setFromMatrixPosition(e.matrixWorld),
        H_.setFromMatrixPosition(this.matrixWorld)
      const i = Wf.distanceTo(H_) / e.zoom
      t[0].object.visible = !0
      let r, s
      for (r = 1, s = t.length; r < s && i >= t[r].distance; r++)
        (t[r - 1].object.visible = !1), (t[r].object.visible = !0)
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1
    }
  }
  toJSON(e) {
    const t = super.toJSON(e)
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), (t.object.levels = [])
    const i = this.levels
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r]
      t.object.levels.push({ object: o.object.uuid, distance: o.distance })
    }
    return t
  }
}
const G_ = new X(),
  V_ = new en(),
  W_ = new en(),
  Rk = new X(),
  j_ = new mt()
class Bd extends Xt {
  constructor(e, t) {
    super(e, t),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new mt()),
      (this.bindMatrixInverse = new mt())
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      this
    )
  }
  bind(e, t) {
    ;(this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert()
  }
  pose() {
    this.skeleton.pose()
  }
  normalizeSkinWeights() {
    const e = new en(),
      t = this.geometry.attributes.skinWeight
    for (let i = 0, r = t.count; i < r; i++) {
      ;(e.x = t.getX(i)),
        (e.y = t.getY(i)),
        (e.z = t.getZ(i)),
        (e.w = t.getW(i))
      const s = 1 / e.manhattanLength()
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w)
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          )
  }
  boneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry
    V_.fromBufferAttribute(r.attributes.skinIndex, e),
      W_.fromBufferAttribute(r.attributes.skinWeight, e),
      G_.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0)
    for (let s = 0; s < 4; s++) {
      const o = W_.getComponent(s)
      if (o !== 0) {
        const a = V_.getComponent(s)
        j_.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(Rk.copy(G_).applyMatrix4(j_), o)
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse)
  }
}
Bd.prototype.isSkinnedMesh = !0
class kd extends kt {
  constructor() {
    super(), (this.type = "Bone")
  }
}
kd.prototype.isBone = !0
class Ba extends Vn {
  constructor(e = null, t = 1, i = 1, r, s, o, a, A, c = On, d = On, p, m) {
    super(null, o, a, A, c, d, r, s, p, m),
      (this.image = { data: e, width: t, height: i }),
      (this.magFilter = c),
      (this.minFilter = d),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
Ba.prototype.isDataTexture = !0
const $_ = new mt(),
  Pk = new mt()
class Od {
  constructor(e = [], t = []) {
    ;(this.uuid = ir()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init()
  }
  init() {
    const e = this.bones,
      t = this.boneInverses
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses()
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = [])
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new mt())
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new mt()
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i)
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e]
      i && i.matrixWorld.copy(this.boneInverses[e]).invert()
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e]
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale))
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : Pk
      $_.multiplyMatrices(a, t[s]), $_.toArray(i, s * 16)
    }
    r !== null && (r.needsUpdate = !0)
  }
  clone() {
    return new Od(this.bones, this.boneInverses)
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4)
    ;(e = _5(e)), (e = Math.max(e, 4))
    const t = new Float32Array(e * e * 4)
    t.set(this.boneMatrices)
    const i = new Ba(t, e, e, Ai, Rs)
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      (this.boneTextureSize = e),
      this
    )
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t]
      if (r.name === e) return r
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null))
  }
  fromJSON(e, t) {
    this.uuid = e.uuid
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i]
      let o = t[s]
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new kd())),
        this.bones.push(o),
        this.boneInverses.push(new mt().fromArray(e.boneInverses[i]))
    }
    return this.init(), this
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    }
    e.uuid = this.uuid
    const t = this.bones,
      i = this.boneInverses
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r]
      e.bones.push(o.uuid)
      const a = i[r]
      e.boneInverses.push(a.toArray())
    }
    return e
  }
}
class Ha extends Bt {
  constructor(e, t, i, r = 1) {
    typeof i == "number" &&
      ((r = i),
      (i = !1),
      console.error(
        "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
      )),
      super(e, t, i),
      (this.meshPerAttribute = r)
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    )
  }
}
Ha.prototype.isInstancedBufferAttribute = !0
const Q_ = new mt(),
  X_ = new mt(),
  jf = [],
  cA = new Xt()
class c2 extends Xt {
  constructor(e, t, i) {
    super(e, t),
      (this.instanceMatrix = new Ha(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.frustumCulled = !1)
  }
  copy(e) {
    return (
      super.copy(e),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      this
    )
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3)
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16)
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count
    if (
      ((cA.geometry = this.geometry),
      (cA.material = this.material),
      cA.material !== void 0)
    )
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, Q_),
          X_.multiplyMatrices(i, Q_),
          (cA.matrixWorld = X_),
          cA.raycast(e, jf)
        for (let o = 0, a = jf.length; o < a; o++) {
          const A = jf[o]
          ;(A.instanceId = s), (A.object = this), t.push(A)
        }
        jf.length = 0
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new Ha(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3)
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16)
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" })
  }
}
c2.prototype.isInstancedMesh = !0
class Nn extends ii {
  constructor(e) {
    super(),
      (this.type = "LineBasicMaterial"),
      (this.color = new Ke(16777215)),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      this
    )
  }
}
Nn.prototype.isLineBasicMaterial = !0
const Y_ = new X(),
  Z_ = new X(),
  J_ = new mt(),
  tm = new Wo(),
  $f = new ds()
class br extends kt {
  constructor(e = new yt(), t = new Nn()) {
    super(),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets()
  }
  copy(e) {
    return (
      super.copy(e),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  computeLineDistances() {
    const e = this.geometry
    if (e.isBufferGeometry)
      if (e.index === null) {
        const t = e.attributes.position,
          i = [0]
        for (let r = 1, s = t.count; r < s; r++)
          Y_.fromBufferAttribute(t, r - 1),
            Z_.fromBufferAttribute(t, r),
            (i[r] = i[r - 1]),
            (i[r] += Y_.distanceTo(Z_))
        e.setAttribute("lineDistance", new ut(i, 1))
      } else
        console.warn(
          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        )
    else
      e.isGeometry &&
        console.error(
          "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        )
    return this
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      $f.copy(i.boundingSphere),
      $f.applyMatrix4(r),
      ($f.radius += s),
      e.ray.intersectsSphere($f) === !1)
    )
      return
    J_.copy(r).invert(), tm.copy(e.ray).applyMatrix4(J_)
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      A = a * a,
      c = new X(),
      d = new X(),
      p = new X(),
      m = new X(),
      y = this.isLineSegments ? 2 : 1
    if (i.isBufferGeometry) {
      const x = i.index,
        C = i.attributes.position
      if (x !== null) {
        const M = Math.max(0, o.start),
          _ = Math.min(x.count, o.start + o.count)
        for (let R = M, T = _ - 1; R < T; R += y) {
          const L = x.getX(R),
            B = x.getX(R + 1)
          if (
            (c.fromBufferAttribute(C, L),
            d.fromBufferAttribute(C, B),
            tm.distanceSqToSegment(c, d, m, p) > A)
          )
            continue
          m.applyMatrix4(this.matrixWorld)
          const O = e.ray.origin.distanceTo(m)
          O < e.near ||
            O > e.far ||
            t.push({
              distance: O,
              point: p.clone().applyMatrix4(this.matrixWorld),
              index: R,
              face: null,
              faceIndex: null,
              object: this,
            })
        }
      } else {
        const M = Math.max(0, o.start),
          _ = Math.min(C.count, o.start + o.count)
        for (let R = M, T = _ - 1; R < T; R += y) {
          if (
            (c.fromBufferAttribute(C, R),
            d.fromBufferAttribute(C, R + 1),
            tm.distanceSqToSegment(c, d, m, p) > A)
          )
            continue
          m.applyMatrix4(this.matrixWorld)
          const B = e.ray.origin.distanceTo(m)
          B < e.near ||
            B > e.far ||
            t.push({
              distance: B,
              point: p.clone().applyMatrix4(this.matrixWorld),
              index: R,
              face: null,
              faceIndex: null,
              object: this,
            })
        }
      }
    } else
      i.isGeometry &&
        console.error(
          "THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        )
  }
  updateMorphTargets() {
    const e = this.geometry
    if (e.isBufferGeometry) {
      const t = e.morphAttributes,
        i = Object.keys(t)
      if (i.length > 0) {
        const r = t[i[0]]
        if (r !== void 0) {
          ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
          for (let s = 0, o = r.length; s < o; s++) {
            const a = r[s].name || String(s)
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[a] = s)
          }
        }
      }
    } else {
      const t = e.morphTargets
      t !== void 0 &&
        t.length > 0 &&
        console.error(
          "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
        )
    }
  }
}
br.prototype.isLine = !0
const K_ = new X(),
  e3 = new X()
class yi extends br {
  constructor(e, t) {
    super(e, t), (this.type = "LineSegments")
  }
  computeLineDistances() {
    const e = this.geometry
    if (e.isBufferGeometry)
      if (e.index === null) {
        const t = e.attributes.position,
          i = []
        for (let r = 0, s = t.count; r < s; r += 2)
          K_.fromBufferAttribute(t, r),
            e3.fromBufferAttribute(t, r + 1),
            (i[r] = r === 0 ? 0 : i[r - 1]),
            (i[r + 1] = i[r] + K_.distanceTo(e3))
        e.setAttribute("lineDistance", new ut(i, 1))
      } else
        console.warn(
          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        )
    else
      e.isGeometry &&
        console.error(
          "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
        )
    return this
  }
}
yi.prototype.isLineSegments = !0
class A2 extends br {
  constructor(e, t) {
    super(e, t), (this.type = "LineLoop")
  }
}
A2.prototype.isLineLoop = !0
class rl extends ii {
  constructor(e) {
    super(),
      (this.type = "PointsMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      this
    )
  }
}
rl.prototype.isPointsMaterial = !0
const t3 = new mt(),
  P1 = new Wo(),
  Qf = new ds(),
  Xf = new X()
class Hu extends kt {
  constructor(e = new yt(), t = new rl()) {
    super(),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets()
  }
  copy(e) {
    return (
      super.copy(e),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Qf.copy(i.boundingSphere),
      Qf.applyMatrix4(r),
      (Qf.radius += s),
      e.ray.intersectsSphere(Qf) === !1)
    )
      return
    t3.copy(r).invert(), P1.copy(e.ray).applyMatrix4(t3)
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      A = a * a
    if (i.isBufferGeometry) {
      const c = i.index,
        p = i.attributes.position
      if (c !== null) {
        const m = Math.max(0, o.start),
          y = Math.min(c.count, o.start + o.count)
        for (let x = m, S = y; x < S; x++) {
          const C = c.getX(x)
          Xf.fromBufferAttribute(p, C), n3(Xf, C, A, r, e, t, this)
        }
      } else {
        const m = Math.max(0, o.start),
          y = Math.min(p.count, o.start + o.count)
        for (let x = m, S = y; x < S; x++)
          Xf.fromBufferAttribute(p, x), n3(Xf, x, A, r, e, t, this)
      }
    } else
      console.error(
        "THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
      )
  }
  updateMorphTargets() {
    const e = this.geometry
    if (e.isBufferGeometry) {
      const t = e.morphAttributes,
        i = Object.keys(t)
      if (i.length > 0) {
        const r = t[i[0]]
        if (r !== void 0) {
          ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
          for (let s = 0, o = r.length; s < o; s++) {
            const a = r[s].name || String(s)
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[a] = s)
          }
        }
      }
    } else {
      const t = e.morphTargets
      t !== void 0 &&
        t.length > 0 &&
        console.error(
          "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
        )
    }
  }
}
Hu.prototype.isPoints = !0
function n3(n, e, t, i, r, s, o) {
  const a = P1.distanceSqToPoint(n)
  if (a < t) {
    const A = new X()
    P1.closestPointToPoint(n, A), A.applyMatrix4(i)
    const c = r.ray.origin.distanceTo(A)
    if (c < r.near || c > r.far) return
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: A,
      index: e,
      face: null,
      object: o,
    })
  }
}
class $5 extends Vn {
  constructor(e, t, i, r, s, o, a, A, c) {
    super(e, t, i, r, s, o, a, A, c),
      (this.minFilter = o !== void 0 ? o : Mn),
      (this.magFilter = s !== void 0 ? s : Mn),
      (this.generateMipmaps = !1)
    const d = this
    function p() {
      ;(d.needsUpdate = !0), e.requestVideoFrameCallback(p)
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(p)
  }
  clone() {
    return new this.constructor(this.image).copy(this)
  }
  update() {
    const e = this.image
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0)
  }
}
$5.prototype.isVideoTexture = !0
class Q5 extends Vn {
  constructor(e, t, i) {
    super({ width: e, height: t }),
      (this.format = i),
      (this.magFilter = On),
      (this.minFilter = On),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0)
  }
}
Q5.prototype.isFramebufferTexture = !0
class u2 extends Vn {
  constructor(e, t, i, r, s, o, a, A, c, d, p, m) {
    super(null, o, a, A, c, d, r, s, p, m),
      (this.image = { width: t, height: i }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1)
  }
}
u2.prototype.isCompressedTexture = !0
class X5 extends Vn {
  constructor(e, t, i, r, s, o, a, A, c) {
    super(e, t, i, r, s, o, a, A, c), (this.needsUpdate = !0)
  }
}
X5.prototype.isCanvasTexture = !0
class Ga extends yt {
  constructor(e = 1, t = 8, i = 0, r = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: i,
        thetaLength: r,
      }),
      (t = Math.max(3, t))
    const s = [],
      o = [],
      a = [],
      A = [],
      c = new X(),
      d = new qe()
    o.push(0, 0, 0), a.push(0, 0, 1), A.push(0.5, 0.5)
    for (let p = 0, m = 3; p <= t; p++, m += 3) {
      const y = i + (p / t) * r
      ;(c.x = e * Math.cos(y)),
        (c.y = e * Math.sin(y)),
        o.push(c.x, c.y, c.z),
        a.push(0, 0, 1),
        (d.x = (o[m] / e + 1) / 2),
        (d.y = (o[m + 1] / e + 1) / 2),
        A.push(d.x, d.y)
    }
    for (let p = 1; p <= t; p++) s.push(p, p + 1, 0)
    this.setIndex(s),
      this.setAttribute("position", new ut(o, 3)),
      this.setAttribute("normal", new ut(a, 3)),
      this.setAttribute("uv", new ut(A, 2))
  }
  static fromJSON(e) {
    return new Ga(e.radius, e.segments, e.thetaStart, e.thetaLength)
  }
}
class zs extends yt {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    r = 8,
    s = 1,
    o = !1,
    a = 0,
    A = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: A,
      })
    const c = this
    ;(r = Math.floor(r)), (s = Math.floor(s))
    const d = [],
      p = [],
      m = [],
      y = []
    let x = 0
    const S = [],
      C = i / 2
    let M = 0
    _(),
      o === !1 && (e > 0 && R(!0), t > 0 && R(!1)),
      this.setIndex(d),
      this.setAttribute("position", new ut(p, 3)),
      this.setAttribute("normal", new ut(m, 3)),
      this.setAttribute("uv", new ut(y, 2))
    function _() {
      const T = new X(),
        L = new X()
      let B = 0
      const k = (t - e) / i
      for (let O = 0; O <= s; O++) {
        const W = [],
          z = O / s,
          P = z * (t - e) + e
        for (let N = 0; N <= r; N++) {
          const G = N / r,
            j = G * A + a,
            V = Math.sin(j),
            Y = Math.cos(j)
          ;(L.x = P * V),
            (L.y = -z * i + C),
            (L.z = P * Y),
            p.push(L.x, L.y, L.z),
            T.set(V, k, Y).normalize(),
            m.push(T.x, T.y, T.z),
            y.push(G, 1 - z),
            W.push(x++)
        }
        S.push(W)
      }
      for (let O = 0; O < r; O++)
        for (let W = 0; W < s; W++) {
          const z = S[W][O],
            P = S[W + 1][O],
            N = S[W + 1][O + 1],
            G = S[W][O + 1]
          d.push(z, P, G), d.push(P, N, G), (B += 6)
        }
      c.addGroup(M, B, 0), (M += B)
    }
    function R(T) {
      const L = x,
        B = new qe(),
        k = new X()
      let O = 0
      const W = T === !0 ? e : t,
        z = T === !0 ? 1 : -1
      for (let N = 1; N <= r; N++)
        p.push(0, C * z, 0), m.push(0, z, 0), y.push(0.5, 0.5), x++
      const P = x
      for (let N = 0; N <= r; N++) {
        const j = (N / r) * A + a,
          V = Math.cos(j),
          Y = Math.sin(j)
        ;(k.x = W * Y),
          (k.y = C * z),
          (k.z = W * V),
          p.push(k.x, k.y, k.z),
          m.push(0, z, 0),
          (B.x = V * 0.5 + 0.5),
          (B.y = Y * 0.5 * z + 0.5),
          y.push(B.x, B.y),
          x++
      }
      for (let N = 0; N < r; N++) {
        const G = L + N,
          j = P + N
        T === !0 ? d.push(j, j + 1, G) : d.push(j + 1, j, G), (O += 3)
      }
      c.addGroup(M, O, T === !0 ? 1 : 2), (M += O)
    }
  }
  static fromJSON(e) {
    return new zs(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class _c extends zs {
  constructor(e = 1, t = 1, i = 8, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, r, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: r,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      })
  }
  static fromJSON(e) {
    return new _c(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class cs extends yt {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: r })
    const s = [],
      o = []
    a(r),
      c(i),
      d(),
      this.setAttribute("position", new ut(s, 3)),
      this.setAttribute("normal", new ut(s.slice(), 3)),
      this.setAttribute("uv", new ut(o, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals()
    function a(_) {
      const R = new X(),
        T = new X(),
        L = new X()
      for (let B = 0; B < t.length; B += 3)
        y(t[B + 0], R), y(t[B + 1], T), y(t[B + 2], L), A(R, T, L, _)
    }
    function A(_, R, T, L) {
      const B = L + 1,
        k = []
      for (let O = 0; O <= B; O++) {
        k[O] = []
        const W = _.clone().lerp(T, O / B),
          z = R.clone().lerp(T, O / B),
          P = B - O
        for (let N = 0; N <= P; N++)
          N === 0 && O === B
            ? (k[O][N] = W)
            : (k[O][N] = W.clone().lerp(z, N / P))
      }
      for (let O = 0; O < B; O++)
        for (let W = 0; W < 2 * (B - O) - 1; W++) {
          const z = Math.floor(W / 2)
          W % 2 === 0
            ? (m(k[O][z + 1]), m(k[O + 1][z]), m(k[O][z]))
            : (m(k[O][z + 1]), m(k[O + 1][z + 1]), m(k[O + 1][z]))
        }
    }
    function c(_) {
      const R = new X()
      for (let T = 0; T < s.length; T += 3)
        (R.x = s[T + 0]),
          (R.y = s[T + 1]),
          (R.z = s[T + 2]),
          R.normalize().multiplyScalar(_),
          (s[T + 0] = R.x),
          (s[T + 1] = R.y),
          (s[T + 2] = R.z)
    }
    function d() {
      const _ = new X()
      for (let R = 0; R < s.length; R += 3) {
        ;(_.x = s[R + 0]), (_.y = s[R + 1]), (_.z = s[R + 2])
        const T = C(_) / 2 / Math.PI + 0.5,
          L = M(_) / Math.PI + 0.5
        o.push(T, 1 - L)
      }
      x(), p()
    }
    function p() {
      for (let _ = 0; _ < o.length; _ += 6) {
        const R = o[_ + 0],
          T = o[_ + 2],
          L = o[_ + 4],
          B = Math.max(R, T, L),
          k = Math.min(R, T, L)
        B > 0.9 &&
          k < 0.1 &&
          (R < 0.2 && (o[_ + 0] += 1),
          T < 0.2 && (o[_ + 2] += 1),
          L < 0.2 && (o[_ + 4] += 1))
      }
    }
    function m(_) {
      s.push(_.x, _.y, _.z)
    }
    function y(_, R) {
      const T = _ * 3
      ;(R.x = e[T + 0]), (R.y = e[T + 1]), (R.z = e[T + 2])
    }
    function x() {
      const _ = new X(),
        R = new X(),
        T = new X(),
        L = new X(),
        B = new qe(),
        k = new qe(),
        O = new qe()
      for (let W = 0, z = 0; W < s.length; W += 9, z += 6) {
        _.set(s[W + 0], s[W + 1], s[W + 2]),
          R.set(s[W + 3], s[W + 4], s[W + 5]),
          T.set(s[W + 6], s[W + 7], s[W + 8]),
          B.set(o[z + 0], o[z + 1]),
          k.set(o[z + 2], o[z + 3]),
          O.set(o[z + 4], o[z + 5]),
          L.copy(_).add(R).add(T).divideScalar(3)
        const P = C(L)
        S(B, z + 0, _, P), S(k, z + 2, R, P), S(O, z + 4, T, P)
      }
    }
    function S(_, R, T, L) {
      L < 0 && _.x === 1 && (o[R] = _.x - 1),
        T.x === 0 && T.z === 0 && (o[R] = L / 2 / Math.PI + 0.5)
    }
    function C(_) {
      return Math.atan2(_.z, -_.x)
    }
    function M(_) {
      return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z))
    }
  }
  static fromJSON(e) {
    return new cs(e.vertices, e.indices, e.radius, e.details)
  }
}
class xc extends cs {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = 1 / i,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        0,
        -i,
        0,
        -r,
        i,
        0,
        -r,
        -i,
        0,
        r,
        i,
        0,
        r,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ]
    super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t })
  }
  static fromJSON(e) {
    return new xc(e.radius, e.detail)
  }
}
const Yf = new X(),
  Zf = new X(),
  nm = new X(),
  Jf = new qn()
class f2 extends yt {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const r = Math.pow(10, 4),
        s = Math.cos(Ia * t),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        A = o ? o.count : a.count,
        c = [0, 0, 0],
        d = ["a", "b", "c"],
        p = new Array(3),
        m = {},
        y = []
      for (let x = 0; x < A; x += 3) {
        o
          ? ((c[0] = o.getX(x)), (c[1] = o.getX(x + 1)), (c[2] = o.getX(x + 2)))
          : ((c[0] = x), (c[1] = x + 1), (c[2] = x + 2))
        const { a: S, b: C, c: M } = Jf
        if (
          (S.fromBufferAttribute(a, c[0]),
          C.fromBufferAttribute(a, c[1]),
          M.fromBufferAttribute(a, c[2]),
          Jf.getNormal(nm),
          (p[0] = `${Math.round(S.x * r)},${Math.round(S.y * r)},${Math.round(
            S.z * r
          )}`),
          (p[1] = `${Math.round(C.x * r)},${Math.round(C.y * r)},${Math.round(
            C.z * r
          )}`),
          (p[2] = `${Math.round(M.x * r)},${Math.round(M.y * r)},${Math.round(
            M.z * r
          )}`),
          !(p[0] === p[1] || p[1] === p[2] || p[2] === p[0]))
        )
          for (let _ = 0; _ < 3; _++) {
            const R = (_ + 1) % 3,
              T = p[_],
              L = p[R],
              B = Jf[d[_]],
              k = Jf[d[R]],
              O = `${T}_${L}`,
              W = `${L}_${T}`
            W in m && m[W]
              ? (nm.dot(m[W].normal) <= s &&
                  (y.push(B.x, B.y, B.z), y.push(k.x, k.y, k.z)),
                (m[W] = null))
              : O in m ||
                (m[O] = { index0: c[_], index1: c[R], normal: nm.clone() })
          }
      }
      for (const x in m)
        if (m[x]) {
          const { index0: S, index1: C } = m[x]
          Yf.fromBufferAttribute(a, S),
            Zf.fromBufferAttribute(a, C),
            y.push(Yf.x, Yf.y, Yf.z),
            y.push(Zf.x, Zf.y, Zf.z)
        }
      this.setAttribute("position", new ut(y, 3))
    }
  }
}
class Vi {
  constructor() {
    ;(this.type = "Curve"), (this.arcLengthDivisions = 200)
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e)
    return this.getPoint(i, t)
  }
  getPoints(e = 5) {
    const t = []
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e))
    return t
  }
  getSpacedPoints(e = 5) {
    const t = []
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e))
    return t
  }
  getLength() {
    const e = this.getLengths()
    return e[e.length - 1]
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths
    this.needsUpdate = !1
    const t = []
    let i,
      r = this.getPoint(0),
      s = 0
    t.push(0)
    for (let o = 1; o <= e; o++)
      (i = this.getPoint(o / e)), (s += i.distanceTo(r)), t.push(s), (r = i)
    return (this.cacheArcLengths = t), t
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), this.getLengths()
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths()
    let r = 0
    const s = i.length
    let o
    t ? (o = t) : (o = e * i[s - 1])
    let a = 0,
      A = s - 1,
      c
    for (; a <= A; )
      if (((r = Math.floor(a + (A - a) / 2)), (c = i[r] - o), c < 0)) a = r + 1
      else if (c > 0) A = r - 1
      else {
        A = r
        break
      }
    if (((r = A), i[r] === o)) return r / (s - 1)
    const d = i[r],
      m = i[r + 1] - d,
      y = (o - d) / m
    return (r + y) / (s - 1)
  }
  getTangent(e, t) {
    let r = e - 1e-4,
      s = e + 1e-4
    r < 0 && (r = 0), s > 1 && (s = 1)
    const o = this.getPoint(r),
      a = this.getPoint(s),
      A = t || (o.isVector2 ? new qe() : new X())
    return A.copy(a).sub(o).normalize(), A
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e)
    return this.getTangent(i, t)
  }
  computeFrenetFrames(e, t) {
    const i = new X(),
      r = [],
      s = [],
      o = [],
      a = new X(),
      A = new mt()
    for (let y = 0; y <= e; y++) {
      const x = y / e
      r[y] = this.getTangentAt(x, new X())
    }
    ;(s[0] = new X()), (o[0] = new X())
    let c = Number.MAX_VALUE
    const d = Math.abs(r[0].x),
      p = Math.abs(r[0].y),
      m = Math.abs(r[0].z)
    d <= c && ((c = d), i.set(1, 0, 0)),
      p <= c && ((c = p), i.set(0, 1, 0)),
      m <= c && i.set(0, 0, 1),
      a.crossVectors(r[0], i).normalize(),
      s[0].crossVectors(r[0], a),
      o[0].crossVectors(r[0], s[0])
    for (let y = 1; y <= e; y++) {
      if (
        ((s[y] = s[y - 1].clone()),
        (o[y] = o[y - 1].clone()),
        a.crossVectors(r[y - 1], r[y]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize()
        const x = Math.acos(li(r[y - 1].dot(r[y]), -1, 1))
        s[y].applyMatrix4(A.makeRotationAxis(a, x))
      }
      o[y].crossVectors(r[y], s[y])
    }
    if (t === !0) {
      let y = Math.acos(li(s[0].dot(s[e]), -1, 1))
      ;(y /= e), r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (y = -y)
      for (let x = 1; x <= e; x++)
        s[x].applyMatrix4(A.makeRotationAxis(r[x], y * x)),
          o[x].crossVectors(r[x], s[x])
    }
    return { tangents: r, normals: s, binormals: o }
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this
  }
  toJSON() {
    const e = {
      metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
    }
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    )
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this
  }
}
class Gu extends Vi {
  constructor(
    e = 0,
    t = 0,
    i = 1,
    r = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    A = 0
  ) {
    super(),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = i),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = A)
  }
  getPoint(e, t) {
    const i = t || new qe(),
      r = Math.PI * 2
    let s = this.aEndAngle - this.aStartAngle
    const o = Math.abs(s) < Number.EPSILON
    for (; s < 0; ) s += r
    for (; s > r; ) s -= r
    s < Number.EPSILON && (o ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !o && (s === r ? (s = -r) : (s = s - r))
    const a = this.aStartAngle + e * s
    let A = this.aX + this.xRadius * Math.cos(a),
      c = this.aY + this.yRadius * Math.sin(a)
    if (this.aRotation !== 0) {
      const d = Math.cos(this.aRotation),
        p = Math.sin(this.aRotation),
        m = A - this.aX,
        y = c - this.aY
      ;(A = m * d - y * p + this.aX), (c = m * p + y * d + this.aY)
    }
    return i.set(A, c)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    )
  }
}
Gu.prototype.isEllipseCurve = !0
class h2 extends Gu {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o), (this.type = "ArcCurve")
  }
}
h2.prototype.isArcCurve = !0
function d2() {
  let n = 0,
    e = 0,
    t = 0,
    i = 0
  function r(s, o, a, A) {
    ;(n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - A),
      (i = 2 * s - 2 * o + a + A)
  }
  return {
    initCatmullRom: function (s, o, a, A, c) {
      r(o, a, c * (a - s), c * (A - o))
    },
    initNonuniformCatmullRom: function (s, o, a, A, c, d, p) {
      let m = (o - s) / c - (a - s) / (c + d) + (a - o) / d,
        y = (a - o) / d - (A - o) / (d + p) + (A - a) / p
      ;(m *= d), (y *= d), r(o, a, m, y)
    },
    calc: function (s) {
      const o = s * s,
        a = o * s
      return n + e * s + t * o + i * a
    },
  }
}
const Kf = new X(),
  im = new d2(),
  rm = new d2(),
  sm = new d2()
class p2 extends Vi {
  constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
    super(),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = r)
  }
  getPoint(e, t = new X()) {
    const i = t,
      r = this.points,
      s = r.length,
      o = (s - (this.closed ? 0 : 1)) * e
    let a = Math.floor(o),
      A = o - a
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : A === 0 && a === s - 1 && ((a = s - 2), (A = 1))
    let c, d
    this.closed || a > 0
      ? (c = r[(a - 1) % s])
      : (Kf.subVectors(r[0], r[1]).add(r[0]), (c = Kf))
    const p = r[a % s],
      m = r[(a + 1) % s]
    if (
      (this.closed || a + 2 < s
        ? (d = r[(a + 2) % s])
        : (Kf.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (d = Kf)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const y = this.curveType === "chordal" ? 0.5 : 0.25
      let x = Math.pow(c.distanceToSquared(p), y),
        S = Math.pow(p.distanceToSquared(m), y),
        C = Math.pow(m.distanceToSquared(d), y)
      S < 1e-4 && (S = 1),
        x < 1e-4 && (x = S),
        C < 1e-4 && (C = S),
        im.initNonuniformCatmullRom(c.x, p.x, m.x, d.x, x, S, C),
        rm.initNonuniformCatmullRom(c.y, p.y, m.y, d.y, x, S, C),
        sm.initNonuniformCatmullRom(c.z, p.z, m.z, d.z, x, S, C)
    } else
      this.curveType === "catmullrom" &&
        (im.initCatmullRom(c.x, p.x, m.x, d.x, this.tension),
        rm.initCatmullRom(c.y, p.y, m.y, d.y, this.tension),
        sm.initCatmullRom(c.z, p.z, m.z, d.z, this.tension))
    return i.set(im.calc(A), rm.calc(A), sm.calc(A)), i
  }
  copy(e) {
    super.copy(e), (this.points = [])
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t]
      this.points.push(r.clone())
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    e.points = []
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t]
      e.points.push(r.toArray())
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    )
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = [])
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t]
      this.points.push(new X().fromArray(r))
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    )
  }
}
p2.prototype.isCatmullRomCurve3 = !0
function i3(n, e, t, i, r) {
  const s = (i - e) * 0.5,
    o = (r - t) * 0.5,
    a = n * n,
    A = n * a
  return (
    (2 * t - 2 * i + s + o) * A + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
  )
}
function Lk(n, e) {
  const t = 1 - n
  return t * t * e
}
function Dk(n, e) {
  return 2 * (1 - n) * n * e
}
function Ik(n, e) {
  return n * n * e
}
function OA(n, e, t, i) {
  return Lk(n, e) + Dk(n, t) + Ik(n, i)
}
function Bk(n, e) {
  const t = 1 - n
  return t * t * t * e
}
function kk(n, e) {
  const t = 1 - n
  return 3 * t * t * n * e
}
function Ok(n, e) {
  return 3 * (1 - n) * n * n * e
}
function qk(n, e) {
  return n * n * n * e
}
function qA(n, e, t, i, r) {
  return Bk(n, e) + kk(n, t) + Ok(n, i) + qk(n, r)
}
class qd extends Vi {
  constructor(e = new qe(), t = new qe(), i = new qe(), r = new qe()) {
    super(),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r)
  }
  getPoint(e, t = new qe()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3
    return i.set(qA(e, r.x, s.x, o.x, a.x), qA(e, r.y, s.y, o.y, a.y)), i
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    )
  }
}
qd.prototype.isCubicBezierCurve = !0
class Fd extends Vi {
  constructor(e = new X(), t = new X(), i = new X(), r = new X()) {
    super(),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r)
  }
  getPoint(e, t = new X()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3
    return (
      i.set(
        qA(e, r.x, s.x, o.x, a.x),
        qA(e, r.y, s.y, o.y, a.y),
        qA(e, r.z, s.z, o.z, a.z)
      ),
      i
    )
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    )
  }
}
Fd.prototype.isCubicBezierCurve3 = !0
class Vu extends Vi {
  constructor(e = new qe(), t = new qe()) {
    super(), (this.type = "LineCurve"), (this.v1 = e), (this.v2 = t)
  }
  getPoint(e, t = new qe()) {
    const i = t
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    )
  }
  getPointAt(e, t) {
    return this.getPoint(e, t)
  }
  getTangent(e, t) {
    const i = t || new qe()
    return i.copy(this.v2).sub(this.v1).normalize(), i
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
  }
  toJSON() {
    const e = super.toJSON()
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    )
  }
}
Vu.prototype.isLineCurve = !0
class Y5 extends Vi {
  constructor(e = new X(), t = new X()) {
    super(),
      (this.type = "LineCurve3"),
      (this.isLineCurve3 = !0),
      (this.v1 = e),
      (this.v2 = t)
  }
  getPoint(e, t = new X()) {
    const i = t
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    )
  }
  getPointAt(e, t) {
    return this.getPoint(e, t)
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
  }
  toJSON() {
    const e = super.toJSON()
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    )
  }
}
class Nd extends Vi {
  constructor(e = new qe(), t = new qe(), i = new qe()) {
    super(),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i)
  }
  getPoint(e, t = new qe()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2
    return i.set(OA(e, r.x, s.x, o.x), OA(e, r.y, s.y, o.y)), i
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    )
  }
}
Nd.prototype.isQuadraticBezierCurve = !0
class Wu extends Vi {
  constructor(e = new X(), t = new X(), i = new X()) {
    super(),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i)
  }
  getPoint(e, t = new X()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2
    return (
      i.set(OA(e, r.x, s.x, o.x), OA(e, r.y, s.y, o.y), OA(e, r.z, s.z, o.z)), i
    )
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    )
  }
}
Wu.prototype.isQuadraticBezierCurve3 = !0
class Ud extends Vi {
  constructor(e = []) {
    super(), (this.type = "SplineCurve"), (this.points = e)
  }
  getPoint(e, t = new qe()) {
    const i = t,
      r = this.points,
      s = (r.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      A = r[o === 0 ? o : o - 1],
      c = r[o],
      d = r[o > r.length - 2 ? r.length - 1 : o + 1],
      p = r[o > r.length - 3 ? r.length - 1 : o + 2]
    return i.set(i3(a, A.x, c.x, d.x, p.x), i3(a, A.y, c.y, d.y, p.y)), i
  }
  copy(e) {
    super.copy(e), (this.points = [])
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t]
      this.points.push(r.clone())
    }
    return this
  }
  toJSON() {
    const e = super.toJSON()
    e.points = []
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t]
      e.points.push(r.toArray())
    }
    return e
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = [])
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t]
      this.points.push(new qe().fromArray(r))
    }
    return this
  }
}
Ud.prototype.isSplineCurve = !0
var m2 = Object.freeze({
  __proto__: null,
  ArcCurve: h2,
  CatmullRomCurve3: p2,
  CubicBezierCurve: qd,
  CubicBezierCurve3: Fd,
  EllipseCurve: Gu,
  LineCurve: Vu,
  LineCurve3: Y5,
  QuadraticBezierCurve: Nd,
  QuadraticBezierCurve3: Wu,
  SplineCurve: Ud,
})
class Z5 extends Vi {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1)
  }
  add(e) {
    this.curves.push(e)
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1)
    e.equals(t) || this.curves.push(new Vu(t, e))
  }
  getPoint(e, t) {
    const i = e * this.getLength(),
      r = this.getCurveLengths()
    let s = 0
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i,
          a = this.curves[s],
          A = a.getLength(),
          c = A === 0 ? 0 : 1 - o / A
        return a.getPointAt(c, t)
      }
      s++
    }
    return null
  }
  getLength() {
    const e = this.getCurveLengths()
    return e[e.length - 1]
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths()
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths
    const e = []
    let t = 0
    for (let i = 0, r = this.curves.length; i < r; i++)
      (t += this.curves[i].getLength()), e.push(t)
    return (this.cacheLengths = e), e
  }
  getSpacedPoints(e = 40) {
    const t = []
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e))
    return this.autoClose && t.push(t[0]), t
  }
  getPoints(e = 12) {
    const t = []
    let i
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r],
        a =
          o && o.isEllipseCurve
            ? e * 2
            : o && (o.isLineCurve || o.isLineCurve3)
            ? 1
            : o && o.isSplineCurve
            ? e * o.points.length
            : e,
        A = o.getPoints(a)
      for (let c = 0; c < A.length; c++) {
        const d = A[c]
        ;(i && i.equals(d)) || (t.push(d), (i = d))
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    )
  }
  copy(e) {
    super.copy(e), (this.curves = [])
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t]
      this.curves.push(r.clone())
    }
    return (this.autoClose = e.autoClose), this
  }
  toJSON() {
    const e = super.toJSON()
    ;(e.autoClose = this.autoClose), (e.curves = [])
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t]
      e.curves.push(r.toJSON())
    }
    return e
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = [])
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t]
      this.curves.push(new m2[r.type]().fromJSON(r))
    }
    return this
  }
}
class ru extends Z5 {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new qe()),
      e && this.setFromPoints(e)
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y)
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y)
    return this
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this
  }
  lineTo(e, t) {
    const i = new Vu(this.currentPoint.clone(), new qe(e, t))
    return this.curves.push(i), this.currentPoint.set(e, t), this
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new Nd(this.currentPoint.clone(), new qe(e, t), new qe(i, r))
    return this.curves.push(s), this.currentPoint.set(i, r), this
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new qd(
      this.currentPoint.clone(),
      new qe(e, t),
      new qe(i, r),
      new qe(s, o)
    )
    return this.curves.push(a), this.currentPoint.set(s, o), this
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      i = new Ud(t)
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x,
      A = this.currentPoint.y
    return this.absarc(e + a, t + A, i, r, s, o), this
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this
  }
  ellipse(e, t, i, r, s, o, a, A) {
    const c = this.currentPoint.x,
      d = this.currentPoint.y
    return this.absellipse(e + c, t + d, i, r, s, o, a, A), this
  }
  absellipse(e, t, i, r, s, o, a, A) {
    const c = new Gu(e, t, i, r, s, o, a, A)
    if (this.curves.length > 0) {
      const p = c.getPoint(0)
      p.equals(this.currentPoint) || this.lineTo(p.x, p.y)
    }
    this.curves.push(c)
    const d = c.getPoint(1)
    return this.currentPoint.copy(d), this
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this
  }
  toJSON() {
    const e = super.toJSON()
    return (e.currentPoint = this.currentPoint.toArray()), e
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
  }
}
class ns extends ru {
  constructor(e) {
    super(e), (this.uuid = ir()), (this.type = "Shape"), (this.holes = [])
  }
  getPointsHoles(e) {
    const t = []
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e)
    return t
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) }
  }
  copy(e) {
    super.copy(e), (this.holes = [])
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t]
      this.holes.push(r.clone())
    }
    return this
  }
  toJSON() {
    const e = super.toJSON()
    ;(e.uuid = this.uuid), (e.holes = [])
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t]
      e.holes.push(r.toJSON())
    }
    return e
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = [])
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t]
      this.holes.push(new ru().fromJSON(r))
    }
    return this
  }
}
const Fk = {
  triangulate: function (n, e, t = 2) {
    const i = e && e.length,
      r = i ? e[0] * t : n.length
    let s = J5(n, 0, r, t, !0)
    const o = []
    if (!s || s.next === s.prev) return o
    let a, A, c, d, p, m, y
    if ((i && (s = Gk(n, e, s, t)), n.length > 80 * t)) {
      ;(a = c = n[0]), (A = d = n[1])
      for (let x = t; x < r; x += t)
        (p = n[x]),
          (m = n[x + 1]),
          p < a && (a = p),
          m < A && (A = m),
          p > c && (c = p),
          m > d && (d = m)
      ;(y = Math.max(c - a, d - A)), (y = y !== 0 ? 1 / y : 0)
    }
    return su(s, o, t, a, A, y), o
  },
}
function J5(n, e, t, i, r) {
  let s, o
  if (r === eO(n, e, t, i) > 0)
    for (s = e; s < t; s += i) o = r3(s, n[s], n[s + 1], o)
  else for (s = t - i; s >= e; s -= i) o = r3(s, n[s], n[s + 1], o)
  return o && zd(o, o.next) && (au(o), (o = o.next)), o
}
function Uo(n, e) {
  if (!n) return n
  e || (e = n)
  let t = n,
    i
  do
    if (
      ((i = !1), !t.steiner && (zd(t, t.next) || Sn(t.prev, t, t.next) === 0))
    ) {
      if ((au(t), (t = e = t.prev), t === t.next)) break
      i = !0
    } else t = t.next
  while (i || t !== e)
  return e
}
function su(n, e, t, i, r, s, o) {
  if (!n) return
  !o && s && Qk(n, i, r, s)
  let a = n,
    A,
    c
  for (; n.prev !== n.next; ) {
    if (((A = n.prev), (c = n.next), s ? Uk(n, i, r, s) : Nk(n))) {
      e.push(A.i / t),
        e.push(n.i / t),
        e.push(c.i / t),
        au(n),
        (n = c.next),
        (a = c.next)
      continue
    }
    if (((n = c), n === a)) {
      o
        ? o === 1
          ? ((n = zk(Uo(n), e, t)), su(n, e, t, i, r, s, 2))
          : o === 2 && Hk(n, e, t, i, r, s)
        : su(Uo(n), e, t, i, r, s, 1)
      break
    }
  }
}
function Nk(n) {
  const e = n.prev,
    t = n,
    i = n.next
  if (Sn(e, t, i) >= 0) return !1
  let r = n.next.next
  for (; r !== n.prev; ) {
    if (
      Hl(e.x, e.y, t.x, t.y, i.x, i.y, r.x, r.y) &&
      Sn(r.prev, r, r.next) >= 0
    )
      return !1
    r = r.next
  }
  return !0
}
function Uk(n, e, t, i) {
  const r = n.prev,
    s = n,
    o = n.next
  if (Sn(r, s, o) >= 0) return !1
  const a = r.x < s.x ? (r.x < o.x ? r.x : o.x) : s.x < o.x ? s.x : o.x,
    A = r.y < s.y ? (r.y < o.y ? r.y : o.y) : s.y < o.y ? s.y : o.y,
    c = r.x > s.x ? (r.x > o.x ? r.x : o.x) : s.x > o.x ? s.x : o.x,
    d = r.y > s.y ? (r.y > o.y ? r.y : o.y) : s.y > o.y ? s.y : o.y,
    p = L1(a, A, e, t, i),
    m = L1(c, d, e, t, i)
  let y = n.prevZ,
    x = n.nextZ
  for (; y && y.z >= p && x && x.z <= m; ) {
    if (
      (y !== n.prev &&
        y !== n.next &&
        Hl(r.x, r.y, s.x, s.y, o.x, o.y, y.x, y.y) &&
        Sn(y.prev, y, y.next) >= 0) ||
      ((y = y.prevZ),
      x !== n.prev &&
        x !== n.next &&
        Hl(r.x, r.y, s.x, s.y, o.x, o.y, x.x, x.y) &&
        Sn(x.prev, x, x.next) >= 0)
    )
      return !1
    x = x.nextZ
  }
  for (; y && y.z >= p; ) {
    if (
      y !== n.prev &&
      y !== n.next &&
      Hl(r.x, r.y, s.x, s.y, o.x, o.y, y.x, y.y) &&
      Sn(y.prev, y, y.next) >= 0
    )
      return !1
    y = y.prevZ
  }
  for (; x && x.z <= m; ) {
    if (
      x !== n.prev &&
      x !== n.next &&
      Hl(r.x, r.y, s.x, s.y, o.x, o.y, x.x, x.y) &&
      Sn(x.prev, x, x.next) >= 0
    )
      return !1
    x = x.nextZ
  }
  return !0
}
function zk(n, e, t) {
  let i = n
  do {
    const r = i.prev,
      s = i.next.next
    !zd(r, s) &&
      K5(r, i, i.next, s) &&
      ou(r, s) &&
      ou(s, r) &&
      (e.push(r.i / t),
      e.push(i.i / t),
      e.push(s.i / t),
      au(i),
      au(i.next),
      (i = n = s)),
      (i = i.next)
  } while (i !== n)
  return Uo(i)
}
function Hk(n, e, t, i, r, s) {
  let o = n
  do {
    let a = o.next.next
    for (; a !== o.prev; ) {
      if (o.i !== a.i && Zk(o, a)) {
        let A = e6(o, a)
        ;(o = Uo(o, o.next)),
          (A = Uo(A, A.next)),
          su(o, e, t, i, r, s),
          su(A, e, t, i, r, s)
        return
      }
      a = a.next
    }
    o = o.next
  } while (o !== n)
}
function Gk(n, e, t, i) {
  const r = []
  let s, o, a, A, c
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * i),
      (A = s < o - 1 ? e[s + 1] * i : n.length),
      (c = J5(n, a, A, i, !1)),
      c === c.next && (c.steiner = !0),
      r.push(Yk(c))
  for (r.sort(Vk), s = 0; s < r.length; s++) Wk(r[s], t), (t = Uo(t, t.next))
  return t
}
function Vk(n, e) {
  return n.x - e.x
}
function Wk(n, e) {
  if (((e = jk(n, e)), e)) {
    const t = e6(e, n)
    Uo(e, e.next), Uo(t, t.next)
  }
}
function jk(n, e) {
  let t = e
  const i = n.x,
    r = n.y
  let s = -1 / 0,
    o
  do {
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      const m = t.x + ((r - t.y) * (t.next.x - t.x)) / (t.next.y - t.y)
      if (m <= i && m > s) {
        if (((s = m), m === i)) {
          if (r === t.y) return t
          if (r === t.next.y) return t.next
        }
        o = t.x < t.next.x ? t : t.next
      }
    }
    t = t.next
  } while (t !== e)
  if (!o) return null
  if (i === s) return o
  const a = o,
    A = o.x,
    c = o.y
  let d = 1 / 0,
    p
  t = o
  do
    i >= t.x &&
      t.x >= A &&
      i !== t.x &&
      Hl(r < c ? i : s, r, A, c, r < c ? s : i, r, t.x, t.y) &&
      ((p = Math.abs(r - t.y) / (i - t.x)),
      ou(t, n) &&
        (p < d || (p === d && (t.x > o.x || (t.x === o.x && $k(o, t))))) &&
        ((o = t), (d = p))),
      (t = t.next)
  while (t !== a)
  return o
}
function $k(n, e) {
  return Sn(n.prev, n, e.prev) < 0 && Sn(e.next, n, n.next) < 0
}
function Qk(n, e, t, i) {
  let r = n
  do
    r.z === null && (r.z = L1(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next)
  while (r !== n)
  ;(r.prevZ.nextZ = null), (r.prevZ = null), Xk(r)
}
function Xk(n) {
  let e,
    t,
    i,
    r,
    s,
    o,
    a,
    A,
    c = 1
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < c && (a++, (i = i.nextZ), !!i); e++);
      for (A = c; a > 0 || (A > 0 && i); )
        a !== 0 && (A === 0 || !i || t.z <= i.z)
          ? ((r = t), (t = t.nextZ), a--)
          : ((r = i), (i = i.nextZ), A--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r)
      t = i
    }
    ;(s.nextZ = null), (c *= 2)
  } while (o > 1)
  return n
}
function L1(n, e, t, i, r) {
  return (
    (n = 32767 * (n - t) * r),
    (e = 32767 * (e - i) * r),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  )
}
function Yk(n) {
  let e = n,
    t = n
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next)
  while (e !== n)
  return t
}
function Hl(n, e, t, i, r, s, o, a) {
  return (
    (r - o) * (e - a) - (n - o) * (s - a) >= 0 &&
    (n - o) * (i - a) - (t - o) * (e - a) >= 0 &&
    (t - o) * (s - a) - (r - o) * (i - a) >= 0
  )
}
function Zk(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !Jk(n, e) &&
    ((ou(n, e) &&
      ou(e, n) &&
      Kk(n, e) &&
      (Sn(n.prev, n, e.prev) || Sn(n, e.prev, e))) ||
      (zd(n, e) && Sn(n.prev, n, n.next) > 0 && Sn(e.prev, e, e.next) > 0))
  )
}
function Sn(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function zd(n, e) {
  return n.x === e.x && n.y === e.y
}
function K5(n, e, t, i) {
  const r = th(Sn(n, e, t)),
    s = th(Sn(n, e, i)),
    o = th(Sn(t, i, n)),
    a = th(Sn(t, i, e))
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && eh(n, t, e)) ||
    (s === 0 && eh(n, i, e)) ||
    (o === 0 && eh(t, n, i)) ||
    (a === 0 && eh(t, e, i))
  )
}
function eh(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  )
}
function th(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0
}
function Jk(n, e) {
  let t = n
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      K5(t, t.next, n, e)
    )
      return !0
    t = t.next
  } while (t !== n)
  return !1
}
function ou(n, e) {
  return Sn(n.prev, n, n.next) < 0
    ? Sn(n, e, n.next) >= 0 && Sn(n, n.prev, e) >= 0
    : Sn(n, e, n.prev) < 0 || Sn(n, n.next, e) < 0
}
function Kk(n, e) {
  let t = n,
    i = !1
  const r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next)
  while (t !== n)
  return i
}
function e6(n, e) {
  const t = new D1(n.i, n.x, n.y),
    i = new D1(e.i, e.x, e.y),
    r = n.next,
    s = e.prev
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  )
}
function r3(n, e, t, i) {
  const r = new D1(n, e, t)
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  )
}
function au(n) {
  ;(n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function D1(n, e, t) {
  ;(this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = null),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1)
}
function eO(n, e, t, i) {
  let r = 0
  for (let s = e, o = t - i; s < t; s += i)
    (r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s)
  return r
}
class is {
  static area(e) {
    const t = e.length
    let i = 0
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y
    return i * 0.5
  }
  static isClockWise(e) {
    return is.area(e) < 0
  }
  static triangulateShape(e, t) {
    const i = [],
      r = [],
      s = []
    s3(e), o3(i, e)
    let o = e.length
    t.forEach(s3)
    for (let A = 0; A < t.length; A++)
      r.push(o), (o += t[A].length), o3(i, t[A])
    const a = Fk.triangulate(i, r)
    for (let A = 0; A < a.length; A += 3) s.push(a.slice(A, A + 3))
    return s
  }
}
function s3(n) {
  const e = n.length
  e > 2 && n[e - 1].equals(n[0]) && n.pop()
}
function o3(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y)
}
class Nr extends yt {
  constructor(
    e = new ns([
      new qe(0.5, 0.5),
      new qe(-0.5, 0.5),
      new qe(-0.5, -0.5),
      new qe(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e])
    const i = this,
      r = [],
      s = []
    for (let a = 0, A = e.length; a < A; a++) {
      const c = e[a]
      o(c)
    }
    this.setAttribute("position", new ut(r, 3)),
      this.setAttribute("uv", new ut(s, 2)),
      this.computeVertexNormals()
    function o(a) {
      const A = [],
        c = t.curveSegments !== void 0 ? t.curveSegments : 12,
        d = t.steps !== void 0 ? t.steps : 1
      let p = t.depth !== void 0 ? t.depth : 1,
        m = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        y = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        x = t.bevelSize !== void 0 ? t.bevelSize : y - 0.1,
        S = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        C = t.bevelSegments !== void 0 ? t.bevelSegments : 3
      const M = t.extrudePath,
        _ = t.UVGenerator !== void 0 ? t.UVGenerator : tO
      t.amount !== void 0 &&
        (console.warn(
          "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
        ),
        (p = t.amount))
      let R,
        T = !1,
        L,
        B,
        k,
        O
      M &&
        ((R = M.getSpacedPoints(d)),
        (T = !0),
        (m = !1),
        (L = M.computeFrenetFrames(d, !1)),
        (B = new X()),
        (k = new X()),
        (O = new X())),
        m || ((C = 0), (y = 0), (x = 0), (S = 0))
      const W = a.extractPoints(c)
      let z = W.shape
      const P = W.holes
      if (!is.isClockWise(z)) {
        z = z.reverse()
        for (let ye = 0, D = P.length; ye < D; ye++) {
          const q = P[ye]
          is.isClockWise(q) && (P[ye] = q.reverse())
        }
      }
      const G = is.triangulateShape(z, P),
        j = z
      for (let ye = 0, D = P.length; ye < D; ye++) {
        const q = P[ye]
        z = z.concat(q)
      }
      function V(ye, D, q) {
        return (
          D || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          D.clone().multiplyScalar(q).add(ye)
        )
      }
      const Y = z.length,
        ne = G.length
      function le(ye, D, q) {
        let F, te, oe
        const ue = ye.x - D.x,
          Ee = ye.y - D.y,
          Ce = q.x - ye.x,
          Se = q.y - ye.y,
          $ = ue * ue + Ee * Ee,
          Q = ue * Se - Ee * Ce
        if (Math.abs(Q) > Number.EPSILON) {
          const pe = Math.sqrt($),
            Re = Math.sqrt(Ce * Ce + Se * Se),
            Ue = D.x - Ee / pe,
            _e = D.y + ue / pe,
            Xe = q.x - Se / Re,
            se = q.y + Ce / Re,
            be = ((Xe - Ue) * Se - (se - _e) * Ce) / (ue * Se - Ee * Ce)
          ;(F = Ue + ue * be - ye.x), (te = _e + Ee * be - ye.y)
          const ze = F * F + te * te
          if (ze <= 2) return new qe(F, te)
          oe = Math.sqrt(ze / 2)
        } else {
          let pe = !1
          ue > Number.EPSILON
            ? Ce > Number.EPSILON && (pe = !0)
            : ue < -Number.EPSILON
            ? Ce < -Number.EPSILON && (pe = !0)
            : Math.sign(Ee) === Math.sign(Se) && (pe = !0),
            pe
              ? ((F = -Ee), (te = ue), (oe = Math.sqrt($)))
              : ((F = ue), (te = Ee), (oe = Math.sqrt($ / 2)))
        }
        return new qe(F / oe, te / oe)
      }
      const Te = []
      for (
        let ye = 0, D = j.length, q = D - 1, F = ye + 1;
        ye < D;
        ye++, q++, F++
      )
        q === D && (q = 0), F === D && (F = 0), (Te[ye] = le(j[ye], j[q], j[F]))
      const Ae = []
      let ge,
        Me = Te.concat()
      for (let ye = 0, D = P.length; ye < D; ye++) {
        const q = P[ye]
        ge = []
        for (
          let F = 0, te = q.length, oe = te - 1, ue = F + 1;
          F < te;
          F++, oe++, ue++
        )
          oe === te && (oe = 0),
            ue === te && (ue = 0),
            (ge[F] = le(q[F], q[oe], q[ue]))
        Ae.push(ge), (Me = Me.concat(ge))
      }
      for (let ye = 0; ye < C; ye++) {
        const D = ye / C,
          q = y * Math.cos((D * Math.PI) / 2),
          F = x * Math.sin((D * Math.PI) / 2) + S
        for (let te = 0, oe = j.length; te < oe; te++) {
          const ue = V(j[te], Te[te], F)
          ve(ue.x, ue.y, -q)
        }
        for (let te = 0, oe = P.length; te < oe; te++) {
          const ue = P[te]
          ge = Ae[te]
          for (let Ee = 0, Ce = ue.length; Ee < Ce; Ee++) {
            const Se = V(ue[Ee], ge[Ee], F)
            ve(Se.x, Se.y, -q)
          }
        }
      }
      const Ne = x + S
      for (let ye = 0; ye < Y; ye++) {
        const D = m ? V(z[ye], Me[ye], Ne) : z[ye]
        T
          ? (k.copy(L.normals[0]).multiplyScalar(D.x),
            B.copy(L.binormals[0]).multiplyScalar(D.y),
            O.copy(R[0]).add(k).add(B),
            ve(O.x, O.y, O.z))
          : ve(D.x, D.y, 0)
      }
      for (let ye = 1; ye <= d; ye++)
        for (let D = 0; D < Y; D++) {
          const q = m ? V(z[D], Me[D], Ne) : z[D]
          T
            ? (k.copy(L.normals[ye]).multiplyScalar(q.x),
              B.copy(L.binormals[ye]).multiplyScalar(q.y),
              O.copy(R[ye]).add(k).add(B),
              ve(O.x, O.y, O.z))
            : ve(q.x, q.y, (p / d) * ye)
        }
      for (let ye = C - 1; ye >= 0; ye--) {
        const D = ye / C,
          q = y * Math.cos((D * Math.PI) / 2),
          F = x * Math.sin((D * Math.PI) / 2) + S
        for (let te = 0, oe = j.length; te < oe; te++) {
          const ue = V(j[te], Te[te], F)
          ve(ue.x, ue.y, p + q)
        }
        for (let te = 0, oe = P.length; te < oe; te++) {
          const ue = P[te]
          ge = Ae[te]
          for (let Ee = 0, Ce = ue.length; Ee < Ce; Ee++) {
            const Se = V(ue[Ee], ge[Ee], F)
            T
              ? ve(Se.x, Se.y + R[d - 1].y, R[d - 1].x + q)
              : ve(Se.x, Se.y, p + q)
          }
        }
      }
      Ze(), K()
      function Ze() {
        const ye = r.length / 3
        if (m) {
          let D = 0,
            q = Y * D
          for (let F = 0; F < ne; F++) {
            const te = G[F]
            Be(te[2] + q, te[1] + q, te[0] + q)
          }
          ;(D = d + C * 2), (q = Y * D)
          for (let F = 0; F < ne; F++) {
            const te = G[F]
            Be(te[0] + q, te[1] + q, te[2] + q)
          }
        } else {
          for (let D = 0; D < ne; D++) {
            const q = G[D]
            Be(q[2], q[1], q[0])
          }
          for (let D = 0; D < ne; D++) {
            const q = G[D]
            Be(q[0] + Y * d, q[1] + Y * d, q[2] + Y * d)
          }
        }
        i.addGroup(ye, r.length / 3 - ye, 0)
      }
      function K() {
        const ye = r.length / 3
        let D = 0
        Oe(j, D), (D += j.length)
        for (let q = 0, F = P.length; q < F; q++) {
          const te = P[q]
          Oe(te, D), (D += te.length)
        }
        i.addGroup(ye, r.length / 3 - ye, 1)
      }
      function Oe(ye, D) {
        let q = ye.length
        for (; --q >= 0; ) {
          const F = q
          let te = q - 1
          te < 0 && (te = ye.length - 1)
          for (let oe = 0, ue = d + C * 2; oe < ue; oe++) {
            const Ee = Y * oe,
              Ce = Y * (oe + 1),
              Se = D + F + Ee,
              $ = D + te + Ee,
              Q = D + te + Ce,
              pe = D + F + Ce
            Fe(Se, $, Q, pe)
          }
        }
      }
      function ve(ye, D, q) {
        A.push(ye), A.push(D), A.push(q)
      }
      function Be(ye, D, q) {
        je(ye), je(D), je(q)
        const F = r.length / 3,
          te = _.generateTopUV(i, r, F - 3, F - 2, F - 1)
        Ge(te[0]), Ge(te[1]), Ge(te[2])
      }
      function Fe(ye, D, q, F) {
        je(ye), je(D), je(F), je(D), je(q), je(F)
        const te = r.length / 3,
          oe = _.generateSideWallUV(i, r, te - 6, te - 3, te - 2, te - 1)
        Ge(oe[0]), Ge(oe[1]), Ge(oe[3]), Ge(oe[1]), Ge(oe[2]), Ge(oe[3])
      }
      function je(ye) {
        r.push(A[ye * 3 + 0]), r.push(A[ye * 3 + 1]), r.push(A[ye * 3 + 2])
      }
      function Ge(ye) {
        s.push(ye.x), s.push(ye.y)
      }
    }
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      i = this.parameters.options
    return nO(t, i, e)
  }
  static fromJSON(e, t) {
    const i = []
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]]
      i.push(a)
    }
    const r = e.options.extrudePath
    return (
      r !== void 0 && (e.options.extrudePath = new m2[r.type]().fromJSON(r)),
      new Nr(i, e.options)
    )
  }
}
const tO = {
  generateTopUV: function (n, e, t, i, r) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[i * 3],
      A = e[i * 3 + 1],
      c = e[r * 3],
      d = e[r * 3 + 1]
    return [new qe(s, o), new qe(a, A), new qe(c, d)]
  },
  generateSideWallUV: function (n, e, t, i, r, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      A = e[t * 3 + 2],
      c = e[i * 3],
      d = e[i * 3 + 1],
      p = e[i * 3 + 2],
      m = e[r * 3],
      y = e[r * 3 + 1],
      x = e[r * 3 + 2],
      S = e[s * 3],
      C = e[s * 3 + 1],
      M = e[s * 3 + 2]
    return Math.abs(a - d) < Math.abs(o - c)
      ? [new qe(o, 1 - A), new qe(c, 1 - p), new qe(m, 1 - x), new qe(S, 1 - M)]
      : [new qe(a, 1 - A), new qe(d, 1 - p), new qe(y, 1 - x), new qe(C, 1 - M)]
  },
}
function nO(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i]
      t.shapes.push(s.uuid)
    }
  else t.shapes.push(n.uuid)
  return (
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  )
}
class bc extends cs {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ]
    super(r, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t })
  }
  static fromJSON(e) {
    return new bc(e.radius, e.detail)
  }
}
class wc extends yt {
  constructor(
    e = [new qe(0, 0.5), new qe(0.5, 0), new qe(0, -0.5)],
    t = 12,
    i = 0,
    r = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }),
      (t = Math.floor(t)),
      (r = li(r, 0, Math.PI * 2))
    const s = [],
      o = [],
      a = [],
      A = [],
      c = [],
      d = 1 / t,
      p = new X(),
      m = new qe(),
      y = new X(),
      x = new X(),
      S = new X()
    let C = 0,
      M = 0
    for (let _ = 0; _ <= e.length - 1; _++)
      switch (_) {
        case 0:
          ;(C = e[_ + 1].x - e[_].x),
            (M = e[_ + 1].y - e[_].y),
            (y.x = M * 1),
            (y.y = -C),
            (y.z = M * 0),
            S.copy(y),
            y.normalize(),
            A.push(y.x, y.y, y.z)
          break
        case e.length - 1:
          A.push(S.x, S.y, S.z)
          break
        default:
          ;(C = e[_ + 1].x - e[_].x),
            (M = e[_ + 1].y - e[_].y),
            (y.x = M * 1),
            (y.y = -C),
            (y.z = M * 0),
            x.copy(y),
            (y.x += S.x),
            (y.y += S.y),
            (y.z += S.z),
            y.normalize(),
            A.push(y.x, y.y, y.z),
            S.copy(x)
      }
    for (let _ = 0; _ <= t; _++) {
      const R = i + _ * d * r,
        T = Math.sin(R),
        L = Math.cos(R)
      for (let B = 0; B <= e.length - 1; B++) {
        ;(p.x = e[B].x * T),
          (p.y = e[B].y),
          (p.z = e[B].x * L),
          o.push(p.x, p.y, p.z),
          (m.x = _ / t),
          (m.y = B / (e.length - 1)),
          a.push(m.x, m.y)
        const k = A[3 * B + 0] * T,
          O = A[3 * B + 1],
          W = A[3 * B + 0] * L
        c.push(k, O, W)
      }
    }
    for (let _ = 0; _ < t; _++)
      for (let R = 0; R < e.length - 1; R++) {
        const T = R + _ * e.length,
          L = T,
          B = T + e.length,
          k = T + e.length + 1,
          O = T + 1
        s.push(L, B, O), s.push(k, O, B)
      }
    this.setIndex(s),
      this.setAttribute("position", new ut(o, 3)),
      this.setAttribute("uv", new ut(a, 2)),
      this.setAttribute("normal", new ut(c, 3))
  }
  static fromJSON(e) {
    return new wc(e.points, e.segments, e.phiStart, e.phiLength)
  }
}
class Va extends cs {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      r = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ]
    super(i, r, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t })
  }
  static fromJSON(e) {
    return new Va(e.radius, e.detail)
  }
}
class Mc extends yt {
  constructor(e = 0.5, t = 1, i = 8, r = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: r,
        thetaStart: s,
        thetaLength: o,
      }),
      (i = Math.max(3, i)),
      (r = Math.max(1, r))
    const a = [],
      A = [],
      c = [],
      d = []
    let p = e
    const m = (t - e) / r,
      y = new X(),
      x = new qe()
    for (let S = 0; S <= r; S++) {
      for (let C = 0; C <= i; C++) {
        const M = s + (C / i) * o
        ;(y.x = p * Math.cos(M)),
          (y.y = p * Math.sin(M)),
          A.push(y.x, y.y, y.z),
          c.push(0, 0, 1),
          (x.x = (y.x / t + 1) / 2),
          (x.y = (y.y / t + 1) / 2),
          d.push(x.x, x.y)
      }
      p += m
    }
    for (let S = 0; S < r; S++) {
      const C = S * (i + 1)
      for (let M = 0; M < i; M++) {
        const _ = M + C,
          R = _,
          T = _ + i + 1,
          L = _ + i + 2,
          B = _ + 1
        a.push(R, T, B), a.push(T, L, B)
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new ut(A, 3)),
      this.setAttribute("normal", new ut(c, 3)),
      this.setAttribute("uv", new ut(d, 2))
  }
  static fromJSON(e) {
    return new Mc(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class Wa extends yt {
  constructor(
    e = new ns([new qe(0, 0.5), new qe(-0.5, -0.5), new qe(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t })
    const i = [],
      r = [],
      s = [],
      o = []
    let a = 0,
      A = 0
    if (Array.isArray(e) === !1) c(e)
    else
      for (let d = 0; d < e.length; d++)
        c(e[d]), this.addGroup(a, A, d), (a += A), (A = 0)
    this.setIndex(i),
      this.setAttribute("position", new ut(r, 3)),
      this.setAttribute("normal", new ut(s, 3)),
      this.setAttribute("uv", new ut(o, 2))
    function c(d) {
      const p = r.length / 3,
        m = d.extractPoints(t)
      let y = m.shape
      const x = m.holes
      is.isClockWise(y) === !1 && (y = y.reverse())
      for (let C = 0, M = x.length; C < M; C++) {
        const _ = x[C]
        is.isClockWise(_) === !0 && (x[C] = _.reverse())
      }
      const S = is.triangulateShape(y, x)
      for (let C = 0, M = x.length; C < M; C++) {
        const _ = x[C]
        y = y.concat(_)
      }
      for (let C = 0, M = y.length; C < M; C++) {
        const _ = y[C]
        r.push(_.x, _.y, 0), s.push(0, 0, 1), o.push(_.x, _.y)
      }
      for (let C = 0, M = S.length; C < M; C++) {
        const _ = S[C],
          R = _[0] + p,
          T = _[1] + p,
          L = _[2] + p
        i.push(R, T, L), (A += 3)
      }
    }
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes
    return iO(t, e)
  }
  static fromJSON(e, t) {
    const i = []
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]]
      i.push(o)
    }
    return new Wa(i, e.curveSegments)
  }
}
function iO(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, i = n.length; t < i; t++) {
      const r = n[t]
      e.shapes.push(r.uuid)
    }
  else e.shapes.push(n.uuid)
  return e
}
class As extends yt {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    r = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i)))
    const A = Math.min(o + a, Math.PI)
    let c = 0
    const d = [],
      p = new X(),
      m = new X(),
      y = [],
      x = [],
      S = [],
      C = []
    for (let M = 0; M <= i; M++) {
      const _ = [],
        R = M / i
      let T = 0
      M == 0 && o == 0
        ? (T = 0.5 / t)
        : M == i && A == Math.PI && (T = -0.5 / t)
      for (let L = 0; L <= t; L++) {
        const B = L / t
        ;(p.x = -e * Math.cos(r + B * s) * Math.sin(o + R * a)),
          (p.y = e * Math.cos(o + R * a)),
          (p.z = e * Math.sin(r + B * s) * Math.sin(o + R * a)),
          x.push(p.x, p.y, p.z),
          m.copy(p).normalize(),
          S.push(m.x, m.y, m.z),
          C.push(B + T, 1 - R),
          _.push(c++)
      }
      d.push(_)
    }
    for (let M = 0; M < i; M++)
      for (let _ = 0; _ < t; _++) {
        const R = d[M][_ + 1],
          T = d[M][_],
          L = d[M + 1][_],
          B = d[M + 1][_ + 1]
        ;(M !== 0 || o > 0) && y.push(R, T, B),
          (M !== i - 1 || A < Math.PI) && y.push(T, L, B)
      }
    this.setIndex(y),
      this.setAttribute("position", new ut(x, 3)),
      this.setAttribute("normal", new ut(S, 3)),
      this.setAttribute("uv", new ut(C, 2))
  }
  static fromJSON(e) {
    return new As(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class Sc extends cs {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]
    super(i, r, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t })
  }
  static fromJSON(e) {
    return new Sc(e.radius, e.detail)
  }
}
class Ec extends yt {
  constructor(e = 1, t = 0.4, i = 8, r = 6, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: r,
        arc: s,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r))
    const o = [],
      a = [],
      A = [],
      c = [],
      d = new X(),
      p = new X(),
      m = new X()
    for (let y = 0; y <= i; y++)
      for (let x = 0; x <= r; x++) {
        const S = (x / r) * s,
          C = (y / i) * Math.PI * 2
        ;(p.x = (e + t * Math.cos(C)) * Math.cos(S)),
          (p.y = (e + t * Math.cos(C)) * Math.sin(S)),
          (p.z = t * Math.sin(C)),
          a.push(p.x, p.y, p.z),
          (d.x = e * Math.cos(S)),
          (d.y = e * Math.sin(S)),
          m.subVectors(p, d).normalize(),
          A.push(m.x, m.y, m.z),
          c.push(x / r),
          c.push(y / i)
      }
    for (let y = 1; y <= i; y++)
      for (let x = 1; x <= r; x++) {
        const S = (r + 1) * y + x - 1,
          C = (r + 1) * (y - 1) + x - 1,
          M = (r + 1) * (y - 1) + x,
          _ = (r + 1) * y + x
        o.push(S, C, _), o.push(C, M, _)
      }
    this.setIndex(o),
      this.setAttribute("position", new ut(a, 3)),
      this.setAttribute("normal", new ut(A, 3)),
      this.setAttribute("uv", new ut(c, 2))
  }
  static fromJSON(e) {
    return new Ec(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
  }
}
class Tc extends yt {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: i,
        radialSegments: r,
        p: s,
        q: o,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r))
    const a = [],
      A = [],
      c = [],
      d = [],
      p = new X(),
      m = new X(),
      y = new X(),
      x = new X(),
      S = new X(),
      C = new X(),
      M = new X()
    for (let R = 0; R <= i; ++R) {
      const T = (R / i) * s * Math.PI * 2
      _(T, s, o, e, y),
        _(T + 0.01, s, o, e, x),
        C.subVectors(x, y),
        M.addVectors(x, y),
        S.crossVectors(C, M),
        M.crossVectors(S, C),
        S.normalize(),
        M.normalize()
      for (let L = 0; L <= r; ++L) {
        const B = (L / r) * Math.PI * 2,
          k = -t * Math.cos(B),
          O = t * Math.sin(B)
        ;(p.x = y.x + (k * M.x + O * S.x)),
          (p.y = y.y + (k * M.y + O * S.y)),
          (p.z = y.z + (k * M.z + O * S.z)),
          A.push(p.x, p.y, p.z),
          m.subVectors(p, y).normalize(),
          c.push(m.x, m.y, m.z),
          d.push(R / i),
          d.push(L / r)
      }
    }
    for (let R = 1; R <= i; R++)
      for (let T = 1; T <= r; T++) {
        const L = (r + 1) * (R - 1) + (T - 1),
          B = (r + 1) * R + (T - 1),
          k = (r + 1) * R + T,
          O = (r + 1) * (R - 1) + T
        a.push(L, B, O), a.push(B, k, O)
      }
    this.setIndex(a),
      this.setAttribute("position", new ut(A, 3)),
      this.setAttribute("normal", new ut(c, 3)),
      this.setAttribute("uv", new ut(d, 2))
    function _(R, T, L, B, k) {
      const O = Math.cos(R),
        W = Math.sin(R),
        z = (L / T) * R,
        P = Math.cos(z)
      ;(k.x = B * (2 + P) * 0.5 * O),
        (k.y = B * (2 + P) * W * 0.5),
        (k.z = B * Math.sin(z) * 0.5)
    }
  }
  static fromJSON(e) {
    return new Tc(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    )
  }
}
class ja extends yt {
  constructor(
    e = new Wu(new X(-1, -1, 0), new X(-1, 1, 0), new X(1, 1, 0)),
    t = 64,
    i = 1,
    r = 8,
    s = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: i,
        radialSegments: r,
        closed: s,
      })
    const o = e.computeFrenetFrames(t, s)
    ;(this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals)
    const a = new X(),
      A = new X(),
      c = new qe()
    let d = new X()
    const p = [],
      m = [],
      y = [],
      x = []
    S(),
      this.setIndex(x),
      this.setAttribute("position", new ut(p, 3)),
      this.setAttribute("normal", new ut(m, 3)),
      this.setAttribute("uv", new ut(y, 2))
    function S() {
      for (let R = 0; R < t; R++) C(R)
      C(s === !1 ? t : 0), _(), M()
    }
    function C(R) {
      d = e.getPointAt(R / t, d)
      const T = o.normals[R],
        L = o.binormals[R]
      for (let B = 0; B <= r; B++) {
        const k = (B / r) * Math.PI * 2,
          O = Math.sin(k),
          W = -Math.cos(k)
        ;(A.x = W * T.x + O * L.x),
          (A.y = W * T.y + O * L.y),
          (A.z = W * T.z + O * L.z),
          A.normalize(),
          m.push(A.x, A.y, A.z),
          (a.x = d.x + i * A.x),
          (a.y = d.y + i * A.y),
          (a.z = d.z + i * A.z),
          p.push(a.x, a.y, a.z)
      }
    }
    function M() {
      for (let R = 1; R <= t; R++)
        for (let T = 1; T <= r; T++) {
          const L = (r + 1) * (R - 1) + (T - 1),
            B = (r + 1) * R + (T - 1),
            k = (r + 1) * R + T,
            O = (r + 1) * (R - 1) + T
          x.push(L, B, O), x.push(B, k, O)
        }
    }
    function _() {
      for (let R = 0; R <= t; R++)
        for (let T = 0; T <= r; T++)
          (c.x = R / t), (c.y = T / r), y.push(c.x, c.y)
    }
  }
  toJSON() {
    const e = super.toJSON()
    return (e.path = this.parameters.path.toJSON()), e
  }
  static fromJSON(e) {
    return new ja(
      new m2[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    )
  }
}
class Hd extends yt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        i = new Set(),
        r = new X(),
        s = new X()
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index
        let A = e.groups
        A.length === 0 && (A = [{ start: 0, count: a.count, materialIndex: 0 }])
        for (let c = 0, d = A.length; c < d; ++c) {
          const p = A[c],
            m = p.start,
            y = p.count
          for (let x = m, S = m + y; x < S; x += 3)
            for (let C = 0; C < 3; C++) {
              const M = a.getX(x + C),
                _ = a.getX(x + ((C + 1) % 3))
              r.fromBufferAttribute(o, M),
                s.fromBufferAttribute(o, _),
                a3(r, s, i) === !0 &&
                  (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z))
            }
        }
      } else {
        const o = e.attributes.position
        for (let a = 0, A = o.count / 3; a < A; a++)
          for (let c = 0; c < 3; c++) {
            const d = 3 * a + c,
              p = 3 * a + ((c + 1) % 3)
            r.fromBufferAttribute(o, d),
              s.fromBufferAttribute(o, p),
              a3(r, s, i) === !0 &&
                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z))
          }
      }
      this.setAttribute("position", new ut(t, 3))
    }
  }
}
function a3(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i, r), !0)
}
var l3 = Object.freeze({
  __proto__: null,
  BoxGeometry: Us,
  BoxBufferGeometry: Us,
  CircleGeometry: Ga,
  CircleBufferGeometry: Ga,
  ConeGeometry: _c,
  ConeBufferGeometry: _c,
  CylinderGeometry: zs,
  CylinderBufferGeometry: zs,
  DodecahedronGeometry: xc,
  DodecahedronBufferGeometry: xc,
  EdgesGeometry: f2,
  ExtrudeGeometry: Nr,
  ExtrudeBufferGeometry: Nr,
  IcosahedronGeometry: bc,
  IcosahedronBufferGeometry: bc,
  LatheGeometry: wc,
  LatheBufferGeometry: wc,
  OctahedronGeometry: Va,
  OctahedronBufferGeometry: Va,
  PlaneGeometry: za,
  PlaneBufferGeometry: za,
  PolyhedronGeometry: cs,
  PolyhedronBufferGeometry: cs,
  RingGeometry: Mc,
  RingBufferGeometry: Mc,
  ShapeGeometry: Wa,
  ShapeBufferGeometry: Wa,
  SphereGeometry: As,
  SphereBufferGeometry: As,
  TetrahedronGeometry: Sc,
  TetrahedronBufferGeometry: Sc,
  TorusGeometry: Ec,
  TorusBufferGeometry: Ec,
  TorusKnotGeometry: Tc,
  TorusKnotBufferGeometry: Tc,
  TubeGeometry: ja,
  TubeBufferGeometry: ja,
  WireframeGeometry: Hd,
})
class g2 extends ii {
  constructor(e) {
    super(),
      (this.type = "ShadowMaterial"),
      (this.color = new Ke(0)),
      (this.transparent = !0),
      this.setValues(e)
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this
  }
}
g2.prototype.isShadowMaterial = !0
class Gd extends ii {
  constructor(e) {
    super(),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Ke(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ke(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = il),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      this
    )
  }
}
Gd.prototype.isMeshStandardMaterial = !0
class y2 extends Gd {
  constructor(e) {
    super(),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new qe(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return li((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1)
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t)
        },
      }),
      (this.sheenColor = new Ke(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 0),
      (this.attenuationColor = new Ke(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Ke(1, 1, 1)),
      (this.specularColorMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._transmission = 0),
      this.setValues(e)
  }
  get sheen() {
    return this._sheen
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e)
  }
  get clearcoat() {
    return this._clearcoat
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e)
  }
  get transmission() {
    return this._transmission
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    )
  }
}
y2.prototype.isMeshPhysicalMaterial = !0
class Vd extends ii {
  constructor(e) {
    super(),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Ke(16777215)),
      (this.specular = new Ke(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ke(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = il),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = ku),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      this
    )
  }
}
Vd.prototype.isMeshPhongMaterial = !0
class v2 extends ii {
  constructor(e) {
    super(),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ke(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = il),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      this
    )
  }
}
v2.prototype.isMeshToonMaterial = !0
class _2 extends ii {
  constructor(e) {
    super(),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = il),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.flatShading = !1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    )
  }
}
_2.prototype.isMeshNormalMaterial = !0
class Zs extends ii {
  constructor(e) {
    super(),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ke(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = ku),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      this
    )
  }
}
Zs.prototype.isMeshLambertMaterial = !0
class x2 extends ii {
  constructor(e) {
    super(),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Ke(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = il),
      (this.normalScale = new qe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      this
    )
  }
}
x2.prototype.isMeshMatcapMaterial = !0
class b2 extends Nn {
  constructor(e) {
    super(),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    )
  }
}
b2.prototype.isLineDashedMaterial = !0
var rO = Object.freeze({
  __proto__: null,
  ShadowMaterial: g2,
  SpriteMaterial: Dd,
  RawShaderMaterial: Gc,
  ShaderMaterial: ar,
  PointsMaterial: rl,
  MeshPhysicalMaterial: y2,
  MeshStandardMaterial: Gd,
  MeshPhongMaterial: Vd,
  MeshToonMaterial: v2,
  MeshNormalMaterial: _2,
  MeshLambertMaterial: Zs,
  MeshDepthMaterial: Rd,
  MeshDistanceMaterial: Pd,
  MeshBasicMaterial: Mr,
  MeshMatcapMaterial: x2,
  LineDashedMaterial: b2,
  LineBasicMaterial: Nn,
  Material: ii,
})
const mn = {
  arraySlice: function (n, e, t) {
    return mn.isTypedArray(n)
      ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length))
      : n.slice(e, t)
  },
  convertArray: function (n, e, t) {
    return !n || (!t && n.constructor === e)
      ? n
      : typeof e.BYTES_PER_ELEMENT == "number"
      ? new e(n)
      : Array.prototype.slice.call(n)
  },
  isTypedArray: function (n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView)
  },
  getKeyframeOrder: function (n) {
    function e(r, s) {
      return n[r] - n[s]
    }
    const t = n.length,
      i = new Array(t)
    for (let r = 0; r !== t; ++r) i[r] = r
    return i.sort(e), i
  },
  sortedArray: function (n, e, t) {
    const i = n.length,
      r = new n.constructor(i)
    for (let s = 0, o = 0; o !== i; ++s) {
      const a = t[s] * e
      for (let A = 0; A !== e; ++A) r[o++] = n[a + A]
    }
    return r
  },
  flattenJSON: function (n, e, t, i) {
    let r = 1,
      s = n[0]
    for (; s !== void 0 && s[i] === void 0; ) s = n[r++]
    if (s === void 0) return
    let o = s[i]
    if (o !== void 0)
      if (Array.isArray(o))
        do
          (o = s[i]),
            o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
            (s = n[r++])
        while (s !== void 0)
      else if (o.toArray !== void 0)
        do
          (o = s[i]),
            o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
            (s = n[r++])
        while (s !== void 0)
      else
        do (o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++])
        while (s !== void 0)
  },
  subclip: function (n, e, t, i, r = 30) {
    const s = n.clone()
    s.name = e
    const o = []
    for (let A = 0; A < s.tracks.length; ++A) {
      const c = s.tracks[A],
        d = c.getValueSize(),
        p = [],
        m = []
      for (let y = 0; y < c.times.length; ++y) {
        const x = c.times[y] * r
        if (!(x < t || x >= i)) {
          p.push(c.times[y])
          for (let S = 0; S < d; ++S) m.push(c.values[y * d + S])
        }
      }
      p.length !== 0 &&
        ((c.times = mn.convertArray(p, c.times.constructor)),
        (c.values = mn.convertArray(m, c.values.constructor)),
        o.push(c))
    }
    s.tracks = o
    let a = 1 / 0
    for (let A = 0; A < s.tracks.length; ++A)
      a > s.tracks[A].times[0] && (a = s.tracks[A].times[0])
    for (let A = 0; A < s.tracks.length; ++A) s.tracks[A].shift(-1 * a)
    return s.resetDuration(), s
  },
  makeClipAdditive: function (n, e = 0, t = n, i = 30) {
    i <= 0 && (i = 30)
    const r = t.tracks.length,
      s = e / i
    for (let o = 0; o < r; ++o) {
      const a = t.tracks[o],
        A = a.ValueTypeName
      if (A === "bool" || A === "string") continue
      const c = n.tracks.find(function (M) {
        return M.name === a.name && M.ValueTypeName === A
      })
      if (c === void 0) continue
      let d = 0
      const p = a.getValueSize()
      a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (d = p / 3)
      let m = 0
      const y = c.getValueSize()
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
        (m = y / 3)
      const x = a.times.length - 1
      let S
      if (s <= a.times[0]) {
        const M = d,
          _ = p - d
        S = mn.arraySlice(a.values, M, _)
      } else if (s >= a.times[x]) {
        const M = x * p + d,
          _ = M + p - d
        S = mn.arraySlice(a.values, M, _)
      } else {
        const M = a.createInterpolant(),
          _ = d,
          R = p - d
        M.evaluate(s), (S = mn.arraySlice(M.resultBuffer, _, R))
      }
      A === "quaternion" &&
        new Jn().fromArray(S).normalize().conjugate().toArray(S)
      const C = c.times.length
      for (let M = 0; M < C; ++M) {
        const _ = M * y + m
        if (A === "quaternion")
          Jn.multiplyQuaternionsFlat(c.values, _, S, 0, c.values, _)
        else {
          const R = y - m * 2
          for (let T = 0; T < R; ++T) c.values[_ + T] -= S[T]
        }
      }
    }
    return (n.blendMode = n2), n
  },
}
class Hs {
  constructor(e, t, i, r) {
    ;(this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {})
  }
  evaluate(e) {
    const t = this.parameterPositions
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1]
    e: {
      t: {
        let o
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.afterEnd_(i - 1, e, s)
                )
              }
              if (i === a) break
              if (((s = r), (r = t[++i]), e < r)) break t
            }
            o = t.length
            break n
          }
          if (!(e >= s)) {
            const a = t[1]
            e < a && ((i = 2), (s = a))
            for (let A = i - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.beforeStart_(0, e, r)
              if (i === A) break
              if (((r = s), (s = t[--i - 1]), e >= s)) break t
            }
            ;(o = i), (i = 0)
            break n
          }
          break e
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1
          e < t[a] ? (o = a) : (i = a + 1)
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return (this._cachedIndex = 0), this.beforeStart_(0, e, r)
        if (r === void 0)
          return (
            (i = t.length), (this._cachedIndex = i), this.afterEnd_(i - 1, s, e)
          )
      }
      ;(this._cachedIndex = i), this.intervalChanged_(i, s, r)
    }
    return this.interpolate_(i, s, e, r)
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r
    for (let o = 0; o !== r; ++o) t[o] = i[s + o]
    return t
  }
  interpolate_() {
    throw new Error("call to abstract method")
  }
  intervalChanged_() {}
}
Hs.prototype.beforeStart_ = Hs.prototype.copySampleValue_
Hs.prototype.afterEnd_ = Hs.prototype.copySampleValue_
class t6 extends Hs {
  constructor(e, t, i, r) {
    super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: ba, endingEnd: ba })
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions
    let s = e - 2,
      o = e + 1,
      a = r[s],
      A = r[o]
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case wa:
          ;(s = e), (a = 2 * t - i)
          break
        case tu:
          ;(s = r.length - 2), (a = t + r[s] - r[s + 1])
          break
        default:
          ;(s = e), (a = i)
      }
    if (A === void 0)
      switch (this.getSettings_().endingEnd) {
        case wa:
          ;(o = e), (A = 2 * i - t)
          break
        case tu:
          ;(o = 1), (A = i + r[1] - r[0])
          break
        default:
          ;(o = e - 1), (A = t)
      }
    const c = (i - t) * 0.5,
      d = this.valueSize
    ;(this._weightPrev = c / (t - a)),
      (this._weightNext = c / (A - i)),
      (this._offsetPrev = s * d),
      (this._offsetNext = o * d)
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      A = e * a,
      c = A - a,
      d = this._offsetPrev,
      p = this._offsetNext,
      m = this._weightPrev,
      y = this._weightNext,
      x = (i - t) / (r - t),
      S = x * x,
      C = S * x,
      M = -m * C + 2 * m * S - m * x,
      _ = (1 + m) * C + (-1.5 - 2 * m) * S + (-0.5 + m) * x + 1,
      R = (-1 - y) * C + (1.5 + y) * S + 0.5 * x,
      T = y * C - y * S
    for (let L = 0; L !== a; ++L)
      s[L] = M * o[d + L] + _ * o[c + L] + R * o[A + L] + T * o[p + L]
    return s
  }
}
class w2 extends Hs {
  constructor(e, t, i, r) {
    super(e, t, i, r)
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      A = e * a,
      c = A - a,
      d = (i - t) / (r - t),
      p = 1 - d
    for (let m = 0; m !== a; ++m) s[m] = o[c + m] * p + o[A + m] * d
    return s
  }
}
class n6 extends Hs {
  constructor(e, t, i, r) {
    super(e, t, i, r)
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1)
  }
}
class Hr {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined")
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e)
    ;(this.name = e),
      (this.times = mn.convertArray(t, this.TimeBufferType)),
      (this.values = mn.convertArray(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation)
  }
  static toJSON(e) {
    const t = e.constructor
    let i
    if (t.toJSON !== this.toJSON) i = t.toJSON(e)
    else {
      i = {
        name: e.name,
        times: mn.convertArray(e.times, Array),
        values: mn.convertArray(e.values, Array),
      }
      const r = e.getInterpolation()
      r !== e.DefaultInterpolation && (i.interpolation = r)
    }
    return (i.type = e.ValueTypeName), i
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new n6(this.times, this.values, this.getValueSize(), e)
  }
  InterpolantFactoryMethodLinear(e) {
    return new w2(this.times, this.values, this.getValueSize(), e)
  }
  InterpolantFactoryMethodSmooth(e) {
    return new t6(this.times, this.values, this.getValueSize(), e)
  }
  setInterpolation(e) {
    let t
    switch (e) {
      case KA:
        t = this.InterpolantFactoryMethodDiscrete
        break
      case eu:
        t = this.InterpolantFactoryMethodLinear
        break
      case Wh:
        t = this.InterpolantFactoryMethodSmooth
        break
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation)
        else throw new Error(i)
      return console.warn("THREE.KeyframeTrack:", i), this
    }
    return (this.createInterpolant = t), this
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return KA
      case this.InterpolantFactoryMethodLinear:
        return eu
      case this.InterpolantFactoryMethodSmooth:
        return Wh
    }
  }
  getValueSize() {
    return this.values.length / this.times.length
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e
    }
    return this
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e
    }
    return this
  }
  trim(e, t) {
    const i = this.times,
      r = i.length
    let s = 0,
      o = r - 1
    for (; s !== r && i[s] < e; ) ++s
    for (; o !== -1 && i[o] > t; ) --o
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1))
      const a = this.getValueSize()
      ;(this.times = mn.arraySlice(i, s, o)),
        (this.values = mn.arraySlice(this.values, s * a, o * a))
    }
    return this
  }
  validate() {
    let e = !0
    const t = this.getValueSize()
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1))
    const i = this.times,
      r = this.values,
      s = i.length
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1))
    let o = null
    for (let a = 0; a !== s; a++) {
      const A = i[a]
      if (typeof A == "number" && isNaN(A)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          A
        ),
          (e = !1)
        break
      }
      if (o !== null && o > A) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, A, o),
          (e = !1)
        break
      }
      o = A
    }
    if (r !== void 0 && mn.isTypedArray(r))
      for (let a = 0, A = r.length; a !== A; ++a) {
        const c = r[a]
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c
          ),
            (e = !1)
          break
        }
      }
    return e
  }
  optimize() {
    const e = mn.arraySlice(this.times),
      t = mn.arraySlice(this.values),
      i = this.getValueSize(),
      r = this.getInterpolation() === Wh,
      s = e.length - 1
    let o = 1
    for (let a = 1; a < s; ++a) {
      let A = !1
      const c = e[a],
        d = e[a + 1]
      if (c !== d && (a !== 1 || c !== e[0]))
        if (r) A = !0
        else {
          const p = a * i,
            m = p - i,
            y = p + i
          for (let x = 0; x !== i; ++x) {
            const S = t[p + x]
            if (S !== t[m + x] || S !== t[y + x]) {
              A = !0
              break
            }
          }
        }
      if (A) {
        if (a !== o) {
          e[o] = e[a]
          const p = a * i,
            m = o * i
          for (let y = 0; y !== i; ++y) t[m + y] = t[p + y]
        }
        ++o
      }
    }
    if (s > 0) {
      e[o] = e[s]
      for (let a = s * i, A = o * i, c = 0; c !== i; ++c) t[A + c] = t[a + c]
      ++o
    }
    return (
      o !== e.length
        ? ((this.times = mn.arraySlice(e, 0, o)),
          (this.values = mn.arraySlice(t, 0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    )
  }
  clone() {
    const e = mn.arraySlice(this.times, 0),
      t = mn.arraySlice(this.values, 0),
      i = this.constructor,
      r = new i(this.name, e, t)
    return (r.createInterpolant = this.createInterpolant), r
  }
}
Hr.prototype.TimeBufferType = Float32Array
Hr.prototype.ValueBufferType = Float32Array
Hr.prototype.DefaultInterpolation = eu
class sl extends Hr {}
sl.prototype.ValueTypeName = "bool"
sl.prototype.ValueBufferType = Array
sl.prototype.DefaultInterpolation = KA
sl.prototype.InterpolantFactoryMethodLinear = void 0
sl.prototype.InterpolantFactoryMethodSmooth = void 0
class M2 extends Hr {}
M2.prototype.ValueTypeName = "color"
class lu extends Hr {}
lu.prototype.ValueTypeName = "number"
class i6 extends Hs {
  constructor(e, t, i, r) {
    super(e, t, i, r)
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      A = (i - t) / (r - t)
    let c = e * a
    for (let d = c + a; c !== d; c += 4) Jn.slerpFlat(s, 0, o, c - a, o, c, A)
    return s
  }
}
class Wc extends Hr {
  InterpolantFactoryMethodLinear(e) {
    return new i6(this.times, this.values, this.getValueSize(), e)
  }
}
Wc.prototype.ValueTypeName = "quaternion"
Wc.prototype.DefaultInterpolation = eu
Wc.prototype.InterpolantFactoryMethodSmooth = void 0
class ol extends Hr {}
ol.prototype.ValueTypeName = "string"
ol.prototype.ValueBufferType = Array
ol.prototype.DefaultInterpolation = KA
ol.prototype.InterpolantFactoryMethodLinear = void 0
ol.prototype.InterpolantFactoryMethodSmooth = void 0
class cu extends Hr {}
cu.prototype.ValueTypeName = "vector"
class Au {
  constructor(e, t = -1, i, r = _d) {
    ;(this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = ir()),
      this.duration < 0 && this.resetDuration()
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1)
    for (let o = 0, a = i.length; o !== a; ++o) t.push(oO(i[o]).scale(r))
    const s = new this(e.name, e.duration, t, e.blendMode)
    return (s.uuid = e.uuid), s
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      }
    for (let s = 0, o = i.length; s !== o; ++s) t.push(Hr.toJSON(i[s]))
    return r
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = []
    for (let a = 0; a < s; a++) {
      let A = [],
        c = []
      A.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0)
      const d = mn.getKeyframeOrder(A)
      ;(A = mn.sortedArray(A, 1, d)),
        (c = mn.sortedArray(c, 1, d)),
        !r && A[0] === 0 && (A.push(s), c.push(c[0])),
        o.push(
          new lu(".morphTargetInfluences[" + t[a].name + "]", A, c).scale(1 / i)
        )
    }
    return new this(e, -1, o)
  }
  static findByName(e, t) {
    let i = e
    if (!Array.isArray(e)) {
      const r = e
      i = (r.geometry && r.geometry.animations) || r.animations
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r]
    return null
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/
    for (let a = 0, A = e.length; a < A; a++) {
      const c = e[a],
        d = c.name.match(s)
      if (d && d.length > 1) {
        const p = d[1]
        let m = r[p]
        m || (r[p] = m = []), m.push(c)
      }
    }
    const o = []
    for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i))
    return o
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      )
    const i = function (p, m, y, x, S) {
        if (y.length !== 0) {
          const C = [],
            M = []
          mn.flattenJSON(y, C, M, x), C.length !== 0 && S.push(new p(m, C, M))
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode
    let A = e.length || -1
    const c = e.hierarchy || []
    for (let p = 0; p < c.length; p++) {
      const m = c[p].keys
      if (!(!m || m.length === 0))
        if (m[0].morphTargets) {
          const y = {}
          let x
          for (x = 0; x < m.length; x++)
            if (m[x].morphTargets)
              for (let S = 0; S < m[x].morphTargets.length; S++)
                y[m[x].morphTargets[S]] = -1
          for (const S in y) {
            const C = [],
              M = []
            for (let _ = 0; _ !== m[x].morphTargets.length; ++_) {
              const R = m[x]
              C.push(R.time), M.push(R.morphTarget === S ? 1 : 0)
            }
            r.push(new lu(".morphTargetInfluence[" + S + "]", C, M))
          }
          A = y.length * (o || 1)
        } else {
          const y = ".bones[" + t[p].name + "]"
          i(cu, y + ".position", m, "pos", r),
            i(Wc, y + ".quaternion", m, "rot", r),
            i(cu, y + ".scale", m, "scl", r)
        }
    }
    return r.length === 0 ? null : new this(s, A, r, a)
  }
  resetDuration() {
    const e = this.tracks
    let t = 0
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i]
      t = Math.max(t, s.times[s.times.length - 1])
    }
    return (this.duration = t), this
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration)
    return this
  }
  validate() {
    let e = !0
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate()
    return e
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize()
    return this
  }
  clone() {
    const e = []
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone())
    return new this.constructor(this.name, this.duration, e, this.blendMode)
  }
  toJSON() {
    return this.constructor.toJSON(this)
  }
}
function sO(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return lu
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return cu
    case "color":
      return M2
    case "quaternion":
      return Wc
    case "bool":
    case "boolean":
      return sl
    case "string":
      return ol
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}
function oO(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse")
  const e = sO(n.type)
  if (n.times === void 0) {
    const t = [],
      i = []
    mn.flattenJSON(n.keys, t, i, "value"), (n.times = t), (n.values = i)
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation)
}
const $a = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e)
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n]
  },
  remove: function (n) {
    delete this.files[n]
  },
  clear: function () {
    this.files = {}
  },
}
class S2 {
  constructor(e, t, i) {
    const r = this
    let s = !1,
      o = 0,
      a = 0,
      A
    const c = []
    ;(this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (d) {
        a++, s === !1 && r.onStart !== void 0 && r.onStart(d, o, a), (s = !0)
      }),
      (this.itemEnd = function (d) {
        o++,
          r.onProgress !== void 0 && r.onProgress(d, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad())
      }),
      (this.itemError = function (d) {
        r.onError !== void 0 && r.onError(d)
      }),
      (this.resolveURL = function (d) {
        return A ? A(d) : d
      }),
      (this.setURLModifier = function (d) {
        return (A = d), this
      }),
      (this.addHandler = function (d, p) {
        return c.push(d, p), this
      }),
      (this.removeHandler = function (d) {
        const p = c.indexOf(d)
        return p !== -1 && c.splice(p, 2), this
      }),
      (this.getHandler = function (d) {
        for (let p = 0, m = c.length; p < m; p += 2) {
          const y = c[p],
            x = c[p + 1]
          if ((y.global && (y.lastIndex = 0), y.test(d))) return x
        }
        return null
      })
  }
}
const r6 = new S2()
class Pi {
  constructor(e) {
    ;(this.manager = e !== void 0 ? e : r6),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {})
  }
  load() {}
  loadAsync(e, t) {
    const i = this
    return new Promise(function (r, s) {
      i.load(e, r, t, s)
    })
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this
  }
  setPath(e) {
    return (this.path = e), this
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this
  }
}
const bs = {}
class us extends Pi {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e))
    const s = $a.get(e)
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e)
        }, 0),
        s
      )
    if (bs[e] !== void 0) {
      bs[e].push({ onLoad: t, onProgress: i, onError: r })
      return
    }
    ;(bs[e] = []), bs[e].push({ onLoad: t, onProgress: i, onError: r })
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      A = this.responseType
    fetch(o)
      .then(c => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream == "undefined" || c.body.getReader === void 0)
          )
            return c
          const d = bs[e],
            p = c.body.getReader(),
            m = c.headers.get("Content-Length"),
            y = m ? parseInt(m) : 0,
            x = y !== 0
          let S = 0
          const C = new ReadableStream({
            start(M) {
              _()
              function _() {
                p.read().then(({ done: R, value: T }) => {
                  if (R) M.close()
                  else {
                    S += T.byteLength
                    const L = new ProgressEvent("progress", {
                      lengthComputable: x,
                      loaded: S,
                      total: y,
                    })
                    for (let B = 0, k = d.length; B < k; B++) {
                      const O = d[B]
                      O.onProgress && O.onProgress(L)
                    }
                    M.enqueue(T), _()
                  }
                })
              }
            },
          })
          return new Response(C)
        } else
          throw Error(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`
          )
      })
      .then(c => {
        switch (A) {
          case "arraybuffer":
            return c.arrayBuffer()
          case "blob":
            return c.blob()
          case "document":
            return c.text().then(d => new DOMParser().parseFromString(d, a))
          case "json":
            return c.json()
          default:
            if (a === void 0) return c.text()
            {
              const p = /charset="?([^;"\s]*)"?/i.exec(a),
                m = p && p[1] ? p[1].toLowerCase() : void 0,
                y = new TextDecoder(m)
              return c.arrayBuffer().then(x => y.decode(x))
            }
        }
      })
      .then(c => {
        $a.add(e, c)
        const d = bs[e]
        delete bs[e]
        for (let p = 0, m = d.length; p < m; p++) {
          const y = d[p]
          y.onLoad && y.onLoad(c)
        }
      })
      .catch(c => {
        const d = bs[e]
        if (d === void 0) throw (this.manager.itemError(e), c)
        delete bs[e]
        for (let p = 0, m = d.length; p < m; p++) {
          const y = d[p]
          y.onError && y.onError(c)
        }
        this.manager.itemError(e)
      })
      .finally(() => {
        this.manager.itemEnd(e)
      }),
      this.manager.itemStart(e)
  }
  setResponseType(e) {
    return (this.responseType = e), this
  }
  setMimeType(e) {
    return (this.mimeType = e), this
  }
}
class aO extends Pi {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = new us(this.manager)
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)))
          } catch (A) {
            r ? r(A) : console.error(A), s.manager.itemError(e)
          }
        },
        i,
        r
      )
  }
  parse(e) {
    const t = []
    for (let i = 0; i < e.length; i++) {
      const r = Au.parse(e[i])
      t.push(r)
    }
    return t
  }
}
class lO extends Pi {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = [],
      a = new u2(),
      A = new us(this.manager)
    A.setPath(this.path),
      A.setResponseType("arraybuffer"),
      A.setRequestHeader(this.requestHeader),
      A.setWithCredentials(s.withCredentials)
    let c = 0
    function d(p) {
      A.load(
        e[p],
        function (m) {
          const y = s.parse(m, !0)
          ;(o[p] = {
            width: y.width,
            height: y.height,
            format: y.format,
            mipmaps: y.mipmaps,
          }),
            (c += 1),
            c === 6 &&
              (y.mipmapCount === 1 && (a.minFilter = Mn),
              (a.image = o),
              (a.format = y.format),
              (a.needsUpdate = !0),
              t && t(a))
        },
        i,
        r
      )
    }
    if (Array.isArray(e)) for (let p = 0, m = e.length; p < m; ++p) d(p)
    else
      A.load(
        e,
        function (p) {
          const m = s.parse(p, !0)
          if (m.isCubemap) {
            const y = m.mipmaps.length / m.mipmapCount
            for (let x = 0; x < y; x++) {
              o[x] = { mipmaps: [] }
              for (let S = 0; S < m.mipmapCount; S++)
                o[x].mipmaps.push(m.mipmaps[x * m.mipmapCount + S]),
                  (o[x].format = m.format),
                  (o[x].width = m.width),
                  (o[x].height = m.height)
            }
            a.image = o
          } else
            (a.image.width = m.width),
              (a.image.height = m.height),
              (a.mipmaps = m.mipmaps)
          m.mipmapCount === 1 && (a.minFilter = Mn),
            (a.format = m.format),
            (a.needsUpdate = !0),
            t && t(a)
        },
        i,
        r
      )
    return a
  }
}
class uu extends Pi {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e))
    const s = this,
      o = $a.get(e)
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e)
        }, 0),
        o
      )
    const a = iu("img")
    function A() {
      d(), $a.add(e, this), t && t(this), s.manager.itemEnd(e)
    }
    function c(p) {
      d(), r && r(p), s.manager.itemError(e), s.manager.itemEnd(e)
    }
    function d() {
      a.removeEventListener("load", A, !1),
        a.removeEventListener("error", c, !1)
    }
    return (
      a.addEventListener("load", A, !1),
      a.addEventListener("error", c, !1),
      e.substr(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    )
  }
}
class s6 extends Pi {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = new Hc(),
      o = new uu(this.manager)
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path)
    let a = 0
    function A(c) {
      o.load(
        e[c],
        function (d) {
          ;(s.images[c] = d), a++, a === 6 && ((s.needsUpdate = !0), t && t(s))
        },
        void 0,
        r
      )
    }
    for (let c = 0; c < e.length; ++c) A(c)
    return s
  }
}
class o6 extends Pi {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = new Ba(),
      a = new us(this.manager)
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (A) {
          const c = s.parse(A)
          !c ||
            (c.image !== void 0
              ? (o.image = c.image)
              : c.data !== void 0 &&
                ((o.image.width = c.width),
                (o.image.height = c.height),
                (o.image.data = c.data)),
            (o.wrapS = c.wrapS !== void 0 ? c.wrapS : ci),
            (o.wrapT = c.wrapT !== void 0 ? c.wrapT : ci),
            (o.magFilter = c.magFilter !== void 0 ? c.magFilter : Mn),
            (o.minFilter = c.minFilter !== void 0 ? c.minFilter : Mn),
            (o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.encoding !== void 0 && (o.encoding = c.encoding),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 &&
              ((o.mipmaps = c.mipmaps), (o.minFilter = nl)),
            c.mipmapCount === 1 && (o.minFilter = Mn),
            c.generateMipmaps !== void 0 &&
              (o.generateMipmaps = c.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, c))
        },
        i,
        r
      ),
      o
    )
  }
}
class E2 extends Pi {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = new Vn(),
      o = new uu(this.manager)
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          ;(s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s)
        },
        i,
        r
      ),
      s
    )
  }
}
class Ur extends kt {
  constructor(e, t = 1) {
    super(),
      (this.type = "Light"),
      (this.color = new Ke(e)),
      (this.intensity = t)
  }
  dispose() {}
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    )
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    )
  }
}
Ur.prototype.isLight = !0
class T2 extends Ur {
  constructor(e, t, i) {
    super(e, i),
      (this.type = "HemisphereLight"),
      this.position.copy(kt.DefaultUp),
      this.updateMatrix(),
      (this.groundColor = new Ke(t))
  }
  copy(e) {
    return (
      Ur.prototype.copy.call(this, e),
      this.groundColor.copy(e.groundColor),
      this
    )
  }
}
T2.prototype.isHemisphereLight = !0
const c3 = new mt(),
  A3 = new X(),
  u3 = new X()
class C2 {
  constructor(e) {
    ;(this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new qe(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new mt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Fu()),
      (this._frameExtents = new qe(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new en(0, 0, 1, 1)])
  }
  getViewportCount() {
    return this._viewportCount
  }
  getFrustum() {
    return this._frustum
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix
    A3.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(A3),
      u3.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(u3),
      t.updateMatrixWorld(),
      c3.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(c3),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(t.projectionMatrix),
      i.multiply(t.matrixWorldInverse)
  }
  getViewport(e) {
    return this._viewports[e]
  }
  getFrameExtents() {
    return this._frameExtents
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const e = {}
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    )
  }
}
class a6 extends C2 {
  constructor() {
    super(new ei(50, 1, 0.5, 500)), (this.focus = 1)
  }
  updateMatrices(e) {
    const t = this.camera,
      i = nu * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far
    ;(i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e)
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this
  }
}
a6.prototype.isSpotLightShadow = !0
class R2 extends Ur {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 1) {
    super(e, t),
      (this.type = "SpotLight"),
      this.position.copy(kt.DefaultUp),
      this.updateMatrix(),
      (this.target = new kt()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.shadow = new a6())
  }
  get power() {
    return this.intensity * Math.PI
  }
  set power(e) {
    this.intensity = e / Math.PI
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e) {
    return (
      super.copy(e),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
R2.prototype.isSpotLight = !0
const f3 = new mt(),
  AA = new X(),
  om = new X()
class l6 extends C2 {
  constructor() {
    super(new ei(90, 1, 0.5, 500)),
      (this._frameExtents = new qe(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new en(2, 1, 1, 1),
        new en(0, 1, 1, 1),
        new en(3, 1, 1, 1),
        new en(1, 1, 1, 1),
        new en(3, 0, 1, 1),
        new en(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new X(1, 0, 0),
        new X(-1, 0, 0),
        new X(0, 0, 1),
        new X(0, 0, -1),
        new X(0, 1, 0),
        new X(0, -1, 0),
      ]),
      (this._cubeUps = [
        new X(0, 1, 0),
        new X(0, 1, 0),
        new X(0, 1, 0),
        new X(0, 1, 0),
        new X(0, 0, 1),
        new X(0, 0, -1),
      ])
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      AA.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(AA),
      om.copy(i.position),
      om.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(om),
      i.updateMatrixWorld(),
      r.makeTranslation(-AA.x, -AA.y, -AA.z),
      f3.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(f3)
  }
}
l6.prototype.isPointLightShadow = !0
class P2 extends Ur {
  constructor(e, t, i = 0, r = 1) {
    super(e, t),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new l6())
  }
  get power() {
    return this.intensity * 4 * Math.PI
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI)
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e) {
    return (
      super.copy(e),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
P2.prototype.isPointLight = !0
class c6 extends C2 {
  constructor() {
    super(new Nu(-5, 5, 5, -5, 0.5, 500))
  }
}
c6.prototype.isDirectionalLightShadow = !0
class L2 extends Ur {
  constructor(e, t) {
    super(e, t),
      (this.type = "DirectionalLight"),
      this.position.copy(kt.DefaultUp),
      this.updateMatrix(),
      (this.target = new kt()),
      (this.shadow = new c6())
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
L2.prototype.isDirectionalLight = !0
class D2 extends Ur {
  constructor(e, t) {
    super(e, t), (this.type = "AmbientLight")
  }
}
D2.prototype.isAmbientLight = !0
class I2 extends Ur {
  constructor(e, t, i = 10, r = 10) {
    super(e, t),
      (this.type = "RectAreaLight"),
      (this.width = i),
      (this.height = r)
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI)
  }
  copy(e) {
    return super.copy(e), (this.width = e.width), (this.height = e.height), this
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (t.object.width = this.width), (t.object.height = this.height), t
  }
}
I2.prototype.isRectAreaLight = !0
class B2 {
  constructor() {
    this.coefficients = []
    for (let e = 0; e < 9; e++) this.coefficients.push(new X())
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t])
    return this
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0)
    return this
  }
  getAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * r),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * i),
      t.addScaledVector(o[4], 1.092548 * (i * r)),
      t.addScaledVector(o[5], 1.092548 * (r * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (i * s)),
      t.addScaledVector(o[8], 0.546274 * (i * i - r * r)),
      t
    )
  }
  getIrradianceAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * r),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * i),
      t.addScaledVector(o[4], 2 * 0.429043 * i * r),
      t.addScaledVector(o[5], 2 * 0.429043 * r * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * i * s),
      t.addScaledVector(o[8], 0.429043 * (i * i - r * r)),
      t
    )
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t])
    return this
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t)
    return this
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e)
    return this
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t)
    return this
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1
    return !0
  }
  copy(e) {
    return this.set(e.coefficients)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  fromArray(e, t = 0) {
    const i = this.coefficients
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3)
    return this
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3)
    return e
  }
  static getBasisAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z
    ;(t[0] = 0.282095),
      (t[1] = 0.488603 * r),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * i),
      (t[4] = 1.092548 * i * r),
      (t[5] = 1.092548 * r * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * i * s),
      (t[8] = 0.546274 * (i * i - r * r))
  }
}
B2.prototype.isSphericalHarmonics3 = !0
class ju extends Ur {
  constructor(e = new B2(), t = 1) {
    super(void 0, t), (this.sh = e)
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (t.object.sh = this.sh.toArray()), t
  }
}
ju.prototype.isLightProbe = !0
class A6 extends Pi {
  constructor(e) {
    super(e), (this.textures = {})
  }
  load(e, t, i, r) {
    const s = this,
      o = new us(s.manager)
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)))
          } catch (A) {
            r ? r(A) : console.error(A), s.manager.itemError(e)
          }
        },
        i,
        r
      )
  }
  parse(e) {
    const t = this.textures
    function i(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      )
    }
    const r = new rO[e.type]()
    if (
      (e.uuid !== void 0 && (r.uuid = e.uuid),
      e.name !== void 0 && (r.name = e.name),
      e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
      e.roughness !== void 0 && (r.roughness = e.roughness),
      e.metalness !== void 0 && (r.metalness = e.metalness),
      e.sheen !== void 0 && (r.sheen = e.sheen),
      e.sheenColor !== void 0 && (r.sheenColor = new Ke().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        r.emissive !== void 0 &&
        r.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        r.specular !== void 0 &&
        r.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (r.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        r.specularColor !== void 0 &&
        r.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (r.shininess = e.shininess),
      e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = e.clearcoatRoughness),
      e.transmission !== void 0 && (r.transmission = e.transmission),
      e.thickness !== void 0 && (r.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (r.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        r.attenuationColor !== void 0 &&
        r.attenuationColor.setHex(e.attenuationColor),
      e.fog !== void 0 && (r.fog = e.fog),
      e.flatShading !== void 0 && (r.flatShading = e.flatShading),
      e.blending !== void 0 && (r.blending = e.blending),
      e.combine !== void 0 && (r.combine = e.combine),
      e.side !== void 0 && (r.side = e.side),
      e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (r.opacity = e.opacity),
      e.transparent !== void 0 && (r.transparent = e.transparent),
      e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
      e.depthTest !== void 0 && (r.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
      e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
      e.stencilWriteMask !== void 0 &&
        (r.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
      e.wireframe !== void 0 && (r.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (r.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (r.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (r.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (r.rotation = e.rotation),
      e.linewidth !== 1 && (r.linewidth = e.linewidth),
      e.dashSize !== void 0 && (r.dashSize = e.dashSize),
      e.gapSize !== void 0 && (r.gapSize = e.gapSize),
      e.scale !== void 0 && (r.scale = e.scale),
      e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (r.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (r.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (r.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (r.premultipliedAlpha = e.premultipliedAlpha),
      e.visible !== void 0 && (r.visible = e.visible),
      e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
      e.userData !== void 0 && (r.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (r.vertexColors = e.vertexColors > 0)
          : (r.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s]
        switch (((r.uniforms[s] = {}), o.type)) {
          case "t":
            r.uniforms[s].value = i(o.value)
            break
          case "c":
            r.uniforms[s].value = new Ke().setHex(o.value)
            break
          case "v2":
            r.uniforms[s].value = new qe().fromArray(o.value)
            break
          case "v3":
            r.uniforms[s].value = new X().fromArray(o.value)
            break
          case "v4":
            r.uniforms[s].value = new en().fromArray(o.value)
            break
          case "m3":
            r.uniforms[s].value = new Zn().fromArray(o.value)
            break
          case "m4":
            r.uniforms[s].value = new mt().fromArray(o.value)
            break
          default:
            r.uniforms[s].value = o.value
        }
      }
    if (
      (e.defines !== void 0 && (r.defines = e.defines),
      e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) r.extensions[s] = e.extensions[s]
    if (
      (e.shading !== void 0 && (r.flatShading = e.shading === 1),
      e.size !== void 0 && (r.size = e.size),
      e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (r.map = i(e.map)),
      e.matcap !== void 0 && (r.matcap = i(e.matcap)),
      e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
      e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
      e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
      e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale
      Array.isArray(s) === !1 && (s = [s, s]),
        (r.normalScale = new qe().fromArray(s))
    }
    return (
      e.displacementMap !== void 0 &&
        (r.displacementMap = i(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (r.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (r.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
      e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
      e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (r.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (r.specularIntensityMap = i(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (r.specularColorMap = i(e.specularColorMap)),
      e.envMap !== void 0 && (r.envMap = i(e.envMap)),
      e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (r.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
      e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
      e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (r.clearcoatNormalScale = new qe().fromArray(e.clearcoatNormalScale)),
      e.transmissionMap !== void 0 &&
        (r.transmissionMap = i(e.transmissionMap)),
      e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
      e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
      r
    )
  }
  setTextures(e) {
    return (this.textures = e), this
  }
}
class x0 {
  static decodeText(e) {
    if (typeof TextDecoder != "undefined") return new TextDecoder().decode(e)
    let t = ""
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i])
    try {
      return decodeURIComponent(escape(t))
    } catch {
      return t
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/")
    return t === -1 ? "./" : e.substr(0, t + 1)
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e)
  }
}
class Wd extends yt {
  constructor() {
    super(),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0)
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const e = super.toJSON(this)
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    )
  }
}
Wd.prototype.isInstancedBufferGeometry = !0
class u6 extends Pi {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = new us(s.manager)
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)))
          } catch (A) {
            r ? r(A) : console.error(A), s.manager.itemError(e)
          }
        },
        i,
        r
      )
  }
  parse(e) {
    const t = {},
      i = {}
    function r(y, x) {
      if (t[x] !== void 0) return t[x]
      const C = y.interleavedBuffers[x],
        M = s(y, C.buffer),
        _ = zl(C.type, M),
        R = new $o(_, C.stride)
      return (R.uuid = C.uuid), (t[x] = R), R
    }
    function s(y, x) {
      if (i[x] !== void 0) return i[x]
      const C = y.arrayBuffers[x],
        M = new Uint32Array(C).buffer
      return (i[x] = M), M
    }
    const o = e.isInstancedBufferGeometry ? new Wd() : new yt(),
      a = e.data.index
    if (a !== void 0) {
      const y = zl(a.type, a.array)
      o.setIndex(new Bt(y, 1))
    }
    const A = e.data.attributes
    for (const y in A) {
      const x = A[y]
      let S
      if (x.isInterleavedBufferAttribute) {
        const C = r(e.data, x.data)
        S = new Fr(C, x.itemSize, x.offset, x.normalized)
      } else {
        const C = zl(x.type, x.array),
          M = x.isInstancedBufferAttribute ? Ha : Bt
        S = new M(C, x.itemSize, x.normalized)
      }
      x.name !== void 0 && (S.name = x.name),
        x.usage !== void 0 && S.setUsage(x.usage),
        x.updateRange !== void 0 &&
          ((S.updateRange.offset = x.updateRange.offset),
          (S.updateRange.count = x.updateRange.count)),
        o.setAttribute(y, S)
    }
    const c = e.data.morphAttributes
    if (c)
      for (const y in c) {
        const x = c[y],
          S = []
        for (let C = 0, M = x.length; C < M; C++) {
          const _ = x[C]
          let R
          if (_.isInterleavedBufferAttribute) {
            const T = r(e.data, _.data)
            R = new Fr(T, _.itemSize, _.offset, _.normalized)
          } else {
            const T = zl(_.type, _.array)
            R = new Bt(T, _.itemSize, _.normalized)
          }
          _.name !== void 0 && (R.name = _.name), S.push(R)
        }
        o.morphAttributes[y] = S
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0)
    const p = e.data.groups || e.data.drawcalls || e.data.offsets
    if (p !== void 0)
      for (let y = 0, x = p.length; y !== x; ++y) {
        const S = p[y]
        o.addGroup(S.start, S.count, S.materialIndex)
      }
    const m = e.data.boundingSphere
    if (m !== void 0) {
      const y = new X()
      m.center !== void 0 && y.fromArray(m.center),
        (o.boundingSphere = new ds(y, m.radius))
    }
    return (
      e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    )
  }
}
class cO extends Pi {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = this.path === "" ? x0.extractUrlBase(e) : this.path
    this.resourcePath = this.resourcePath || o
    const a = new us(this.manager)
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (A) {
          let c = null
          try {
            c = JSON.parse(A)
          } catch (p) {
            r !== void 0 && r(p),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                p.message
              )
            return
          }
          const d = c.metadata
          if (
            d === void 0 ||
            d.type === void 0 ||
            d.type.toLowerCase() === "geometry"
          ) {
            console.error("THREE.ObjectLoader: Can't load " + e)
            return
          }
          s.parse(c, t)
        },
        i,
        r
      )
  }
  async loadAsync(e, t) {
    const i = this,
      r = this.path === "" ? x0.extractUrlBase(e) : this.path
    this.resourcePath = this.resourcePath || r
    const s = new us(this.manager)
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials)
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      A = a.metadata
    if (
      A === void 0 ||
      A.type === void 0 ||
      A.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e)
    return await i.parseAsync(a)
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(c)
      }),
      a = this.parseTextures(e.textures, o),
      A = this.parseMaterials(e.materials, a),
      c = this.parseObject(e.object, s, A, a, i),
      d = this.parseSkeletons(e.skeletons, c)
    if ((this.bindSkeletons(c, d), t !== void 0)) {
      let p = !1
      for (const m in o)
        if (o[m] instanceof HTMLImageElement) {
          p = !0
          break
        }
      p === !1 && t(c)
    }
    return c
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      r = this.parseGeometries(e.geometries, i),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      A = this.parseObject(e.object, r, a, o, t),
      c = this.parseSkeletons(e.skeletons, A)
    return this.bindSkeletons(A, c), A
  }
  parseShapes(e) {
    const t = {}
    if (e !== void 0)
      for (let i = 0, r = e.length; i < r; i++) {
        const s = new ns().fromJSON(e[i])
        t[s.uuid] = s
      }
    return t
  }
  parseSkeletons(e, t) {
    const i = {},
      r = {}
    if (
      (t.traverse(function (s) {
        s.isBone && (r[s.uuid] = s)
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new Od().fromJSON(e[s], r)
        i[a.uuid] = a
      }
    return i
  }
  parseGeometries(e, t) {
    const i = {}
    if (e !== void 0) {
      const r = new u6()
      for (let s = 0, o = e.length; s < o; s++) {
        let a
        const A = e[s]
        switch (A.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(A)
            break
          case "Geometry":
            console.error(
              "THREE.ObjectLoader: The legacy Geometry type is no longer supported."
            )
            break
          default:
            A.type in l3
              ? (a = l3[A.type].fromJSON(A, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${A.type}"`
                )
        }
        ;(a.uuid = A.uuid),
          A.name !== void 0 && (a.name = A.name),
          a.isBufferGeometry === !0 &&
            A.userData !== void 0 &&
            (a.userData = A.userData),
          (i[A.uuid] = a)
      }
    }
    return i
  }
  parseMaterials(e, t) {
    const i = {},
      r = {}
    if (e !== void 0) {
      const s = new A6()
      s.setTextures(t)
      for (let o = 0, a = e.length; o < a; o++) {
        const A = e[o]
        if (A.type === "MultiMaterial") {
          const c = []
          for (let d = 0; d < A.materials.length; d++) {
            const p = A.materials[d]
            i[p.uuid] === void 0 && (i[p.uuid] = s.parse(p)), c.push(i[p.uuid])
          }
          r[A.uuid] = c
        } else
          i[A.uuid] === void 0 && (i[A.uuid] = s.parse(A)),
            (r[A.uuid] = i[A.uuid])
      }
    }
    return r
  }
  parseAnimations(e) {
    const t = {}
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const r = e[i],
          s = Au.parse(r)
        t[s.uuid] = s
      }
    return t
  }
  parseImages(e, t) {
    const i = this,
      r = {}
    let s
    function o(A) {
      return (
        i.manager.itemStart(A),
        s.load(
          A,
          function () {
            i.manager.itemEnd(A)
          },
          void 0,
          function () {
            i.manager.itemError(A), i.manager.itemEnd(A)
          }
        )
      )
    }
    function a(A) {
      if (typeof A == "string") {
        const c = A,
          d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c
        return o(d)
      } else
        return A.data
          ? { data: zl(A.type, A.data), width: A.width, height: A.height }
          : null
    }
    if (e !== void 0 && e.length > 0) {
      const A = new S2(t)
      ;(s = new uu(A)), s.setCrossOrigin(this.crossOrigin)
      for (let c = 0, d = e.length; c < d; c++) {
        const p = e[c],
          m = p.url
        if (Array.isArray(m)) {
          r[p.uuid] = []
          for (let y = 0, x = m.length; y < x; y++) {
            const S = m[y],
              C = a(S)
            C !== null &&
              (C instanceof HTMLImageElement
                ? r[p.uuid].push(C)
                : r[p.uuid].push(new Ba(C.data, C.width, C.height)))
          }
        } else {
          const y = a(p.url)
          y !== null && (r[p.uuid] = y)
        }
      }
    }
    return r
  }
  async parseImagesAsync(e) {
    const t = this,
      i = {}
    let r
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          A = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a
        return await r.loadAsync(A)
      } else
        return o.data
          ? { data: zl(o.type, o.data), width: o.width, height: o.height }
          : null
    }
    if (e !== void 0 && e.length > 0) {
      ;(r = new uu(this.manager)), r.setCrossOrigin(this.crossOrigin)
      for (let o = 0, a = e.length; o < a; o++) {
        const A = e[o],
          c = A.url
        if (Array.isArray(c)) {
          i[A.uuid] = []
          for (let d = 0, p = c.length; d < p; d++) {
            const m = c[d],
              y = await s(m)
            y !== null &&
              (y instanceof HTMLImageElement
                ? i[A.uuid].push(y)
                : i[A.uuid].push(new Ba(y.data, y.width, y.height)))
          }
        } else {
          const d = await s(A.url)
          d !== null && (i[A.uuid] = d)
        }
      }
    }
    return i
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          o[s])
    }
    const r = {}
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s]
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image)
        let A
        const c = t[a.image]
        Array.isArray(c)
          ? ((A = new Hc(c)), c.length === 6 && (A.needsUpdate = !0))
          : (c && c.data
              ? (A = new Ba(c.data, c.width, c.height))
              : (A = new Vn(c)),
            c && (A.needsUpdate = !0)),
          (A.uuid = a.uuid),
          a.name !== void 0 && (A.name = a.name),
          a.mapping !== void 0 && (A.mapping = i(a.mapping, AO)),
          a.offset !== void 0 && A.offset.fromArray(a.offset),
          a.repeat !== void 0 && A.repeat.fromArray(a.repeat),
          a.center !== void 0 && A.center.fromArray(a.center),
          a.rotation !== void 0 && (A.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((A.wrapS = i(a.wrap[0], h3)), (A.wrapT = i(a.wrap[1], h3))),
          a.format !== void 0 && (A.format = a.format),
          a.type !== void 0 && (A.type = a.type),
          a.encoding !== void 0 && (A.encoding = a.encoding),
          a.minFilter !== void 0 && (A.minFilter = i(a.minFilter, d3)),
          a.magFilter !== void 0 && (A.magFilter = i(a.magFilter, d3)),
          a.anisotropy !== void 0 && (A.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (A.flipY = a.flipY),
          a.premultiplyAlpha !== void 0 &&
            (A.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (A.unpackAlignment = a.unpackAlignment),
          a.userData !== void 0 && (A.userData = a.userData),
          (r[a.uuid] = A)
      }
    return r
  }
  parseObject(e, t, i, r, s) {
    let o
    function a(m) {
      return (
        t[m] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", m),
        t[m]
      )
    }
    function A(m) {
      if (m !== void 0) {
        if (Array.isArray(m)) {
          const y = []
          for (let x = 0, S = m.length; x < S; x++) {
            const C = m[x]
            i[C] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", C),
              y.push(i[C])
          }
          return y
        }
        return (
          i[m] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", m),
          i[m]
        )
      }
    }
    function c(m) {
      return (
        r[m] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", m),
        r[m]
      )
    }
    let d, p
    switch (e.type) {
      case "Scene":
        ;(o = new Ld()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new Ke(e.background))
              : (o.background = c(e.background))),
          e.environment !== void 0 && (o.environment = c(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new zu(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new Uu(e.fog.color, e.fog.density)))
        break
      case "PerspectiveCamera":
        ;(o = new ei(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view))
        break
      case "OrthographicCamera":
        ;(o = new Nu(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view))
        break
      case "AmbientLight":
        o = new D2(e.color, e.intensity)
        break
      case "DirectionalLight":
        o = new L2(e.color, e.intensity)
        break
      case "PointLight":
        o = new P2(e.color, e.intensity, e.distance, e.decay)
        break
      case "RectAreaLight":
        o = new I2(e.color, e.intensity, e.width, e.height)
        break
      case "SpotLight":
        o = new R2(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )
        break
      case "HemisphereLight":
        o = new T2(e.color, e.groundColor, e.intensity)
        break
      case "LightProbe":
        o = new ju().fromJSON(e)
        break
      case "SkinnedMesh":
        ;(d = a(e.geometry)),
          (p = A(e.material)),
          (o = new Bd(d, p)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton)
        break
      case "Mesh":
        ;(d = a(e.geometry)), (p = A(e.material)), (o = new Xt(d, p))
        break
      case "InstancedMesh":
        ;(d = a(e.geometry)), (p = A(e.material))
        const m = e.count,
          y = e.instanceMatrix,
          x = e.instanceColor
        ;(o = new c2(d, p, m)),
          (o.instanceMatrix = new Ha(new Float32Array(y.array), 16)),
          x !== void 0 &&
            (o.instanceColor = new Ha(new Float32Array(x.array), x.itemSize))
        break
      case "LOD":
        o = new j5()
        break
      case "Line":
        o = new br(a(e.geometry), A(e.material))
        break
      case "LineLoop":
        o = new A2(a(e.geometry), A(e.material))
        break
      case "LineSegments":
        o = new yi(a(e.geometry), A(e.material))
        break
      case "PointCloud":
      case "Points":
        o = new Hu(a(e.geometry), A(e.material))
        break
      case "Sprite":
        o = new Id(A(e.material))
        break
      case "Group":
        o = new zi()
        break
      case "Bone":
        o = new kd()
        break
      default:
        o = new kt()
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const m = e.children
      for (let y = 0; y < m.length; y++)
        o.add(this.parseObject(m[y], t, i, r, s))
    }
    if (e.animations !== void 0) {
      const m = e.animations
      for (let y = 0; y < m.length; y++) {
        const x = m[y]
        o.animations.push(s[x])
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate)
      const m = e.levels
      for (let y = 0; y < m.length; y++) {
        const x = m[y],
          S = o.getObjectByProperty("uuid", x.object)
        S !== void 0 && o.addLevel(S, x.distance)
      }
    }
    return o
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (i) {
        if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
          const r = t[i.skeleton]
          r === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                i.skeleton
              )
            : i.bind(r, i.bindMatrix)
        }
      })
  }
  setTexturePath(e) {
    return (
      console.warn(
        "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
      ),
      this.setResourcePath(e)
    )
  }
}
const AO = {
    UVMapping: vd,
    CubeReflectionMapping: el,
    CubeRefractionMapping: tl,
    EquirectangularReflectionMapping: XA,
    EquirectangularRefractionMapping: YA,
    CubeUVReflectionMapping: zc,
    CubeUVRefractionMapping: Ou,
  },
  h3 = {
    RepeatWrapping: ZA,
    ClampToEdgeWrapping: ci,
    MirroredRepeatWrapping: JA,
  },
  d3 = {
    NearestFilter: On,
    NearestMipmapNearestFilter: g0,
    NearestMipmapLinearFilter: y0,
    LinearFilter: Mn,
    LinearMipmapNearestFilter: t2,
    LinearMipmapLinearFilter: nl,
  }
class f6 extends Pi {
  constructor(e) {
    super(e),
      typeof createImageBitmap == "undefined" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch == "undefined" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" })
  }
  setOptions(e) {
    return (this.options = e), this
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e))
    const s = this,
      o = $a.get(e)
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e)
        }, 0),
        o
      )
    const a = {}
    ;(a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (A) {
          return A.blob()
        })
        .then(function (A) {
          return createImageBitmap(
            A,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          )
        })
        .then(function (A) {
          $a.add(e, A), t && t(A), s.manager.itemEnd(e)
        })
        .catch(function (A) {
          r && r(A), s.manager.itemError(e), s.manager.itemEnd(e)
        }),
      s.manager.itemStart(e)
  }
}
f6.prototype.isImageBitmapLoader = !0
let nh
const k2 = {
  getContext: function () {
    return (
      nh === void 0 &&
        (nh = new (window.AudioContext || window.webkitAudioContext)()),
      nh
    )
  },
  setContext: function (n) {
    nh = n
  },
}
class h6 extends Pi {
  constructor(e) {
    super(e)
  }
  load(e, t, i, r) {
    const s = this,
      o = new us(this.manager)
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            const A = a.slice(0)
            k2.getContext().decodeAudioData(A, function (d) {
              t(d)
            })
          } catch (A) {
            r ? r(A) : console.error(A), s.manager.itemError(e)
          }
        },
        i,
        r
      )
  }
}
class d6 extends ju {
  constructor(e, t, i = 1) {
    super(void 0, i)
    const r = new Ke().set(e),
      s = new Ke().set(t),
      o = new X(r.r, r.g, r.b),
      a = new X(s.r, s.g, s.b),
      A = Math.sqrt(Math.PI),
      c = A * Math.sqrt(0.75)
    this.sh.coefficients[0].copy(o).add(a).multiplyScalar(A),
      this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)
  }
}
d6.prototype.isHemisphereLightProbe = !0
class p6 extends ju {
  constructor(e, t = 1) {
    super(void 0, t)
    const i = new Ke().set(e)
    this.sh.coefficients[0]
      .set(i.r, i.g, i.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI))
  }
}
p6.prototype.isAmbientLightProbe = !0
const p3 = new mt(),
  m3 = new mt(),
  aa = new mt()
class uO {
  constructor() {
    ;(this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new ei()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new ei()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      })
  }
  update(e) {
    const t = this._cache
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      ;(t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        aa.copy(e.projectionMatrix)
      const r = t.eyeSep / 2,
        s = (r * t.near) / t.focus,
        o = (t.near * Math.tan(Ia * t.fov * 0.5)) / t.zoom
      let a, A
      ;(m3.elements[12] = -r),
        (p3.elements[12] = r),
        (a = -o * t.aspect + s),
        (A = o * t.aspect + s),
        (aa.elements[0] = (2 * t.near) / (A - a)),
        (aa.elements[8] = (A + a) / (A - a)),
        this.cameraL.projectionMatrix.copy(aa),
        (a = -o * t.aspect - s),
        (A = o * t.aspect - s),
        (aa.elements[0] = (2 * t.near) / (A - a)),
        (aa.elements[8] = (A + a) / (A - a)),
        this.cameraR.projectionMatrix.copy(aa)
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(m3),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(p3)
  }
}
class m6 {
  constructor(e = !0) {
    ;(this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1)
  }
  start() {
    ;(this.startTime = g3()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0)
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1)
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime
  }
  getDelta() {
    let e = 0
    if (this.autoStart && !this.running) return this.start(), 0
    if (this.running) {
      const t = g3()
      ;(e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e)
    }
    return e
  }
}
function g3() {
  return (typeof performance == "undefined" ? Date : performance).now()
}
const la = new X(),
  y3 = new Jn(),
  fO = new X(),
  ca = new X()
class hO extends kt {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = k2.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new m6())
  }
  getInput() {
    return this.gain
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    )
  }
  getFilter() {
    return this.filter
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    )
  }
  getMasterVolume() {
    return this.gain.gain.value
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    )
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e)
    const t = this.context.listener,
      i = this.up
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(la, y3, fO),
      ca.set(0, 0, -1).applyQuaternion(y3),
      t.positionX)
    ) {
      const r = this.context.currentTime + this.timeDelta
      t.positionX.linearRampToValueAtTime(la.x, r),
        t.positionY.linearRampToValueAtTime(la.y, r),
        t.positionZ.linearRampToValueAtTime(la.z, r),
        t.forwardX.linearRampToValueAtTime(ca.x, r),
        t.forwardY.linearRampToValueAtTime(ca.y, r),
        t.forwardZ.linearRampToValueAtTime(ca.z, r),
        t.upX.linearRampToValueAtTime(i.x, r),
        t.upY.linearRampToValueAtTime(i.y, r),
        t.upZ.linearRampToValueAtTime(i.z, r)
    } else
      t.setPosition(la.x, la.y, la.z),
        t.setOrientation(ca.x, ca.y, ca.z, i.x, i.y, i.z)
  }
}
class O2 extends kt {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = [])
  }
  getOutput() {
    return this.gain
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    )
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    )
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    )
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    )
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.")
      return
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.")
      return
    }
    this._startedAt = this.context.currentTime + e
    const t = this.context.createBufferSource()
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    )
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.")
      return
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    )
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.")
      return
    }
    return (
      (this._progress = 0),
      this.source.stop(),
      (this.source.onended = null),
      (this.isPlaying = !1),
      this
    )
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0])
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e])
      this.filters[this.filters.length - 1].connect(this.getOutput())
    } else this.source.connect(this.getOutput())
    return (this._connected = !0), this
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0])
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e])
      this.filters[this.filters.length - 1].disconnect(this.getOutput())
    } else this.source.disconnect(this.getOutput())
    return (this._connected = !1), this
  }
  getFilters() {
    return this.filters
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    )
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      )
  }
  getDetune() {
    return this.detune
  }
  getFilter() {
    return this.getFilters()[0]
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : [])
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.")
      return
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    )
  }
  getPlaybackRate() {
    return this.playbackRate
  }
  onEnded() {
    this.isPlaying = !1
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.")
      return
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    )
  }
  setLoopStart(e) {
    return (this.loopStart = e), this
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this
  }
  getVolume() {
    return this.gain.gain.value
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    )
  }
}
const Aa = new X(),
  v3 = new Jn(),
  dO = new X(),
  ua = new X()
class pO extends O2 {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain)
  }
  getOutput() {
    return this.panner
  }
  getRefDistance() {
    return this.panner.refDistance
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this
  }
  getDistanceModel() {
    return this.panner.distanceModel
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this
  }
  getMaxDistance() {
    return this.panner.maxDistance
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this
  }
  setDirectionalCone(e, t, i) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = i),
      this
    )
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return
    this.matrixWorld.decompose(Aa, v3, dO), ua.set(0, 0, 1).applyQuaternion(v3)
    const t = this.panner
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta
      t.positionX.linearRampToValueAtTime(Aa.x, i),
        t.positionY.linearRampToValueAtTime(Aa.y, i),
        t.positionZ.linearRampToValueAtTime(Aa.z, i),
        t.orientationX.linearRampToValueAtTime(ua.x, i),
        t.orientationY.linearRampToValueAtTime(ua.y, i),
        t.orientationZ.linearRampToValueAtTime(ua.z, i)
    } else t.setPosition(Aa.x, Aa.y, Aa.z), t.setOrientation(ua.x, ua.y, ua.z)
  }
}
class g6 {
  constructor(e, t = 2048) {
    ;(this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser)
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data
  }
  getAverageFrequency() {
    let e = 0
    const t = this.getFrequencyData()
    for (let i = 0; i < t.length; i++) e += t[i]
    return e / t.length
  }
}
class y6 {
  constructor(e, t, i) {
    ;(this.binding = e), (this.valueSize = i)
    let r, s, o
    switch (t) {
      case "quaternion":
        ;(r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5)
        break
      case "string":
      case "bool":
        ;(r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5))
        break
      default:
        ;(r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5))
    }
    ;(this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0)
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r
    let o = this.cumulativeWeight
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a]
      o = t
    } else {
      o += t
      const a = t / o
      this._mixBufferRegion(i, s, 0, a, r)
    }
    this.cumulativeWeight = o
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e)
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const A = t * this._origIndex
      this._mixBufferRegion(i, r, A, 1 - s, t)
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t)
    for (let A = t, c = t + t; A !== c; ++A)
      if (i[A] !== i[A + t]) {
        a.setValue(i, r)
        break
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex
    e.getValue(t, r)
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)]
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0)
  }
  restoreOriginalState() {
    const e = this.valueSize * 3
    this.binding.setValue(this.buffer, e)
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize
    for (let i = e; i < t; i++) this.buffer[i] = 0
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1)
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i]
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o]
  }
  _slerp(e, t, i, r) {
    Jn.slerpFlat(e, t, e, t, e, i, r)
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s
    Jn.multiplyQuaternionsFlat(e, o, e, t, e, i),
      Jn.slerpFlat(e, t, e, t, e, o, r)
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r
    for (let a = 0; a !== s; ++a) {
      const A = t + a
      e[A] = e[A] * o + e[i + a] * r
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o
      e[a] = e[a] + e[i + o] * r
    }
  }
}
const q2 = "\\[\\]\\.:\\/",
  mO = new RegExp("[" + q2 + "]", "g"),
  F2 = "[^" + q2 + "]",
  gO = "[^" + q2.replace("\\.", "") + "]",
  yO = /((?:WC+[\/:])*)/.source.replace("WC", F2),
  vO = /(WCOD+)?/.source.replace("WCOD", gO),
  _O = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", F2),
  xO = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", F2),
  bO = new RegExp("^" + yO + vO + _O + xO + "$"),
  wO = ["material", "materials", "bones"]
class MO {
  constructor(e, t, i) {
    const r = i || jt.parseTrackName(t)
    ;(this._targetGroup = e), (this._bindings = e.subscribe_(t, r))
  }
  getValue(e, t) {
    this.bind()
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i]
    r !== void 0 && r.getValue(e, t)
  }
  setValue(e, t) {
    const i = this._bindings
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t)
  }
  bind() {
    const e = this._bindings
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind()
  }
  unbind() {
    const e = this._bindings
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind()
  }
}
class jt {
  constructor(e, t, i) {
    ;(this.path = t),
      (this.parsedPath = i || jt.parseTrackName(t)),
      (this.node = jt.findNode(e, this.parsedPath.nodeName) || e),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new jt.Composite(e, t, i)
      : new jt(e, t, i)
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(mO, "")
  }
  static parseTrackName(e) {
    const t = bO.exec(e)
    if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e)
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".")
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1)
      wO.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s))
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      )
    return i
  }
  static findNode(e, t) {
    if (!t || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t)
      if (i !== void 0) return i
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o]
            if (a.name === t || a.uuid === t) return a
            const A = i(a.children)
            if (A) return A
          }
          return null
        },
        r = i(e.children)
      if (r) return r
    }
    return null
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName]
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r]
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex]
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t)
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t]
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    ;(this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0)
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    ;(this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
    this.targetObject.needsUpdate = !0
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++]
    this.targetObject.matrixWorldNeedsUpdate = !0
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t]
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    ;(this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0)
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    ;(this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t)
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0)
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t)
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t)
  }
  bind() {
    let e = this.node
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName
    let s = t.propertyIndex
    if (
      (e ||
        ((e = jt.findNode(this.rootNode, t.nodeName) || this.rootNode),
        (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      )
      return
    }
    if (i) {
      let c = t.objectIndex
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            )
            return
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            )
            return
          }
          e = e.material.materials
          break
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            )
            return
          }
          e = e.skeleton.bones
          for (let d = 0; d < e.length; d++)
            if (e[d].name === c) {
              c = d
              break
            }
          break
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            )
            return
          }
          e = e[i]
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          )
          return
        }
        e = e[c]
      }
    }
    const o = e[r]
    if (o === void 0) {
      const c = t.nodeName
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          r +
          " but it wasn't found.",
        e
      )
      return
    }
    let a = this.Versioning.None
    ;(this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate)
    let A = this.BindingType.Direct
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          )
          return
        }
        if (e.geometry.isBufferGeometry) {
          if (!e.geometry.morphAttributes) {
            console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            )
            return
          }
          e.morphTargetDictionary[s] !== void 0 &&
            (s = e.morphTargetDictionary[s])
        } else {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
            this
          )
          return
        }
      }
      ;(A = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s)
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((A = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((A = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = r)
    ;(this.getValue = this.GetterByBindingType[A]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[A][a])
  }
  unbind() {
    ;(this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
}
jt.Composite = MO
jt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
}
jt.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }
jt.prototype.GetterByBindingType = [
  jt.prototype._getValue_direct,
  jt.prototype._getValue_array,
  jt.prototype._getValue_arrayElement,
  jt.prototype._getValue_toArray,
]
jt.prototype.SetterByBindingTypeAndVersioning = [
  [
    jt.prototype._setValue_direct,
    jt.prototype._setValue_direct_setNeedsUpdate,
    jt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    jt.prototype._setValue_array,
    jt.prototype._setValue_array_setNeedsUpdate,
    jt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    jt.prototype._setValue_arrayElement,
    jt.prototype._setValue_arrayElement_setNeedsUpdate,
    jt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    jt.prototype._setValue_fromArray,
    jt.prototype._setValue_fromArray_setNeedsUpdate,
    jt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
]
class v6 {
  constructor() {
    ;(this.uuid = ir()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0)
    const e = {}
    this._indicesByUUID = e
    for (let i = 0, r = arguments.length; i !== r; ++i) e[arguments[i].uuid] = i
    ;(this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {})
    const t = this
    this.stats = {
      objects: {
        get total() {
          return t._objects.length
        },
        get inUse() {
          return this.total - t.nCachedObjects_
        },
      },
      get bindingsPerObject() {
        return t._bindings.length
      },
    }
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._paths,
      r = this._parsedPaths,
      s = this._bindings,
      o = s.length
    let a,
      A = e.length,
      c = this.nCachedObjects_
    for (let d = 0, p = arguments.length; d !== p; ++d) {
      const m = arguments[d],
        y = m.uuid
      let x = t[y]
      if (x === void 0) {
        ;(x = A++), (t[y] = x), e.push(m)
        for (let S = 0, C = o; S !== C; ++S) s[S].push(new jt(m, i[S], r[S]))
      } else if (x < c) {
        a = e[x]
        const S = --c,
          C = e[S]
        ;(t[C.uuid] = x), (e[x] = C), (t[y] = S), (e[S] = m)
        for (let M = 0, _ = o; M !== _; ++M) {
          const R = s[M],
            T = R[S]
          let L = R[x]
          ;(R[x] = T), L === void 0 && (L = new jt(m, i[M], r[M])), (R[S] = L)
        }
      } else
        e[x] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          )
    }
    this.nCachedObjects_ = c
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length
    let s = this.nCachedObjects_
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const A = arguments[o],
        c = A.uuid,
        d = t[c]
      if (d !== void 0 && d >= s) {
        const p = s++,
          m = e[p]
        ;(t[m.uuid] = d), (e[d] = m), (t[c] = p), (e[p] = A)
        for (let y = 0, x = r; y !== x; ++y) {
          const S = i[y],
            C = S[p],
            M = S[d]
          ;(S[d] = C), (S[p] = M)
        }
      }
    }
    this.nCachedObjects_ = s
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length
    let s = this.nCachedObjects_,
      o = e.length
    for (let a = 0, A = arguments.length; a !== A; ++a) {
      const c = arguments[a],
        d = c.uuid,
        p = t[d]
      if (p !== void 0)
        if ((delete t[d], p < s)) {
          const m = --s,
            y = e[m],
            x = --o,
            S = e[x]
          ;(t[y.uuid] = p), (e[p] = y), (t[S.uuid] = m), (e[m] = S), e.pop()
          for (let C = 0, M = r; C !== M; ++C) {
            const _ = i[C],
              R = _[m],
              T = _[x]
            ;(_[p] = R), (_[m] = T), _.pop()
          }
        } else {
          const m = --o,
            y = e[m]
          m > 0 && (t[y.uuid] = p), (e[p] = y), e.pop()
          for (let x = 0, S = r; x !== S; ++x) {
            const C = i[x]
            ;(C[p] = C[m]), C.pop()
          }
        }
    }
    this.nCachedObjects_ = s
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath
    let r = i[e]
    const s = this._bindings
    if (r !== void 0) return s[r]
    const o = this._paths,
      a = this._parsedPaths,
      A = this._objects,
      c = A.length,
      d = this.nCachedObjects_,
      p = new Array(c)
    ;(r = s.length), (i[e] = r), o.push(e), a.push(t), s.push(p)
    for (let m = d, y = A.length; m !== y; ++m) {
      const x = A[m]
      p[m] = new jt(x, e, t)
    }
    return p
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      i = t[e]
    if (i !== void 0) {
      const r = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        A = o[a],
        c = e[a]
      ;(t[c] = i),
        (o[i] = A),
        o.pop(),
        (s[i] = s[a]),
        s.pop(),
        (r[i] = r[a]),
        r.pop()
    }
  }
}
v6.prototype.isAnimationObjectGroup = !0
class SO {
  constructor(e, t, i = null, r = t.blendMode) {
    ;(this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = r)
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      A = { endingStart: ba, endingEnd: ba }
    for (let c = 0; c !== o; ++c) {
      const d = s[c].createInterpolant(null)
      ;(a[c] = d), (d.settings = A)
    }
    ;(this._interpolantSettings = A),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = h5),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0)
  }
  play() {
    return this._mixer._activateAction(this), this
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset()
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    )
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    )
  }
  isScheduled() {
    return this._mixer._isActiveAction(this)
  }
  startAt(e) {
    return (this._startTime = e), this
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    )
  }
  getEffectiveWeight() {
    return this._effectiveWeight
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1)
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0)
  }
  crossFadeFrom(e, t, i) {
    if ((e.fadeOut(t), this.fadeIn(t), i)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        a = r / s
      e.warp(1, o, t), this.warp(a, 1, t)
    }
    return this
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i)
  }
  stopFading() {
    const e = this._weightInterpolant
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    )
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    )
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping()
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    )
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e)
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale
    let a = this._timeScaleInterpolant
    a === null &&
      ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a))
    const A = a.parameterPositions,
      c = a.sampleValues
    return (A[0] = s), (A[1] = s + i), (c[0] = e / o), (c[1] = t / o), this
  }
  stopWarping() {
    const e = this._timeScaleInterpolant
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    )
  }
  getMixer() {
    return this._mixer
  }
  getClip() {
    return this._clip
  }
  getRoot() {
    return this._localRoot || this._mixer._root
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e)
      return
    }
    const s = this._startTime
    if (s !== null) {
      const A = (e - s) * i
      if (A < 0 || i === 0) return
      ;(this._startTime = null), (t = i * A)
    }
    t *= this._updateTimeScale(e)
    const o = this._updateTime(t),
      a = this._updateWeight(e)
    if (a > 0) {
      const A = this._interpolants,
        c = this._propertyBindings
      switch (this.blendMode) {
        case n2:
          for (let d = 0, p = A.length; d !== p; ++d)
            A[d].evaluate(o), c[d].accumulateAdditive(a)
          break
        case _d:
        default:
          for (let d = 0, p = A.length; d !== p; ++d)
            A[d].evaluate(o), c[d].accumulate(r, a)
      }
    }
  }
  _updateWeight(e) {
    let t = 0
    if (this.enabled) {
      t = this.weight
      const i = this._weightInterpolant
      if (i !== null) {
        const r = i.evaluate(e)[0]
        ;(t *= r),
          e > i.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1))
      }
    }
    return (this._effectiveWeight = t), t
  }
  _updateTimeScale(e) {
    let t = 0
    if (!this.paused) {
      t = this.timeScale
      const i = this._timeScaleInterpolant
      i !== null &&
        ((t *= i.evaluate(e)[0]),
        e > i.parameterPositions[1] &&
          (this.stopWarping(),
          t === 0 ? (this.paused = !0) : (this.timeScale = t)))
    }
    return (this._effectiveTimeScale = t), t
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop
    let r = this.time + e,
      s = this._loopCount
    const o = i === d5
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r
    if (i === f5) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1))
      e: {
        if (r >= t) r = t
        else if (r < 0) r = 0
        else {
          this.time = r
          break e
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          })
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const a = Math.floor(r / t)
        ;(r -= t * a), (s += Math.abs(a))
        const A = this.repetitions - s
        if (A <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            })
        else {
          if (A === 1) {
            const c = e < 0
            this._setEndings(c, !c, o)
          } else this._setEndings(!1, !1, o)
          ;(this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            })
        }
      } else this.time = r
      if (o && (s & 1) === 1) return t - r
    }
    return r
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings
    i
      ? ((r.endingStart = wa), (r.endingEnd = wa))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? wa : ba)
          : (r.endingStart = tu),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? wa : ba) : (r.endingEnd = tu))
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time
    let o = this._weightInterpolant
    o === null &&
      ((o = r._lendControlInterpolant()), (this._weightInterpolant = o))
    const a = o.parameterPositions,
      A = o.sampleValues
    return (a[0] = s), (A[0] = t), (a[1] = s + e), (A[1] = i), this
  }
}
class _6 extends Ys {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1)
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      a = e._interpolants,
      A = i.uuid,
      c = this._bindingsByRootAndName
    let d = c[A]
    d === void 0 && ((d = {}), (c[A] = d))
    for (let p = 0; p !== s; ++p) {
      const m = r[p],
        y = m.name
      let x = d[y]
      if (x !== void 0) ++x.referenceCount, (o[p] = x)
      else {
        if (((x = o[p]), x !== void 0)) {
          x._cacheIndex === null &&
            (++x.referenceCount, this._addInactiveBinding(x, A, y))
          continue
        }
        const S = t && t._propertyBindings[p].binding.parsedPath
        ;(x = new y6(jt.create(i, y, S), m.ValueTypeName, m.getValueSize())),
          ++x.referenceCount,
          this._addInactiveBinding(x, A, y),
          (o[p] = x)
      }
      a[p].resultBuffer = x.buffer
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r]
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, i)
      }
      const t = e._propertyBindings
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i]
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState())
      }
      this._lendAction(e)
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i]
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s))
      }
      this._takeBackAction(e)
    }
  }
  _initMemoryManager() {
    ;(this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0)
    const e = this
    this.stats = {
      actions: {
        get total() {
          return e._actions.length
        },
        get inUse() {
          return e._nActiveActions
        },
      },
      bindings: {
        get total() {
          return e._bindings.length
        },
        get inUse() {
          return e._nActiveBindings
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length
        },
        get inUse() {
          return e._nActiveControlInterpolants
        },
      },
    }
  }
  _isActiveAction(e) {
    const t = e._cacheIndex
    return t !== null && t < this._nActiveActions
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip
    let o = s[t]
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o)
    else {
      const a = o.knownActions
      ;(e._byClipCacheIndex = a.length), a.push(e)
    }
    ;(e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e)
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex
    ;(i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null)
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      A = a.knownActions,
      c = A[A.length - 1],
      d = e._byClipCacheIndex
    ;(c._byClipCacheIndex = d),
      (A[d] = c),
      A.pop(),
      (e._byClipCacheIndex = null)
    const p = a.actionByRoot,
      m = (e._localRoot || this._root).uuid
    delete p[m],
      A.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e)
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i]
      --s.referenceCount === 0 && this._removeInactiveBinding(s)
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r]
    ;(e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s)
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r]
    ;(e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s)
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings
    let o = r[t]
    o === void 0 && ((o = {}), (r[t] = o)),
      (o[i] = e),
      (e._cacheIndex = s.length),
      s.push(e)
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      o = this._bindingsByRootAndName,
      a = o[r],
      A = t[t.length - 1],
      c = e._cacheIndex
    ;(A._cacheIndex = c),
      (t[c] = A),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[r]
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r]
    ;(e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s)
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r]
    ;(e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s)
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++
    let i = e[t]
    return (
      i === void 0 &&
        ((i = new w2(
          new Float32Array(2),
          new Float32Array(2),
          1,
          this._controlInterpolantsResultBuffer
        )),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    )
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r]
    ;(e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s)
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid
    let o = typeof e == "string" ? Au.findByName(r, e) : e
    const a = o !== null ? o.uuid : e,
      A = this._actionsByClip[a]
    let c = null
    if (
      (i === void 0 && (o !== null ? (i = o.blendMode) : (i = _d)),
      A !== void 0)
    ) {
      const p = A.actionByRoot[s]
      if (p !== void 0 && p.blendMode === i) return p
      ;(c = A.knownActions[0]), o === null && (o = c._clip)
    }
    if (o === null) return null
    const d = new SO(this, o, t, i)
    return this._bindAction(d, c), this._addInactiveAction(d, a, s), d
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == "string" ? Au.findByName(i, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o]
    return (a !== void 0 && a.actionByRoot[r]) || null
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions
    for (let i = t - 1; i >= 0; --i) e[i].stop()
    return this
  }
  update(e) {
    e *= this.timeScale
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1)
    for (let c = 0; c !== i; ++c) t[c]._update(r, e, s, o)
    const a = this._bindings,
      A = this._nActiveBindings
    for (let c = 0; c !== A; ++c) a[c].apply(o)
    return this
  }
  setTime(e) {
    this.time = 0
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0
    return this.update(e)
  }
  getRoot() {
    return this._root
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i]
    if (s !== void 0) {
      const o = s.knownActions
      for (let a = 0, A = o.length; a !== A; ++a) {
        const c = o[a]
        this._deactivateAction(c)
        const d = c._cacheIndex,
          p = t[t.length - 1]
        ;(c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (p._cacheIndex = d),
          (t[d] = p),
          t.pop(),
          this._removeInactiveBindingsForAction(c)
      }
      delete r[i]
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip
    for (const o in i) {
      const a = i[o].actionByRoot,
        A = a[t]
      A !== void 0 && (this._deactivateAction(A), this._removeInactiveAction(A))
    }
    const r = this._bindingsByRootAndName,
      s = r[t]
    if (s !== void 0)
      for (const o in s) {
        const a = s[o]
        a.restoreOriginalState(), this._removeInactiveBinding(a)
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t)
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i))
  }
}
_6.prototype._controlInterpolantsResultBuffer = new Float32Array(1)
class jd {
  constructor(e) {
    typeof e == "string" &&
      (console.warn("THREE.Uniform: Type parameter is no longer needed."),
      (e = arguments[1])),
      (this.value = e)
  }
  clone() {
    return new jd(this.value.clone === void 0 ? this.value : this.value.clone())
  }
}
class $d extends $o {
  constructor(e, t, i = 1) {
    super(e, t), (this.meshPerAttribute = i)
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
  }
  clone(e) {
    const t = super.clone(e)
    return (t.meshPerAttribute = this.meshPerAttribute), t
  }
  toJSON(e) {
    const t = super.toJSON(e)
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    )
  }
}
$d.prototype.isInstancedInterleavedBuffer = !0
class x6 {
  constructor(e, t, i, r, s) {
    ;(this.buffer = e),
      (this.type = t),
      (this.itemSize = i),
      (this.elementSize = r),
      (this.count = s),
      (this.version = 0)
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setBuffer(e) {
    return (this.buffer = e), this
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this
  }
  setItemSize(e) {
    return (this.itemSize = e), this
  }
  setCount(e) {
    return (this.count = e), this
  }
}
x6.prototype.isGLBufferAttribute = !0
class EO {
  constructor(e, t, i = 0, r = 1 / 0) {
    ;(this.ray = new Wo(e, t)),
      (this.near = i),
      (this.far = r),
      (this.camera = null),
      (this.layers = new bd()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      })
  }
  set(e, t) {
    this.ray.set(e, t)
  }
  setFromCamera(e, t) {
    t && t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t && t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
  }
  intersectObject(e, t = !0, i = []) {
    return I1(e, this, i, t), i.sort(_3), i
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++) I1(e[r], this, i, t)
    return i.sort(_3), i
  }
}
function _3(n, e) {
  return n.distance - e.distance
}
function I1(n, e, t, i) {
  if ((n.layers.test(e.layers) && n.raycast(e, t), i === !0)) {
    const r = n.children
    for (let s = 0, o = r.length; s < o; s++) I1(r[s], e, t, !0)
  }
}
class B1 {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    )
  }
  makeSafe() {
    return (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z)
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(li(t / this.radius, -1, 1)))),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class TO {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.theta = t), (this.y = i), this
  }
  set(e, t, i) {
    return (this.radius = e), (this.theta = t), (this.y = i), this
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    )
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z)
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + i * i)),
      (this.theta = Math.atan2(e, i)),
      (this.y = t),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const x3 = new qe()
class jc {
  constructor(e = new qe(1 / 0, 1 / 0), t = new qe(-1 / 0, -1 / 0)) {
    ;(this.min = e), (this.max = t)
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this
  }
  setFromPoints(e) {
    this.makeEmpty()
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t])
    return this
  }
  setFromCenterAndSize(e, t) {
    const i = x3.copy(t).multiplyScalar(0.5)
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    )
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    )
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    )
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    )
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    )
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max)
  }
  distanceToPoint(e) {
    return x3.copy(e).clamp(this.min, this.max).sub(e).length()
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max)
  }
}
jc.prototype.isBox2 = !0
const b3 = new X(),
  ih = new X()
class N2 {
  constructor(e = new X(), t = new X()) {
    ;(this.start = e), (this.end = t)
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5)
  }
  delta(e) {
    return e.subVectors(this.end, this.start)
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end)
  }
  distance() {
    return this.start.distanceTo(this.end)
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start)
  }
  closestPointToPointParameter(e, t) {
    b3.subVectors(e, this.start), ih.subVectors(this.end, this.start)
    const i = ih.dot(ih)
    let s = ih.dot(b3) / i
    return t && (s = li(s, 0, 1)), s
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t)
    return this.delta(i).multiplyScalar(r).add(this.start)
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const w3 = new X()
class CO extends kt {
  constructor(e, t) {
    super(),
      (this.light = e),
      this.light.updateMatrixWorld(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t)
    const i = new yt(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ]
    for (let o = 0, a = 1, A = 32; o < A; o++, a++) {
      const c = (o / A) * Math.PI * 2,
        d = (a / A) * Math.PI * 2
      r.push(Math.cos(c), Math.sin(c), 1, Math.cos(d), Math.sin(d), 1)
    }
    i.setAttribute("position", new ut(r, 3))
    const s = new Nn({ fog: !1, toneMapped: !1 })
    ;(this.cone = new yi(i, s)), this.add(this.cone), this.update()
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose()
  }
  update() {
    this.light.updateMatrixWorld()
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle)
    this.cone.scale.set(t, t, e),
      w3.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(w3),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color)
  }
}
const mo = new X(),
  rh = new mt(),
  am = new mt()
class b6 extends yi {
  constructor(e) {
    const t = w6(e),
      i = new yt(),
      r = [],
      s = [],
      o = new Ke(0, 0, 1),
      a = new Ke(0, 1, 0)
    for (let c = 0; c < t.length; c++) {
      const d = t[c]
      d.parent &&
        d.parent.isBone &&
        (r.push(0, 0, 0),
        r.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b))
    }
    i.setAttribute("position", new ut(r, 3)),
      i.setAttribute("color", new ut(s, 3))
    const A = new Nn({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    })
    super(i, A),
      (this.type = "SkeletonHelper"),
      (this.isSkeletonHelper = !0),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1)
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      i = this.geometry,
      r = i.getAttribute("position")
    am.copy(this.root.matrixWorld).invert()
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s]
      a.parent &&
        a.parent.isBone &&
        (rh.multiplyMatrices(am, a.matrixWorld),
        mo.setFromMatrixPosition(rh),
        r.setXYZ(o, mo.x, mo.y, mo.z),
        rh.multiplyMatrices(am, a.parent.matrixWorld),
        mo.setFromMatrixPosition(rh),
        r.setXYZ(o + 1, mo.x, mo.y, mo.z),
        (o += 2))
    }
    ;(i.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e)
  }
}
function w6(n) {
  const e = []
  n && n.isBone && e.push(n)
  for (let t = 0; t < n.children.length; t++) e.push.apply(e, w6(n.children[t]))
  return e
}
class RO extends Xt {
  constructor(e, t, i) {
    const r = new As(t, 4, 2),
      s = new Mr({ wireframe: !0, fog: !1, toneMapped: !1 })
    super(r, s),
      (this.light = e),
      this.light.updateMatrixWorld(),
      (this.color = i),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update()
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
  update() {
    this.color !== void 0
      ? this.material.color.set(this.color)
      : this.material.color.copy(this.light.color)
  }
}
const PO = new X(),
  M3 = new Ke(),
  S3 = new Ke()
class LO extends kt {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      this.light.updateMatrixWorld(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i)
    const r = new Va(t)
    r.rotateY(Math.PI * 0.5),
      (this.material = new Mr({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0)
    const s = r.getAttribute("position"),
      o = new Float32Array(s.count * 3)
    r.setAttribute("color", new Bt(o, 3)),
      this.add(new Xt(r, this.material)),
      this.update()
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose()
  }
  update() {
    const e = this.children[0]
    if (this.color !== void 0) this.material.color.set(this.color)
    else {
      const t = e.geometry.getAttribute("color")
      M3.copy(this.light.color), S3.copy(this.light.groundColor)
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? M3 : S3
        t.setXYZ(i, s.r, s.g, s.b)
      }
      t.needsUpdate = !0
    }
    e.lookAt(PO.setFromMatrixPosition(this.light.matrixWorld).negate())
  }
}
class M6 extends yi {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    ;(i = new Ke(i)), (r = new Ke(r))
    const s = t / 2,
      o = e / t,
      a = e / 2,
      A = [],
      c = []
    for (let m = 0, y = 0, x = -a; m <= t; m++, x += o) {
      A.push(-a, 0, x, a, 0, x), A.push(x, 0, -a, x, 0, a)
      const S = m === s ? i : r
      S.toArray(c, y),
        (y += 3),
        S.toArray(c, y),
        (y += 3),
        S.toArray(c, y),
        (y += 3),
        S.toArray(c, y),
        (y += 3)
    }
    const d = new yt()
    d.setAttribute("position", new ut(A, 3)),
      d.setAttribute("color", new ut(c, 3))
    const p = new Nn({ vertexColors: !0, toneMapped: !1 })
    super(d, p), (this.type = "GridHelper")
  }
}
class DO extends yi {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    ;(s = new Ke(s)), (o = new Ke(o))
    const a = [],
      A = []
    for (let p = 0; p <= t; p++) {
      const m = (p / t) * (Math.PI * 2),
        y = Math.sin(m) * e,
        x = Math.cos(m) * e
      a.push(0, 0, 0), a.push(y, 0, x)
      const S = p & 1 ? s : o
      A.push(S.r, S.g, S.b), A.push(S.r, S.g, S.b)
    }
    for (let p = 0; p <= i; p++) {
      const m = p & 1 ? s : o,
        y = e - (e / i) * p
      for (let x = 0; x < r; x++) {
        let S = (x / r) * (Math.PI * 2),
          C = Math.sin(S) * y,
          M = Math.cos(S) * y
        a.push(C, 0, M),
          A.push(m.r, m.g, m.b),
          (S = ((x + 1) / r) * (Math.PI * 2)),
          (C = Math.sin(S) * y),
          (M = Math.cos(S) * y),
          a.push(C, 0, M),
          A.push(m.r, m.g, m.b)
      }
    }
    const c = new yt()
    c.setAttribute("position", new ut(a, 3)),
      c.setAttribute("color", new ut(A, 3))
    const d = new Nn({ vertexColors: !0, toneMapped: !1 })
    super(c, d), (this.type = "PolarGridHelper")
  }
}
const E3 = new X(),
  sh = new X(),
  T3 = new X()
class IO extends kt {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      this.light.updateMatrixWorld(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      t === void 0 && (t = 1)
    let r = new yt()
    r.setAttribute(
      "position",
      new ut([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    )
    const s = new Nn({ fog: !1, toneMapped: !1 })
    ;(this.lightPlane = new br(r, s)),
      this.add(this.lightPlane),
      (r = new yt()),
      r.setAttribute("position", new ut([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new br(r, s)),
      this.add(this.targetLine),
      this.update()
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose()
  }
  update() {
    E3.setFromMatrixPosition(this.light.matrixWorld),
      sh.setFromMatrixPosition(this.light.target.matrixWorld),
      T3.subVectors(sh, E3),
      this.lightPlane.lookAt(sh),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(sh),
      (this.targetLine.scale.z = T3.length())
  }
}
const oh = new X(),
  Cn = new qu()
class BO extends yi {
  constructor(e) {
    const t = new yt(),
      i = new Nn({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      o = {},
      a = new Ke(16755200),
      A = new Ke(16711680),
      c = new Ke(43775),
      d = new Ke(16777215),
      p = new Ke(3355443)
    m("n1", "n2", a),
      m("n2", "n4", a),
      m("n4", "n3", a),
      m("n3", "n1", a),
      m("f1", "f2", a),
      m("f2", "f4", a),
      m("f4", "f3", a),
      m("f3", "f1", a),
      m("n1", "f1", a),
      m("n2", "f2", a),
      m("n3", "f3", a),
      m("n4", "f4", a),
      m("p", "n1", A),
      m("p", "n2", A),
      m("p", "n3", A),
      m("p", "n4", A),
      m("u1", "u2", c),
      m("u2", "u3", c),
      m("u3", "u1", c),
      m("c", "t", d),
      m("p", "c", p),
      m("cn1", "cn2", p),
      m("cn3", "cn4", p),
      m("cf1", "cf2", p),
      m("cf3", "cf4", p)
    function m(x, S, C) {
      y(x, C), y(S, C)
    }
    function y(x, S) {
      r.push(0, 0, 0),
        s.push(S.r, S.g, S.b),
        o[x] === void 0 && (o[x] = []),
        o[x].push(r.length / 3 - 1)
    }
    t.setAttribute("position", new ut(r, 3)),
      t.setAttribute("color", new ut(s, 3)),
      super(t, i),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update()
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      i = 1,
      r = 1
    Cn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      kn("c", t, e, Cn, 0, 0, -1),
      kn("t", t, e, Cn, 0, 0, 1),
      kn("n1", t, e, Cn, -i, -r, -1),
      kn("n2", t, e, Cn, i, -r, -1),
      kn("n3", t, e, Cn, -i, r, -1),
      kn("n4", t, e, Cn, i, r, -1),
      kn("f1", t, e, Cn, -i, -r, 1),
      kn("f2", t, e, Cn, i, -r, 1),
      kn("f3", t, e, Cn, -i, r, 1),
      kn("f4", t, e, Cn, i, r, 1),
      kn("u1", t, e, Cn, i * 0.7, r * 1.1, -1),
      kn("u2", t, e, Cn, -i * 0.7, r * 1.1, -1),
      kn("u3", t, e, Cn, 0, r * 2, -1),
      kn("cf1", t, e, Cn, -i, 0, 1),
      kn("cf2", t, e, Cn, i, 0, 1),
      kn("cf3", t, e, Cn, 0, -r, 1),
      kn("cf4", t, e, Cn, 0, r, 1),
      kn("cn1", t, e, Cn, -i, 0, -1),
      kn("cn2", t, e, Cn, i, 0, -1),
      kn("cn3", t, e, Cn, 0, -r, -1),
      kn("cn4", t, e, Cn, 0, r, -1),
      (e.getAttribute("position").needsUpdate = !0)
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
function kn(n, e, t, i, r, s, o) {
  oh.set(r, s, o).unproject(i)
  const a = e[n]
  if (a !== void 0) {
    const A = t.getAttribute("position")
    for (let c = 0, d = a.length; c < d; c++) A.setXYZ(a[c], oh.x, oh.y, oh.z)
  }
}
const ah = new Ri()
class S6 extends yi {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new Float32Array(8 * 3),
      s = new yt()
    s.setIndex(new Bt(i, 1)),
      s.setAttribute("position", new Bt(r, 3)),
      super(s, new Nn({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update()
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && ah.setFromObject(this.object),
      ah.isEmpty())
    )
      return
    const t = ah.min,
      i = ah.max,
      r = this.geometry.attributes.position,
      s = r.array
    ;(s[0] = i.x),
      (s[1] = i.y),
      (s[2] = i.z),
      (s[3] = t.x),
      (s[4] = i.y),
      (s[5] = i.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = i.z),
      (s[9] = i.x),
      (s[10] = t.y),
      (s[11] = i.z),
      (s[12] = i.x),
      (s[13] = i.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = i.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = i.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (r.needsUpdate = !0),
      this.geometry.computeBoundingSphere()
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this
  }
  copy(e) {
    return yi.prototype.copy.call(this, e), (this.object = e.object), this
  }
}
class kO extends yi {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new yt()
    s.setIndex(new Bt(i, 1)),
      s.setAttribute("position", new ut(r, 3)),
      super(s, new Nn({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere()
  }
  updateMatrixWorld(e) {
    const t = this.box
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e))
  }
}
class OO extends br {
  constructor(e, t = 1, i = 16776960) {
    const r = i,
      s = [
        1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1,
        1, 1, 1, 0, 0, 1, 0, 0, 0,
      ],
      o = new yt()
    o.setAttribute("position", new ut(s, 3)),
      o.computeBoundingSphere(),
      super(o, new Nn({ color: r, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t)
    const a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
      A = new yt()
    A.setAttribute("position", new ut(a, 3)),
      A.computeBoundingSphere(),
      this.add(
        new Xt(
          A,
          new Mr({
            color: r,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      )
  }
  updateMatrixWorld(e) {
    let t = -this.plane.constant
    Math.abs(t) < 1e-8 && (t = 1e-8),
      this.scale.set(0.5 * this.size, 0.5 * this.size, t),
      (this.children[0].material.side = t < 0 ? Pn : Na),
      this.lookAt(this.plane.normal),
      super.updateMatrixWorld(e)
  }
}
const C3 = new X()
let lh, lm
class qO extends kt {
  constructor(
    e = new X(0, 0, 1),
    t = new X(0, 0, 0),
    i = 1,
    r = 16776960,
    s = i * 0.2,
    o = s * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      lh === void 0 &&
        ((lh = new yt()),
        lh.setAttribute("position", new ut([0, 0, 0, 0, 1, 0], 3)),
        (lm = new zs(0, 0.5, 1, 5, 1)),
        lm.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new br(lh, new Nn({ color: r, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Xt(lm, new Mr({ color: r, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(i, s, o)
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1)
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0)
    else {
      C3.set(e.z, 0, -e.x).normalize()
      const t = Math.acos(e.y)
      this.quaternion.setFromAxisAngle(C3, t)
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(i, t, i),
      (this.cone.position.y = e),
      this.cone.updateMatrix()
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e)
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    )
  }
}
class E6 extends yi {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new yt()
    r.setAttribute("position", new ut(t, 3)),
      r.setAttribute("color", new ut(i, 3))
    const s = new Nn({ vertexColors: !0, toneMapped: !1 })
    super(r, s), (this.type = "AxesHelper")
  }
  setColors(e, t, i) {
    const r = new Ke(),
      s = this.geometry.attributes.color.array
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(t),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(i),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    )
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class T6 {
  constructor() {
    ;(this.type = "ShapePath"),
      (this.color = new Ke()),
      (this.subPaths = []),
      (this.currentPath = null)
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new ru()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    )
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this
  }
  toShapes(e, t) {
    function i(_) {
      const R = []
      for (let T = 0, L = _.length; T < L; T++) {
        const B = _[T],
          k = new ns()
        ;(k.curves = B.curves), R.push(k)
      }
      return R
    }
    function r(_, R) {
      const T = R.length
      let L = !1
      for (let B = T - 1, k = 0; k < T; B = k++) {
        let O = R[B],
          W = R[k],
          z = W.x - O.x,
          P = W.y - O.y
        if (Math.abs(P) > Number.EPSILON) {
          if (
            (P < 0 && ((O = R[k]), (z = -z), (W = R[B]), (P = -P)),
            _.y < O.y || _.y > W.y)
          )
            continue
          if (_.y === O.y) {
            if (_.x === O.x) return !0
          } else {
            const N = P * (_.x - O.x) - z * (_.y - O.y)
            if (N === 0) return !0
            if (N < 0) continue
            L = !L
          }
        } else {
          if (_.y !== O.y) continue
          if ((W.x <= _.x && _.x <= O.x) || (O.x <= _.x && _.x <= W.x))
            return !0
        }
      }
      return L
    }
    const s = is.isClockWise,
      o = this.subPaths
    if (o.length === 0) return []
    if (t === !0) return i(o)
    let a, A, c
    const d = []
    if (o.length === 1)
      return (A = o[0]), (c = new ns()), (c.curves = A.curves), d.push(c), d
    let p = !s(o[0].getPoints())
    p = e ? !p : p
    const m = [],
      y = []
    let x = [],
      S = 0,
      C
    ;(y[S] = void 0), (x[S] = [])
    for (let _ = 0, R = o.length; _ < R; _++)
      (A = o[_]),
        (C = A.getPoints()),
        (a = s(C)),
        (a = e ? !a : a),
        a
          ? (!p && y[S] && S++,
            (y[S] = { s: new ns(), p: C }),
            (y[S].s.curves = A.curves),
            p && S++,
            (x[S] = []))
          : x[S].push({ h: A, p: C[0] })
    if (!y[0]) return i(o)
    if (y.length > 1) {
      let _ = !1
      const R = []
      for (let T = 0, L = y.length; T < L; T++) m[T] = []
      for (let T = 0, L = y.length; T < L; T++) {
        const B = x[T]
        for (let k = 0; k < B.length; k++) {
          const O = B[k]
          let W = !0
          for (let z = 0; z < y.length; z++)
            r(O.p, y[z].p) &&
              (T !== z && R.push({ froms: T, tos: z, hole: k }),
              W ? ((W = !1), m[z].push(O)) : (_ = !0))
          W && m[T].push(O)
        }
      }
      R.length > 0 && (_ || (x = m))
    }
    let M
    for (let _ = 0, R = y.length; _ < R; _++) {
      ;(c = y[_].s), d.push(c), (M = x[_])
      for (let T = 0, L = M.length; T < L; T++) c.holes.push(M[T].h)
    }
    return d
  }
}
const C6 = new Float32Array(1),
  FO = new Int32Array(C6.buffer)
class NO {
  static toHalfFloat(e) {
    e > 65504 &&
      (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."),
      (e = 65504)),
      (C6[0] = e)
    const t = FO[0]
    let i = (t >> 16) & 32768,
      r = (t >> 12) & 2047
    const s = (t >> 23) & 255
    return s < 103
      ? i
      : s > 142
      ? ((i |= 31744), (i |= (s == 255 ? 0 : 1) && t & 8388607), i)
      : s < 113
      ? ((r |= 2048), (i |= (r >> (114 - s)) + ((r >> (113 - s)) & 1)), i)
      : ((i |= ((s - 112) << 10) | (r >> 1)), (i += r & 1), i)
  }
}
const UO = 0,
  zO = 1,
  HO = 0,
  GO = 1,
  VO = 2
function WO(n) {
  return (
    console.warn(
      "THREE.MeshFaceMaterial has been removed. Use an Array instead."
    ),
    n
  )
}
function jO(n = []) {
  return (
    console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
    (n.isMultiMaterial = !0),
    (n.materials = n),
    (n.clone = function () {
      return n.slice()
    }),
    n
  )
}
function $O(n, e) {
  return (
    console.warn("THREE.PointCloud has been renamed to THREE.Points."),
    new Hu(n, e)
  )
}
function QO(n) {
  return (
    console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Id(n)
  )
}
function XO(n, e) {
  return (
    console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
    new Hu(n, e)
  )
}
function YO(n) {
  return (
    console.warn(
      "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
    ),
    new rl(n)
  )
}
function ZO(n) {
  return (
    console.warn(
      "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
    ),
    new rl(n)
  )
}
function JO(n) {
  return (
    console.warn(
      "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
    ),
    new rl(n)
  )
}
function KO(n, e, t) {
  return (
    console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
    new X(n, e, t)
  )
}
function eq(n, e) {
  return (
    console.warn(
      "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
    ),
    new Bt(n, e).setUsage(yc)
  )
}
function tq(n, e) {
  return (
    console.warn(
      "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
    ),
    new S5(n, e)
  )
}
function nq(n, e) {
  return (
    console.warn(
      "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
    ),
    new E5(n, e)
  )
}
function iq(n, e) {
  return (
    console.warn(
      "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
    ),
    new T5(n, e)
  )
}
function rq(n, e) {
  return (
    console.warn(
      "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
    ),
    new C5(n, e)
  )
}
function sq(n, e) {
  return (
    console.warn(
      "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
    ),
    new wd(n, e)
  )
}
function oq(n, e) {
  return (
    console.warn(
      "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
    ),
    new R5(n, e)
  )
}
function aq(n, e) {
  return (
    console.warn(
      "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
    ),
    new Md(n, e)
  )
}
function lq(n, e) {
  return (
    console.warn(
      "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
    ),
    new ut(n, e)
  )
}
function cq(n, e) {
  return (
    console.warn(
      "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
    ),
    new L5(n, e)
  )
}
Vi.create = function (n, e) {
  return (
    console.log("THREE.Curve.create() has been deprecated"),
    (n.prototype = Object.create(Vi.prototype)),
    (n.prototype.constructor = n),
    (n.prototype.getPoint = e),
    n
  )
}
ru.prototype.fromPoints = function (n) {
  return (
    console.warn(
      "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
    ),
    this.setFromPoints(n)
  )
}
function Aq(n) {
  return (
    console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
    new E6(n)
  )
}
function uq(n, e) {
  return (
    console.warn(
      "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
    ),
    new S6(n, e)
  )
}
function fq(n, e) {
  return (
    console.warn(
      "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
    ),
    new yi(new f2(n.geometry), new Nn({ color: e !== void 0 ? e : 16777215 }))
  )
}
M6.prototype.setColors = function () {
  console.error(
    "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
  )
}
b6.prototype.update = function () {
  console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
}
function hq(n, e) {
  return (
    console.warn(
      "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
    ),
    new yi(new Hd(n.geometry), new Nn({ color: e !== void 0 ? e : 16777215 }))
  )
}
Pi.prototype.extractUrlBase = function (n) {
  return (
    console.warn(
      "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
    ),
    x0.extractUrlBase(n)
  )
}
Pi.Handlers = {
  add: function () {
    console.error(
      "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
    )
  },
  get: function () {
    console.error(
      "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
    )
  },
}
function dq(n) {
  return (
    console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
    new us(n)
  )
}
function pq(n) {
  return (
    console.warn(
      "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
    ),
    new o6(n)
  )
}
jc.prototype.center = function (n) {
  return (
    console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
    this.getCenter(n)
  )
}
jc.prototype.empty = function () {
  return (
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
  )
}
jc.prototype.isIntersectionBox = function (n) {
  return (
    console.warn(
      "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
    ),
    this.intersectsBox(n)
  )
}
jc.prototype.size = function (n) {
  return (
    console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
    this.getSize(n)
  )
}
Ri.prototype.center = function (n) {
  return (
    console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
    this.getCenter(n)
  )
}
Ri.prototype.empty = function () {
  return (
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
  )
}
Ri.prototype.isIntersectionBox = function (n) {
  return (
    console.warn(
      "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
    ),
    this.intersectsBox(n)
  )
}
Ri.prototype.isIntersectionSphere = function (n) {
  return (
    console.warn(
      "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
    ),
    this.intersectsSphere(n)
  )
}
Ri.prototype.size = function (n) {
  return (
    console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
    this.getSize(n)
  )
}
ds.prototype.empty = function () {
  return (
    console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
    this.isEmpty()
  )
}
Fu.prototype.setFromMatrix = function (n) {
  return (
    console.warn(
      "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
    ),
    this.setFromProjectionMatrix(n)
  )
}
N2.prototype.center = function (n) {
  return (
    console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
    this.getCenter(n)
  )
}
Zn.prototype.flattenToArrayOffset = function (n, e) {
  return (
    console.warn(
      "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
    ),
    this.toArray(n, e)
  )
}
Zn.prototype.multiplyVector3 = function (n) {
  return (
    console.warn(
      "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
    ),
    n.applyMatrix3(this)
  )
}
Zn.prototype.multiplyVector3Array = function () {
  console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
}
Zn.prototype.applyToBufferAttribute = function (n) {
  return (
    console.warn(
      "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
    ),
    n.applyMatrix3(this)
  )
}
Zn.prototype.applyToVector3Array = function () {
  console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
}
Zn.prototype.getInverse = function (n) {
  return (
    console.warn(
      "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
    ),
    this.copy(n).invert()
  )
}
mt.prototype.extractPosition = function (n) {
  return (
    console.warn(
      "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
    ),
    this.copyPosition(n)
  )
}
mt.prototype.flattenToArrayOffset = function (n, e) {
  return (
    console.warn(
      "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
    ),
    this.toArray(n, e)
  )
}
mt.prototype.getPosition = function () {
  return (
    console.warn(
      "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
    ),
    new X().setFromMatrixColumn(this, 3)
  )
}
mt.prototype.setRotationFromQuaternion = function (n) {
  return (
    console.warn(
      "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
    ),
    this.makeRotationFromQuaternion(n)
  )
}
mt.prototype.multiplyToArray = function () {
  console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
}
mt.prototype.multiplyVector3 = function (n) {
  return (
    console.warn(
      "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
    ),
    n.applyMatrix4(this)
  )
}
mt.prototype.multiplyVector4 = function (n) {
  return (
    console.warn(
      "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
    ),
    n.applyMatrix4(this)
  )
}
mt.prototype.multiplyVector3Array = function () {
  console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
}
mt.prototype.rotateAxis = function (n) {
  console.warn(
    "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
  ),
    n.transformDirection(this)
}
mt.prototype.crossVector = function (n) {
  return (
    console.warn(
      "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
    ),
    n.applyMatrix4(this)
  )
}
mt.prototype.translate = function () {
  console.error("THREE.Matrix4: .translate() has been removed.")
}
mt.prototype.rotateX = function () {
  console.error("THREE.Matrix4: .rotateX() has been removed.")
}
mt.prototype.rotateY = function () {
  console.error("THREE.Matrix4: .rotateY() has been removed.")
}
mt.prototype.rotateZ = function () {
  console.error("THREE.Matrix4: .rotateZ() has been removed.")
}
mt.prototype.rotateByAxis = function () {
  console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
}
mt.prototype.applyToBufferAttribute = function (n) {
  return (
    console.warn(
      "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
    ),
    n.applyMatrix4(this)
  )
}
mt.prototype.applyToVector3Array = function () {
  console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
}
mt.prototype.makeFrustum = function (n, e, t, i, r, s) {
  return (
    console.warn(
      "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
    ),
    this.makePerspective(n, e, i, t, r, s)
  )
}
mt.prototype.getInverse = function (n) {
  return (
    console.warn(
      "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
    ),
    this.copy(n).invert()
  )
}
Zr.prototype.isIntersectionLine = function (n) {
  return (
    console.warn(
      "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
    ),
    this.intersectsLine(n)
  )
}
Jn.prototype.multiplyVector3 = function (n) {
  return (
    console.warn(
      "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
    ),
    n.applyQuaternion(this)
  )
}
Jn.prototype.inverse = function () {
  return (
    console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
    this.invert()
  )
}
Wo.prototype.isIntersectionBox = function (n) {
  return (
    console.warn(
      "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
    ),
    this.intersectsBox(n)
  )
}
Wo.prototype.isIntersectionPlane = function (n) {
  return (
    console.warn(
      "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
    ),
    this.intersectsPlane(n)
  )
}
Wo.prototype.isIntersectionSphere = function (n) {
  return (
    console.warn(
      "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
    ),
    this.intersectsSphere(n)
  )
}
qn.prototype.area = function () {
  return (
    console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
    this.getArea()
  )
}
qn.prototype.barycoordFromPoint = function (n, e) {
  return (
    console.warn(
      "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
    ),
    this.getBarycoord(n, e)
  )
}
qn.prototype.midpoint = function (n) {
  return (
    console.warn(
      "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
    ),
    this.getMidpoint(n)
  )
}
qn.prototypenormal = function (n) {
  return (
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    this.getNormal(n)
  )
}
qn.prototype.plane = function (n) {
  return (
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
    this.getPlane(n)
  )
}
qn.barycoordFromPoint = function (n, e, t, i, r) {
  return (
    console.warn(
      "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
    ),
    qn.getBarycoord(n, e, t, i, r)
  )
}
qn.normal = function (n, e, t, i) {
  return (
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
    qn.getNormal(n, e, t, i)
  )
}
ns.prototype.extractAllPoints = function (n) {
  return (
    console.warn(
      "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
    ),
    this.extractPoints(n)
  )
}
ns.prototype.extrude = function (n) {
  return (
    console.warn(
      "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
    ),
    new Nr(this, n)
  )
}
ns.prototype.makeGeometry = function (n) {
  return (
    console.warn(
      "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
    ),
    new Wa(this, n)
  )
}
qe.prototype.fromAttribute = function (n, e, t) {
  return (
    console.warn(
      "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
    ),
    this.fromBufferAttribute(n, e, t)
  )
}
qe.prototype.distanceToManhattan = function (n) {
  return (
    console.warn(
      "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
    ),
    this.manhattanDistanceTo(n)
  )
}
qe.prototype.lengthManhattan = function () {
  return (
    console.warn(
      "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
    ),
    this.manhattanLength()
  )
}
X.prototype.setEulerFromRotationMatrix = function () {
  console.error(
    "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
  )
}
X.prototype.setEulerFromQuaternion = function () {
  console.error(
    "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
  )
}
X.prototype.getPositionFromMatrix = function (n) {
  return (
    console.warn(
      "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
    ),
    this.setFromMatrixPosition(n)
  )
}
X.prototype.getScaleFromMatrix = function (n) {
  return (
    console.warn(
      "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
    ),
    this.setFromMatrixScale(n)
  )
}
X.prototype.getColumnFromMatrix = function (n, e) {
  return (
    console.warn(
      "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
    ),
    this.setFromMatrixColumn(e, n)
  )
}
X.prototype.applyProjection = function (n) {
  return (
    console.warn(
      "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
    ),
    this.applyMatrix4(n)
  )
}
X.prototype.fromAttribute = function (n, e, t) {
  return (
    console.warn(
      "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
    ),
    this.fromBufferAttribute(n, e, t)
  )
}
X.prototype.distanceToManhattan = function (n) {
  return (
    console.warn(
      "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
    ),
    this.manhattanDistanceTo(n)
  )
}
X.prototype.lengthManhattan = function () {
  return (
    console.warn(
      "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
    ),
    this.manhattanLength()
  )
}
en.prototype.fromAttribute = function (n, e, t) {
  return (
    console.warn(
      "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
    ),
    this.fromBufferAttribute(n, e, t)
  )
}
en.prototype.lengthManhattan = function () {
  return (
    console.warn(
      "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
    ),
    this.manhattanLength()
  )
}
kt.prototype.getChildByName = function (n) {
  return (
    console.warn(
      "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
    ),
    this.getObjectByName(n)
  )
}
kt.prototype.renderDepth = function () {
  console.warn(
    "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
  )
}
kt.prototype.translate = function (n, e) {
  return (
    console.warn(
      "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
    ),
    this.translateOnAxis(e, n)
  )
}
kt.prototype.getWorldRotation = function () {
  console.error(
    "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
  )
}
kt.prototype.applyMatrix = function (n) {
  return (
    console.warn(
      "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
    ),
    this.applyMatrix4(n)
  )
}
Object.defineProperties(kt.prototype, {
  eulerOrder: {
    get: function () {
      return (
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
        this.rotation.order
      )
    },
    set: function (n) {
      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
        (this.rotation.order = n)
    },
  },
  useQuaternion: {
    get: function () {
      console.warn(
        "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
      )
    },
    set: function () {
      console.warn(
        "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
      )
    },
  },
})
Xt.prototype.setDrawMode = function () {
  console.error(
    "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
  )
}
Object.defineProperties(Xt.prototype, {
  drawMode: {
    get: function () {
      return (
        console.error(
          "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
        ),
        i2
      )
    },
    set: function () {
      console.error(
        "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
      )
    },
  },
})
Bd.prototype.initBones = function () {
  console.error("THREE.SkinnedMesh: initBones() has been removed.")
}
ei.prototype.setLens = function (n, e) {
  console.warn(
    "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
  ),
    e !== void 0 && (this.filmGauge = e),
    this.setFocalLength(n)
}
Object.defineProperties(Ur.prototype, {
  onlyShadow: {
    set: function () {
      console.warn("THREE.Light: .onlyShadow has been removed.")
    },
  },
  shadowCameraFov: {
    set: function (n) {
      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
        (this.shadow.camera.fov = n)
    },
  },
  shadowCameraLeft: {
    set: function (n) {
      console.warn(
        "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
      ),
        (this.shadow.camera.left = n)
    },
  },
  shadowCameraRight: {
    set: function (n) {
      console.warn(
        "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
      ),
        (this.shadow.camera.right = n)
    },
  },
  shadowCameraTop: {
    set: function (n) {
      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
        (this.shadow.camera.top = n)
    },
  },
  shadowCameraBottom: {
    set: function (n) {
      console.warn(
        "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
      ),
        (this.shadow.camera.bottom = n)
    },
  },
  shadowCameraNear: {
    set: function (n) {
      console.warn(
        "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
      ),
        (this.shadow.camera.near = n)
    },
  },
  shadowCameraFar: {
    set: function (n) {
      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
        (this.shadow.camera.far = n)
    },
  },
  shadowCameraVisible: {
    set: function () {
      console.warn(
        "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
      )
    },
  },
  shadowBias: {
    set: function (n) {
      console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
        (this.shadow.bias = n)
    },
  },
  shadowDarkness: {
    set: function () {
      console.warn("THREE.Light: .shadowDarkness has been removed.")
    },
  },
  shadowMapWidth: {
    set: function (n) {
      console.warn(
        "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
      ),
        (this.shadow.mapSize.width = n)
    },
  },
  shadowMapHeight: {
    set: function (n) {
      console.warn(
        "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
      ),
        (this.shadow.mapSize.height = n)
    },
  },
})
Object.defineProperties(Bt.prototype, {
  length: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
        ),
        this.array.length
      )
    },
  },
  dynamic: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
        ),
        this.usage === yc
      )
    },
    set: function () {
      console.warn(
        "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
      ),
        this.setUsage(yc)
    },
  },
})
Bt.prototype.setDynamic = function (n) {
  return (
    console.warn(
      "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
    ),
    this.setUsage(n === !0 ? yc : gc),
    this
  )
}
;(Bt.prototype.copyIndicesArray = function () {
  console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
}),
  (Bt.prototype.setArray = function () {
    console.error(
      "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
    )
  })
yt.prototype.addIndex = function (n) {
  console.warn(
    "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
  ),
    this.setIndex(n)
}
yt.prototype.addAttribute = function (n, e) {
  return (
    console.warn(
      "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
    ),
    !(e && e.isBufferAttribute) && !(e && e.isInterleavedBufferAttribute)
      ? (console.warn(
          "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
        ),
        this.setAttribute(n, new Bt(arguments[1], arguments[2])))
      : n === "index"
      ? (console.warn(
          "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
        ),
        this.setIndex(e),
        this)
      : this.setAttribute(n, e)
  )
}
yt.prototype.addDrawCall = function (n, e, t) {
  t !== void 0 &&
    console.warn(
      "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
    ),
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
    this.addGroup(n, e)
}
yt.prototype.clearDrawCalls = function () {
  console.warn(
    "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
  ),
    this.clearGroups()
}
yt.prototype.computeOffsets = function () {
  console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
}
yt.prototype.removeAttribute = function (n) {
  return (
    console.warn(
      "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
    ),
    this.deleteAttribute(n)
  )
}
yt.prototype.applyMatrix = function (n) {
  return (
    console.warn(
      "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
    ),
    this.applyMatrix4(n)
  )
}
Object.defineProperties(yt.prototype, {
  drawcalls: {
    get: function () {
      return (
        console.error(
          "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
        ),
        this.groups
      )
    },
  },
  offsets: {
    get: function () {
      return (
        console.warn(
          "THREE.BufferGeometry: .offsets has been renamed to .groups."
        ),
        this.groups
      )
    },
  },
})
$o.prototype.setDynamic = function (n) {
  return (
    console.warn(
      "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
    ),
    this.setUsage(n === !0 ? yc : gc),
    this
  )
}
$o.prototype.setArray = function () {
  console.error(
    "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
  )
}
Nr.prototype.getArrays = function () {
  console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
}
Nr.prototype.addShapeList = function () {
  console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
}
Nr.prototype.addShape = function () {
  console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
}
Ld.prototype.dispose = function () {
  console.error("THREE.Scene: .dispose() has been removed.")
}
jd.prototype.onUpdate = function () {
  return (
    console.warn(
      "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
    ),
    this
  )
}
Object.defineProperties(ii.prototype, {
  wrapAround: {
    get: function () {
      console.warn("THREE.Material: .wrapAround has been removed.")
    },
    set: function () {
      console.warn("THREE.Material: .wrapAround has been removed.")
    },
  },
  overdraw: {
    get: function () {
      console.warn("THREE.Material: .overdraw has been removed.")
    },
    set: function () {
      console.warn("THREE.Material: .overdraw has been removed.")
    },
  },
  wrapRGB: {
    get: function () {
      return (
        console.warn("THREE.Material: .wrapRGB has been removed."), new Ke()
      )
    },
  },
  shading: {
    get: function () {
      console.error(
        "THREE." +
          this.type +
          ": .shading has been removed. Use the boolean .flatShading instead."
      )
    },
    set: function (n) {
      console.warn(
        "THREE." +
          this.type +
          ": .shading has been removed. Use the boolean .flatShading instead."
      ),
        (this.flatShading = n === Jg)
    },
  },
  stencilMask: {
    get: function () {
      return (
        console.warn(
          "THREE." +
            this.type +
            ": .stencilMask has been removed. Use .stencilFuncMask instead."
        ),
        this.stencilFuncMask
      )
    },
    set: function (n) {
      console.warn(
        "THREE." +
          this.type +
          ": .stencilMask has been removed. Use .stencilFuncMask instead."
      ),
        (this.stencilFuncMask = n)
    },
  },
  vertexTangents: {
    get: function () {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
    },
    set: function () {
      console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
    },
  },
})
Object.defineProperties(ar.prototype, {
  derivatives: {
    get: function () {
      return (
        console.warn(
          "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
        ),
        this.extensions.derivatives
      )
    },
    set: function (n) {
      console.warn(
        "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
      ),
        (this.extensions.derivatives = n)
    },
  },
})
rn.prototype.clearTarget = function (n, e, t, i) {
  console.warn(
    "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
  ),
    this.setRenderTarget(n),
    this.clear(e, t, i)
}
rn.prototype.animate = function (n) {
  console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
    this.setAnimationLoop(n)
}
rn.prototype.getCurrentRenderTarget = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
    ),
    this.getRenderTarget()
  )
}
rn.prototype.getMaxAnisotropy = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
    ),
    this.capabilities.getMaxAnisotropy()
  )
}
rn.prototype.getPrecision = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
    ),
    this.capabilities.precision
  )
}
rn.prototype.resetGLState = function () {
  return (
    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
    this.state.reset()
  )
}
rn.prototype.supportsFloatTextures = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
    ),
    this.extensions.get("OES_texture_float")
  )
}
rn.prototype.supportsHalfFloatTextures = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
    ),
    this.extensions.get("OES_texture_half_float")
  )
}
rn.prototype.supportsStandardDerivatives = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
    ),
    this.extensions.get("OES_standard_derivatives")
  )
}
rn.prototype.supportsCompressedTextureS3TC = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
    ),
    this.extensions.get("WEBGL_compressed_texture_s3tc")
  )
}
rn.prototype.supportsCompressedTexturePVRTC = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
    ),
    this.extensions.get("WEBGL_compressed_texture_pvrtc")
  )
}
rn.prototype.supportsBlendMinMax = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
    ),
    this.extensions.get("EXT_blend_minmax")
  )
}
rn.prototype.supportsVertexTextures = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
    ),
    this.capabilities.vertexTextures
  )
}
rn.prototype.supportsInstancedArrays = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
    ),
    this.extensions.get("ANGLE_instanced_arrays")
  )
}
rn.prototype.enableScissorTest = function (n) {
  console.warn(
    "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
  ),
    this.setScissorTest(n)
}
rn.prototype.initMaterial = function () {
  console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
}
rn.prototype.addPrePlugin = function () {
  console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
}
rn.prototype.addPostPlugin = function () {
  console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
}
rn.prototype.updateShadowMap = function () {
  console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
}
rn.prototype.setFaceCulling = function () {
  console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
}
rn.prototype.allocTextureUnit = function () {
  console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
}
rn.prototype.setTexture = function () {
  console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
}
rn.prototype.setTexture2D = function () {
  console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
}
rn.prototype.setTextureCube = function () {
  console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
}
rn.prototype.getActiveMipMapLevel = function () {
  return (
    console.warn(
      "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
    ),
    this.getActiveMipmapLevel()
  )
}
Object.defineProperties(rn.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled
    },
    set: function (n) {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
      ),
        (this.shadowMap.enabled = n)
    },
  },
  shadowMapType: {
    get: function () {
      return this.shadowMap.type
    },
    set: function (n) {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
      ),
        (this.shadowMap.type = n)
    },
  },
  shadowMapCullFace: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
      )
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
      )
    },
  },
  context: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
        ),
        this.getContext()
      )
    },
  },
  vr: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
        this.xr
      )
    },
  },
  gammaInput: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
        ),
        !1
      )
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
      )
    },
  },
  gammaOutput: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
        ),
        !1
      )
    },
    set: function (n) {
      console.warn(
        "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
      ),
        (this.outputEncoding = n === !0 ? pn : Ns)
    },
  },
  toneMappingWhitePoint: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
        ),
        1
      )
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
      )
    },
  },
  gammaFactor: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
      )
    },
    set: function () {
      console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
    },
  },
})
Object.defineProperties(H5.prototype, {
  cullFace: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
      )
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
      )
    },
  },
  renderReverseSided: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
      )
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
      )
    },
  },
  renderSingleSided: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
      )
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
      )
    },
  },
})
function mq(n, e, t) {
  return (
    console.warn(
      "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
    ),
    new Ed(n, t)
  )
}
Object.defineProperties(rr.prototype, {
  wrapS: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
        this.texture.wrapS
      )
    },
    set: function (n) {
      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
        (this.texture.wrapS = n)
    },
  },
  wrapT: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
        this.texture.wrapT
      )
    },
    set: function (n) {
      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
        (this.texture.wrapT = n)
    },
  },
  magFilter: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
        ),
        this.texture.magFilter
      )
    },
    set: function (n) {
      console.warn(
        "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
      ),
        (this.texture.magFilter = n)
    },
  },
  minFilter: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
        ),
        this.texture.minFilter
      )
    },
    set: function (n) {
      console.warn(
        "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
      ),
        (this.texture.minFilter = n)
    },
  },
  anisotropy: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
        ),
        this.texture.anisotropy
      )
    },
    set: function (n) {
      console.warn(
        "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
      ),
        (this.texture.anisotropy = n)
    },
  },
  offset: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .offset is now .texture.offset."
        ),
        this.texture.offset
      )
    },
    set: function (n) {
      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
        (this.texture.offset = n)
    },
  },
  repeat: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
        ),
        this.texture.repeat
      )
    },
    set: function (n) {
      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
        (this.texture.repeat = n)
    },
  },
  format: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .format is now .texture.format."
        ),
        this.texture.format
      )
    },
    set: function (n) {
      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
        (this.texture.format = n)
    },
  },
  type: {
    get: function () {
      return (
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
        this.texture.type
      )
    },
    set: function (n) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
        (this.texture.type = n)
    },
  },
  generateMipmaps: {
    get: function () {
      return (
        console.warn(
          "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
        ),
        this.texture.generateMipmaps
      )
    },
    set: function (n) {
      console.warn(
        "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
      ),
        (this.texture.generateMipmaps = n)
    },
  },
})
O2.prototype.load = function (n) {
  console.warn(
    "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
  )
  const e = this
  return (
    new h6().load(n, function (i) {
      e.setBuffer(i)
    }),
    this
  )
}
g6.prototype.getData = function () {
  return (
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
    this.getFrequencyData()
  )
}
Sd.prototype.updateCubeMap = function (n, e) {
  return (
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
    this.update(n, e)
  )
}
Sd.prototype.clear = function (n, e, t, i) {
  return (
    console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
    this.renderTarget.clear(n, e, t, i)
  )
}
Vo.crossOrigin = void 0
Vo.loadTexture = function (n, e, t, i) {
  console.warn(
    "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
  )
  const r = new E2()
  r.setCrossOrigin(this.crossOrigin)
  const s = r.load(n, t, void 0, i)
  return e && (s.mapping = e), s
}
Vo.loadTextureCube = function (n, e, t, i) {
  console.warn(
    "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
  )
  const r = new s6()
  r.setCrossOrigin(this.crossOrigin)
  const s = r.load(n, t, void 0, i)
  return e && (s.mapping = e), s
}
Vo.loadCompressedTexture = function () {
  console.error(
    "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
  )
}
Vo.loadCompressedTextureCube = function () {
  console.error(
    "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
  )
}
function gq() {
  console.error("THREE.CanvasRenderer has been removed")
}
function yq() {
  console.error("THREE.JSONLoader has been removed.")
}
const vq = {
  createMultiMaterialObject: function () {
    console.error(
      "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
    )
  },
  detach: function () {
    console.error(
      "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
    )
  },
  attach: function () {
    console.error(
      "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
    )
  },
}
function _q() {
  console.error(
    "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
  )
}
function xq() {
  return (
    console.error(
      "THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"
    ),
    new yt()
  )
}
function bq() {
  return (
    console.error(
      "THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"
    ),
    new yt()
  )
}
function wq() {
  console.error(
    "THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js"
  )
}
function Mq() {
  console.error(
    "THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js"
  )
}
function Sq() {
  console.error("THREE.ImmediateRenderObject has been removed.")
}
typeof __THREE_DEVTOOLS__ != "undefined" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: yd } })
  )
typeof window != "undefined" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = yd))
var yj = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: X4,
      AddEquation: va,
      AddOperation: W4,
      AdditiveAnimationBlendMode: n2,
      AdditiveBlending: Jm,
      AlphaFormat: n5,
      AlwaysDepth: F4,
      AlwaysStencilFunc: v5,
      AmbientLight: D2,
      AmbientLightProbe: p6,
      AnimationClip: Au,
      AnimationLoader: aO,
      AnimationMixer: _6,
      AnimationObjectGroup: v6,
      AnimationUtils: mn,
      ArcCurve: h2,
      ArrayCamera: l2,
      ArrowHelper: qO,
      Audio: O2,
      AudioAnalyser: g6,
      AudioContext: k2,
      AudioListener: hO,
      AudioLoader: h6,
      AxesHelper: E6,
      AxisHelper: Aq,
      BackSide: Pn,
      BasicDepthPacking: m5,
      BasicShadowMap: cP,
      BinaryTextureLoader: pq,
      Bone: kd,
      BooleanKeyframeTrack: sl,
      BoundingBoxHelper: uq,
      Box2: jc,
      Box3: Ri,
      Box3Helper: kO,
      BoxBufferGeometry: Us,
      BoxGeometry: Us,
      BoxHelper: S6,
      BufferAttribute: Bt,
      BufferGeometry: yt,
      BufferGeometryLoader: u6,
      ByteType: Z4,
      Cache: $a,
      Camera: qu,
      CameraHelper: BO,
      CanvasRenderer: gq,
      CanvasTexture: X5,
      CatmullRomCurve3: p2,
      CineonToneMapping: Q4,
      CircleBufferGeometry: Ga,
      CircleGeometry: Ga,
      ClampToEdgeWrapping: ci,
      Clock: m6,
      Color: Ke,
      ColorKeyframeTrack: M2,
      CompressedTexture: u2,
      CompressedTextureLoader: lO,
      ConeBufferGeometry: _c,
      ConeGeometry: _c,
      CubeCamera: Sd,
      CubeReflectionMapping: el,
      CubeRefractionMapping: tl,
      CubeTexture: Hc,
      CubeTextureLoader: s6,
      CubeUVReflectionMapping: zc,
      CubeUVRefractionMapping: Ou,
      CubicBezierCurve: qd,
      CubicBezierCurve3: Fd,
      CubicInterpolant: t6,
      CullFaceBack: Zm,
      CullFaceFront: w4,
      CullFaceFrontBack: lP,
      CullFaceNone: b4,
      Curve: Vi,
      CurvePath: Z5,
      CustomBlending: S4,
      CustomToneMapping: Y4,
      CylinderBufferGeometry: zs,
      CylinderGeometry: zs,
      Cylindrical: TO,
      DataTexture: Ba,
      DataTexture2DArray: Td,
      DataTexture3D: a2,
      DataTextureLoader: o6,
      DataUtils: NO,
      DecrementStencilOp: yP,
      DecrementWrapStencilOp: _P,
      DefaultLoadingManager: r6,
      DepthFormat: Po,
      DepthStencilFormat: Ua,
      DepthTexture: _0,
      DirectionalLight: L2,
      DirectionalLightHelper: IO,
      DiscreteInterpolant: n6,
      DodecahedronBufferGeometry: xc,
      DodecahedronGeometry: xc,
      DoubleSide: ls,
      DstAlphaFactor: D4,
      DstColorFactor: B4,
      DynamicBufferAttribute: eq,
      DynamicCopyUsage: BP,
      DynamicDrawUsage: yc,
      DynamicReadUsage: LP,
      EdgesGeometry: f2,
      EdgesHelper: fq,
      EllipseCurve: Gu,
      EqualDepth: U4,
      EqualStencilFunc: MP,
      EquirectangularReflectionMapping: XA,
      EquirectangularRefractionMapping: YA,
      Euler: jo,
      EventDispatcher: Ys,
      ExtrudeBufferGeometry: Nr,
      ExtrudeGeometry: Nr,
      FaceColors: GO,
      FileLoader: us,
      FlatShading: Jg,
      Float16BufferAttribute: P5,
      Float32Attribute: lq,
      Float32BufferAttribute: ut,
      Float64Attribute: cq,
      Float64BufferAttribute: L5,
      FloatType: Rs,
      Fog: zu,
      FogExp2: Uu,
      Font: Mq,
      FontLoader: wq,
      FramebufferTexture: Q5,
      FrontSide: Na,
      Frustum: Fu,
      GLBufferAttribute: x6,
      GLSL1: OP,
      GLSL3: S1,
      GreaterDepth: H4,
      GreaterEqualDepth: z4,
      GreaterEqualStencilFunc: CP,
      GreaterStencilFunc: EP,
      GridHelper: M6,
      Group: zi,
      HalfFloatType: La,
      HemisphereLight: T2,
      HemisphereLightHelper: LO,
      HemisphereLightProbe: d6,
      IcosahedronBufferGeometry: bc,
      IcosahedronGeometry: bc,
      ImageBitmapLoader: f6,
      ImageLoader: uu,
      ImageUtils: Vo,
      ImmediateRenderObject: Sq,
      IncrementStencilOp: gP,
      IncrementWrapStencilOp: vP,
      InstancedBufferAttribute: Ha,
      InstancedBufferGeometry: Wd,
      InstancedInterleavedBuffer: $d,
      InstancedMesh: c2,
      Int16Attribute: rq,
      Int16BufferAttribute: C5,
      Int32Attribute: oq,
      Int32BufferAttribute: R5,
      Int8Attribute: tq,
      Int8BufferAttribute: S5,
      IntType: K4,
      InterleavedBuffer: $o,
      InterleavedBufferAttribute: Fr,
      Interpolant: Hs,
      InterpolateDiscrete: KA,
      InterpolateLinear: eu,
      InterpolateSmooth: Wh,
      InvertStencilOp: xP,
      JSONLoader: yq,
      KeepStencilOp: jh,
      KeyframeTrack: Hr,
      LOD: j5,
      LatheBufferGeometry: wc,
      LatheGeometry: wc,
      Layers: bd,
      LensFlare: _q,
      LessDepth: N4,
      LessEqualDepth: m0,
      LessEqualStencilFunc: SP,
      LessStencilFunc: wP,
      Light: Ur,
      LightProbe: ju,
      Line: br,
      Line3: N2,
      LineBasicMaterial: Nn,
      LineCurve: Vu,
      LineCurve3: Y5,
      LineDashedMaterial: b2,
      LineLoop: A2,
      LinePieces: zO,
      LineSegments: yi,
      LineStrip: UO,
      LinearEncoding: Ns,
      LinearFilter: Mn,
      LinearInterpolant: w2,
      LinearMipMapLinearFilter: dP,
      LinearMipMapNearestFilter: hP,
      LinearMipmapLinearFilter: nl,
      LinearMipmapNearestFilter: t2,
      LinearToneMapping: j4,
      Loader: Pi,
      LoaderUtils: x0,
      LoadingManager: S2,
      LoopOnce: f5,
      LoopPingPong: d5,
      LoopRepeat: h5,
      LuminanceAlphaFormat: s5,
      LuminanceFormat: r5,
      MOUSE: ha,
      Material: ii,
      MaterialLoader: A6,
      Math: T1,
      MathUtils: T1,
      Matrix3: Zn,
      Matrix4: mt,
      MaxEquation: n1,
      Mesh: Xt,
      MeshBasicMaterial: Mr,
      MeshDepthMaterial: Rd,
      MeshDistanceMaterial: Pd,
      MeshFaceMaterial: WO,
      MeshLambertMaterial: Zs,
      MeshMatcapMaterial: x2,
      MeshNormalMaterial: _2,
      MeshPhongMaterial: Vd,
      MeshPhysicalMaterial: y2,
      MeshStandardMaterial: Gd,
      MeshToonMaterial: v2,
      MinEquation: t1,
      MirroredRepeatWrapping: JA,
      MixOperation: V4,
      MultiMaterial: jO,
      MultiplyBlending: e1,
      MultiplyOperation: ku,
      NearestFilter: On,
      NearestMipMapLinearFilter: fP,
      NearestMipMapNearestFilter: uP,
      NearestMipmapLinearFilter: y0,
      NearestMipmapNearestFilter: g0,
      NeverDepth: q4,
      NeverStencilFunc: bP,
      NoBlending: Ds,
      NoColors: HO,
      NoToneMapping: Is,
      NormalAnimationBlendMode: _d,
      NormalBlending: Ro,
      NotEqualDepth: G4,
      NotEqualStencilFunc: TP,
      NumberKeyframeTrack: lu,
      Object3D: kt,
      ObjectLoader: cO,
      ObjectSpaceNormalMap: y5,
      OctahedronBufferGeometry: Va,
      OctahedronGeometry: Va,
      OneFactor: R4,
      OneMinusDstAlphaFactor: I4,
      OneMinusDstColorFactor: k4,
      OneMinusSrcAlphaFactor: e2,
      OneMinusSrcColorFactor: L4,
      OrthographicCamera: Nu,
      PCFShadowMap: Zg,
      PCFSoftShadowMap: M4,
      PMREMGenerator: C1,
      ParametricGeometry: xq,
      Particle: QO,
      ParticleBasicMaterial: ZO,
      ParticleSystem: XO,
      ParticleSystemMaterial: JO,
      Path: ru,
      PerspectiveCamera: ei,
      Plane: Zr,
      PlaneBufferGeometry: za,
      PlaneGeometry: za,
      PlaneHelper: OO,
      PointCloud: $O,
      PointCloudMaterial: YO,
      PointLight: P2,
      PointLightHelper: RO,
      Points: Hu,
      PointsMaterial: rl,
      PolarGridHelper: DO,
      PolyhedronBufferGeometry: cs,
      PolyhedronGeometry: cs,
      PositionalAudio: pO,
      PropertyBinding: jt,
      PropertyMixer: y6,
      QuadraticBezierCurve: Nd,
      QuadraticBezierCurve3: Wu,
      Quaternion: Jn,
      QuaternionKeyframeTrack: Wc,
      QuaternionLinearInterpolant: i6,
      REVISION: yd,
      RGBADepthPacking: g5,
      RGBAFormat: Ai,
      RGBAIntegerFormat: A5,
      RGBA_ASTC_10x10_Format: _1,
      RGBA_ASTC_10x5_Format: g1,
      RGBA_ASTC_10x6_Format: y1,
      RGBA_ASTC_10x8_Format: v1,
      RGBA_ASTC_12x10_Format: x1,
      RGBA_ASTC_12x12_Format: b1,
      RGBA_ASTC_4x4_Format: c1,
      RGBA_ASTC_5x4_Format: A1,
      RGBA_ASTC_5x5_Format: u1,
      RGBA_ASTC_6x5_Format: f1,
      RGBA_ASTC_6x6_Format: h1,
      RGBA_ASTC_8x5_Format: d1,
      RGBA_ASTC_8x6_Format: p1,
      RGBA_ASTC_8x8_Format: m1,
      RGBA_BPTC_Format: w1,
      RGBA_ETC2_EAC_Format: l1,
      RGBA_PVRTC_2BPPV1_Format: o1,
      RGBA_PVRTC_4BPPV1_Format: s1,
      RGBA_S3TC_DXT1_Format: Hh,
      RGBA_S3TC_DXT3_Format: Gh,
      RGBA_S3TC_DXT5_Format: Vh,
      RGBFormat: i5,
      RGB_ETC1_Format: u5,
      RGB_ETC2_Format: a1,
      RGB_PVRTC_2BPPV1_Format: r1,
      RGB_PVRTC_4BPPV1_Format: i1,
      RGB_S3TC_DXT1_Format: zh,
      RGFormat: l5,
      RGIntegerFormat: c5,
      RawShaderMaterial: Gc,
      Ray: Wo,
      Raycaster: EO,
      RectAreaLight: I2,
      RedFormat: o5,
      RedIntegerFormat: a5,
      ReinhardToneMapping: $4,
      RepeatWrapping: ZA,
      ReplaceStencilOp: mP,
      ReverseSubtractEquation: T4,
      RingBufferGeometry: Mc,
      RingGeometry: Mc,
      Scene: Ld,
      SceneUtils: vq,
      ShaderChunk: Ot,
      ShaderLib: mr,
      ShaderMaterial: ar,
      ShadowMaterial: g2,
      Shape: ns,
      ShapeBufferGeometry: Wa,
      ShapeGeometry: Wa,
      ShapePath: T6,
      ShapeUtils: is,
      ShortType: J4,
      Skeleton: Od,
      SkeletonHelper: b6,
      SkinnedMesh: Bd,
      SmoothShading: AP,
      Sphere: ds,
      SphereBufferGeometry: As,
      SphereGeometry: As,
      Spherical: B1,
      SphericalHarmonics3: B2,
      SplineCurve: Ud,
      SpotLight: R2,
      SpotLightHelper: CO,
      Sprite: Id,
      SpriteMaterial: Dd,
      SrcAlphaFactor: Kg,
      SrcAlphaSaturateFactor: O4,
      SrcColorFactor: P4,
      StaticCopyUsage: IP,
      StaticDrawUsage: gc,
      StaticReadUsage: PP,
      StereoCamera: uO,
      StreamCopyUsage: kP,
      StreamDrawUsage: RP,
      StreamReadUsage: DP,
      StringKeyframeTrack: ol,
      SubtractEquation: E4,
      SubtractiveBlending: Km,
      TOUCH: da,
      TangentSpaceNormalMap: il,
      TetrahedronBufferGeometry: Sc,
      TetrahedronGeometry: Sc,
      TextGeometry: bq,
      Texture: Vn,
      TextureLoader: E2,
      TorusBufferGeometry: Ec,
      TorusGeometry: Ec,
      TorusKnotBufferGeometry: Tc,
      TorusKnotGeometry: Tc,
      Triangle: qn,
      TriangleFanDrawMode: M1,
      TriangleStripDrawMode: p5,
      TrianglesDrawMode: i2,
      TubeBufferGeometry: ja,
      TubeGeometry: ja,
      UVMapping: vd,
      Uint16Attribute: sq,
      Uint16BufferAttribute: wd,
      Uint32Attribute: aq,
      Uint32BufferAttribute: Md,
      Uint8Attribute: nq,
      Uint8BufferAttribute: E5,
      Uint8ClampedAttribute: iq,
      Uint8ClampedBufferAttribute: T5,
      Uniform: jd,
      UniformsLib: et,
      UniformsUtils: s2,
      UnsignedByteType: Bs,
      UnsignedInt248Type: Da,
      UnsignedIntType: BA,
      UnsignedShort4444Type: e5,
      UnsignedShort5551Type: t5,
      UnsignedShortType: mc,
      VSMShadowMap: Ul,
      Vector2: qe,
      Vector3: X,
      Vector4: en,
      VectorKeyframeTrack: cu,
      Vertex: KO,
      VertexColors: VO,
      VideoTexture: $5,
      WebGL1Renderer: V5,
      WebGLCubeRenderTarget: Ed,
      WebGLMultipleRenderTargets: M5,
      WebGLMultisampleRenderTarget: xd,
      WebGLRenderTarget: rr,
      WebGLRenderTargetCube: mq,
      WebGLRenderer: rn,
      WebGLUtils: G5,
      WireframeGeometry: Hd,
      WireframeHelper: hq,
      WrapAroundEnding: tu,
      XHRLoader: dq,
      ZeroCurvatureEnding: ba,
      ZeroFactor: C4,
      ZeroSlopeEnding: wa,
      ZeroStencilOp: pP,
      _SRGBAFormat: v0,
      sRGBEncoding: pn,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
)
const R3 = { type: "change" },
  cm = { type: "start" },
  P3 = { type: "end" }
class vj extends Ys {
  constructor(e, t) {
    super(),
      t === void 0 &&
        console.warn(
          'THREE.OrbitControls: The second parameter "domElement" is now mandatory.'
        ),
      t === document &&
        console.error(
          'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
        ),
      (this.object = e),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none"),
      (this.enabled = !0),
      (this.target = new X()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: ha.ROTATE,
        MIDDLE: ha.DOLLY,
        RIGHT: ha.PAN,
      }),
      (this.touches = { ONE: da.ROTATE, TWO: da.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return a.phi
      }),
      (this.getAzimuthalAngle = function () {
        return a.theta
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target)
      }),
      (this.listenToKeyEvents = function (se) {
        se.addEventListener("keydown", Se), (this._domElementKeyEvents = se)
      }),
      (this.saveState = function () {
        i.target0.copy(i.target),
          i.position0.copy(i.object.position),
          (i.zoom0 = i.object.zoom)
      }),
      (this.reset = function () {
        i.target.copy(i.target0),
          i.object.position.copy(i.position0),
          (i.object.zoom = i.zoom0),
          i.object.updateProjectionMatrix(),
          i.dispatchEvent(R3),
          i.update(),
          (s = r.NONE)
      }),
      (this.update = (function () {
        const se = new X(),
          be = new Jn().setFromUnitVectors(e.up, new X(0, 1, 0)),
          ze = be.clone().invert(),
          at = new X(),
          de = new Jn(),
          it = 2 * Math.PI
        return function () {
          const ft = i.object.position
          se.copy(ft).sub(i.target),
            se.applyQuaternion(be),
            a.setFromVector3(se),
            i.autoRotate && s === r.NONE && W(k()),
            i.enableDamping
              ? ((a.theta += A.theta * i.dampingFactor),
                (a.phi += A.phi * i.dampingFactor))
              : ((a.theta += A.theta), (a.phi += A.phi))
          let De = i.minAzimuthAngle,
            ht = i.maxAzimuthAngle
          return (
            isFinite(De) &&
              isFinite(ht) &&
              (De < -Math.PI ? (De += it) : De > Math.PI && (De -= it),
              ht < -Math.PI ? (ht += it) : ht > Math.PI && (ht -= it),
              De <= ht
                ? (a.theta = Math.max(De, Math.min(ht, a.theta)))
                : (a.theta =
                    a.theta > (De + ht) / 2
                      ? Math.max(De, a.theta)
                      : Math.min(ht, a.theta))),
            (a.phi = Math.max(
              i.minPolarAngle,
              Math.min(i.maxPolarAngle, a.phi)
            )),
            a.makeSafe(),
            (a.radius *= c),
            (a.radius = Math.max(
              i.minDistance,
              Math.min(i.maxDistance, a.radius)
            )),
            i.enableDamping === !0
              ? i.target.addScaledVector(d, i.dampingFactor)
              : i.target.add(d),
            se.setFromSpherical(a),
            se.applyQuaternion(ze),
            ft.copy(i.target).add(se),
            i.object.lookAt(i.target),
            i.enableDamping === !0
              ? ((A.theta *= 1 - i.dampingFactor),
                (A.phi *= 1 - i.dampingFactor),
                d.multiplyScalar(1 - i.dampingFactor))
              : (A.set(0, 0, 0), d.set(0, 0, 0)),
            (c = 1),
            p ||
            at.distanceToSquared(i.object.position) > o ||
            8 * (1 - de.dot(i.object.quaternion)) > o
              ? (i.dispatchEvent(R3),
                at.copy(i.object.position),
                de.copy(i.object.quaternion),
                (p = !1),
                !0)
              : !1
          )
        }
      })()),
      (this.dispose = function () {
        i.domElement.removeEventListener("contextmenu", pe),
          i.domElement.removeEventListener("pointerdown", q),
          i.domElement.removeEventListener("pointercancel", oe),
          i.domElement.removeEventListener("wheel", Ce),
          i.domElement.removeEventListener("pointermove", F),
          i.domElement.removeEventListener("pointerup", te),
          i._domElementKeyEvents !== null &&
            i._domElementKeyEvents.removeEventListener("keydown", Se)
      })
    const i = this,
      r = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      }
    let s = r.NONE
    const o = 1e-6,
      a = new B1(),
      A = new B1()
    let c = 1
    const d = new X()
    let p = !1
    const m = new qe(),
      y = new qe(),
      x = new qe(),
      S = new qe(),
      C = new qe(),
      M = new qe(),
      _ = new qe(),
      R = new qe(),
      T = new qe(),
      L = [],
      B = {}
    function k() {
      return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed
    }
    function O() {
      return Math.pow(0.95, i.zoomSpeed)
    }
    function W(se) {
      A.theta -= se
    }
    function z(se) {
      A.phi -= se
    }
    const P = (function () {
        const se = new X()
        return function (ze, at) {
          se.setFromMatrixColumn(at, 0), se.multiplyScalar(-ze), d.add(se)
        }
      })(),
      N = (function () {
        const se = new X()
        return function (ze, at) {
          i.screenSpacePanning === !0
            ? se.setFromMatrixColumn(at, 1)
            : (se.setFromMatrixColumn(at, 0), se.crossVectors(i.object.up, se)),
            se.multiplyScalar(ze),
            d.add(se)
        }
      })(),
      G = (function () {
        const se = new X()
        return function (ze, at) {
          const de = i.domElement
          if (i.object.isPerspectiveCamera) {
            const it = i.object.position
            se.copy(it).sub(i.target)
            let tt = se.length()
            ;(tt *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
              P((2 * ze * tt) / de.clientHeight, i.object.matrix),
              N((2 * at * tt) / de.clientHeight, i.object.matrix)
          } else
            i.object.isOrthographicCamera
              ? (P(
                  (ze * (i.object.right - i.object.left)) /
                    i.object.zoom /
                    de.clientWidth,
                  i.object.matrix
                ),
                N(
                  (at * (i.object.top - i.object.bottom)) /
                    i.object.zoom /
                    de.clientHeight,
                  i.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (i.enablePan = !1))
        }
      })()
    function j(se) {
      i.object.isPerspectiveCamera
        ? (c /= se)
        : i.object.isOrthographicCamera
        ? ((i.object.zoom = Math.max(
            i.minZoom,
            Math.min(i.maxZoom, i.object.zoom * se)
          )),
          i.object.updateProjectionMatrix(),
          (p = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1))
    }
    function V(se) {
      i.object.isPerspectiveCamera
        ? (c *= se)
        : i.object.isOrthographicCamera
        ? ((i.object.zoom = Math.max(
            i.minZoom,
            Math.min(i.maxZoom, i.object.zoom / se)
          )),
          i.object.updateProjectionMatrix(),
          (p = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1))
    }
    function Y(se) {
      m.set(se.clientX, se.clientY)
    }
    function ne(se) {
      _.set(se.clientX, se.clientY)
    }
    function le(se) {
      S.set(se.clientX, se.clientY)
    }
    function Te(se) {
      y.set(se.clientX, se.clientY),
        x.subVectors(y, m).multiplyScalar(i.rotateSpeed)
      const be = i.domElement
      W((2 * Math.PI * x.x) / be.clientHeight),
        z((2 * Math.PI * x.y) / be.clientHeight),
        m.copy(y),
        i.update()
    }
    function Ae(se) {
      R.set(se.clientX, se.clientY),
        T.subVectors(R, _),
        T.y > 0 ? j(O()) : T.y < 0 && V(O()),
        _.copy(R),
        i.update()
    }
    function ge(se) {
      C.set(se.clientX, se.clientY),
        M.subVectors(C, S).multiplyScalar(i.panSpeed),
        G(M.x, M.y),
        S.copy(C),
        i.update()
    }
    function Me(se) {
      se.deltaY < 0 ? V(O()) : se.deltaY > 0 && j(O()), i.update()
    }
    function Ne(se) {
      let be = !1
      switch (se.code) {
        case i.keys.UP:
          G(0, i.keyPanSpeed), (be = !0)
          break
        case i.keys.BOTTOM:
          G(0, -i.keyPanSpeed), (be = !0)
          break
        case i.keys.LEFT:
          G(i.keyPanSpeed, 0), (be = !0)
          break
        case i.keys.RIGHT:
          G(-i.keyPanSpeed, 0), (be = !0)
          break
      }
      be && (se.preventDefault(), i.update())
    }
    function Ze() {
      if (L.length === 1) m.set(L[0].pageX, L[0].pageY)
      else {
        const se = 0.5 * (L[0].pageX + L[1].pageX),
          be = 0.5 * (L[0].pageY + L[1].pageY)
        m.set(se, be)
      }
    }
    function K() {
      if (L.length === 1) S.set(L[0].pageX, L[0].pageY)
      else {
        const se = 0.5 * (L[0].pageX + L[1].pageX),
          be = 0.5 * (L[0].pageY + L[1].pageY)
        S.set(se, be)
      }
    }
    function Oe() {
      const se = L[0].pageX - L[1].pageX,
        be = L[0].pageY - L[1].pageY,
        ze = Math.sqrt(se * se + be * be)
      _.set(0, ze)
    }
    function ve() {
      i.enableZoom && Oe(), i.enablePan && K()
    }
    function Be() {
      i.enableZoom && Oe(), i.enableRotate && Ze()
    }
    function Fe(se) {
      if (L.length == 1) y.set(se.pageX, se.pageY)
      else {
        const ze = Xe(se),
          at = 0.5 * (se.pageX + ze.x),
          de = 0.5 * (se.pageY + ze.y)
        y.set(at, de)
      }
      x.subVectors(y, m).multiplyScalar(i.rotateSpeed)
      const be = i.domElement
      W((2 * Math.PI * x.x) / be.clientHeight),
        z((2 * Math.PI * x.y) / be.clientHeight),
        m.copy(y)
    }
    function je(se) {
      if (L.length === 1) C.set(se.pageX, se.pageY)
      else {
        const be = Xe(se),
          ze = 0.5 * (se.pageX + be.x),
          at = 0.5 * (se.pageY + be.y)
        C.set(ze, at)
      }
      M.subVectors(C, S).multiplyScalar(i.panSpeed), G(M.x, M.y), S.copy(C)
    }
    function Ge(se) {
      const be = Xe(se),
        ze = se.pageX - be.x,
        at = se.pageY - be.y,
        de = Math.sqrt(ze * ze + at * at)
      R.set(0, de),
        T.set(0, Math.pow(R.y / _.y, i.zoomSpeed)),
        j(T.y),
        _.copy(R)
    }
    function ye(se) {
      i.enableZoom && Ge(se), i.enablePan && je(se)
    }
    function D(se) {
      i.enableZoom && Ge(se), i.enableRotate && Fe(se)
    }
    function q(se) {
      i.enabled !== !1 &&
        (L.length === 0 &&
          (i.domElement.setPointerCapture(se.pointerId),
          i.domElement.addEventListener("pointermove", F),
          i.domElement.addEventListener("pointerup", te)),
        Re(se),
        se.pointerType === "touch" ? $(se) : ue(se))
    }
    function F(se) {
      i.enabled !== !1 && (se.pointerType === "touch" ? Q(se) : Ee(se))
    }
    function te(se) {
      Ue(se),
        L.length === 0 &&
          (i.domElement.releasePointerCapture(se.pointerId),
          i.domElement.removeEventListener("pointermove", F),
          i.domElement.removeEventListener("pointerup", te)),
        i.dispatchEvent(P3),
        (s = r.NONE)
    }
    function oe(se) {
      Ue(se)
    }
    function ue(se) {
      let be
      switch (se.button) {
        case 0:
          be = i.mouseButtons.LEFT
          break
        case 1:
          be = i.mouseButtons.MIDDLE
          break
        case 2:
          be = i.mouseButtons.RIGHT
          break
        default:
          be = -1
      }
      switch (be) {
        case ha.DOLLY:
          if (i.enableZoom === !1) return
          ne(se), (s = r.DOLLY)
          break
        case ha.ROTATE:
          if (se.ctrlKey || se.metaKey || se.shiftKey) {
            if (i.enablePan === !1) return
            le(se), (s = r.PAN)
          } else {
            if (i.enableRotate === !1) return
            Y(se), (s = r.ROTATE)
          }
          break
        case ha.PAN:
          if (se.ctrlKey || se.metaKey || se.shiftKey) {
            if (i.enableRotate === !1) return
            Y(se), (s = r.ROTATE)
          } else {
            if (i.enablePan === !1) return
            le(se), (s = r.PAN)
          }
          break
        default:
          s = r.NONE
      }
      s !== r.NONE && i.dispatchEvent(cm)
    }
    function Ee(se) {
      if (i.enabled !== !1)
        switch (s) {
          case r.ROTATE:
            if (i.enableRotate === !1) return
            Te(se)
            break
          case r.DOLLY:
            if (i.enableZoom === !1) return
            Ae(se)
            break
          case r.PAN:
            if (i.enablePan === !1) return
            ge(se)
            break
        }
    }
    function Ce(se) {
      i.enabled === !1 ||
        i.enableZoom === !1 ||
        s !== r.NONE ||
        (se.preventDefault(), i.dispatchEvent(cm), Me(se), i.dispatchEvent(P3))
    }
    function Se(se) {
      i.enabled === !1 || i.enablePan === !1 || Ne(se)
    }
    function $(se) {
      switch ((_e(se), L.length)) {
        case 1:
          switch (i.touches.ONE) {
            case da.ROTATE:
              if (i.enableRotate === !1) return
              Ze(), (s = r.TOUCH_ROTATE)
              break
            case da.PAN:
              if (i.enablePan === !1) return
              K(), (s = r.TOUCH_PAN)
              break
            default:
              s = r.NONE
          }
          break
        case 2:
          switch (i.touches.TWO) {
            case da.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return
              ve(), (s = r.TOUCH_DOLLY_PAN)
              break
            case da.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return
              Be(), (s = r.TOUCH_DOLLY_ROTATE)
              break
            default:
              s = r.NONE
          }
          break
        default:
          s = r.NONE
      }
      s !== r.NONE && i.dispatchEvent(cm)
    }
    function Q(se) {
      switch ((_e(se), s)) {
        case r.TOUCH_ROTATE:
          if (i.enableRotate === !1) return
          Fe(se), i.update()
          break
        case r.TOUCH_PAN:
          if (i.enablePan === !1) return
          je(se), i.update()
          break
        case r.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return
          ye(se), i.update()
          break
        case r.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return
          D(se), i.update()
          break
        default:
          s = r.NONE
      }
    }
    function pe(se) {
      i.enabled !== !1 && se.preventDefault()
    }
    function Re(se) {
      L.push(se)
    }
    function Ue(se) {
      delete B[se.pointerId]
      for (let be = 0; be < L.length; be++)
        if (L[be].pointerId == se.pointerId) {
          L.splice(be, 1)
          return
        }
    }
    function _e(se) {
      let be = B[se.pointerId]
      be === void 0 && ((be = new qe()), (B[se.pointerId] = be)),
        be.set(se.pageX, se.pageY)
    }
    function Xe(se) {
      const be = se.pointerId === L[0].pointerId ? L[1] : L[0]
      return B[be.pointerId]
    }
    i.domElement.addEventListener("contextmenu", pe),
      i.domElement.addEventListener("pointerdown", q),
      i.domElement.addEventListener("pointercancel", oe),
      i.domElement.addEventListener("wheel", Ce, { passive: !1 }),
      this.update()
  }
}
var ps = (n, e) => {
    const t = n.__vccOpts || n
    for (const [i, r] of e) t[i] = r
    return t
  },
  _j = zt("/__NUXT_BASE__/bg-about.d57f76e2.svg".replace("/__NUXT_BASE__", "")),
  xj = zt(
    "/__NUXT_BASE__/global-icon.183dd30b.svg".replace("/__NUXT_BASE__", "")
  ),
  bj = zt("/__NUXT_BASE__/mine.5270d6af.png".replace("/__NUXT_BASE__", "")),
  wj = zt(
    "/__NUXT_BASE__/short-seperater.ce4616c9.svg".replace("/__NUXT_BASE__", "")
  )
const ch = void 0
var Gs =
  typeof globalThis != "undefined"
    ? globalThis
    : typeof window != "undefined"
    ? window
    : typeof global != "undefined"
    ? global
    : typeof self != "undefined"
    ? self
    : {}
function Eq(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n
}
function Tq(n) {
  if (n.__esModule) return n
  var e = Object.defineProperty({}, "__esModule", { value: !0 })
  return (
    Object.keys(n).forEach(function (t) {
      var i = Object.getOwnPropertyDescriptor(n, t)
      Object.defineProperty(
        e,
        t,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return n[t]
              },
            }
      )
    }),
    e
  )
}
var fu = {},
  R6 = {},
  Cc = {},
  $u = {},
  Cq =
    (Gs && Gs.__awaiter) ||
    function (n, e, t, i) {
      function r(s) {
        return s instanceof t
          ? s
          : new t(function (o) {
              o(s)
            })
      }
      return new (t || (t = Promise))(function (s, o) {
        function a(d) {
          try {
            c(i.next(d))
          } catch (p) {
            o(p)
          }
        }
        function A(d) {
          try {
            c(i.throw(d))
          } catch (p) {
            o(p)
          }
        }
        function c(d) {
          d.done ? s(d.value) : r(d.value).then(a, A)
        }
        c((i = i.apply(n, e || [])).next())
      })
    },
  Rq =
    (Gs && Gs.__generator) ||
    function (n, e) {
      var t = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1]
            return s[1]
          },
          trys: [],
          ops: [],
        },
        i,
        r,
        s,
        o
      return (
        (o = { next: a(0), throw: a(1), return: a(2) }),
        typeof Symbol == "function" &&
          (o[Symbol.iterator] = function () {
            return this
          }),
        o
      )
      function a(c) {
        return function (d) {
          return A([c, d])
        }
      }
      function A(c) {
        if (i) throw new TypeError("Generator is already executing.")
        for (; t; )
          try {
            if (
              ((i = 1),
              r &&
                (s =
                  c[0] & 2
                    ? r.return
                    : c[0]
                    ? r.throw || ((s = r.return) && s.call(r), 0)
                    : r.next) &&
                !(s = s.call(r, c[1])).done)
            )
              return s
            switch (((r = 0), s && (c = [c[0] & 2, s.value]), c[0])) {
              case 0:
              case 1:
                s = c
                break
              case 4:
                return t.label++, { value: c[1], done: !1 }
              case 5:
                t.label++, (r = c[1]), (c = [0])
                continue
              case 7:
                ;(c = t.ops.pop()), t.trys.pop()
                continue
              default:
                if (
                  ((s = t.trys),
                  !(s = s.length > 0 && s[s.length - 1]) &&
                    (c[0] === 6 || c[0] === 2))
                ) {
                  t = 0
                  continue
                }
                if (c[0] === 3 && (!s || (c[1] > s[0] && c[1] < s[3]))) {
                  t.label = c[1]
                  break
                }
                if (c[0] === 6 && t.label < s[1]) {
                  ;(t.label = s[1]), (s = c)
                  break
                }
                if (s && t.label < s[2]) {
                  ;(t.label = s[2]), t.ops.push(c)
                  break
                }
                s[2] && t.ops.pop(), t.trys.pop()
                continue
            }
            c = e.call(n, t)
          } catch (d) {
            ;(c = [6, d]), (r = 0)
          } finally {
            i = s = 0
          }
        if (c[0] & 5) throw c[1]
        return { value: c[0] ? c[1] : void 0, done: !0 }
      }
    }
Object.defineProperty($u, "__esModule", { value: !0 })
$u.ReCaptchaInstance = void 0
var Pq = (function () {
  function n(e, t, i) {
    ;(this.siteKey = e),
      (this.recaptchaID = t),
      (this.recaptcha = i),
      (this.styleContainer = null)
  }
  return (
    (n.prototype.execute = function (e) {
      return Cq(this, void 0, void 0, function () {
        return Rq(this, function (t) {
          return [
            2,
            this.recaptcha.enterprise
              ? this.recaptcha.enterprise.execute(this.recaptchaID, {
                  action: e,
                })
              : this.recaptcha.execute(this.recaptchaID, { action: e }),
          ]
        })
      })
    }),
    (n.prototype.getSiteKey = function () {
      return this.siteKey
    }),
    (n.prototype.hideBadge = function () {
      this.styleContainer === null &&
        ((this.styleContainer = document.createElement("style")),
        (this.styleContainer.innerHTML =
          ".grecaptcha-badge{visibility:hidden !important;}"),
        document.head.appendChild(this.styleContainer))
    }),
    (n.prototype.showBadge = function () {
      this.styleContainer !== null &&
        (document.head.removeChild(this.styleContainer),
        (this.styleContainer = null))
    }),
    n
  )
})()
$u.ReCaptchaInstance = Pq
Object.defineProperty(Cc, "__esModule", { value: !0 })
Cc.getInstance = Cc.load = void 0
var Lq = $u,
  So
;(function (n) {
  ;(n[(n.NOT_LOADED = 0)] = "NOT_LOADED"),
    (n[(n.LOADING = 1)] = "LOADING"),
    (n[(n.LOADED = 2)] = "LOADED")
})(So || (So = {}))
var P6 = (function () {
  function n() {}
  return (
    (n.load = function (e, t) {
      if ((t === void 0 && (t = {}), typeof document == "undefined"))
        return Promise.reject(new Error("This is a library for the browser!"))
      if (n.getLoadingState() === So.LOADED)
        return n.instance.getSiteKey() === e
          ? Promise.resolve(n.instance)
          : Promise.reject(
              new Error("reCAPTCHA already loaded with different site key!")
            )
      if (n.getLoadingState() === So.LOADING)
        return e !== n.instanceSiteKey
          ? Promise.reject(
              new Error("reCAPTCHA already loaded with different site key!")
            )
          : new Promise(function (r, s) {
              n.successfulLoadingConsumers.push(function (o) {
                return r(o)
              }),
                n.errorLoadingRunnable.push(function (o) {
                  return s(o)
                })
            })
      ;(n.instanceSiteKey = e), n.setLoadingState(So.LOADING)
      var i = new n()
      return new Promise(function (r, s) {
        i.loadScript(
          e,
          t.useRecaptchaNet || !1,
          t.useEnterprise || !1,
          t.renderParameters ? t.renderParameters : {},
          t.customUrl
        )
          .then(function () {
            n.setLoadingState(So.LOADED)
            var o = i.doExplicitRender(
                grecaptcha,
                e,
                t.explicitRenderParameters ? t.explicitRenderParameters : {},
                t.useEnterprise || !1
              ),
              a = new Lq.ReCaptchaInstance(e, o, grecaptcha)
            n.successfulLoadingConsumers.forEach(function (A) {
              return A(a)
            }),
              (n.successfulLoadingConsumers = []),
              t.autoHideBadge && a.hideBadge(),
              (n.instance = a),
              r(a)
          })
          .catch(function (o) {
            n.errorLoadingRunnable.forEach(function (a) {
              return a(o)
            }),
              (n.errorLoadingRunnable = []),
              s(o)
          })
      })
    }),
    (n.getInstance = function () {
      return n.instance
    }),
    (n.setLoadingState = function (e) {
      n.loadingState = e
    }),
    (n.getLoadingState = function () {
      return n.loadingState === null ? So.NOT_LOADED : n.loadingState
    }),
    (n.prototype.loadScript = function (e, t, i, r, s) {
      var o = this
      t === void 0 && (t = !1),
        i === void 0 && (i = !1),
        r === void 0 && (r = {}),
        s === void 0 && (s = "")
      var a = document.createElement("script")
      a.setAttribute("recaptcha-v3-script", "")
      var A = "https://www.google.com/recaptcha/api.js"
      t &&
        (i
          ? (A = "https://recaptcha.net/recaptcha/enterprise.js")
          : (A = "https://recaptcha.net/recaptcha/api.js")),
        i && (A = "https://www.google.com/recaptcha/enterprise.js"),
        s && (A = s),
        r.render && (r.render = void 0)
      var c = this.buildQueryString(r)
      return (
        (a.src = A + "?render=explicit" + c),
        new Promise(function (d, p) {
          a.addEventListener(
            "load",
            o.waitForScriptToLoad(function () {
              d(a)
            }, i),
            !1
          ),
            (a.onerror = function (m) {
              n.setLoadingState(So.NOT_LOADED), p(m)
            }),
            document.head.appendChild(a)
        })
      )
    }),
    (n.prototype.buildQueryString = function (e) {
      var t = Object.keys(e)
      return t.length < 1
        ? ""
        : "&" +
            Object.keys(e)
              .filter(function (i) {
                return !!e[i]
              })
              .map(function (i) {
                return i + "=" + e[i]
              })
              .join("&")
    }),
    (n.prototype.waitForScriptToLoad = function (e, t) {
      var i = this
      return function () {
        window.grecaptcha === void 0
          ? setTimeout(function () {
              i.waitForScriptToLoad(e, t)
            }, n.SCRIPT_LOAD_DELAY)
          : t
          ? window.grecaptcha.enterprise.ready(function () {
              e()
            })
          : window.grecaptcha.ready(function () {
              e()
            })
      }
    }),
    (n.prototype.doExplicitRender = function (e, t, i, r) {
      var s = { sitekey: t, badge: i.badge, size: i.size, tabindex: i.tabindex }
      return i.container
        ? r
          ? e.enterprise.render(i.container, s)
          : e.render(i.container, s)
        : r
        ? e.enterprise.render(s)
        : e.render(s)
    }),
    (n.loadingState = null),
    (n.instance = null),
    (n.instanceSiteKey = null),
    (n.successfulLoadingConsumers = []),
    (n.errorLoadingRunnable = []),
    (n.SCRIPT_LOAD_DELAY = 25),
    n
  )
})()
Cc.load = P6.load
Cc.getInstance = P6.getInstance
;(function (n) {
  Object.defineProperty(n, "__esModule", { value: !0 }),
    (n.ReCaptchaInstance = n.getInstance = n.load = void 0)
  var e = Cc
  Object.defineProperty(n, "load", {
    enumerable: !0,
    get: function () {
      return e.load
    },
  }),
    Object.defineProperty(n, "getInstance", {
      enumerable: !0,
      get: function () {
        return e.getInstance
      },
    })
  var t = $u
  Object.defineProperty(n, "ReCaptchaInstance", {
    enumerable: !0,
    get: function () {
      return t.ReCaptchaInstance
    },
  })
})(R6)
var Dq = Tq(s9),
  L6 =
    (Gs && Gs.__awaiter) ||
    function (n, e, t, i) {
      function r(s) {
        return s instanceof t
          ? s
          : new t(function (o) {
              o(s)
            })
      }
      return new (t || (t = Promise))(function (s, o) {
        function a(d) {
          try {
            c(i.next(d))
          } catch (p) {
            o(p)
          }
        }
        function A(d) {
          try {
            c(i.throw(d))
          } catch (p) {
            o(p)
          }
        }
        function c(d) {
          d.done ? s(d.value) : r(d.value).then(a, A)
        }
        c((i = i.apply(n, e || [])).next())
      })
    },
  D6 =
    (Gs && Gs.__generator) ||
    function (n, e) {
      var t = {
          label: 0,
          sent: function () {
            if (s[0] & 1) throw s[1]
            return s[1]
          },
          trys: [],
          ops: [],
        },
        i,
        r,
        s,
        o
      return (
        (o = { next: a(0), throw: a(1), return: a(2) }),
        typeof Symbol == "function" &&
          (o[Symbol.iterator] = function () {
            return this
          }),
        o
      )
      function a(c) {
        return function (d) {
          return A([c, d])
        }
      }
      function A(c) {
        if (i) throw new TypeError("Generator is already executing.")
        for (; t; )
          try {
            if (
              ((i = 1),
              r &&
                (s =
                  c[0] & 2
                    ? r.return
                    : c[0]
                    ? r.throw || ((s = r.return) && s.call(r), 0)
                    : r.next) &&
                !(s = s.call(r, c[1])).done)
            )
              return s
            switch (((r = 0), s && (c = [c[0] & 2, s.value]), c[0])) {
              case 0:
              case 1:
                s = c
                break
              case 4:
                return t.label++, { value: c[1], done: !1 }
              case 5:
                t.label++, (r = c[1]), (c = [0])
                continue
              case 7:
                ;(c = t.ops.pop()), t.trys.pop()
                continue
              default:
                if (
                  ((s = t.trys),
                  !(s = s.length > 0 && s[s.length - 1]) &&
                    (c[0] === 6 || c[0] === 2))
                ) {
                  t = 0
                  continue
                }
                if (c[0] === 3 && (!s || (c[1] > s[0] && c[1] < s[3]))) {
                  t.label = c[1]
                  break
                }
                if (c[0] === 6 && t.label < s[1]) {
                  ;(t.label = s[1]), (s = c)
                  break
                }
                if (s && t.label < s[2]) {
                  ;(t.label = s[2]), t.ops.push(c)
                  break
                }
                s[2] && t.ops.pop(), t.trys.pop()
                continue
            }
            c = e.call(n, t)
          } catch (d) {
            ;(c = [6, d]), (r = 0)
          } finally {
            i = s = 0
          }
        if (c[0] & 5) throw c[1]
        return { value: c[0] ? c[1] : void 0, done: !0 }
      }
    }
Object.defineProperty(fu, "__esModule", { value: !0 })
var Iq = (fu.useReCaptcha = kq = fu.VueReCaptcha = void 0),
  Bq = R6,
  k1 = Dq,
  I6 = Symbol("VueReCaptchaInjectKey"),
  ic = { loadedWaiters: [], error: null },
  kq = (fu.VueReCaptcha = {
    install: function (n, e) {
      var t = k1.ref(!1),
        i = k1.ref(void 0)
      ;(n.config.globalProperties.$recaptchaLoaded = L3(t)),
        qq(e)
          .then(function (r) {
            ;(t.value = !0),
              (i.value = r),
              (n.config.globalProperties.$recaptcha = D3(i)),
              (n.config.globalProperties.$recaptchaInstance = i),
              ic.loadedWaiters.forEach(function (s) {
                return s.resolve(!0)
              })
          })
          .catch(function (r) {
            ;(ic.error = r),
              ic.loadedWaiters.forEach(function (s) {
                return s.reject(r)
              })
          }),
        n.provide(I6, {
          instance: i,
          isLoaded: t,
          executeRecaptcha: D3(i),
          recaptchaLoaded: L3(t),
        })
    },
  })
function Oq() {
  return k1.inject(I6)
}
Iq = fu.useReCaptcha = Oq
function qq(n) {
  return L6(this, void 0, void 0, function () {
    return D6(this, function (e) {
      switch (e.label) {
        case 0:
          return [4, Bq.load(n.siteKey, n.loaderOptions)]
        case 1:
          return [2, e.sent()]
      }
    })
  })
}
function L3(n) {
  return function () {
    return new Promise(function (e, t) {
      if (ic.error !== null) return t(ic.error)
      if (n.value) return e(!0)
      ic.loadedWaiters.push({ resolve: e, reject: t })
    })
  }
}
function D3(n) {
  var e = this
  return function (t) {
    return L6(e, void 0, void 0, function () {
      var i
      return D6(this, function (r) {
        switch (r.label) {
          case 0:
            return [
              4,
              (i = n.value) === null || i === void 0 ? void 0 : i.execute(t),
            ]
          case 1:
            return [2, r.sent()]
        }
      })
    })
  }
}
var Fq = Object.defineProperty,
  Nq = Object.defineProperties,
  Uq = Object.getOwnPropertyDescriptors,
  I3 = Object.getOwnPropertySymbols,
  zq = Object.prototype.hasOwnProperty,
  Hq = Object.prototype.propertyIsEnumerable,
  B3 = (n, e, t) =>
    e in n
      ? Fq(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  Yr = (n, e) => {
    for (var t in e || (e = {})) zq.call(e, t) && B3(n, t, e[t])
    if (I3) for (var t of I3(e)) Hq.call(e, t) && B3(n, t, e[t])
    return n
  },
  U2 = (n, e) => Nq(n, Uq(e))
const _A = {
  type: "default",
  timeout: 5e3,
  showCloseButton: !0,
  position: "top-right",
  transition: "bounce",
  hideProgressBar: !1,
  swipeClose: !0,
}
var ka, go
;((go = ka || (ka = {}))[(go.TITLE_ONLY = 0)] = "TITLE_ONLY"),
  (go[(go.TITLE_DESCRIPTION = 1)] = "TITLE_DESCRIPTION"),
  (go[(go.COMPONENT = 2)] = "COMPONENT"),
  (go[(go.VNODE = 3)] = "VNODE")
const Gq = {
    "top-left": {
      bounce: "mosha__bounceInLeft",
      zoom: "mosha__zoomIn",
      slide: "mosha__slideInLeft",
    },
    "top-right": {
      bounce: "mosha__bounceInRight",
      zoom: "mosha__zoomIn",
      slide: "mosha__slideInRight",
    },
    "top-center": {
      bounce: "mosha__bounceInDown",
      zoom: "mosha__zoomIn",
      slide: "mosha__slideInDown",
    },
    "bottom-center": {
      bounce: "mosha__bounceInUp",
      zoom: "mosha__zoomIn",
      slide: "mosha__slideInUp",
    },
    "bottom-right": {
      bounce: "mosha__bounceInRight",
      zoom: "mosha__zoomIn",
      slide: "mosha__slideInRight",
    },
    "bottom-left": {
      bounce: "mosha__bounceInLeft",
      zoom: "mosha__zoomIn",
      slide: "mosha__slideInLeft",
    },
  },
  k3 = (n, e = 300) => {
    let t
    return (...i) => {
      t && (clearTimeout(t), (t = void 0)), (t = setTimeout(() => n(...i), e))
    }
  },
  Vq = (n, e, t) => {
    const i = $n(),
      r = $n(void 0),
      s = $n(),
      o = c => c instanceof MouseEvent,
      a = c => {
        t !== !1 &&
          i.value &&
          (o(c)
            ? (r.value = i.value.clientX - c.clientX)
            : (r.value = i.value.touches[0].clientX - c.touches[0].clientX),
          (s.value = U2(Yr({}, s.value), { transition: "none" })),
          n.endsWith("left")
            ? (s.value.left = -r.value + "px !important")
            : n.endsWith("right")
            ? (s.value.right = `${r.value}px !important`)
            : r.value > 0
            ? (s.value.left = -r.value + "px !important")
            : (s.value.right = `${r.value}px !important`),
          Math.abs(r.value) > 200 && e())
      },
      A = c => {
        t !== !1 &&
          (i.value && (i.value = void 0),
          r.value && (r.value = void 0),
          removeEventListener(c, a))
      }
    return (
      Oo(() => {
        t !== !1 && (A("mousemove"), A("touchmove"))
      }),
      {
        swipedDiff: r,
        swipeStart: i,
        swipeStyle: s,
        swipeHandler: a,
        startSwipeHandler: c => {
          if (t === !1) return
          i.value = c
          const d = o(c) ? "mousemove" : "touchmove",
            p = o(c) ? "mouseup" : "touchend"
          addEventListener(d, a),
            addEventListener(p, () =>
              (m => {
                const y = { transition: "left .3s ease-out", left: 0 },
                  x = { transition: "right .3s ease-out", right: 0 },
                  S = { transition: "all .3s ease-out", left: 0, right: 0 }
                n.endsWith("left")
                  ? (s.value = Yr(Yr({}, s.value), y))
                  : n.endsWith("right")
                  ? (s.value = Yr(Yr({}, s.value), x))
                  : (s.value = Yr(Yr({}, s.value), S)),
                  (i.value = void 0),
                  (r.value = void 0),
                  removeEventListener(m, a)
              })(d)
            )
        },
        cleanUpMove: A,
      }
    )
  }
var B6 = ni({ props: { type: { type: String, default: "default" } } })
const Wq = { class: "mosha__icon" },
  jq = {
    key: 0,
    xmlns: "http://www.w3.org/2000/svg",
    height: "32px",
    viewBox: "0 0 24 24",
    width: "32px",
    fill: "#ffffff",
  },
  $q = At(
    "path",
    {
      d: "M4.47 21h15.06c1.54 0 2.5-1.67 1.73-3L13.73 4.99c-.77-1.33-2.69-1.33-3.46 0L2.74 18c-.77 1.33.19 3 1.73 3zM12 14c-.55 0-1-.45-1-1v-2c0-.55.45-1 1-1s1 .45 1 1v2c0 .55-.45 1-1 1zm1 4h-2v-2h2v2z",
    },
    null,
    -1
  ),
  Qq = {
    key: 1,
    xmlns: "http://www.w3.org/2000/svg",
    height: "32px",
    viewBox: "0 0 24 24",
    width: "32px",
    fill: "#ffffff",
  },
  Xq = At(
    "path",
    {
      d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 11c-.55 0-1-.45-1-1V8c0-.55.45-1 1-1s1 .45 1 1v4c0 .55-.45 1-1 1zm1 4h-2v-2h2v2z",
    },
    null,
    -1
  ),
  Yq = {
    key: 2,
    xmlns: "http://www.w3.org/2000/svg",
    height: "32px",
    viewBox: "0 0 24 24",
    width: "32px",
    fill: "#ffffff",
  },
  Zq = At("path", { d: "M0 0h24v24H0V0z", fill: "none" }, null, -1),
  Jq = At(
    "path",
    {
      d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM9.29 16.29L5.7 12.7c-.39-.39-.39-1.02 0-1.41.39-.39 1.02-.39 1.41 0L10 14.17l6.88-6.88c.39-.39 1.02-.39 1.41 0 .39.39.39 1.02 0 1.41l-7.59 7.59c-.38.39-1.02.39-1.41 0z",
    },
    null,
    -1
  ),
  Kq = {
    key: 3,
    xmlns: "http://www.w3.org/2000/svg",
    height: "32px",
    viewBox: "0 0 24 24",
    width: "32px",
    fill: "#616161",
  },
  eF = At("path", { d: "M0 0h24v24H0z", fill: "none" }, null, -1),
  tF = At(
    "path",
    {
      d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z",
    },
    null,
    -1
  ),
  nF = {
    key: 4,
    xmlns: "http://www.w3.org/2000/svg",
    height: "32px",
    viewBox: "0 0 24 24",
    width: "32px",
    fill: "#ffffff",
  },
  iF = At("path", { d: "M0 0h24v24H0z", fill: "none" }, null, -1),
  rF = At(
    "path",
    {
      d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z",
    },
    null,
    -1
  )
B6.render = function (n, e, t, i, r, s) {
  return (
    It(),
    Kt("span", Wq, [
      n.type === "warning"
        ? (It(), Kt("svg", jq, [$q]))
        : n.type === "danger"
        ? (It(), Kt("svg", Qq, [Xq]))
        : n.type === "success"
        ? (It(), Kt("svg", Yq, [Zq, Jq]))
        : n.type === "default"
        ? (It(), Kt("svg", Kq, [eF, tF]))
        : (It(), Kt("svg", nF, [iF, rF])),
    ])
  )
}
var $h = ni({
  name: "MToast",
  components: { MIcon: B6 },
  props: {
    visible: Boolean,
    text: { type: String, default: "" },
    description: { type: String, default: "" },
    toastBackgroundColor: { type: String, default: "" },
    type: { type: String, default: "default" },
    onClose: { type: Function, default: () => null },
    onCloseHandler: { type: Function, required: !0 },
    offset: { type: Number, required: !0 },
    id: { type: Number, required: !0 },
    timeout: { type: Number, default: 5e3 },
    position: { type: String, required: !0 },
    showCloseButton: { type: Boolean, default: !0 },
    swipeClose: { type: Boolean, default: !0 },
    hideProgressBar: { type: Boolean, default: !1 },
    showIcon: { type: Boolean, default: !1 },
    transition: { type: String, default: "bounce" },
  },
  setup(n, e) {
    const t = $n(),
      { width: i } = (() => {
        const _ = $n(-1),
          R = $n(-1),
          T = L => {
            L !== null &&
              L.currentTarget !== null &&
              ((_.value = L.currentTarget.innerWidth),
              (R.value = L.currentTarget.innerHeight))
          }
        return (
          Ls(() => {
            window.innerWidth > 0 &&
              ((_.value = window.innerWidth), (R.value = window.innerHeight)),
              window.addEventListener("resize", k3(T))
          }),
          Oo(() => {
            window.removeEventListener("resize", k3(T))
          }),
          { width: _, height: R }
        )
      })(),
      {
        swipedDiff: r,
        startSwipeHandler: s,
        swipeStyle: o,
        cleanUpMove: a,
      } = Vq(n.position, n.onCloseHandler, n.swipeClose),
      { transitionType: A } =
        ((c = n.position),
        (d = n.transition),
        (p = r),
        {
          transitionType: _n(() =>
            p.value > 200
              ? "mosha__fadeOutLeft"
              : p.value < -200
              ? "mosha__fadeOutRight"
              : Gq[c][d]
          ),
        })
    var c, d, p
    const {
        start: m,
        stop: y,
        progress: x,
      } = ((_, R) => {
        const T = $n(),
          L = $n(0),
          B = $n(R),
          k = $n(),
          O = $n(100),
          W = () => {
            clearInterval(k.value), clearTimeout(T.value)
          }
        return (
          Ls(() => {}),
          Oo(() => {
            W()
          }),
          {
            start: () => {
              ;(L.value = Date.now()),
                clearTimeout(T.value),
                (k.value = setInterval(() => {
                  O.value--
                }, R / 100 - 5)),
                (T.value = setTimeout(_, B.value))
            },
            stop: () => {
              clearInterval(k.value),
                clearTimeout(T.value),
                (B.value -= Date.now() - L.value)
            },
            clear: W,
            progress: O,
          }
        )
      })(() => {
        n.onCloseHandler()
      }, n.timeout),
      S = _n(() => e.slots.default),
      C = _n(() => /<\/?[a-z][\s\S]*>/i.test(n.description)),
      M = () => {
        n.timeout > 0 && m()
      }
    return (
      s0(() => {
        const { customStyle: _ } = ((R, T, L) => {
          const B = _n(() => {
            switch (R) {
              case "top-left":
                return { left: "0", top: `${T}px` }
              case "bottom-left":
                return { left: "0", bottom: `${T}px` }
              case "bottom-right":
                return { right: "0", bottom: `${T}px` }
              case "top-center":
                return {
                  top: `${T}px`,
                  left: "0",
                  right: "0",
                  marginRight: "auto",
                  marginLeft: "auto",
                }
              case "bottom-center":
                return {
                  bottom: `${T}px`,
                  left: "0",
                  right: "0",
                  marginRight: "auto",
                  marginLeft: "auto",
                }
              default:
                return { right: "0", top: `${T}px` }
            }
          })
          return (
            L.length > 0 && (B.value.backgroundColor = L), { customStyle: B }
          )
        })(n.position, n.offset, n.toastBackgroundColor)
        t.value = _.value
      }),
      Ls(() => {
        M()
      }),
      {
        style: t,
        transitionType: A,
        startTimer: M,
        progress: x,
        onTouchStart: _ => {
          s(_)
        },
        onMouseLeave: () => {
          a("mousemove"), M()
        },
        onMouseDown: _ => {
          s(_)
        },
        swipeStyle: o,
        isSlotPassed: S,
        isDescriptionHtml: C,
        onMouseEnter: () => {
          n.timeout > 0 && i.value > 425 && y()
        },
      }
    )
  },
})
const sF = { class: "mosha__toast__content-wrapper" },
  oF = { class: "mosha__toast__content" },
  aF = { class: "mosha__toast__content__text" },
  lF = { key: 1, class: "mosha__toast__content__description" },
  cF = { key: 0, class: "mosha__toast__slot-wrapper" }
$h.render = function (n, e, t, i, r, s) {
  const o = Bu("MIcon")
  return (
    It(),
    Kt(
      Fc,
      { name: n.transitionType, type: "animation" },
      {
        default: Xn(() => [
          n.visible
            ? (It(),
              Kt(
                "div",
                {
                  key: 0,
                  class: [
                    "mosha__toast",
                    n.toastBackgroundColor ? null : n.type,
                  ],
                  style: [n.style, n.swipeStyle],
                  onMouseenter:
                    e[2] ||
                    (e[2] = (...a) => n.onMouseEnter && n.onMouseEnter(...a)),
                  onMouseleave:
                    e[3] ||
                    (e[3] = (...a) => n.onMouseLeave && n.onMouseLeave(...a)),
                  onTouchstartPassive:
                    e[4] ||
                    (e[4] = (...a) => n.onTouchStart && n.onTouchStart(...a)),
                  onMousedown:
                    e[5] ||
                    (e[5] = (...a) => n.onMouseDown && n.onMouseDown(...a)),
                },
                [
                  At("div", sF, [
                    n.showIcon
                      ? (It(),
                        Kt(o, { key: 0, type: n.type }, null, 8, ["type"]))
                      : Ss("", !0),
                    At("div", oF, [
                      At("div", aF, vr(n.text), 1),
                      n.description.length > 0 && n.isDescriptionHtml
                        ? (It(),
                          Kt(
                            "div",
                            {
                              key: 0,
                              class: "mosha__toast__content__description",
                              innerHTML: n.description,
                            },
                            null,
                            8,
                            ["innerHTML"]
                          ))
                        : Ss("", !0),
                      n.description.length > 0 && !n.isDescriptionHtml
                        ? (It(), Kt("div", lF, vr(n.description), 1))
                        : Ss("", !0),
                    ]),
                  ]),
                  n.isSlotPassed
                    ? (It(), Kt("div", cF, [rw(n.$slots, "default")]))
                    : Ss("", !0),
                  n.showCloseButton
                    ? (It(),
                      Kt("div", {
                        key: 1,
                        class: "mosha__toast__close-icon",
                        onClick:
                          e[1] ||
                          (e[1] = (...a) =>
                            n.onCloseHandler && n.onCloseHandler(...a)),
                      }))
                    : Ss("", !0),
                  n.hideProgressBar
                    ? Ss("", !0)
                    : (It(),
                      Kt(
                        "div",
                        {
                          key: 2,
                          class: "mosha__toast__progress",
                          style: { width: `${n.progress}%` },
                        },
                        null,
                        4
                      )),
                ],
                38
              ))
            : Ss("", !0),
        ]),
        _: 3,
      },
      8,
      ["name"]
    )
  )
}
const b0 = {
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  "bottom-right": [],
  "top-center": [],
  "bottom-center": [],
}
let AF = 0
const Mj = (n, e) => {
    const t = AF++,
      i = e ? uF(e) : _A
    if (n.__v_isVNode)
      return Am(t, ka.VNODE, i, n), { close: () => rc(t, i.position) }
    if (n.hasOwnProperty("render"))
      return Am(t, ka.COMPONENT, i, n), { close: () => rc(t, i.position) }
    const r = fF(n)
    return Am(t, ka.TITLE_DESCRIPTION, i, r), { close: () => rc(t, i.position) }
  },
  Am = (n, e, t, i) => {
    setTimeout(() => {
      const r = hF(t, b0, 12),
        s = document.createElement("div")
      let o
      document.body.appendChild(s),
        (o =
          e === ka.VNODE
            ? At($h, um(t, n, r, rc), () => [i])
            : e === ka.TITLE_DESCRIPTION
            ? At($h, um(t, n, r, rc, i))
            : At($h, um(t, n, r, rc), () => [At(i)])),
        jA(o, s),
        b0[t.position].push({ toastVNode: o, container: s }),
        o.component && (o.component.props.visible = !0)
    }, 1)
  },
  um = (n, e, t, i, r) =>
    U2(Yr(Yr({}, n), r), {
      id: e,
      offset: t,
      visible: !1,
      onCloseHandler: () => {
        i(e, n.position ? n.position : "top-right")
      },
    }),
  uF = n => {
    const e = U2(Yr({}, n), {
      type: n.type || _A.type,
      timeout: n.timeout || _A.timeout,
      showCloseButton: n.showCloseButton,
      position: n.position || _A.position,
      showIcon: n.showIcon,
      swipeClose: n.swipeClose,
      transition: n.transition || _A.transition,
    })
    return (
      (e.hideProgressBar = e.timeout !== void 0 && e.timeout <= 0),
      n.hideProgressBar !== void 0 && (e.hideProgressBar = n.hideProgressBar),
      e
    )
  },
  fF = n => ({
    text: typeof n == "string" ? n : n.title,
    description: typeof n == "string" ? void 0 : n.description,
  }),
  hF = (n, e, t) => {
    let i = t
    if (!n.position) throw new Error("no position")
    return (
      e[n.position].forEach(({ toastVNode: r }) => {
        i += r.el.offsetHeight + t || 0
      }),
      i
    )
  },
  rc = (n, e) => {
    const t = b0[e],
      i = t.findIndex(({ toastVNode: a }) => a.props && n === a.props.id)
    if (i === -1) return
    const { container: r, toastVNode: s } = t[i]
    if (!s.el) return
    const o = s.el.offsetHeight
    b0[e].splice(i, 1),
      ((a, A, c, d) => {
        for (let p = a; p < A.length; p++) {
          const { toastVNode: m } = A[p]
          if (!m.el) return
          const y = c.split("-")[0] || "top",
            x = parseInt(m.el.style[y], 10) - d - 12
          if (!m.component) return
          m.component.props.offset = x
        }
      })(i, t, e, o),
      s.component &&
        ((s.component.props.visible = !1),
        s.component.props.onClose && s.component.props.onClose(),
        setTimeout(() => {
          jA(null, r), document.body.removeChild(r)
        }, 1e3))
  }
var Sj = zt(
  "/__NUXT_BASE__/bg-back-map.dfd58379.jpg".replace("/__NUXT_BASE__", "")
)
const Ah = void 0,
  uh = void 0
var Ej = zt(
  "/__NUXT_BASE__/heliumtrack-logo.a20f11b6.png".replace("/__NUXT_BASE__", "")
)
const fh = void 0
var Tj = zt("/__NUXT_BASE__/graph1.7d9383c1.svg".replace("/__NUXT_BASE__", "")),
  Cj = zt("/__NUXT_BASE__/scale.0aeece47.png".replace("/__NUXT_BASE__", "")),
  Rj = zt("/__NUXT_BASE__/graph2.be2de5ca.svg".replace("/__NUXT_BASE__", ""))
const hh = void 0
var Pj = zt("/__NUXT_BASE__/fastco.89271404.png".replace("/__NUXT_BASE__", "")),
  Lj = zt("/__NUXT_BASE__/forbes.9d6d06b4.png".replace("/__NUXT_BASE__", "")),
  Dj = zt("/__NUXT_BASE__/coindesk.31a33949.png".replace("/__NUXT_BASE__", "")),
  Ij = zt("/__NUXT_BASE__/decrypt.2d54af88.png".replace("/__NUXT_BASE__", "")),
  Bj = zt(
    "/__NUXT_BASE__/join-for-free.e9cd1718.svg".replace("/__NUXT_BASE__", "")
  ),
  kj = zt(
    "/__NUXT_BASE__/commission.74b54b04.svg".replace("/__NUXT_BASE__", "")
  ),
  Oj = zt(
    "/__NUXT_BASE__/powerful-coded.bd4488ae.svg".replace("/__NUXT_BASE__", "")
  ),
  qj = zt("/__NUXT_BASE__/plug-in.5917e705.svg".replace("/__NUXT_BASE__", "")),
  Fj = zt(
    "/__NUXT_BASE__/videostart.5552bcb6.jpg".replace("/__NUXT_BASE__", "")
  )
var Nj = zt(
    "/__NUXT_BASE__/explorer-bg.f0b99834.jpg".replace("/__NUXT_BASE__", "")
  ),
  Uj = zt(
    "/__NUXT_BASE__/explorer-icon.1f5b7678.svg".replace("/__NUXT_BASE__", "")
  ),
  zj = zt(
    "/__NUXT_BASE__/mine-city-bg.05124918.jpg".replace("/__NUXT_BASE__", "")
  ),
  Hj = zt("/__NUXT_BASE__/mine-bg.f58be730.svg".replace("/__NUXT_BASE__", "")),
  Gj = zt("/__NUXT_BASE__/rak.e78d0100.svg".replace("/__NUXT_BASE__", "")),
  Vj = zt("/__NUXT_BASE__/nebra.4fc52192.svg".replace("/__NUXT_BASE__", "")),
  Wj = zt("/__NUXT_BASE__/calchip.168948f7.svg".replace("/__NUXT_BASE__", "")),
  jj = zt("/__NUXT_BASE__/bobcat.c74d060e.svg".replace("/__NUXT_BASE__", "")),
  $j = zt(
    "/__NUXT_BASE__/globa-filler.d3be88ab.svg".replace("/__NUXT_BASE__", "")
  )
const dh = void 0
var Qj = zt(
  "/__NUXT_BASE__/the-orignal.5ef7590e.png".replace("/__NUXT_BASE__", "")
)
const ph = void 0,
  mh = { middleware: "redirect-to-panel-with-token" },
  gh = void 0,
  yh = void 0,
  vh = { middleware: "redirect-to-panel-with-ref" }
var dF = [
  {
    name: "affiliate",
    path: "/affiliate",
    file: "/app/pages/affiliate.vue",
    children: [],
    meta: ch,
    alias: (ch == null ? void 0 : ch.alias) || [],
    component: () =>
      Qi(
        () => import("./affiliate-974eff6c.mjs"),
        ["affiliate-974eff6c.mjs", "HeliumGlobe-a4e8cc3d.mjs"]
      ),
  },
  {
    name: "contact",
    path: "/contact",
    file: "/app/pages/contact.vue",
    children: [],
    meta: Ah,
    alias: (Ah == null ? void 0 : Ah.alias) || [],
    component: () => Qi(() => import("./contact-80c67f21.mjs"), []),
  },
  {
    name: "explorer",
    path: "/explorer",
    file: "/app/pages/explorer.vue",
    children: [],
    meta: uh,
    alias: (uh == null ? void 0 : uh.alias) || [],
    component: () => Qi(() => import("./explorer-1d64258f.mjs"), []),
  },
  {
    name: "heliumtrack",
    path: "/heliumtrack",
    file: "/app/pages/heliumtrack.vue",
    children: [],
    meta: fh,
    alias: (fh == null ? void 0 : fh.alias) || [],
    component: () => Qi(() => import("./heliumtrack-59cf0846.mjs"), []),
  },
  {
    name: "hnt",
    path: "/hnt",
    file: "/app/pages/hnt.vue",
    children: [],
    meta: hh,
    alias: (hh == null ? void 0 : hh.alias) || [],
    component: () => Qi(() => import("./hnt-fcb593af.mjs"), []),
  },
  {
    name: "index",
    path: "/",
    file: "/app/pages/index.vue",
    children: [],
    meta: dh,
    alias: (dh == null ? void 0 : dh.alias) || [],
    component: () =>
      Qi(
        () => import("./index-bcdc3ea4.mjs"),
        ["index-bcdc3ea4.mjs", "Hero-34c92610.mjs", "HeliumGlobe-a4e8cc3d.mjs"]
      ),
  },
  {
    name: "overview",
    path: "/overview",
    file: "/app/pages/overview.vue",
    children: [],
    meta: ph,
    alias: (ph == null ? void 0 : ph.alias) || [],
    component: () => Qi(() => import("./overview-19b2aa5c.mjs"), []),
  },
  {
    name: "password-reset-token",
    path: "/password/reset/:token",
    file: "/app/pages/password/reset/[token].vue",
    children: [],
    meta: mh,
    alias: (mh == null ? void 0 : mh.alias) || [],
    component: () =>
      Qi(
        () => import("./_token_-a8db2d4d.mjs"),
        [
          "_token_-a8db2d4d.mjs",
          "Hero-34c92610.mjs",
          "HeliumGlobe-a4e8cc3d.mjs",
        ]
      ),
  },
  {
    name: "privacy",
    path: "/privacy",
    file: "/app/pages/privacy.vue",
    children: [],
    meta: gh,
    alias: (gh == null ? void 0 : gh.alias) || [],
    component: () => Qi(() => import("./privacy-d6c02b59.mjs"), []),
  },
  {
    name: "terms",
    path: "/terms",
    file: "/app/pages/terms.vue",
    children: [],
    meta: yh,
    alias: (yh == null ? void 0 : yh.alias) || [],
    component: () => Qi(() => import("./terms-62b2e6c0.mjs"), []),
  },
  {
    name: "u-username",
    path: "/u/:username",
    file: "/app/pages/u/[username].vue",
    children: [],
    meta: vh,
    alias: (vh == null ? void 0 : vh.alias) || [],
    component: () =>
      Qi(
        () => import("./_username_-cf01fe11.mjs"),
        [
          "_username_-cf01fe11.mjs",
          "Hero-34c92610.mjs",
          "HeliumGlobe-a4e8cc3d.mjs",
        ]
      ),
  },
]
const pF = {}
var mF = { ...pF }
const gF = [],
  fm = {
    "redirect-to-panel-with-ref": () =>
      Qi(() => import("./redirectToPanelWithRef-f7b526fc.mjs"), []),
    "redirect-to-panel-with-token": () =>
      Qi(() => import("./redirectToPanelWithToken-b8a23119.mjs"), []),
  }
function yF(n, e) {
  const { pathname: t, search: i, hash: r } = e,
    s = n.indexOf("#")
  if (s > -1) {
    const a = r.includes(n.slice(s)) ? n.slice(s).length : 1
    let A = r.slice(a)
    return A[0] !== "/" && (A = "/" + A), Lv(A, "")
  }
  return Lv(t, n) + i + r
}
var vF = Nc(async n => {
  n.vueApp.component("NuxtPage", Cp),
    n.vueApp.component("NuxtNestedPage", Cp),
    n.vueApp.component("NuxtChild", Cp)
  const e = a4().app.baseURL,
    t = kC(e),
    i = yF(e, window.location),
    r = yR({ ...mF, history: t, routes: dF })
  n.vueApp.use(r)
  const s = n0(r.currentRoute.value)
  r.afterEach((p, m) => {
    s.value = m
  }),
    Object.defineProperty(n.vueApp.config.globalProperties, "previousRoute", {
      get: () => s.value,
    })
  const o = {}
  for (const p in r.currentRoute.value) o[p] = _n(() => r.currentRoute.value[p])
  const a = n0(r.resolve(i)),
    A = () => {
      a.value = r.currentRoute.value
    }
  n.hook("page:finish", A),
    r.afterEach((p, m) => {
      var y, x, S, C
      ;((x = (y = p.matched[0]) == null ? void 0 : y.components) == null
        ? void 0
        : x.default) ===
        ((C = (S = m.matched[0]) == null ? void 0 : S.components) == null
          ? void 0
          : C.default) && A()
    })
  const c = {}
  for (const p in a.value) c[p] = _n(() => a.value[p])
  ;(n._route = Or(o)),
    (n._activeRoute = Or(c)),
    (n._middleware = n._middleware || { global: [], named: {} })
  const d = QA()
  try {
    await r.isReady()
  } catch (p) {
    ya(n, Uh, [p])
  }
  return (
    r.beforeEach(async (p, m) => {
      var x
      ;(p.meta = Or(p.meta)), (n._processingMiddleware = !0)
      const y = new Set([...gF, ...n._middleware.global])
      for (const S of p.matched) {
        const C = S.meta.middleware
        if (!!C)
          if (Array.isArray(C)) for (const M of C) y.add(M)
          else y.add(C)
      }
      for (const S of y) {
        const C =
          typeof S == "string"
            ? n._middleware.named[S] ||
              (await ((x = fm[S]) == null
                ? void 0
                : x.call(fm).then(_ => _.default || _)))
            : S
        if (!C) throw new Error(`Unknown route middleware: '${S}'.`)
        const M = await ya(n, C, [p, m])
        if (M || M === !1) return M
      }
    }),
    r.afterEach(async p => {
      delete n._processingMiddleware,
        !n.isHydrating && d.value && (await ya(n, _R)),
        p.matched.length === 0 &&
          ya(n, Uh, [
            xR({
              statusCode: 404,
              statusMessage: `Page not found: ${p.fullPath}`,
            }),
          ])
    }),
    n.hooks.hookOnce("app:created", async () => {
      try {
        await r.replace({ ...r.resolve(i), name: void 0, force: !0 })
      } catch (p) {
        ya(n, Uh, [p])
      }
    }),
    { provide: { router: r } }
  )
})
const _F = !1
/*!
 * pinia v2.0.14
 * (c) 2022 Eduardo San Martin Morote
 * @license MIT
 */ const k6 = n => n,
  xF = Symbol()
var O3
;(function (n) {
  ;(n.direct = "direct"),
    (n.patchObject = "patch object"),
    (n.patchFunction = "patch function")
})(O3 || (O3 = {}))
function bF() {
  const n = vb(!0),
    e = n.run(() => $n({}))
  let t = [],
    i = []
  const r = Ru({
    install(s) {
      k6(r),
        (r._a = s),
        s.provide(xF, r),
        (s.config.globalProperties.$pinia = r),
        i.forEach(o => t.push(o)),
        (i = [])
    },
    use(s) {
      return !this._a && !_F ? i.push(s) : t.push(s), this
    },
    _p: t,
    _a: null,
    _e: n,
    _s: new Map(),
    state: e,
  })
  return r
}
const wF = (n, e) => {
  const t = bF()
  n.vueApp.use(t),
    e("pinia", t),
    (n.pinia = t),
    k6(t),
    t._p.push(({ store: i }) => {
      Object.defineProperty(i, "$nuxt", { value: n })
    }),
    n.nuxtState && n.nuxtState.pinia && (t.state.value = n.nuxtState.pinia)
}
var MF = Nc(n => {
    n.$router.options.scrollBehavior = () =>
      new Promise((e, t) => {
        setTimeout(() => {
          e({ left: 0, top: 0, behaviour: "smooth" })
        }, 100)
      })
  }),
  SF = Nc(() => ({
    provide: {
      scrollToView: n => {
        const e = document.getElementById(n)
        e && e.scrollIntoView()
      },
    },
  }))
function O1(n, e, t) {
  var i, r, s, o, a
  e == null && (e = 100)
  function A() {
    var d = Date.now() - o
    d < e && d >= 0
      ? (i = setTimeout(A, e - d))
      : ((i = null), t || ((a = n.apply(s, r)), (s = r = null)))
  }
  var c = function () {
    ;(s = this), (r = arguments), (o = Date.now())
    var d = t && !i
    return (
      i || (i = setTimeout(A, e)), d && ((a = n.apply(s, r)), (s = r = null)), a
    )
  }
  return (
    (c.clear = function () {
      i && (clearTimeout(i), (i = null))
    }),
    (c.flush = function () {
      i && ((a = n.apply(s, r)), (s = r = null), clearTimeout(i), (i = null))
    }),
    c
  )
}
O1.debounce = O1
var EF = O1
function TF(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function")
}
function q3(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t]
    ;(i.enumerable = i.enumerable || !1),
      (i.configurable = !0),
      "value" in i && (i.writable = !0),
      Object.defineProperty(n, i.key, i)
  }
}
function CF(n, e, t) {
  return (
    e && q3(n.prototype, e),
    t && q3(n, t),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    n
  )
}
function RF(n, e) {
  return PF(n) || LF(n, e) || DF(n, e) || IF()
}
function PF(n) {
  if (Array.isArray(n)) return n
}
function LF(n, e) {
  var t =
    n == null
      ? null
      : (typeof Symbol != "undefined" && n[Symbol.iterator]) || n["@@iterator"]
  if (t != null) {
    var i = [],
      r = !0,
      s = !1,
      o,
      a
    try {
      for (
        t = t.call(n);
        !(r = (o = t.next()).done) && (i.push(o.value), !(e && i.length === e));
        r = !0
      );
    } catch (A) {
      ;(s = !0), (a = A)
    } finally {
      try {
        !r && t.return != null && t.return()
      } finally {
        if (s) throw a
      }
    }
    return i
  }
}
function DF(n, e) {
  if (!!n) {
    if (typeof n == "string") return F3(n, e)
    var t = Object.prototype.toString.call(n).slice(8, -1)
    if (
      (t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set")
    )
      return Array.from(n)
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return F3(n, e)
  }
}
function F3(n, e) {
  ;(e == null || e > n.length) && (e = n.length)
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t]
  return i
}
function IF() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var BF = CF(function n(e, t) {
  var i = t.default,
    r = i === void 0 ? null : i,
    s = t.triggerUpdate,
    o = s === void 0 ? !0 : s,
    a = t.onChange,
    A = a === void 0 ? function (c, d) {} : a
  TF(this, n),
    (this.name = e),
    (this.defaultVal = r),
    (this.triggerUpdate = o),
    (this.onChange = A)
})
function Wi(n) {
  var e = n.stateInit,
    t =
      e === void 0
        ? function () {
            return {}
          }
        : e,
    i = n.props,
    r = i === void 0 ? {} : i,
    s = n.methods,
    o = s === void 0 ? {} : s,
    a = n.aliases,
    A = a === void 0 ? {} : a,
    c = n.init,
    d = c === void 0 ? function () {} : c,
    p = n.update,
    m = p === void 0 ? function () {} : p,
    y = Object.keys(r).map(function (x) {
      return new BF(x, r[x])
    })
  return function () {
    var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      S = Object.assign({}, t instanceof Function ? t(x) : t, {
        initialised: !1,
      }),
      C = {}
    function M(T) {
      return _(T, x), R(), M
    }
    var _ = function (L, B) {
        d.call(M, L, S, B), (S.initialised = !0)
      },
      R = EF(function () {
        !S.initialised || (m.call(M, S, C), (C = {}))
      }, 1)
    return (
      y.forEach(function (T) {
        M[T.name] = L(T)
        function L(B) {
          var k = B.name,
            O = B.triggerUpdate,
            W = O === void 0 ? !1 : O,
            z = B.onChange,
            P = z === void 0 ? function (j, V) {} : z,
            N = B.defaultVal,
            G = N === void 0 ? null : N
          return function (j) {
            var V = S[k]
            if (!arguments.length) return V
            var Y = j === void 0 ? G : j
            return (
              (S[k] = Y),
              P.call(M, Y, S, V),
              !C.hasOwnProperty(k) && (C[k] = V),
              W && R(),
              M
            )
          }
        }
      }),
      Object.keys(o).forEach(function (T) {
        M[T] = function () {
          for (var L, B = arguments.length, k = new Array(B), O = 0; O < B; O++)
            k[O] = arguments[O]
          return (L = o[T]).call.apply(L, [M, S].concat(k))
        }
      }),
      Object.entries(A).forEach(function (T) {
        var L = RF(T, 2),
          B = L[0],
          k = L[1]
        return (M[B] = M[k])
      }),
      (M.resetProps = function () {
        return (
          y.forEach(function (T) {
            M[T.name](T.defaultVal)
          }),
          M
        )
      }),
      M.resetProps(),
      (S._rerender = R),
      M
    )
  }
}
var FA = {
    Linear: {
      None: function (n) {
        return n
      },
    },
    Quadratic: {
      In: function (n) {
        return n * n
      },
      Out: function (n) {
        return n * (2 - n)
      },
      InOut: function (n) {
        return (n *= 2) < 1 ? 0.5 * n * n : -0.5 * (--n * (n - 2) - 1)
      },
    },
    Cubic: {
      In: function (n) {
        return n * n * n
      },
      Out: function (n) {
        return --n * n * n + 1
      },
      InOut: function (n) {
        return (n *= 2) < 1 ? 0.5 * n * n * n : 0.5 * ((n -= 2) * n * n + 2)
      },
    },
    Quartic: {
      In: function (n) {
        return n * n * n * n
      },
      Out: function (n) {
        return 1 - --n * n * n * n
      },
      InOut: function (n) {
        return (n *= 2) < 1
          ? 0.5 * n * n * n * n
          : -0.5 * ((n -= 2) * n * n * n - 2)
      },
    },
    Quintic: {
      In: function (n) {
        return n * n * n * n * n
      },
      Out: function (n) {
        return --n * n * n * n * n + 1
      },
      InOut: function (n) {
        return (n *= 2) < 1
          ? 0.5 * n * n * n * n * n
          : 0.5 * ((n -= 2) * n * n * n * n + 2)
      },
    },
    Sinusoidal: {
      In: function (n) {
        return 1 - Math.cos((n * Math.PI) / 2)
      },
      Out: function (n) {
        return Math.sin((n * Math.PI) / 2)
      },
      InOut: function (n) {
        return 0.5 * (1 - Math.cos(Math.PI * n))
      },
    },
    Exponential: {
      In: function (n) {
        return n === 0 ? 0 : Math.pow(1024, n - 1)
      },
      Out: function (n) {
        return n === 1 ? 1 : 1 - Math.pow(2, -10 * n)
      },
      InOut: function (n) {
        return n === 0
          ? 0
          : n === 1
          ? 1
          : (n *= 2) < 1
          ? 0.5 * Math.pow(1024, n - 1)
          : 0.5 * (-Math.pow(2, -10 * (n - 1)) + 2)
      },
    },
    Circular: {
      In: function (n) {
        return 1 - Math.sqrt(1 - n * n)
      },
      Out: function (n) {
        return Math.sqrt(1 - --n * n)
      },
      InOut: function (n) {
        return (n *= 2) < 1
          ? -0.5 * (Math.sqrt(1 - n * n) - 1)
          : 0.5 * (Math.sqrt(1 - (n -= 2) * n) + 1)
      },
    },
    Elastic: {
      In: function (n) {
        return n === 0
          ? 0
          : n === 1
          ? 1
          : -Math.pow(2, 10 * (n - 1)) * Math.sin((n - 1.1) * 5 * Math.PI)
      },
      Out: function (n) {
        return n === 0
          ? 0
          : n === 1
          ? 1
          : Math.pow(2, -10 * n) * Math.sin((n - 0.1) * 5 * Math.PI) + 1
      },
      InOut: function (n) {
        return n === 0
          ? 0
          : n === 1
          ? 1
          : ((n *= 2),
            n < 1
              ? -0.5 *
                Math.pow(2, 10 * (n - 1)) *
                Math.sin((n - 1.1) * 5 * Math.PI)
              : 0.5 *
                  Math.pow(2, -10 * (n - 1)) *
                  Math.sin((n - 1.1) * 5 * Math.PI) +
                1)
      },
    },
    Back: {
      In: function (n) {
        var e = 1.70158
        return n * n * ((e + 1) * n - e)
      },
      Out: function (n) {
        var e = 1.70158
        return --n * n * ((e + 1) * n + e) + 1
      },
      InOut: function (n) {
        var e = 2.5949095
        return (n *= 2) < 1
          ? 0.5 * (n * n * ((e + 1) * n - e))
          : 0.5 * ((n -= 2) * n * ((e + 1) * n + e) + 2)
      },
    },
    Bounce: {
      In: function (n) {
        return 1 - FA.Bounce.Out(1 - n)
      },
      Out: function (n) {
        return n < 1 / 2.75
          ? 7.5625 * n * n
          : n < 2 / 2.75
          ? 7.5625 * (n -= 1.5 / 2.75) * n + 0.75
          : n < 2.5 / 2.75
          ? 7.5625 * (n -= 2.25 / 2.75) * n + 0.9375
          : 7.5625 * (n -= 2.625 / 2.75) * n + 0.984375
      },
      InOut: function (n) {
        return n < 0.5
          ? FA.Bounce.In(n * 2) * 0.5
          : FA.Bounce.Out(n * 2 - 1) * 0.5 + 0.5
      },
    },
  },
  xA
typeof self == "undefined" && typeof process != "undefined" && process.hrtime
  ? (xA = function () {
      var n = process.hrtime()
      return n[0] * 1e3 + n[1] / 1e6
    })
  : typeof self != "undefined" &&
    self.performance !== void 0 &&
    self.performance.now !== void 0
  ? (xA = self.performance.now.bind(self.performance))
  : Date.now !== void 0
  ? (xA = Date.now)
  : (xA = function () {
      return new Date().getTime()
    })
var _a = xA,
  O6 = (function () {
    function n() {
      ;(this._tweens = {}), (this._tweensAddedDuringUpdate = {})
    }
    return (
      (n.prototype.getAll = function () {
        var e = this
        return Object.keys(this._tweens).map(function (t) {
          return e._tweens[t]
        })
      }),
      (n.prototype.removeAll = function () {
        this._tweens = {}
      }),
      (n.prototype.add = function (e) {
        ;(this._tweens[e.getId()] = e),
          (this._tweensAddedDuringUpdate[e.getId()] = e)
      }),
      (n.prototype.remove = function (e) {
        delete this._tweens[e.getId()],
          delete this._tweensAddedDuringUpdate[e.getId()]
      }),
      (n.prototype.update = function (e, t) {
        e === void 0 && (e = _a()), t === void 0 && (t = !1)
        var i = Object.keys(this._tweens)
        if (i.length === 0) return !1
        for (; i.length > 0; ) {
          this._tweensAddedDuringUpdate = {}
          for (var r = 0; r < i.length; r++) {
            var s = this._tweens[i[r]],
              o = !t
            s && s.update(e, o) === !1 && !t && delete this._tweens[i[r]]
          }
          i = Object.keys(this._tweensAddedDuringUpdate)
        }
        return !0
      }),
      n
    )
  })(),
  Gl = {
    Linear: function (n, e) {
      var t = n.length - 1,
        i = t * e,
        r = Math.floor(i),
        s = Gl.Utils.Linear
      return e < 0
        ? s(n[0], n[1], i)
        : e > 1
        ? s(n[t], n[t - 1], t - i)
        : s(n[r], n[r + 1 > t ? t : r + 1], i - r)
    },
    Bezier: function (n, e) {
      for (
        var t = 0,
          i = n.length - 1,
          r = Math.pow,
          s = Gl.Utils.Bernstein,
          o = 0;
        o <= i;
        o++
      )
        t += r(1 - e, i - o) * r(e, o) * n[o] * s(i, o)
      return t
    },
    CatmullRom: function (n, e) {
      var t = n.length - 1,
        i = t * e,
        r = Math.floor(i),
        s = Gl.Utils.CatmullRom
      return n[0] === n[t]
        ? (e < 0 && (r = Math.floor((i = t * (1 + e)))),
          s(n[(r - 1 + t) % t], n[r], n[(r + 1) % t], n[(r + 2) % t], i - r))
        : e < 0
        ? n[0] - (s(n[0], n[0], n[1], n[1], -i) - n[0])
        : e > 1
        ? n[t] - (s(n[t], n[t], n[t - 1], n[t - 1], i - t) - n[t])
        : s(
            n[r ? r - 1 : 0],
            n[r],
            n[t < r + 1 ? t : r + 1],
            n[t < r + 2 ? t : r + 2],
            i - r
          )
    },
    Utils: {
      Linear: function (n, e, t) {
        return (e - n) * t + n
      },
      Bernstein: function (n, e) {
        var t = Gl.Utils.Factorial
        return t(n) / t(e) / t(n - e)
      },
      Factorial: (function () {
        var n = [1]
        return function (e) {
          var t = 1
          if (n[e]) return n[e]
          for (var i = e; i > 1; i--) t *= i
          return (n[e] = t), t
        }
      })(),
      CatmullRom: function (n, e, t, i, r) {
        var s = (t - n) * 0.5,
          o = (i - e) * 0.5,
          a = r * r,
          A = r * a
        return (
          (2 * e - 2 * t + s + o) * A +
          (-3 * e + 3 * t - 2 * s - o) * a +
          s * r +
          e
        )
      },
    },
  },
  z2 = (function () {
    function n() {}
    return (
      (n.nextId = function () {
        return n._nextId++
      }),
      (n._nextId = 0),
      n
    )
  })(),
  q6 = new O6(),
  kF = (function () {
    function n(e, t) {
      t === void 0 && (t = q6),
        (this._object = e),
        (this._group = t),
        (this._isPaused = !1),
        (this._pauseStart = 0),
        (this._valuesStart = {}),
        (this._valuesEnd = {}),
        (this._valuesStartRepeat = {}),
        (this._duration = 1e3),
        (this._initialRepeat = 0),
        (this._repeat = 0),
        (this._yoyo = !1),
        (this._isPlaying = !1),
        (this._reversed = !1),
        (this._delayTime = 0),
        (this._startTime = 0),
        (this._easingFunction = FA.Linear.None),
        (this._interpolationFunction = Gl.Linear),
        (this._chainedTweens = []),
        (this._onStartCallbackFired = !1),
        (this._id = z2.nextId()),
        (this._isChainStopped = !1),
        (this._goToEnd = !1)
    }
    return (
      (n.prototype.getId = function () {
        return this._id
      }),
      (n.prototype.isPlaying = function () {
        return this._isPlaying
      }),
      (n.prototype.isPaused = function () {
        return this._isPaused
      }),
      (n.prototype.to = function (e, t) {
        return (
          (this._valuesEnd = Object.create(e)),
          t !== void 0 && (this._duration = t),
          this
        )
      }),
      (n.prototype.duration = function (e) {
        return (this._duration = e), this
      }),
      (n.prototype.start = function (e) {
        if (this._isPlaying) return this
        if (
          (this._group && this._group.add(this),
          (this._repeat = this._initialRepeat),
          this._reversed)
        ) {
          this._reversed = !1
          for (var t in this._valuesStartRepeat)
            this._swapEndStartRepeatValues(t),
              (this._valuesStart[t] = this._valuesStartRepeat[t])
        }
        return (
          (this._isPlaying = !0),
          (this._isPaused = !1),
          (this._onStartCallbackFired = !1),
          (this._isChainStopped = !1),
          (this._startTime =
            e !== void 0
              ? typeof e == "string"
                ? _a() + parseFloat(e)
                : e
              : _a()),
          (this._startTime += this._delayTime),
          this._setupProperties(
            this._object,
            this._valuesStart,
            this._valuesEnd,
            this._valuesStartRepeat
          ),
          this
        )
      }),
      (n.prototype._setupProperties = function (e, t, i, r) {
        for (var s in i) {
          var o = e[s],
            a = Array.isArray(o),
            A = a ? "array" : typeof o,
            c = !a && Array.isArray(i[s])
          if (!(A === "undefined" || A === "function")) {
            if (c) {
              var d = i[s]
              if (d.length === 0) continue
              ;(d = d.map(this._handleRelativeValue.bind(this, o))),
                (i[s] = [o].concat(d))
            }
            if ((A === "object" || a) && o && !c) {
              t[s] = a ? [] : {}
              for (var p in o) t[s][p] = o[p]
              ;(r[s] = a ? [] : {}), this._setupProperties(o, t[s], i[s], r[s])
            } else
              typeof t[s] == "undefined" && (t[s] = o),
                a || (t[s] *= 1),
                c ? (r[s] = i[s].slice().reverse()) : (r[s] = t[s] || 0)
          }
        }
      }),
      (n.prototype.stop = function () {
        return (
          this._isChainStopped ||
            ((this._isChainStopped = !0), this.stopChainedTweens()),
          this._isPlaying
            ? (this._group && this._group.remove(this),
              (this._isPlaying = !1),
              (this._isPaused = !1),
              this._onStopCallback && this._onStopCallback(this._object),
              this)
            : this
        )
      }),
      (n.prototype.end = function () {
        return (this._goToEnd = !0), this.update(1 / 0), this
      }),
      (n.prototype.pause = function (e) {
        return (
          e === void 0 && (e = _a()),
          this._isPaused || !this._isPlaying
            ? this
            : ((this._isPaused = !0),
              (this._pauseStart = e),
              this._group && this._group.remove(this),
              this)
        )
      }),
      (n.prototype.resume = function (e) {
        return (
          e === void 0 && (e = _a()),
          !this._isPaused || !this._isPlaying
            ? this
            : ((this._isPaused = !1),
              (this._startTime += e - this._pauseStart),
              (this._pauseStart = 0),
              this._group && this._group.add(this),
              this)
        )
      }),
      (n.prototype.stopChainedTweens = function () {
        for (var e = 0, t = this._chainedTweens.length; e < t; e++)
          this._chainedTweens[e].stop()
        return this
      }),
      (n.prototype.group = function (e) {
        return (this._group = e), this
      }),
      (n.prototype.delay = function (e) {
        return (this._delayTime = e), this
      }),
      (n.prototype.repeat = function (e) {
        return (this._initialRepeat = e), (this._repeat = e), this
      }),
      (n.prototype.repeatDelay = function (e) {
        return (this._repeatDelayTime = e), this
      }),
      (n.prototype.yoyo = function (e) {
        return (this._yoyo = e), this
      }),
      (n.prototype.easing = function (e) {
        return (this._easingFunction = e), this
      }),
      (n.prototype.interpolation = function (e) {
        return (this._interpolationFunction = e), this
      }),
      (n.prototype.chain = function () {
        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
        return (this._chainedTweens = e), this
      }),
      (n.prototype.onStart = function (e) {
        return (this._onStartCallback = e), this
      }),
      (n.prototype.onUpdate = function (e) {
        return (this._onUpdateCallback = e), this
      }),
      (n.prototype.onRepeat = function (e) {
        return (this._onRepeatCallback = e), this
      }),
      (n.prototype.onComplete = function (e) {
        return (this._onCompleteCallback = e), this
      }),
      (n.prototype.onStop = function (e) {
        return (this._onStopCallback = e), this
      }),
      (n.prototype.update = function (e, t) {
        if (
          (e === void 0 && (e = _a()), t === void 0 && (t = !0), this._isPaused)
        )
          return !0
        var i,
          r,
          s = this._startTime + this._duration
        if (!this._goToEnd && !this._isPlaying) {
          if (e > s) return !1
          t && this.start(e)
        }
        if (((this._goToEnd = !1), e < this._startTime)) return !0
        this._onStartCallbackFired === !1 &&
          (this._onStartCallback && this._onStartCallback(this._object),
          (this._onStartCallbackFired = !0)),
          (r = (e - this._startTime) / this._duration),
          (r = this._duration === 0 || r > 1 ? 1 : r)
        var o = this._easingFunction(r)
        if (
          (this._updateProperties(
            this._object,
            this._valuesStart,
            this._valuesEnd,
            o
          ),
          this._onUpdateCallback && this._onUpdateCallback(this._object, r),
          r === 1)
        )
          if (this._repeat > 0) {
            isFinite(this._repeat) && this._repeat--
            for (i in this._valuesStartRepeat)
              !this._yoyo &&
                typeof this._valuesEnd[i] == "string" &&
                (this._valuesStartRepeat[i] =
                  this._valuesStartRepeat[i] + parseFloat(this._valuesEnd[i])),
                this._yoyo && this._swapEndStartRepeatValues(i),
                (this._valuesStart[i] = this._valuesStartRepeat[i])
            return (
              this._yoyo && (this._reversed = !this._reversed),
              this._repeatDelayTime !== void 0
                ? (this._startTime = e + this._repeatDelayTime)
                : (this._startTime = e + this._delayTime),
              this._onRepeatCallback && this._onRepeatCallback(this._object),
              !0
            )
          } else {
            this._onCompleteCallback && this._onCompleteCallback(this._object)
            for (var a = 0, A = this._chainedTweens.length; a < A; a++)
              this._chainedTweens[a].start(this._startTime + this._duration)
            return (this._isPlaying = !1), !1
          }
        return !0
      }),
      (n.prototype._updateProperties = function (e, t, i, r) {
        for (var s in i)
          if (t[s] !== void 0) {
            var o = t[s] || 0,
              a = i[s],
              A = Array.isArray(e[s]),
              c = Array.isArray(a),
              d = !A && c
            d
              ? (e[s] = this._interpolationFunction(a, r))
              : typeof a == "object" && a
              ? this._updateProperties(e[s], o, a, r)
              : ((a = this._handleRelativeValue(o, a)),
                typeof a == "number" && (e[s] = o + (a - o) * r))
          }
      }),
      (n.prototype._handleRelativeValue = function (e, t) {
        return typeof t != "string"
          ? t
          : t.charAt(0) === "+" || t.charAt(0) === "-"
          ? e + parseFloat(t)
          : parseFloat(t)
      }),
      (n.prototype._swapEndStartRepeatValues = function (e) {
        var t = this._valuesStartRepeat[e],
          i = this._valuesEnd[e]
        typeof i == "string"
          ? (this._valuesStartRepeat[e] =
              this._valuesStartRepeat[e] + parseFloat(i))
          : (this._valuesStartRepeat[e] = this._valuesEnd[e]),
          (this._valuesEnd[e] = t)
      }),
      n
    )
  })(),
  OF = "18.6.4",
  qF = z2.nextId,
  fs = q6,
  FF = fs.getAll.bind(fs),
  NF = fs.removeAll.bind(fs),
  UF = fs.add.bind(fs),
  zF = fs.remove.bind(fs),
  HF = fs.update.bind(fs),
  xn = {
    Easing: FA,
    Group: O6,
    Interpolation: Gl,
    now: _a,
    Sequence: z2,
    nextId: qF,
    Tween: kF,
    VERSION: OF,
    getAll: FF,
    removeAll: NF,
    add: UF,
    remove: zF,
    update: HF,
  },
  H2 = { exports: {} }
H2.exports = Qd
H2.exports.default = Qd
function Qd(n, e, t) {
  t = t || 2
  var i = e && e.length,
    r = i ? e[0] * t : n.length,
    s = F6(n, 0, r, t, !0),
    o = []
  if (!s || s.next === s.prev) return o
  var a, A, c, d, p, m, y
  if ((i && (s = $F(n, e, s, t)), n.length > 80 * t)) {
    ;(a = c = n[0]), (A = d = n[1])
    for (var x = t; x < r; x += t)
      (p = n[x]),
        (m = n[x + 1]),
        p < a && (a = p),
        m < A && (A = m),
        p > c && (c = p),
        m > d && (d = m)
    ;(y = Math.max(c - a, d - A)), (y = y !== 0 ? 1 / y : 0)
  }
  return hu(s, o, t, a, A, y), o
}
function F6(n, e, t, i, r) {
  var s, o
  if (r === N1(n, e, t, i) > 0)
    for (s = e; s < t; s += i) o = N3(s, n[s], n[s + 1], o)
  else for (s = t - i; s >= e; s -= i) o = N3(s, n[s], n[s + 1], o)
  return o && Xd(o, o.next) && (pu(o), (o = o.next)), o
}
function zo(n, e) {
  if (!n) return n
  e || (e = n)
  var t = n,
    i
  do
    if (
      ((i = !1), !t.steiner && (Xd(t, t.next) || En(t.prev, t, t.next) === 0))
    ) {
      if ((pu(t), (t = e = t.prev), t === t.next)) break
      i = !0
    } else t = t.next
  while (i || t !== e)
  return e
}
function hu(n, e, t, i, r, s, o) {
  if (!!n) {
    !o && s && JF(n, i, r, s)
    for (var a = n, A, c; n.prev !== n.next; ) {
      if (((A = n.prev), (c = n.next), s ? VF(n, i, r, s) : GF(n))) {
        e.push(A.i / t),
          e.push(n.i / t),
          e.push(c.i / t),
          pu(n),
          (n = c.next),
          (a = c.next)
        continue
      }
      if (((n = c), n === a)) {
        o
          ? o === 1
            ? ((n = WF(zo(n), e, t)), hu(n, e, t, i, r, s, 2))
            : o === 2 && jF(n, e, t, i, r, s)
          : hu(zo(n), e, t, i, r, s, 1)
        break
      }
    }
  }
}
function GF(n) {
  var e = n.prev,
    t = n,
    i = n.next
  if (En(e, t, i) >= 0) return !1
  for (var r = n.next.next; r !== n.prev; ) {
    if (
      Vl(e.x, e.y, t.x, t.y, i.x, i.y, r.x, r.y) &&
      En(r.prev, r, r.next) >= 0
    )
      return !1
    r = r.next
  }
  return !0
}
function VF(n, e, t, i) {
  var r = n.prev,
    s = n,
    o = n.next
  if (En(r, s, o) >= 0) return !1
  for (
    var a = r.x < s.x ? (r.x < o.x ? r.x : o.x) : s.x < o.x ? s.x : o.x,
      A = r.y < s.y ? (r.y < o.y ? r.y : o.y) : s.y < o.y ? s.y : o.y,
      c = r.x > s.x ? (r.x > o.x ? r.x : o.x) : s.x > o.x ? s.x : o.x,
      d = r.y > s.y ? (r.y > o.y ? r.y : o.y) : s.y > o.y ? s.y : o.y,
      p = q1(a, A, e, t, i),
      m = q1(c, d, e, t, i),
      y = n.prevZ,
      x = n.nextZ;
    y && y.z >= p && x && x.z <= m;

  ) {
    if (
      (y !== n.prev &&
        y !== n.next &&
        Vl(r.x, r.y, s.x, s.y, o.x, o.y, y.x, y.y) &&
        En(y.prev, y, y.next) >= 0) ||
      ((y = y.prevZ),
      x !== n.prev &&
        x !== n.next &&
        Vl(r.x, r.y, s.x, s.y, o.x, o.y, x.x, x.y) &&
        En(x.prev, x, x.next) >= 0)
    )
      return !1
    x = x.nextZ
  }
  for (; y && y.z >= p; ) {
    if (
      y !== n.prev &&
      y !== n.next &&
      Vl(r.x, r.y, s.x, s.y, o.x, o.y, y.x, y.y) &&
      En(y.prev, y, y.next) >= 0
    )
      return !1
    y = y.prevZ
  }
  for (; x && x.z <= m; ) {
    if (
      x !== n.prev &&
      x !== n.next &&
      Vl(r.x, r.y, s.x, s.y, o.x, o.y, x.x, x.y) &&
      En(x.prev, x, x.next) >= 0
    )
      return !1
    x = x.nextZ
  }
  return !0
}
function WF(n, e, t) {
  var i = n
  do {
    var r = i.prev,
      s = i.next.next
    !Xd(r, s) &&
      N6(r, i, i.next, s) &&
      du(r, s) &&
      du(s, r) &&
      (e.push(r.i / t),
      e.push(i.i / t),
      e.push(s.i / t),
      pu(i),
      pu(i.next),
      (i = n = s)),
      (i = i.next)
  } while (i !== n)
  return zo(i)
}
function jF(n, e, t, i, r, s) {
  var o = n
  do {
    for (var a = o.next.next; a !== o.prev; ) {
      if (o.i !== a.i && tN(o, a)) {
        var A = U6(o, a)
        ;(o = zo(o, o.next)),
          (A = zo(A, A.next)),
          hu(o, e, t, i, r, s),
          hu(A, e, t, i, r, s)
        return
      }
      a = a.next
    }
    o = o.next
  } while (o !== n)
}
function $F(n, e, t, i) {
  var r = [],
    s,
    o,
    a,
    A,
    c
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * i),
      (A = s < o - 1 ? e[s + 1] * i : n.length),
      (c = F6(n, a, A, i, !1)),
      c === c.next && (c.steiner = !0),
      r.push(eN(c))
  for (r.sort(QF), s = 0; s < r.length; s++)
    (t = XF(r[s], t)), (t = zo(t, t.next))
  return t
}
function QF(n, e) {
  return n.x - e.x
}
function XF(n, e) {
  var t = YF(n, e)
  if (!t) return e
  var i = U6(t, n),
    r = zo(t, t.next)
  return zo(i, i.next), e === t ? r : e
}
function YF(n, e) {
  var t = e,
    i = n.x,
    r = n.y,
    s = -1 / 0,
    o
  do {
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      var a = t.x + ((r - t.y) * (t.next.x - t.x)) / (t.next.y - t.y)
      if (a <= i && a > s) {
        if (((s = a), a === i)) {
          if (r === t.y) return t
          if (r === t.next.y) return t.next
        }
        o = t.x < t.next.x ? t : t.next
      }
    }
    t = t.next
  } while (t !== e)
  if (!o) return null
  if (i === s) return o
  var A = o,
    c = o.x,
    d = o.y,
    p = 1 / 0,
    m
  t = o
  do
    i >= t.x &&
      t.x >= c &&
      i !== t.x &&
      Vl(r < d ? i : s, r, c, d, r < d ? s : i, r, t.x, t.y) &&
      ((m = Math.abs(r - t.y) / (i - t.x)),
      du(t, n) &&
        (m < p || (m === p && (t.x > o.x || (t.x === o.x && ZF(o, t))))) &&
        ((o = t), (p = m))),
      (t = t.next)
  while (t !== A)
  return o
}
function ZF(n, e) {
  return En(n.prev, n, e.prev) < 0 && En(e.next, n, n.next) < 0
}
function JF(n, e, t, i) {
  var r = n
  do
    r.z === null && (r.z = q1(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next)
  while (r !== n)
  ;(r.prevZ.nextZ = null), (r.prevZ = null), KF(r)
}
function KF(n) {
  var e,
    t,
    i,
    r,
    s,
    o,
    a,
    A,
    c = 1
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < c && (a++, (i = i.nextZ), !!i); e++);
      for (A = c; a > 0 || (A > 0 && i); )
        a !== 0 && (A === 0 || !i || t.z <= i.z)
          ? ((r = t), (t = t.nextZ), a--)
          : ((r = i), (i = i.nextZ), A--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r)
      t = i
    }
    ;(s.nextZ = null), (c *= 2)
  } while (o > 1)
  return n
}
function q1(n, e, t, i, r) {
  return (
    (n = 32767 * (n - t) * r),
    (e = 32767 * (e - i) * r),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  )
}
function eN(n) {
  var e = n,
    t = n
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next)
  while (e !== n)
  return t
}
function Vl(n, e, t, i, r, s, o, a) {
  return (
    (r - o) * (e - a) - (n - o) * (s - a) >= 0 &&
    (n - o) * (i - a) - (t - o) * (e - a) >= 0 &&
    (t - o) * (s - a) - (r - o) * (i - a) >= 0
  )
}
function tN(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !nN(n, e) &&
    ((du(n, e) &&
      du(e, n) &&
      iN(n, e) &&
      (En(n.prev, n, e.prev) || En(n, e.prev, e))) ||
      (Xd(n, e) && En(n.prev, n, n.next) > 0 && En(e.prev, e, e.next) > 0))
  )
}
function En(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}
function Xd(n, e) {
  return n.x === e.x && n.y === e.y
}
function N6(n, e, t, i) {
  var r = xh(En(n, e, t)),
    s = xh(En(n, e, i)),
    o = xh(En(t, i, n)),
    a = xh(En(t, i, e))
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && _h(n, t, e)) ||
    (s === 0 && _h(n, i, e)) ||
    (o === 0 && _h(t, n, i)) ||
    (a === 0 && _h(t, e, i))
  )
}
function _h(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  )
}
function xh(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0
}
function nN(n, e) {
  var t = n
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      N6(t, t.next, n, e)
    )
      return !0
    t = t.next
  } while (t !== n)
  return !1
}
function du(n, e) {
  return En(n.prev, n, n.next) < 0
    ? En(n, e, n.next) >= 0 && En(n, n.prev, e) >= 0
    : En(n, e, n.prev) < 0 || En(n, n.next, e) < 0
}
function iN(n, e) {
  var t = n,
    i = !1,
    r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next)
  while (t !== n)
  return i
}
function U6(n, e) {
  var t = new F1(n.i, n.x, n.y),
    i = new F1(e.i, e.x, e.y),
    r = n.next,
    s = e.prev
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  )
}
function N3(n, e, t, i) {
  var r = new F1(n, e, t)
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  )
}
function pu(n) {
  ;(n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ)
}
function F1(n, e, t) {
  ;(this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = null),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1)
}
Qd.deviation = function (n, e, t, i) {
  var r = e && e.length,
    s = r ? e[0] * t : n.length,
    o = Math.abs(N1(n, 0, s, t))
  if (r)
    for (var a = 0, A = e.length; a < A; a++) {
      var c = e[a] * t,
        d = a < A - 1 ? e[a + 1] * t : n.length
      o -= Math.abs(N1(n, c, d, t))
    }
  var p = 0
  for (a = 0; a < i.length; a += 3) {
    var m = i[a] * t,
      y = i[a + 1] * t,
      x = i[a + 2] * t
    p += Math.abs(
      (n[m] - n[x]) * (n[y + 1] - n[m + 1]) -
        (n[m] - n[y]) * (n[x + 1] - n[m + 1])
    )
  }
  return o === 0 && p === 0 ? 0 : Math.abs((p - o) / o)
}
function N1(n, e, t, i) {
  for (var r = 0, s = e, o = t - i; s < t; s += i)
    (r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s)
  return r
}
Qd.flatten = function (n) {
  for (
    var e = n[0][0].length,
      t = { vertices: [], holes: [], dimensions: e },
      i = 0,
      r = 0;
    r < n.length;
    r++
  ) {
    for (var s = 0; s < n[r].length; s++)
      for (var o = 0; o < e; o++) t.vertices.push(n[r][s][o])
    r > 0 && ((i += n[r - 1].length), t.holes.push(i))
  }
  return t
}
var mu = H2.exports
function Qh(n, e) {
  return n == null || e == null
    ? NaN
    : n < e
    ? -1
    : n > e
    ? 1
    : n >= e
    ? 0
    : NaN
}
function rN(n, e) {
  return n == null || e == null
    ? NaN
    : e < n
    ? -1
    : e > n
    ? 1
    : e >= n
    ? 0
    : NaN
}
function z6(n) {
  let e, t, i
  n.length !== 2
    ? ((e = Qh), (t = (a, A) => Qh(n(a), A)), (i = (a, A) => n(a) - A))
    : ((e = n === Qh || n === rN ? n : sN), (t = n), (i = n))
  function r(a, A, c = 0, d = a.length) {
    if (c < d) {
      if (e(A, A) !== 0) return d
      do {
        const p = (c + d) >>> 1
        t(a[p], A) < 0 ? (c = p + 1) : (d = p)
      } while (c < d)
    }
    return c
  }
  function s(a, A, c = 0, d = a.length) {
    if (c < d) {
      if (e(A, A) !== 0) return d
      do {
        const p = (c + d) >>> 1
        t(a[p], A) <= 0 ? (c = p + 1) : (d = p)
      } while (c < d)
    }
    return c
  }
  function o(a, A, c = 0, d = a.length) {
    const p = r(a, A, c, d - 1)
    return p > c && i(a[p - 1], A) > -i(a[p], A) ? p - 1 : p
  }
  return { left: r, center: o, right: s }
}
function sN() {
  return 0
}
function oN(n) {
  return n === null ? NaN : +n
}
const aN = z6(Qh),
  lN = aN.right
z6(oN).center
var cN = lN
function w0(n, e) {
  let t, i
  if (e === void 0)
    for (const r of n)
      r != null &&
        (t === void 0
          ? r >= r && (t = i = r)
          : (t > r && (t = r), i < r && (i = r)))
  else {
    let r = -1
    for (let s of n)
      (s = e(s, ++r, n)) != null &&
        (t === void 0
          ? s >= s && (t = i = s)
          : (t > s && (t = s), i < s && (i = s)))
  }
  return [t, i]
}
class ks {
  constructor() {
    ;(this._partials = new Float64Array(32)), (this._n = 0)
  }
  add(e) {
    const t = this._partials
    let i = 0
    for (let r = 0; r < this._n && r < 32; r++) {
      const s = t[r],
        o = e + s,
        a = Math.abs(e) < Math.abs(s) ? e - (o - s) : s - (o - e)
      a && (t[i++] = a), (e = o)
    }
    return (t[i] = e), (this._n = i + 1), this
  }
  valueOf() {
    const e = this._partials
    let t = this._n,
      i,
      r,
      s,
      o = 0
    if (t > 0) {
      for (
        o = e[--t];
        t > 0 && ((i = o), (r = e[--t]), (o = i + r), (s = r - (o - i)), !s);

      );
      t > 0 &&
        ((s < 0 && e[t - 1] < 0) || (s > 0 && e[t - 1] > 0)) &&
        ((r = s * 2), (i = o + r), r == i - o && (o = i))
    }
    return o
  }
}
var U1 = Math.sqrt(50),
  z1 = Math.sqrt(10),
  H1 = Math.sqrt(2)
function AN(n, e, t) {
  var i,
    r = -1,
    s,
    o,
    a
  if (((e = +e), (n = +n), (t = +t), n === e && t > 0)) return [n]
  if (
    ((i = e < n) && ((s = n), (n = e), (e = s)),
    (a = H6(n, e, t)) === 0 || !isFinite(a))
  )
    return []
  if (a > 0) {
    let A = Math.round(n / a),
      c = Math.round(e / a)
    for (
      A * a < n && ++A, c * a > e && --c, o = new Array((s = c - A + 1));
      ++r < s;

    )
      o[r] = (A + r) * a
  } else {
    a = -a
    let A = Math.round(n * a),
      c = Math.round(e * a)
    for (
      A / a < n && ++A, c / a > e && --c, o = new Array((s = c - A + 1));
      ++r < s;

    )
      o[r] = (A + r) / a
  }
  return i && o.reverse(), o
}
function H6(n, e, t) {
  var i = (e - n) / Math.max(0, t),
    r = Math.floor(Math.log(i) / Math.LN10),
    s = i / Math.pow(10, r)
  return r >= 0
    ? (s >= U1 ? 10 : s >= z1 ? 5 : s >= H1 ? 2 : 1) * Math.pow(10, r)
    : -Math.pow(10, -r) / (s >= U1 ? 10 : s >= z1 ? 5 : s >= H1 ? 2 : 1)
}
function uN(n, e, t) {
  var i = Math.abs(e - n) / Math.max(0, t),
    r = Math.pow(10, Math.floor(Math.log(i) / Math.LN10)),
    s = i / r
  return (
    s >= U1 ? (r *= 10) : s >= z1 ? (r *= 5) : s >= H1 && (r *= 2),
    e < n ? -r : r
  )
}
function fN(n, e) {
  let t = 0,
    i = 0
  if (e === void 0)
    for (let r of n) r != null && (r = +r) >= r && (++t, (i += r))
  else {
    let r = -1
    for (let s of n)
      (s = e(s, ++r, n)) != null && (s = +s) >= s && (++t, (i += s))
  }
  if (t) return i / t
}
function* hN(n) {
  for (const e of n) yield* e
}
function gu(n) {
  return Array.from(hN(n))
}
function Wl(n, e, t) {
  ;(n = +n),
    (e = +e),
    (t = (r = arguments.length) < 2 ? ((e = n), (n = 0), 1) : r < 3 ? 1 : +t)
  for (
    var i = -1, r = Math.max(0, Math.ceil((e - n) / t)) | 0, s = new Array(r);
    ++i < r;

  )
    s[i] = n + i * t
  return s
}
var qt = 1e-6,
  M0 = 1e-12,
  Vt = Math.PI,
  yr = Vt / 2,
  S0 = Vt / 4,
  lr = Vt * 2,
  Ln = 180 / Vt,
  Tt = Vt / 180,
  An = Math.abs,
  G6 = Math.atan,
  wr = Math.atan2,
  Pt = Math.cos,
  bh = Math.ceil,
  G1 = Math.hypot,
  wt = Math.sin,
  dN =
    Math.sign ||
    function (n) {
      return n > 0 ? 1 : n < 0 ? -1 : 0
    },
  Vs = Math.sqrt
function pN(n) {
  return n > 1 ? 0 : n < -1 ? Vt : Math.acos(n)
}
function Ws(n) {
  return n > 1 ? yr : n < -1 ? -yr : Math.asin(n)
}
function U3(n) {
  return (n = wt(n / 2)) * n
}
function di() {}
function E0(n, e) {
  n && H3.hasOwnProperty(n.type) && H3[n.type](n, e)
}
var z3 = {
    Feature: function (n, e) {
      E0(n.geometry, e)
    },
    FeatureCollection: function (n, e) {
      for (var t = n.features, i = -1, r = t.length; ++i < r; )
        E0(t[i].geometry, e)
    },
  },
  H3 = {
    Sphere: function (n, e) {
      e.sphere()
    },
    Point: function (n, e) {
      ;(n = n.coordinates), e.point(n[0], n[1], n[2])
    },
    MultiPoint: function (n, e) {
      for (var t = n.coordinates, i = -1, r = t.length; ++i < r; )
        (n = t[i]), e.point(n[0], n[1], n[2])
    },
    LineString: function (n, e) {
      V1(n.coordinates, e, 0)
    },
    MultiLineString: function (n, e) {
      for (var t = n.coordinates, i = -1, r = t.length; ++i < r; )
        V1(t[i], e, 0)
    },
    Polygon: function (n, e) {
      G3(n.coordinates, e)
    },
    MultiPolygon: function (n, e) {
      for (var t = n.coordinates, i = -1, r = t.length; ++i < r; ) G3(t[i], e)
    },
    GeometryCollection: function (n, e) {
      for (var t = n.geometries, i = -1, r = t.length; ++i < r; ) E0(t[i], e)
    },
  }
function V1(n, e, t) {
  var i = -1,
    r = n.length - t,
    s
  for (e.lineStart(); ++i < r; ) (s = n[i]), e.point(s[0], s[1], s[2])
  e.lineEnd()
}
function G3(n, e) {
  var t = -1,
    i = n.length
  for (e.polygonStart(); ++t < i; ) V1(n[t], e, 1)
  e.polygonEnd()
}
function Yd(n, e) {
  n && z3.hasOwnProperty(n.type) ? z3[n.type](n, e) : E0(n, e)
}
var T0 = new ks(),
  V3 = new ks(),
  V6,
  W6,
  W1,
  j1,
  $1,
  js = {
    point: di,
    lineStart: di,
    lineEnd: di,
    polygonStart: function () {
      ;(T0 = new ks()), (js.lineStart = mN), (js.lineEnd = gN)
    },
    polygonEnd: function () {
      var n = +T0
      V3.add(n < 0 ? lr + n : n),
        (this.lineStart = this.lineEnd = this.point = di)
    },
    sphere: function () {
      V3.add(lr)
    },
  }
function mN() {
  js.point = yN
}
function gN() {
  j6(V6, W6)
}
function yN(n, e) {
  ;(js.point = j6),
    (V6 = n),
    (W6 = e),
    (n *= Tt),
    (e *= Tt),
    (W1 = n),
    (j1 = Pt((e = e / 2 + S0))),
    ($1 = wt(e))
}
function j6(n, e) {
  ;(n *= Tt), (e *= Tt), (e = e / 2 + S0)
  var t = n - W1,
    i = t >= 0 ? 1 : -1,
    r = i * t,
    s = Pt(e),
    o = wt(e),
    a = $1 * o,
    A = j1 * s + a * Pt(r),
    c = a * i * wt(r)
  T0.add(wr(c, A)), (W1 = n), (j1 = s), ($1 = o)
}
function C0(n) {
  return [wr(n[1], n[0]), Ws(n[2])]
}
function Qa(n) {
  var e = n[0],
    t = n[1],
    i = Pt(t)
  return [i * Pt(e), i * wt(e), wt(t)]
}
function wh(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2]
}
function Rc(n, e) {
  return [
    n[1] * e[2] - n[2] * e[1],
    n[2] * e[0] - n[0] * e[2],
    n[0] * e[1] - n[1] * e[0],
  ]
}
function hm(n, e) {
  ;(n[0] += e[0]), (n[1] += e[1]), (n[2] += e[2])
}
function Mh(n, e) {
  return [n[0] * e, n[1] * e, n[2] * e]
}
function R0(n) {
  var e = Vs(n[0] * n[0] + n[1] * n[1] + n[2] * n[2])
  ;(n[0] /= e), (n[1] /= e), (n[2] /= e)
}
var wn,
  Ni,
  Rn,
  Ki,
  ma,
  $6,
  Q6,
  sc,
  NA,
  Eo,
  $s,
  Es = {
    point: Q1,
    lineStart: W3,
    lineEnd: j3,
    polygonStart: function () {
      ;(Es.point = Y6),
        (Es.lineStart = vN),
        (Es.lineEnd = _N),
        (NA = new ks()),
        js.polygonStart()
    },
    polygonEnd: function () {
      js.polygonEnd(),
        (Es.point = Q1),
        (Es.lineStart = W3),
        (Es.lineEnd = j3),
        T0 < 0
          ? ((wn = -(Rn = 180)), (Ni = -(Ki = 90)))
          : NA > qt
          ? (Ki = 90)
          : NA < -qt && (Ni = -90),
        ($s[0] = wn),
        ($s[1] = Rn)
    },
    sphere: function () {
      ;(wn = -(Rn = 180)), (Ni = -(Ki = 90))
    },
  }
function Q1(n, e) {
  Eo.push(($s = [(wn = n), (Rn = n)])), e < Ni && (Ni = e), e > Ki && (Ki = e)
}
function X6(n, e) {
  var t = Qa([n * Tt, e * Tt])
  if (sc) {
    var i = Rc(sc, t),
      r = [i[1], -i[0], 0],
      s = Rc(r, i)
    R0(s), (s = C0(s))
    var o = n - ma,
      a = o > 0 ? 1 : -1,
      A = s[0] * Ln * a,
      c,
      d = An(o) > 180
    d ^ (a * ma < A && A < a * n)
      ? ((c = s[1] * Ln), c > Ki && (Ki = c))
      : ((A = ((A + 360) % 360) - 180),
        d ^ (a * ma < A && A < a * n)
          ? ((c = -s[1] * Ln), c < Ni && (Ni = c))
          : (e < Ni && (Ni = e), e > Ki && (Ki = e))),
      d
        ? n < ma
          ? Yi(wn, n) > Yi(wn, Rn) && (Rn = n)
          : Yi(n, Rn) > Yi(wn, Rn) && (wn = n)
        : Rn >= wn
        ? (n < wn && (wn = n), n > Rn && (Rn = n))
        : n > ma
        ? Yi(wn, n) > Yi(wn, Rn) && (Rn = n)
        : Yi(n, Rn) > Yi(wn, Rn) && (wn = n)
  } else Eo.push(($s = [(wn = n), (Rn = n)]))
  e < Ni && (Ni = e), e > Ki && (Ki = e), (sc = t), (ma = n)
}
function W3() {
  Es.point = X6
}
function j3() {
  ;($s[0] = wn), ($s[1] = Rn), (Es.point = Q1), (sc = null)
}
function Y6(n, e) {
  if (sc) {
    var t = n - ma
    NA.add(An(t) > 180 ? t + (t > 0 ? 360 : -360) : t)
  } else ($6 = n), (Q6 = e)
  js.point(n, e), X6(n, e)
}
function vN() {
  js.lineStart()
}
function _N() {
  Y6($6, Q6),
    js.lineEnd(),
    An(NA) > qt && (wn = -(Rn = 180)),
    ($s[0] = wn),
    ($s[1] = Rn),
    (sc = null)
}
function Yi(n, e) {
  return (e -= n) < 0 ? e + 360 : e
}
function xN(n, e) {
  return n[0] - e[0]
}
function $3(n, e) {
  return n[0] <= n[1] ? n[0] <= e && e <= n[1] : e < n[0] || n[1] < e
}
function Z6(n) {
  var e, t, i, r, s, o, a
  if (((Ki = Rn = -(wn = Ni = 1 / 0)), (Eo = []), Yd(n, Es), (t = Eo.length))) {
    for (Eo.sort(xN), e = 1, i = Eo[0], s = [i]; e < t; ++e)
      (r = Eo[e]),
        $3(i, r[0]) || $3(i, r[1])
          ? (Yi(i[0], r[1]) > Yi(i[0], i[1]) && (i[1] = r[1]),
            Yi(r[0], i[1]) > Yi(i[0], i[1]) && (i[0] = r[0]))
          : s.push((i = r))
    for (o = -1 / 0, t = s.length - 1, e = 0, i = s[t]; e <= t; i = r, ++e)
      (r = s[e]),
        (a = Yi(i[1], r[0])) > o && ((o = a), (wn = r[0]), (Rn = i[1]))
  }
  return (
    (Eo = $s = null),
    wn === 1 / 0 || Ni === 1 / 0
      ? [
          [NaN, NaN],
          [NaN, NaN],
        ]
      : [
          [wn, Ni],
          [Rn, Ki],
        ]
  )
}
var bA,
  P0,
  L0,
  D0,
  I0,
  B0,
  k0,
  O0,
  X1,
  Y1,
  Z1,
  J6,
  K6,
  Si,
  Ei,
  Ti,
  Br = {
    sphere: di,
    point: G2,
    lineStart: Q3,
    lineEnd: X3,
    polygonStart: function () {
      ;(Br.lineStart = MN), (Br.lineEnd = SN)
    },
    polygonEnd: function () {
      ;(Br.lineStart = Q3), (Br.lineEnd = X3)
    },
  }
function G2(n, e) {
  ;(n *= Tt), (e *= Tt)
  var t = Pt(e)
  Qu(t * Pt(n), t * wt(n), wt(e))
}
function Qu(n, e, t) {
  ++bA, (L0 += (n - L0) / bA), (D0 += (e - D0) / bA), (I0 += (t - I0) / bA)
}
function Q3() {
  Br.point = bN
}
function bN(n, e) {
  ;(n *= Tt), (e *= Tt)
  var t = Pt(e)
  ;(Si = t * Pt(n)),
    (Ei = t * wt(n)),
    (Ti = wt(e)),
    (Br.point = wN),
    Qu(Si, Ei, Ti)
}
function wN(n, e) {
  ;(n *= Tt), (e *= Tt)
  var t = Pt(e),
    i = t * Pt(n),
    r = t * wt(n),
    s = wt(e),
    o = wr(
      Vs(
        (o = Ei * s - Ti * r) * o +
          (o = Ti * i - Si * s) * o +
          (o = Si * r - Ei * i) * o
      ),
      Si * i + Ei * r + Ti * s
    )
  ;(P0 += o),
    (B0 += o * (Si + (Si = i))),
    (k0 += o * (Ei + (Ei = r))),
    (O0 += o * (Ti + (Ti = s))),
    Qu(Si, Ei, Ti)
}
function X3() {
  Br.point = G2
}
function MN() {
  Br.point = EN
}
function SN() {
  e8(J6, K6), (Br.point = G2)
}
function EN(n, e) {
  ;(J6 = n), (K6 = e), (n *= Tt), (e *= Tt), (Br.point = e8)
  var t = Pt(e)
  ;(Si = t * Pt(n)), (Ei = t * wt(n)), (Ti = wt(e)), Qu(Si, Ei, Ti)
}
function e8(n, e) {
  ;(n *= Tt), (e *= Tt)
  var t = Pt(e),
    i = t * Pt(n),
    r = t * wt(n),
    s = wt(e),
    o = Ei * s - Ti * r,
    a = Ti * i - Si * s,
    A = Si * r - Ei * i,
    c = G1(o, a, A),
    d = Ws(c),
    p = c && -d / c
  X1.add(p * o),
    Y1.add(p * a),
    Z1.add(p * A),
    (P0 += d),
    (B0 += d * (Si + (Si = i))),
    (k0 += d * (Ei + (Ei = r))),
    (O0 += d * (Ti + (Ti = s))),
    Qu(Si, Ei, Ti)
}
function Y3(n) {
  ;(bA = P0 = L0 = D0 = I0 = B0 = k0 = O0 = 0),
    (X1 = new ks()),
    (Y1 = new ks()),
    (Z1 = new ks()),
    Yd(n, Br)
  var e = +X1,
    t = +Y1,
    i = +Z1,
    r = G1(e, t, i)
  return r < M0 &&
    ((e = B0),
    (t = k0),
    (i = O0),
    P0 < qt && ((e = L0), (t = D0), (i = I0)),
    (r = G1(e, t, i)),
    r < M0)
    ? [NaN, NaN]
    : [wr(t, e) * Ln, Ws(i / r) * Ln]
}
function J1(n, e) {
  function t(i, r) {
    return (i = n(i, r)), e(i[0], i[1])
  }
  return (
    n.invert &&
      e.invert &&
      (t.invert = function (i, r) {
        return (i = e.invert(i, r)), i && n.invert(i[0], i[1])
      }),
    t
  )
}
function K1(n, e) {
  return [An(n) > Vt ? n + Math.round(-n / lr) * lr : n, e]
}
K1.invert = K1
function t8(n, e, t) {
  return (n %= lr)
    ? e || t
      ? J1(J3(n), K3(e, t))
      : J3(n)
    : e || t
    ? K3(e, t)
    : K1
}
function Z3(n) {
  return function (e, t) {
    return (e += n), [e > Vt ? e - lr : e < -Vt ? e + lr : e, t]
  }
}
function J3(n) {
  var e = Z3(n)
  return (e.invert = Z3(-n)), e
}
function K3(n, e) {
  var t = Pt(n),
    i = wt(n),
    r = Pt(e),
    s = wt(e)
  function o(a, A) {
    var c = Pt(A),
      d = Pt(a) * c,
      p = wt(a) * c,
      m = wt(A),
      y = m * t + d * i
    return [wr(p * r - y * s, d * t - m * i), Ws(y * r + p * s)]
  }
  return (
    (o.invert = function (a, A) {
      var c = Pt(A),
        d = Pt(a) * c,
        p = wt(a) * c,
        m = wt(A),
        y = m * r - p * s
      return [wr(p * r + m * s, d * t + y * i), Ws(y * t - d * i)]
    }),
    o
  )
}
function TN(n) {
  n = t8(n[0] * Tt, n[1] * Tt, n.length > 2 ? n[2] * Tt : 0)
  function e(t) {
    return (t = n(t[0] * Tt, t[1] * Tt)), (t[0] *= Ln), (t[1] *= Ln), t
  }
  return (
    (e.invert = function (t) {
      return (t = n.invert(t[0] * Tt, t[1] * Tt)), (t[0] *= Ln), (t[1] *= Ln), t
    }),
    e
  )
}
function CN(n, e, t, i, r, s) {
  if (!!t) {
    var o = Pt(e),
      a = wt(e),
      A = i * t
    r == null
      ? ((r = e + i * lr), (s = e - A / 2))
      : ((r = ex(o, r)),
        (s = ex(o, s)),
        (i > 0 ? r < s : r > s) && (r += i * lr))
    for (var c, d = r; i > 0 ? d > s : d < s; d -= A)
      (c = C0([o, -a * Pt(d), -a * wt(d)])), n.point(c[0], c[1])
  }
}
function ex(n, e) {
  ;(e = Qa(e)), (e[0] -= n), R0(e)
  var t = pN(-e[1])
  return ((-e[2] < 0 ? -t : t) + lr - qt) % lr
}
function n8() {
  var n = [],
    e
  return {
    point: function (t, i, r) {
      e.push([t, i, r])
    },
    lineStart: function () {
      n.push((e = []))
    },
    lineEnd: di,
    rejoin: function () {
      n.length > 1 && n.push(n.pop().concat(n.shift()))
    },
    result: function () {
      var t = n
      return (n = []), (e = null), t
    },
  }
}
function Xh(n, e) {
  return An(n[0] - e[0]) < qt && An(n[1] - e[1]) < qt
}
function Sh(n, e, t, i) {
  ;(this.x = n),
    (this.z = e),
    (this.o = t),
    (this.e = i),
    (this.v = !1),
    (this.n = this.p = null)
}
function i8(n, e, t, i, r) {
  var s = [],
    o = [],
    a,
    A
  if (
    (n.forEach(function (x) {
      if (!((S = x.length - 1) <= 0)) {
        var S,
          C = x[0],
          M = x[S],
          _
        if (Xh(C, M)) {
          if (!C[2] && !M[2]) {
            for (r.lineStart(), a = 0; a < S; ++a) r.point((C = x[a])[0], C[1])
            r.lineEnd()
            return
          }
          M[0] += 2 * qt
        }
        s.push((_ = new Sh(C, x, null, !0))),
          o.push((_.o = new Sh(C, null, _, !1))),
          s.push((_ = new Sh(M, x, null, !1))),
          o.push((_.o = new Sh(M, null, _, !0)))
      }
    }),
    !!s.length)
  ) {
    for (o.sort(e), tx(s), tx(o), a = 0, A = o.length; a < A; ++a)
      o[a].e = t = !t
    for (var c = s[0], d, p; ; ) {
      for (var m = c, y = !0; m.v; ) if ((m = m.n) === c) return
      ;(d = m.z), r.lineStart()
      do {
        if (((m.v = m.o.v = !0), m.e)) {
          if (y)
            for (a = 0, A = d.length; a < A; ++a) r.point((p = d[a])[0], p[1])
          else i(m.x, m.n.x, 1, r)
          m = m.n
        } else {
          if (y)
            for (d = m.p.z, a = d.length - 1; a >= 0; --a)
              r.point((p = d[a])[0], p[1])
          else i(m.x, m.p.x, -1, r)
          m = m.p
        }
        ;(m = m.o), (d = m.z), (y = !y)
      } while (!m.v)
      r.lineEnd()
    }
  }
}
function tx(n) {
  if (!!(e = n.length)) {
    for (var e, t = 0, i = n[0], r; ++t < e; )
      (i.n = r = n[t]), (r.p = i), (i = r)
    ;(i.n = r = n[0]), (r.p = i)
  }
}
function dm(n) {
  return An(n[0]) <= Vt ? n[0] : dN(n[0]) * (((An(n[0]) + Vt) % lr) - Vt)
}
function r8(n, e) {
  var t = dm(e),
    i = e[1],
    r = wt(i),
    s = [wt(t), -Pt(t), 0],
    o = 0,
    a = 0,
    A = new ks()
  r === 1 ? (i = yr + qt) : r === -1 && (i = -yr - qt)
  for (var c = 0, d = n.length; c < d; ++c)
    if (!!(m = (p = n[c]).length))
      for (
        var p,
          m,
          y = p[m - 1],
          x = dm(y),
          S = y[1] / 2 + S0,
          C = wt(S),
          M = Pt(S),
          _ = 0;
        _ < m;
        ++_, x = T, C = B, M = k, y = R
      ) {
        var R = p[_],
          T = dm(R),
          L = R[1] / 2 + S0,
          B = wt(L),
          k = Pt(L),
          O = T - x,
          W = O >= 0 ? 1 : -1,
          z = W * O,
          P = z > Vt,
          N = C * B
        if (
          (A.add(wr(N * W * wt(z), M * k + N * Pt(z))),
          (o += P ? O + W * lr : O),
          P ^ (x >= t) ^ (T >= t))
        ) {
          var G = Rc(Qa(y), Qa(R))
          R0(G)
          var j = Rc(s, G)
          R0(j)
          var V = (P ^ (O >= 0) ? -1 : 1) * Ws(j[2])
          ;(i > V || (i === V && (G[0] || G[1]))) &&
            (a += P ^ (O >= 0) ? 1 : -1)
        }
      }
  return (o < -qt || (o < qt && A < -M0)) ^ (a & 1)
}
function s8(n, e, t, i) {
  return function (r) {
    var s = e(r),
      o = n8(),
      a = e(o),
      A = !1,
      c,
      d,
      p,
      m = {
        point: y,
        lineStart: S,
        lineEnd: C,
        polygonStart: function () {
          ;(m.point = M), (m.lineStart = _), (m.lineEnd = R), (d = []), (c = [])
        },
        polygonEnd: function () {
          ;(m.point = y), (m.lineStart = S), (m.lineEnd = C), (d = gu(d))
          var T = r8(c, i)
          d.length
            ? (A || (r.polygonStart(), (A = !0)), i8(d, PN, T, t, r))
            : T &&
              (A || (r.polygonStart(), (A = !0)),
              r.lineStart(),
              t(null, null, 1, r),
              r.lineEnd()),
            A && (r.polygonEnd(), (A = !1)),
            (d = c = null)
        },
        sphere: function () {
          r.polygonStart(),
            r.lineStart(),
            t(null, null, 1, r),
            r.lineEnd(),
            r.polygonEnd()
        },
      }
    function y(T, L) {
      n(T, L) && r.point(T, L)
    }
    function x(T, L) {
      s.point(T, L)
    }
    function S() {
      ;(m.point = x), s.lineStart()
    }
    function C() {
      ;(m.point = y), s.lineEnd()
    }
    function M(T, L) {
      p.push([T, L]), a.point(T, L)
    }
    function _() {
      a.lineStart(), (p = [])
    }
    function R() {
      M(p[0][0], p[0][1]), a.lineEnd()
      var T = a.clean(),
        L = o.result(),
        B,
        k = L.length,
        O,
        W,
        z
      if ((p.pop(), c.push(p), (p = null), !!k)) {
        if (T & 1) {
          if (((W = L[0]), (O = W.length - 1) > 0)) {
            for (
              A || (r.polygonStart(), (A = !0)), r.lineStart(), B = 0;
              B < O;
              ++B
            )
              r.point((z = W[B])[0], z[1])
            r.lineEnd()
          }
          return
        }
        k > 1 && T & 2 && L.push(L.pop().concat(L.shift())),
          d.push(L.filter(RN))
      }
    }
    return m
  }
}
function RN(n) {
  return n.length > 1
}
function PN(n, e) {
  return (
    ((n = n.x)[0] < 0 ? n[1] - yr - qt : yr - n[1]) -
    ((e = e.x)[0] < 0 ? e[1] - yr - qt : yr - e[1])
  )
}
var nx = s8(
  function () {
    return !0
  },
  LN,
  IN,
  [-Vt, -yr]
)
function LN(n) {
  var e = NaN,
    t = NaN,
    i = NaN,
    r
  return {
    lineStart: function () {
      n.lineStart(), (r = 1)
    },
    point: function (s, o) {
      var a = s > 0 ? Vt : -Vt,
        A = An(s - e)
      An(A - Vt) < qt
        ? (n.point(e, (t = (t + o) / 2 > 0 ? yr : -yr)),
          n.point(i, t),
          n.lineEnd(),
          n.lineStart(),
          n.point(a, t),
          n.point(s, t),
          (r = 0))
        : i !== a &&
          A >= Vt &&
          (An(e - i) < qt && (e -= i * qt),
          An(s - a) < qt && (s -= a * qt),
          (t = DN(e, t, s, o)),
          n.point(i, t),
          n.lineEnd(),
          n.lineStart(),
          n.point(a, t),
          (r = 0)),
        n.point((e = s), (t = o)),
        (i = a)
    },
    lineEnd: function () {
      n.lineEnd(), (e = t = NaN)
    },
    clean: function () {
      return 2 - r
    },
  }
}
function DN(n, e, t, i) {
  var r,
    s,
    o = wt(n - t)
  return An(o) > qt
    ? G6(
        (wt(e) * (s = Pt(i)) * wt(t) - wt(i) * (r = Pt(e)) * wt(n)) /
          (r * s * o)
      )
    : (e + i) / 2
}
function IN(n, e, t, i) {
  var r
  if (n == null)
    (r = t * yr),
      i.point(-Vt, r),
      i.point(0, r),
      i.point(Vt, r),
      i.point(Vt, 0),
      i.point(Vt, -r),
      i.point(0, -r),
      i.point(-Vt, -r),
      i.point(-Vt, 0),
      i.point(-Vt, r)
  else if (An(n[0] - e[0]) > qt) {
    var s = n[0] < e[0] ? Vt : -Vt
    ;(r = (t * s) / 2), i.point(-s, r), i.point(0, r), i.point(s, r)
  } else i.point(e[0], e[1])
}
function BN(n) {
  var e = Pt(n),
    t = 6 * Tt,
    i = e > 0,
    r = An(e) > qt
  function s(d, p, m, y) {
    CN(y, n, t, m, d, p)
  }
  function o(d, p) {
    return Pt(d) * Pt(p) > e
  }
  function a(d) {
    var p, m, y, x, S
    return {
      lineStart: function () {
        ;(x = y = !1), (S = 1)
      },
      point: function (C, M) {
        var _ = [C, M],
          R,
          T = o(C, M),
          L = i ? (T ? 0 : c(C, M)) : T ? c(C + (C < 0 ? Vt : -Vt), M) : 0
        if (
          (!p && (x = y = T) && d.lineStart(),
          T !== y &&
            ((R = A(p, _)), (!R || Xh(p, R) || Xh(_, R)) && (_[2] = 1)),
          T !== y)
        )
          (S = 0),
            T
              ? (d.lineStart(), (R = A(_, p)), d.point(R[0], R[1]))
              : ((R = A(p, _)), d.point(R[0], R[1], 2), d.lineEnd()),
            (p = R)
        else if (r && p && i ^ T) {
          var B
          !(L & m) &&
            (B = A(_, p, !0)) &&
            ((S = 0),
            i
              ? (d.lineStart(),
                d.point(B[0][0], B[0][1]),
                d.point(B[1][0], B[1][1]),
                d.lineEnd())
              : (d.point(B[1][0], B[1][1]),
                d.lineEnd(),
                d.lineStart(),
                d.point(B[0][0], B[0][1], 3)))
        }
        T && (!p || !Xh(p, _)) && d.point(_[0], _[1]), (p = _), (y = T), (m = L)
      },
      lineEnd: function () {
        y && d.lineEnd(), (p = null)
      },
      clean: function () {
        return S | ((x && y) << 1)
      },
    }
  }
  function A(d, p, m) {
    var y = Qa(d),
      x = Qa(p),
      S = [1, 0, 0],
      C = Rc(y, x),
      M = wh(C, C),
      _ = C[0],
      R = M - _ * _
    if (!R) return !m && d
    var T = (e * M) / R,
      L = (-e * _) / R,
      B = Rc(S, C),
      k = Mh(S, T),
      O = Mh(C, L)
    hm(k, O)
    var W = B,
      z = wh(k, W),
      P = wh(W, W),
      N = z * z - P * (wh(k, k) - 1)
    if (!(N < 0)) {
      var G = Vs(N),
        j = Mh(W, (-z - G) / P)
      if ((hm(j, k), (j = C0(j)), !m)) return j
      var V = d[0],
        Y = p[0],
        ne = d[1],
        le = p[1],
        Te
      Y < V && ((Te = V), (V = Y), (Y = Te))
      var Ae = Y - V,
        ge = An(Ae - Vt) < qt,
        Me = ge || Ae < qt
      if (
        (!ge && le < ne && ((Te = ne), (ne = le), (le = Te)),
        Me
          ? ge
            ? (ne + le > 0) ^ (j[1] < (An(j[0] - V) < qt ? ne : le))
            : ne <= j[1] && j[1] <= le
          : (Ae > Vt) ^ (V <= j[0] && j[0] <= Y))
      ) {
        var Ne = Mh(W, (-z + G) / P)
        return hm(Ne, k), [j, C0(Ne)]
      }
    }
  }
  function c(d, p) {
    var m = i ? n : Vt - n,
      y = 0
    return (
      d < -m ? (y |= 1) : d > m && (y |= 2),
      p < -m ? (y |= 4) : p > m && (y |= 8),
      y
    )
  }
  return s8(o, a, s, i ? [0, -n] : [-Vt, n - Vt])
}
function kN(n, e, t, i, r, s) {
  var o = n[0],
    a = n[1],
    A = e[0],
    c = e[1],
    d = 0,
    p = 1,
    m = A - o,
    y = c - a,
    x
  if (((x = t - o), !(!m && x > 0))) {
    if (((x /= m), m < 0)) {
      if (x < d) return
      x < p && (p = x)
    } else if (m > 0) {
      if (x > p) return
      x > d && (d = x)
    }
    if (((x = r - o), !(!m && x < 0))) {
      if (((x /= m), m < 0)) {
        if (x > p) return
        x > d && (d = x)
      } else if (m > 0) {
        if (x < d) return
        x < p && (p = x)
      }
      if (((x = i - a), !(!y && x > 0))) {
        if (((x /= y), y < 0)) {
          if (x < d) return
          x < p && (p = x)
        } else if (y > 0) {
          if (x > p) return
          x > d && (d = x)
        }
        if (((x = s - a), !(!y && x < 0))) {
          if (((x /= y), y < 0)) {
            if (x > p) return
            x > d && (d = x)
          } else if (y > 0) {
            if (x < d) return
            x < p && (p = x)
          }
          return (
            d > 0 && ((n[0] = o + d * m), (n[1] = a + d * y)),
            p < 1 && ((e[0] = o + p * m), (e[1] = a + p * y)),
            !0
          )
        }
      }
    }
  }
}
var wA = 1e9,
  Eh = -wA
function ON(n, e, t, i) {
  function r(c, d) {
    return n <= c && c <= t && e <= d && d <= i
  }
  function s(c, d, p, m) {
    var y = 0,
      x = 0
    if (c == null || (y = o(c, p)) !== (x = o(d, p)) || (A(c, d) < 0) ^ (p > 0))
      do m.point(y === 0 || y === 3 ? n : t, y > 1 ? i : e)
      while ((y = (y + p + 4) % 4) !== x)
    else m.point(d[0], d[1])
  }
  function o(c, d) {
    return An(c[0] - n) < qt
      ? d > 0
        ? 0
        : 3
      : An(c[0] - t) < qt
      ? d > 0
        ? 2
        : 1
      : An(c[1] - e) < qt
      ? d > 0
        ? 1
        : 0
      : d > 0
      ? 3
      : 2
  }
  function a(c, d) {
    return A(c.x, d.x)
  }
  function A(c, d) {
    var p = o(c, 1),
      m = o(d, 1)
    return p !== m
      ? p - m
      : p === 0
      ? d[1] - c[1]
      : p === 1
      ? c[0] - d[0]
      : p === 2
      ? c[1] - d[1]
      : d[0] - c[0]
  }
  return function (c) {
    var d = c,
      p = n8(),
      m,
      y,
      x,
      S,
      C,
      M,
      _,
      R,
      T,
      L,
      B,
      k = { point: O, lineStart: N, lineEnd: G, polygonStart: z, polygonEnd: P }
    function O(V, Y) {
      r(V, Y) && d.point(V, Y)
    }
    function W() {
      for (var V = 0, Y = 0, ne = y.length; Y < ne; ++Y)
        for (
          var le = y[Y],
            Te = 1,
            Ae = le.length,
            ge = le[0],
            Me,
            Ne,
            Ze = ge[0],
            K = ge[1];
          Te < Ae;
          ++Te
        )
          (Me = Ze),
            (Ne = K),
            (ge = le[Te]),
            (Ze = ge[0]),
            (K = ge[1]),
            Ne <= i
              ? K > i && (Ze - Me) * (i - Ne) > (K - Ne) * (n - Me) && ++V
              : K <= i && (Ze - Me) * (i - Ne) < (K - Ne) * (n - Me) && --V
      return V
    }
    function z() {
      ;(d = p), (m = []), (y = []), (B = !0)
    }
    function P() {
      var V = W(),
        Y = B && V,
        ne = (m = gu(m)).length
      ;(Y || ne) &&
        (c.polygonStart(),
        Y && (c.lineStart(), s(null, null, 1, c), c.lineEnd()),
        ne && i8(m, a, V, s, c),
        c.polygonEnd()),
        (d = c),
        (m = y = x = null)
    }
    function N() {
      ;(k.point = j), y && y.push((x = [])), (L = !0), (T = !1), (_ = R = NaN)
    }
    function G() {
      m && (j(S, C), M && T && p.rejoin(), m.push(p.result())),
        (k.point = O),
        T && d.lineEnd()
    }
    function j(V, Y) {
      var ne = r(V, Y)
      if ((y && x.push([V, Y]), L))
        (S = V),
          (C = Y),
          (M = ne),
          (L = !1),
          ne && (d.lineStart(), d.point(V, Y))
      else if (ne && T) d.point(V, Y)
      else {
        var le = [
            (_ = Math.max(Eh, Math.min(wA, _))),
            (R = Math.max(Eh, Math.min(wA, R))),
          ],
          Te = [
            (V = Math.max(Eh, Math.min(wA, V))),
            (Y = Math.max(Eh, Math.min(wA, Y))),
          ]
        kN(le, Te, n, e, t, i)
          ? (T || (d.lineStart(), d.point(le[0], le[1])),
            d.point(Te[0], Te[1]),
            ne || d.lineEnd(),
            (B = !1))
          : ne && (d.lineStart(), d.point(V, Y), (B = !1))
      }
      ;(_ = V), (R = Y), (T = ne)
    }
    return k
  }
}
var eg,
  tg,
  Yh,
  Zh,
  Pc = {
    sphere: di,
    point: di,
    lineStart: qN,
    lineEnd: di,
    polygonStart: di,
    polygonEnd: di,
  }
function qN() {
  ;(Pc.point = NN), (Pc.lineEnd = FN)
}
function FN() {
  Pc.point = Pc.lineEnd = di
}
function NN(n, e) {
  ;(n *= Tt), (e *= Tt), (tg = n), (Yh = wt(e)), (Zh = Pt(e)), (Pc.point = UN)
}
function UN(n, e) {
  ;(n *= Tt), (e *= Tt)
  var t = wt(e),
    i = Pt(e),
    r = An(n - tg),
    s = Pt(r),
    o = wt(r),
    a = i * o,
    A = Zh * t - Yh * i * s,
    c = Yh * t + Zh * i * s
  eg.add(wr(Vs(a * a + A * A), c)), (tg = n), (Yh = t), (Zh = i)
}
function zN(n) {
  return (eg = new ks()), Yd(n, Pc), +eg
}
var ng = [null, null],
  HN = { type: "LineString", coordinates: ng }
function Ho(n, e) {
  return (ng[0] = n), (ng[1] = e), zN(HN)
}
var ix = {
    Feature: function (n, e) {
      return q0(n.geometry, e)
    },
    FeatureCollection: function (n, e) {
      for (var t = n.features, i = -1, r = t.length; ++i < r; )
        if (q0(t[i].geometry, e)) return !0
      return !1
    },
  },
  rx = {
    Sphere: function () {
      return !0
    },
    Point: function (n, e) {
      return sx(n.coordinates, e)
    },
    MultiPoint: function (n, e) {
      for (var t = n.coordinates, i = -1, r = t.length; ++i < r; )
        if (sx(t[i], e)) return !0
      return !1
    },
    LineString: function (n, e) {
      return ox(n.coordinates, e)
    },
    MultiLineString: function (n, e) {
      for (var t = n.coordinates, i = -1, r = t.length; ++i < r; )
        if (ox(t[i], e)) return !0
      return !1
    },
    Polygon: function (n, e) {
      return ax(n.coordinates, e)
    },
    MultiPolygon: function (n, e) {
      for (var t = n.coordinates, i = -1, r = t.length; ++i < r; )
        if (ax(t[i], e)) return !0
      return !1
    },
    GeometryCollection: function (n, e) {
      for (var t = n.geometries, i = -1, r = t.length; ++i < r; )
        if (q0(t[i], e)) return !0
      return !1
    },
  }
function q0(n, e) {
  return n && rx.hasOwnProperty(n.type) ? rx[n.type](n, e) : !1
}
function sx(n, e) {
  return Ho(n, e) === 0
}
function ox(n, e) {
  for (var t, i, r, s = 0, o = n.length; s < o; s++) {
    if (
      ((i = Ho(n[s], e)),
      i === 0 ||
        (s > 0 &&
          ((r = Ho(n[s], n[s - 1])),
          r > 0 &&
            t <= r &&
            i <= r &&
            (t + i - r) * (1 - Math.pow((t - i) / r, 2)) < M0 * r)))
    )
      return !0
    t = i
  }
  return !1
}
function ax(n, e) {
  return !!r8(n.map(GN), o8(e))
}
function GN(n) {
  return (n = n.map(o8)), n.pop(), n
}
function o8(n) {
  return [n[0] * Tt, n[1] * Tt]
}
function VN(n, e) {
  return (n && ix.hasOwnProperty(n.type) ? ix[n.type] : q0)(n, e)
}
function lx(n, e, t) {
  var i = Wl(n, e - qt, t).concat(e)
  return function (r) {
    return i.map(function (s) {
      return [r, s]
    })
  }
}
function cx(n, e, t) {
  var i = Wl(n, e - qt, t).concat(e)
  return function (r) {
    return i.map(function (s) {
      return [s, r]
    })
  }
}
function WN() {
  var n,
    e,
    t,
    i,
    r,
    s,
    o,
    a,
    A = 10,
    c = A,
    d = 90,
    p = 360,
    m,
    y,
    x,
    S,
    C = 2.5
  function M() {
    return { type: "MultiLineString", coordinates: _() }
  }
  function _() {
    return Wl(bh(i / d) * d, t, d)
      .map(x)
      .concat(Wl(bh(a / p) * p, o, p).map(S))
      .concat(
        Wl(bh(e / A) * A, n, A)
          .filter(function (R) {
            return An(R % d) > qt
          })
          .map(m)
      )
      .concat(
        Wl(bh(s / c) * c, r, c)
          .filter(function (R) {
            return An(R % p) > qt
          })
          .map(y)
      )
  }
  return (
    (M.lines = function () {
      return _().map(function (R) {
        return { type: "LineString", coordinates: R }
      })
    }),
    (M.outline = function () {
      return {
        type: "Polygon",
        coordinates: [
          x(i).concat(
            S(o).slice(1),
            x(t).reverse().slice(1),
            S(a).reverse().slice(1)
          ),
        ],
      }
    }),
    (M.extent = function (R) {
      return arguments.length
        ? M.extentMajor(R).extentMinor(R)
        : M.extentMinor()
    }),
    (M.extentMajor = function (R) {
      return arguments.length
        ? ((i = +R[0][0]),
          (t = +R[1][0]),
          (a = +R[0][1]),
          (o = +R[1][1]),
          i > t && ((R = i), (i = t), (t = R)),
          a > o && ((R = a), (a = o), (o = R)),
          M.precision(C))
        : [
            [i, a],
            [t, o],
          ]
    }),
    (M.extentMinor = function (R) {
      return arguments.length
        ? ((e = +R[0][0]),
          (n = +R[1][0]),
          (s = +R[0][1]),
          (r = +R[1][1]),
          e > n && ((R = e), (e = n), (n = R)),
          s > r && ((R = s), (s = r), (r = R)),
          M.precision(C))
        : [
            [e, s],
            [n, r],
          ]
    }),
    (M.step = function (R) {
      return arguments.length ? M.stepMajor(R).stepMinor(R) : M.stepMinor()
    }),
    (M.stepMajor = function (R) {
      return arguments.length ? ((d = +R[0]), (p = +R[1]), M) : [d, p]
    }),
    (M.stepMinor = function (R) {
      return arguments.length ? ((A = +R[0]), (c = +R[1]), M) : [A, c]
    }),
    (M.precision = function (R) {
      return arguments.length
        ? ((C = +R),
          (m = lx(s, r, 90)),
          (y = cx(e, n, C)),
          (x = lx(a, o, 90)),
          (S = cx(i, t, C)),
          M)
        : C
    }),
    M.extentMajor([
      [-180, -90 + qt],
      [180, 90 - qt],
    ]).extentMinor([
      [-180, -80 - qt],
      [180, 80 + qt],
    ])
  )
}
function jN() {
  return WN()()
}
function V2(n, e) {
  var t = n[0] * Tt,
    i = n[1] * Tt,
    r = e[0] * Tt,
    s = e[1] * Tt,
    o = Pt(i),
    a = wt(i),
    A = Pt(s),
    c = wt(s),
    d = o * Pt(t),
    p = o * wt(t),
    m = A * Pt(r),
    y = A * wt(r),
    x = 2 * Ws(Vs(U3(s - i) + o * A * U3(r - t))),
    S = wt(x),
    C = x
      ? function (M) {
          var _ = wt((M *= x)) / S,
            R = wt(x - M) / S,
            T = R * d + _ * m,
            L = R * p + _ * y,
            B = R * a + _ * c
          return [wr(L, T) * Ln, wr(B, Vs(T * T + L * L)) * Ln]
        }
      : function () {
          return [t * Ln, i * Ln]
        }
  return (C.distance = x), C
}
var Ax = n => n,
  Lc = 1 / 0,
  F0 = Lc,
  yu = -Lc,
  N0 = yu,
  $N = {
    point: QN,
    lineStart: di,
    lineEnd: di,
    polygonStart: di,
    polygonEnd: di,
    result: function () {
      var n = [
        [Lc, F0],
        [yu, N0],
      ]
      return (yu = N0 = -(F0 = Lc = 1 / 0)), n
    },
  }
function QN(n, e) {
  n < Lc && (Lc = n), n > yu && (yu = n), e < F0 && (F0 = e), e > N0 && (N0 = e)
}
var ux = $N
function W2(n) {
  return function (e) {
    var t = new ig()
    for (var i in n) t[i] = n[i]
    return (t.stream = e), t
  }
}
function ig() {}
ig.prototype = {
  constructor: ig,
  point: function (n, e) {
    this.stream.point(n, e)
  },
  sphere: function () {
    this.stream.sphere()
  },
  lineStart: function () {
    this.stream.lineStart()
  },
  lineEnd: function () {
    this.stream.lineEnd()
  },
  polygonStart: function () {
    this.stream.polygonStart()
  },
  polygonEnd: function () {
    this.stream.polygonEnd()
  },
}
function j2(n, e, t) {
  var i = n.clipExtent && n.clipExtent()
  return (
    n.scale(150).translate([0, 0]),
    i != null && n.clipExtent(null),
    Yd(t, n.stream(ux)),
    e(ux.result()),
    i != null && n.clipExtent(i),
    n
  )
}
function a8(n, e, t) {
  return j2(
    n,
    function (i) {
      var r = e[1][0] - e[0][0],
        s = e[1][1] - e[0][1],
        o = Math.min(r / (i[1][0] - i[0][0]), s / (i[1][1] - i[0][1])),
        a = +e[0][0] + (r - o * (i[1][0] + i[0][0])) / 2,
        A = +e[0][1] + (s - o * (i[1][1] + i[0][1])) / 2
      n.scale(150 * o).translate([a, A])
    },
    t
  )
}
function XN(n, e, t) {
  return a8(n, [[0, 0], e], t)
}
function YN(n, e, t) {
  return j2(
    n,
    function (i) {
      var r = +e,
        s = r / (i[1][0] - i[0][0]),
        o = (r - s * (i[1][0] + i[0][0])) / 2,
        a = -s * i[0][1]
      n.scale(150 * s).translate([o, a])
    },
    t
  )
}
function ZN(n, e, t) {
  return j2(
    n,
    function (i) {
      var r = +e,
        s = r / (i[1][1] - i[0][1]),
        o = -s * i[0][0],
        a = (r - s * (i[1][1] + i[0][1])) / 2
      n.scale(150 * s).translate([o, a])
    },
    t
  )
}
var fx = 16,
  JN = Pt(30 * Tt)
function hx(n, e) {
  return +e ? eU(n, e) : KN(n)
}
function KN(n) {
  return W2({
    point: function (e, t) {
      ;(e = n(e, t)), this.stream.point(e[0], e[1])
    },
  })
}
function eU(n, e) {
  function t(i, r, s, o, a, A, c, d, p, m, y, x, S, C) {
    var M = c - i,
      _ = d - r,
      R = M * M + _ * _
    if (R > 4 * e && S--) {
      var T = o + m,
        L = a + y,
        B = A + x,
        k = Vs(T * T + L * L + B * B),
        O = Ws((B /= k)),
        W = An(An(B) - 1) < qt || An(s - p) < qt ? (s + p) / 2 : wr(L, T),
        z = n(W, O),
        P = z[0],
        N = z[1],
        G = P - i,
        j = N - r,
        V = _ * G - M * j
      ;((V * V) / R > e ||
        An((M * G + _ * j) / R - 0.5) > 0.3 ||
        o * m + a * y + A * x < JN) &&
        (t(i, r, s, o, a, A, P, N, W, (T /= k), (L /= k), B, S, C),
        C.point(P, N),
        t(P, N, W, T, L, B, c, d, p, m, y, x, S, C))
    }
  }
  return function (i) {
    var r,
      s,
      o,
      a,
      A,
      c,
      d,
      p,
      m,
      y,
      x,
      S,
      C = {
        point: M,
        lineStart: _,
        lineEnd: T,
        polygonStart: function () {
          i.polygonStart(), (C.lineStart = L)
        },
        polygonEnd: function () {
          i.polygonEnd(), (C.lineStart = _)
        },
      }
    function M(O, W) {
      ;(O = n(O, W)), i.point(O[0], O[1])
    }
    function _() {
      ;(p = NaN), (C.point = R), i.lineStart()
    }
    function R(O, W) {
      var z = Qa([O, W]),
        P = n(O, W)
      t(
        p,
        m,
        d,
        y,
        x,
        S,
        (p = P[0]),
        (m = P[1]),
        (d = O),
        (y = z[0]),
        (x = z[1]),
        (S = z[2]),
        fx,
        i
      ),
        i.point(p, m)
    }
    function T() {
      ;(C.point = M), i.lineEnd()
    }
    function L() {
      _(), (C.point = B), (C.lineEnd = k)
    }
    function B(O, W) {
      R((r = O), W), (s = p), (o = m), (a = y), (A = x), (c = S), (C.point = R)
    }
    function k() {
      t(p, m, d, y, x, S, s, o, r, a, A, c, fx, i), (C.lineEnd = T), T()
    }
    return C
  }
}
var tU = W2({
  point: function (n, e) {
    this.stream.point(n * Tt, e * Tt)
  },
})
function nU(n) {
  return W2({
    point: function (e, t) {
      var i = n(e, t)
      return this.stream.point(i[0], i[1])
    },
  })
}
function iU(n, e, t, i, r) {
  function s(o, a) {
    return (o *= i), (a *= r), [e + n * o, t - n * a]
  }
  return (
    (s.invert = function (o, a) {
      return [((o - e) / n) * i, ((t - a) / n) * r]
    }),
    s
  )
}
function dx(n, e, t, i, r, s) {
  if (!s) return iU(n, e, t, i, r)
  var o = Pt(s),
    a = wt(s),
    A = o * n,
    c = a * n,
    d = o / n,
    p = a / n,
    m = (a * t - o * e) / n,
    y = (a * e + o * t) / n
  function x(S, C) {
    return (S *= i), (C *= r), [A * S - c * C + e, t - c * S - A * C]
  }
  return (
    (x.invert = function (S, C) {
      return [i * (d * S - p * C + m), r * (y - p * S - d * C)]
    }),
    x
  )
}
function rU(n) {
  return sU(function () {
    return n
  })()
}
function sU(n) {
  var e,
    t = 150,
    i = 480,
    r = 250,
    s = 0,
    o = 0,
    a = 0,
    A = 0,
    c = 0,
    d,
    p = 0,
    m = 1,
    y = 1,
    x = null,
    S = nx,
    C = null,
    M,
    _,
    R,
    T = Ax,
    L = 0.5,
    B,
    k,
    O,
    W,
    z
  function P(V) {
    return O(V[0] * Tt, V[1] * Tt)
  }
  function N(V) {
    return (V = O.invert(V[0], V[1])), V && [V[0] * Ln, V[1] * Ln]
  }
  ;(P.stream = function (V) {
    return W && z === V ? W : (W = tU(nU(d)(S(B(T((z = V)))))))
  }),
    (P.preclip = function (V) {
      return arguments.length ? ((S = V), (x = void 0), j()) : S
    }),
    (P.postclip = function (V) {
      return arguments.length ? ((T = V), (C = M = _ = R = null), j()) : T
    }),
    (P.clipAngle = function (V) {
      return arguments.length
        ? ((S = +V ? BN((x = V * Tt)) : ((x = null), nx)), j())
        : x * Ln
    }),
    (P.clipExtent = function (V) {
      return arguments.length
        ? ((T =
            V == null
              ? ((C = M = _ = R = null), Ax)
              : ON(
                  (C = +V[0][0]),
                  (M = +V[0][1]),
                  (_ = +V[1][0]),
                  (R = +V[1][1])
                )),
          j())
        : C == null
        ? null
        : [
            [C, M],
            [_, R],
          ]
    }),
    (P.scale = function (V) {
      return arguments.length ? ((t = +V), G()) : t
    }),
    (P.translate = function (V) {
      return arguments.length ? ((i = +V[0]), (r = +V[1]), G()) : [i, r]
    }),
    (P.center = function (V) {
      return arguments.length
        ? ((s = (V[0] % 360) * Tt), (o = (V[1] % 360) * Tt), G())
        : [s * Ln, o * Ln]
    }),
    (P.rotate = function (V) {
      return arguments.length
        ? ((a = (V[0] % 360) * Tt),
          (A = (V[1] % 360) * Tt),
          (c = V.length > 2 ? (V[2] % 360) * Tt : 0),
          G())
        : [a * Ln, A * Ln, c * Ln]
    }),
    (P.angle = function (V) {
      return arguments.length ? ((p = (V % 360) * Tt), G()) : p * Ln
    }),
    (P.reflectX = function (V) {
      return arguments.length ? ((m = V ? -1 : 1), G()) : m < 0
    }),
    (P.reflectY = function (V) {
      return arguments.length ? ((y = V ? -1 : 1), G()) : y < 0
    }),
    (P.precision = function (V) {
      return arguments.length ? ((B = hx(k, (L = V * V))), j()) : Vs(L)
    }),
    (P.fitExtent = function (V, Y) {
      return a8(P, V, Y)
    }),
    (P.fitSize = function (V, Y) {
      return XN(P, V, Y)
    }),
    (P.fitWidth = function (V, Y) {
      return YN(P, V, Y)
    }),
    (P.fitHeight = function (V, Y) {
      return ZN(P, V, Y)
    })
  function G() {
    var V = dx(t, 0, 0, m, y, p).apply(null, e(s, o)),
      Y = dx(t, i - V[0], r - V[1], m, y, p)
    return (
      (d = t8(a, A, c)), (k = J1(e, Y)), (O = J1(d, k)), (B = hx(k, L)), j()
    )
  }
  function j() {
    return (W = z = null), P
  }
  return function () {
    return (e = n.apply(this, arguments)), (P.invert = e.invert && N), G()
  }
}
function oU(n) {
  return function (e, t) {
    var i = Vs(e * e + t * t),
      r = n(i),
      s = wt(r),
      o = Pt(r)
    return [wr(e * s, i * o), Ws(i && (t * s) / i)]
  }
}
function l8(n, e) {
  var t = Pt(e),
    i = 1 + Pt(n) * t
  return [(t * wt(n)) / i, wt(e) / i]
}
l8.invert = oU(function (n) {
  return 2 * G6(n)
})
function aU() {
  return rU(l8).scale(250).clipAngle(142)
}
function lU(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function")
}
function cU(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 },
  })),
    e && rg(n, e)
}
function U0(n) {
  return (
    (U0 = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    U0(n)
  )
}
function rg(n, e) {
  return (
    (rg =
      Object.setPrototypeOf ||
      function (i, r) {
        return (i.__proto__ = r), i
      }),
    rg(n, e)
  )
}
function AU() {
  if (
    typeof Reflect == "undefined" ||
    !Reflect.construct ||
    Reflect.construct.sham
  )
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function uU(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function fU(n, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e
  if (e !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return uU(n)
}
function hU(n) {
  var e = AU()
  return function () {
    var i = U0(n),
      r
    if (e) {
      var s = U0(this).constructor
      r = Reflect.construct(i, arguments, s)
    } else r = i.apply(this, arguments)
    return fU(this, r)
  }
}
function uA(n, e) {
  return dU(n) || pU(n, e) || c8(n, e) || mU()
}
function dU(n) {
  if (Array.isArray(n)) return n
}
function pU(n, e) {
  var t =
    n == null
      ? null
      : (typeof Symbol != "undefined" && n[Symbol.iterator]) || n["@@iterator"]
  if (t != null) {
    var i = [],
      r = !0,
      s = !1,
      o,
      a
    try {
      for (
        t = t.call(n);
        !(r = (o = t.next()).done) && (i.push(o.value), !(e && i.length === e));
        r = !0
      );
    } catch (A) {
      ;(s = !0), (a = A)
    } finally {
      try {
        !r && t.return != null && t.return()
      } finally {
        if (s) throw a
      }
    }
    return i
  }
}
function c8(n, e) {
  if (!!n) {
    if (typeof n == "string") return px(n, e)
    var t = Object.prototype.toString.call(n).slice(8, -1)
    if (
      (t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set")
    )
      return Array.from(n)
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return px(n, e)
  }
}
function px(n, e) {
  ;(e == null || e > n.length) && (e = n.length)
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t]
  return i
}
function mU() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function gU(n, e) {
  var t =
    (typeof Symbol != "undefined" && n[Symbol.iterator]) || n["@@iterator"]
  if (!t) {
    if (
      Array.isArray(n) ||
      (t = c8(n)) ||
      (e && n && typeof n.length == "number")
    ) {
      t && (n = t)
      var i = 0,
        r = function () {}
      return {
        s: r,
        n: function () {
          return i >= n.length ? { done: !0 } : { done: !1, value: n[i++] }
        },
        e: function (A) {
          throw A
        },
        f: r,
      }
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
  }
  var s = !0,
    o = !1,
    a
  return {
    s: function () {
      t = t.call(n)
    },
    n: function () {
      var A = t.next()
      return (s = A.done), A
    },
    e: function (A) {
      ;(o = !0), (a = A)
    },
    f: function () {
      try {
        !s && t.return != null && t.return()
      } finally {
        if (o) throw a
      }
    },
  }
}
var mx = function () {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
      t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1,
      i = [],
      r = null
    return (
      e.forEach(function (s) {
        if (r) {
          var o = (Ho(s, r) * 180) / Math.PI
          if (o > t)
            for (var a = V2(r, s), A = 1 / Math.ceil(o / t), c = A; c < 1; )
              i.push(a(c)), (c += A)
        }
        i.push((r = s))
      }),
      i
    )
  },
  sg =
    typeof window != "undefined" && window.THREE
      ? window.THREE
      : { BufferGeometry: yt, Float32BufferAttribute: ut },
  yU = new sg.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute",
  A8 = (function (n) {
    cU(t, n)
    var e = hU(t)
    function t(i) {
      var r,
        s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1,
        o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5
      lU(this, t),
        (r = e.call(this)),
        (r.type = "GeoJsonGeometry"),
        (r.parameters = { geoJson: i, radius: s, resolution: o })
      var a = (
          {
            Point: p,
            MultiPoint: m,
            LineString: y,
            MultiLineString: x,
            Polygon: S,
            MultiPolygon: C,
          }[i.type] ||
          function () {
            return []
          }
        )(i.coordinates, s),
        A = [],
        c = [],
        d = 0
      a.forEach(function (M) {
        var _ = A.length
        fA({ indices: A, vertices: c }, M), r.addGroup(_, A.length - _, d++)
      }),
        A.length && r.setIndex(A),
        c.length && r[yU]("position", new sg.Float32BufferAttribute(c, 3))
      function p(M, _) {
        var R = pm(M[1], M[0], _),
          T = []
        return [{ vertices: R, indices: T }]
      }
      function m(M, _) {
        var R = { vertices: [], indices: [] }
        return (
          M.map(function (T) {
            return p(T, _)
          }).forEach(function (T) {
            var L = uA(T, 1),
              B = L[0]
            fA(R, B)
          }),
          [R]
        )
      }
      function y(M, _) {
        for (
          var R = mx(M, o).map(function (W) {
              var z = uA(W, 2),
                P = z[0],
                N = z[1]
              return pm(N, P, _)
            }),
            T = mu.flatten([R]),
            L = T.vertices,
            B = Math.round(L.length / 3),
            k = [],
            O = 1;
          O < B;
          O++
        )
          k.push(O - 1, O)
        return [{ vertices: L, indices: k }]
      }
      function x(M, _) {
        var R = { vertices: [], indices: [] }
        return (
          M.map(function (T) {
            return y(T, _)
          }).forEach(function (T) {
            var L = uA(T, 1),
              B = L[0]
            fA(R, B)
          }),
          [R]
        )
      }
      function S(M, _) {
        for (
          var R = M.map(function (Y) {
              return mx(Y, o).map(function (ne) {
                var le = uA(ne, 2),
                  Te = le[0],
                  Ae = le[1]
                return pm(Ae, Te, _)
              })
            }),
            T = mu.flatten(R),
            L = T.vertices,
            B = T.holes,
            k = B[0] || 1 / 0,
            O = L.slice(0, k * 3),
            W = L.slice(k * 3),
            z = new Set(B),
            P = Math.round(L.length / 3),
            N = [],
            G = [],
            j = 1;
          j < P;
          j++
        )
          z.has(j) || (j < k ? N.push(j - 1, j) : G.push(j - 1 - k, j - k))
        var V = [{ indices: N, vertices: O }]
        return B.length && V.push({ indices: G, vertices: W }), V
      }
      function C(M, _) {
        var R = { vertices: [], indices: [] },
          T = { vertices: [], indices: [] }
        M.map(function (B) {
          return S(B, _)
        }).forEach(function (B) {
          var k = uA(B, 2),
            O = k[0],
            W = k[1]
          fA(R, O), W && fA(T, W)
        })
        var L = [R]
        return T.vertices.length && L.push(T), L
      }
      return r
    }
    return t
  })(sg.BufferGeometry)
function fA(n, e) {
  var t = Math.round(n.vertices.length / 3)
  gx(n.vertices, e.vertices),
    gx(
      n.indices,
      e.indices.map(function (i) {
        return i + t
      })
    )
}
function gx(n, e) {
  var t = gU(e),
    i
  try {
    for (t.s(); !(i = t.n()).done; ) {
      var r = i.value
      n.push(r)
    }
  } catch (s) {
    t.e(s)
  } finally {
    t.f()
  }
}
function pm(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
    i = ((90 - n) * Math.PI) / 180,
    r = ((90 - e) * Math.PI) / 180
  return [
    t * Math.sin(i) * Math.cos(r),
    t * Math.cos(i),
    t * Math.sin(i) * Math.sin(r),
  ]
}
function vU(n) {
  n.computeTangents(),
    console.warn(
      "THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead."
    )
}
function _U(n, e = !1) {
  const t = n[0].index !== null,
    i = new Set(Object.keys(n[0].attributes)),
    r = new Set(Object.keys(n[0].morphAttributes)),
    s = {},
    o = {},
    a = n[0].morphTargetsRelative,
    A = new yt()
  let c = 0
  for (let d = 0; d < n.length; ++d) {
    const p = n[d]
    let m = 0
    if (t !== (p.index !== null))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
            d +
            ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."
        ),
        null
      )
    for (const y in p.attributes) {
      if (!i.has(y))
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
              d +
              '. All geometries must have compatible attributes; make sure "' +
              y +
              '" attribute exists among all geometries, or in none of them.'
          ),
          null
        )
      s[y] === void 0 && (s[y] = []), s[y].push(p.attributes[y]), m++
    }
    if (m !== i.size)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
            d +
            ". Make sure all geometries have the same number of attributes."
        ),
        null
      )
    if (a !== p.morphTargetsRelative)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
            d +
            ". .morphTargetsRelative must be consistent throughout all geometries."
        ),
        null
      )
    for (const y in p.morphAttributes) {
      if (!r.has(y))
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
              d +
              ".  .morphAttributes must be consistent throughout all geometries."
          ),
          null
        )
      o[y] === void 0 && (o[y] = []), o[y].push(p.morphAttributes[y])
    }
    if (
      ((A.userData.mergedUserData = A.userData.mergedUserData || []),
      A.userData.mergedUserData.push(p.userData),
      e)
    ) {
      let y
      if (t) y = p.index.count
      else if (p.attributes.position !== void 0) y = p.attributes.position.count
      else
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " +
              d +
              ". The geometry must have either an index or a position attribute"
          ),
          null
        )
      A.addGroup(c, y, d), (c += y)
    }
  }
  if (t) {
    let d = 0
    const p = []
    for (let m = 0; m < n.length; ++m) {
      const y = n[m].index
      for (let x = 0; x < y.count; ++x) p.push(y.getX(x) + d)
      d += n[m].attributes.position.count
    }
    A.setIndex(p)
  }
  for (const d in s) {
    const p = og(s[d])
    if (!p)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
            d +
            " attribute."
        ),
        null
      )
    A.setAttribute(d, p)
  }
  for (const d in o) {
    const p = o[d][0].length
    if (p === 0) break
    ;(A.morphAttributes = A.morphAttributes || {}), (A.morphAttributes[d] = [])
    for (let m = 0; m < p; ++m) {
      const y = []
      for (let S = 0; S < o[d].length; ++S) y.push(o[d][S][m])
      const x = og(y)
      if (!x)
        return (
          console.error(
            "THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " +
              d +
              " morphAttribute."
          ),
          null
        )
      A.morphAttributes[d].push(x)
    }
  }
  return A
}
function og(n) {
  let e,
    t,
    i,
    r = 0
  for (let a = 0; a < n.length; ++a) {
    const A = n[a]
    if (A.isInterleavedBufferAttribute)
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."
        ),
        null
      )
    if ((e === void 0 && (e = A.array.constructor), e !== A.array.constructor))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."
        ),
        null
      )
    if ((t === void 0 && (t = A.itemSize), t !== A.itemSize))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."
        ),
        null
      )
    if ((i === void 0 && (i = A.normalized), i !== A.normalized))
      return (
        console.error(
          "THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."
        ),
        null
      )
    r += A.array.length
  }
  const s = new e(r)
  let o = 0
  for (let a = 0; a < n.length; ++a)
    s.set(n[a].array, o), (o += n[a].array.length)
  return new Bt(s, t, i)
}
function xU(n) {
  let e,
    t = 0,
    i = 0
  for (let c = 0, d = n.length; c < d; ++c) {
    const p = n[c]
    if ((e === void 0 && (e = p.array.constructor), e !== p.array.constructor))
      return (
        console.error(
          "AttributeBuffers of different types cannot be interleaved"
        ),
        null
      )
    ;(t += p.array.length), (i += p.itemSize)
  }
  const r = new $o(new e(t), i)
  let s = 0
  const o = [],
    a = ["getX", "getY", "getZ", "getW"],
    A = ["setX", "setY", "setZ", "setW"]
  for (let c = 0, d = n.length; c < d; c++) {
    const p = n[c],
      m = p.itemSize,
      y = p.count,
      x = new Fr(r, m, s, p.normalized)
    o.push(x), (s += m)
    for (let S = 0; S < y; S++)
      for (let C = 0; C < m; C++) x[A[C]](S, p[a[C]](S))
  }
  return o
}
function bU(n) {
  let e = 0
  for (const i in n.attributes) {
    const r = n.getAttribute(i)
    e += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT
  }
  const t = n.getIndex()
  return (e += t ? t.count * t.itemSize * t.array.BYTES_PER_ELEMENT : 0), e
}
function wU(n, e = 1e-4) {
  e = Math.max(e, Number.EPSILON)
  const t = {},
    i = n.getIndex(),
    r = n.getAttribute("position"),
    s = i ? i.count : r.count
  let o = 0
  const a = Object.keys(n.attributes),
    A = {},
    c = {},
    d = [],
    p = ["getX", "getY", "getZ", "getW"]
  for (let S = 0, C = a.length; S < C; S++) {
    const M = a[S]
    A[M] = []
    const _ = n.morphAttributes[M]
    _ && (c[M] = new Array(_.length).fill().map(() => []))
  }
  const m = Math.log10(1 / e),
    y = Math.pow(10, m)
  for (let S = 0; S < s; S++) {
    const C = i ? i.getX(S) : S
    let M = ""
    for (let _ = 0, R = a.length; _ < R; _++) {
      const T = a[_],
        L = n.getAttribute(T),
        B = L.itemSize
      for (let k = 0; k < B; k++) M += `${~~(L[p[k]](C) * y)},`
    }
    if (M in t) d.push(t[M])
    else {
      for (let _ = 0, R = a.length; _ < R; _++) {
        const T = a[_],
          L = n.getAttribute(T),
          B = n.morphAttributes[T],
          k = L.itemSize,
          O = A[T],
          W = c[T]
        for (let z = 0; z < k; z++) {
          const P = p[z]
          if ((O.push(L[P](C)), B))
            for (let N = 0, G = B.length; N < G; N++) W[N].push(B[N][P](C))
        }
      }
      ;(t[M] = o), d.push(o), o++
    }
  }
  const x = n.clone()
  for (let S = 0, C = a.length; S < C; S++) {
    const M = a[S],
      _ = n.getAttribute(M),
      R = new _.array.constructor(A[M]),
      T = new Bt(R, _.itemSize, _.normalized)
    if ((x.setAttribute(M, T), M in c))
      for (let L = 0; L < c[M].length; L++) {
        const B = n.morphAttributes[M][L],
          k = new B.array.constructor(c[M][L]),
          O = new Bt(k, B.itemSize, B.normalized)
        x.morphAttributes[M][L] = O
      }
  }
  return x.setIndex(d), x
}
function MU(n, e) {
  if (e === i2)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      n
    )
  if (e === M1 || e === p5) {
    let t = n.getIndex()
    if (t === null) {
      const o = [],
        a = n.getAttribute("position")
      if (a !== void 0) {
        for (let A = 0; A < a.count; A++) o.push(A)
        n.setIndex(o), (t = n.getIndex())
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          n
        )
    }
    const i = t.count - 2,
      r = []
    if (e === M1)
      for (let o = 1; o <= i; o++)
        r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1))
    else
      for (let o = 0; o < i; o++)
        o % 2 === 0
          ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2)))
          : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)))
    r.length / 3 !== i &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      )
    const s = n.clone()
    return s.setIndex(r), s.clearGroups(), s
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      n
    )
}
function SU(n) {
  if (n.geometry.isBufferGeometry !== !0)
    return (
      console.error(
        "THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry."
      ),
      null
    )
  const e = new X(),
    t = new X(),
    i = new X(),
    r = new X(),
    s = new X(),
    o = new X(),
    a = new X(),
    A = new X(),
    c = new X()
  function d(Ae, ge, Me, Ne, Ze, K, Oe, ve, Be) {
    e.fromBufferAttribute(Me, K),
      t.fromBufferAttribute(Me, Oe),
      i.fromBufferAttribute(Me, ve)
    const Fe = Ae.morphTargetInfluences
    if (ge.morphTargets && Ne && Fe) {
      a.set(0, 0, 0), A.set(0, 0, 0), c.set(0, 0, 0)
      for (let je = 0, Ge = Ne.length; je < Ge; je++) {
        const ye = Fe[je],
          D = Ne[je]
        ye !== 0 &&
          (r.fromBufferAttribute(D, K),
          s.fromBufferAttribute(D, Oe),
          o.fromBufferAttribute(D, ve),
          Ze
            ? (a.addScaledVector(r, ye),
              A.addScaledVector(s, ye),
              c.addScaledVector(o, ye))
            : (a.addScaledVector(r.sub(e), ye),
              A.addScaledVector(s.sub(t), ye),
              c.addScaledVector(o.sub(i), ye)))
      }
      e.add(a), t.add(A), i.add(c)
    }
    Ae.isSkinnedMesh &&
      (Ae.boneTransform(K, e),
      Ae.boneTransform(Oe, t),
      Ae.boneTransform(ve, i)),
      (Be[K * 3 + 0] = e.x),
      (Be[K * 3 + 1] = e.y),
      (Be[K * 3 + 2] = e.z),
      (Be[Oe * 3 + 0] = t.x),
      (Be[Oe * 3 + 1] = t.y),
      (Be[Oe * 3 + 2] = t.z),
      (Be[ve * 3 + 0] = i.x),
      (Be[ve * 3 + 1] = i.y),
      (Be[ve * 3 + 2] = i.z)
  }
  const p = n.geometry,
    m = n.material
  let y, x, S
  const C = p.index,
    M = p.attributes.position,
    _ = p.morphAttributes.position,
    R = p.morphTargetsRelative,
    T = p.attributes.normal,
    L = p.morphAttributes.position,
    B = p.groups,
    k = p.drawRange
  let O, W, z, P, N, G, j, V
  const Y = new Float32Array(M.count * M.itemSize),
    ne = new Float32Array(T.count * T.itemSize)
  if (C !== null)
    if (Array.isArray(m))
      for (O = 0, z = B.length; O < z; O++)
        for (
          N = B[O],
            G = m[N.materialIndex],
            j = Math.max(N.start, k.start),
            V = Math.min(N.start + N.count, k.start + k.count),
            W = j,
            P = V;
          W < P;
          W += 3
        )
          (y = C.getX(W)),
            (x = C.getX(W + 1)),
            (S = C.getX(W + 2)),
            d(n, G, M, _, R, y, x, S, Y),
            d(n, G, T, L, R, y, x, S, ne)
    else
      for (
        j = Math.max(0, k.start),
          V = Math.min(C.count, k.start + k.count),
          O = j,
          z = V;
        O < z;
        O += 3
      )
        (y = C.getX(O)),
          (x = C.getX(O + 1)),
          (S = C.getX(O + 2)),
          d(n, m, M, _, R, y, x, S, Y),
          d(n, m, T, L, R, y, x, S, ne)
  else if (M !== void 0)
    if (Array.isArray(m))
      for (O = 0, z = B.length; O < z; O++)
        for (
          N = B[O],
            G = m[N.materialIndex],
            j = Math.max(N.start, k.start),
            V = Math.min(N.start + N.count, k.start + k.count),
            W = j,
            P = V;
          W < P;
          W += 3
        )
          (y = W),
            (x = W + 1),
            (S = W + 2),
            d(n, G, M, _, R, y, x, S, Y),
            d(n, G, T, L, R, y, x, S, ne)
    else
      for (
        j = Math.max(0, k.start),
          V = Math.min(M.count, k.start + k.count),
          O = j,
          z = V;
        O < z;
        O += 3
      )
        (y = O),
          (x = O + 1),
          (S = O + 2),
          d(n, m, M, _, R, y, x, S, Y),
          d(n, m, T, L, R, y, x, S, ne)
  const le = new ut(Y, 3),
    Te = new ut(ne, 3)
  return {
    positionAttribute: M,
    normalAttribute: T,
    morphedPositionAttribute: le,
    morphedNormalAttribute: Te,
  }
}
var $2 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        computeTangents: vU,
        mergeBufferGeometries: _U,
        mergeBufferAttributes: og,
        interleaveAttributes: xU,
        estimateBytesUsed: bU,
        mergeVertices: wU,
        toTrianglesDrawMode: MU,
        computeMorphedAttributes: SU,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  Ye = function (n) {
    return n instanceof Function
      ? n
      : typeof n == "string"
      ? function (e) {
          return e[n]
        }
      : function (e) {
          return n
        }
  },
  u8 = { exports: {} }
;(function (n) {
  ;(function (e) {
    var t = /^\s+/,
      i = /\s+$/,
      r = 0,
      s = e.round,
      o = e.min,
      a = e.max,
      A = e.random
    function c(D, q) {
      if (((D = D || ""), (q = q || {}), D instanceof c)) return D
      if (!(this instanceof c)) return new c(D, q)
      var F = d(D)
      ;(this._originalInput = D),
        (this._r = F.r),
        (this._g = F.g),
        (this._b = F.b),
        (this._a = F.a),
        (this._roundA = s(100 * this._a) / 100),
        (this._format = q.format || F.format),
        (this._gradientType = q.gradientType),
        this._r < 1 && (this._r = s(this._r)),
        this._g < 1 && (this._g = s(this._g)),
        this._b < 1 && (this._b = s(this._b)),
        (this._ok = F.ok),
        (this._tc_id = r++)
    }
    ;(c.prototype = {
      isDark: function () {
        return this.getBrightness() < 128
      },
      isLight: function () {
        return !this.isDark()
      },
      isValid: function () {
        return this._ok
      },
      getOriginalInput: function () {
        return this._originalInput
      },
      getFormat: function () {
        return this._format
      },
      getAlpha: function () {
        return this._a
      },
      getBrightness: function () {
        var D = this.toRgb()
        return (D.r * 299 + D.g * 587 + D.b * 114) / 1e3
      },
      getLuminance: function () {
        var D = this.toRgb(),
          q,
          F,
          te,
          oe,
          ue,
          Ee
        return (
          (q = D.r / 255),
          (F = D.g / 255),
          (te = D.b / 255),
          q <= 0.03928
            ? (oe = q / 12.92)
            : (oe = e.pow((q + 0.055) / 1.055, 2.4)),
          F <= 0.03928
            ? (ue = F / 12.92)
            : (ue = e.pow((F + 0.055) / 1.055, 2.4)),
          te <= 0.03928
            ? (Ee = te / 12.92)
            : (Ee = e.pow((te + 0.055) / 1.055, 2.4)),
          0.2126 * oe + 0.7152 * ue + 0.0722 * Ee
        )
      },
      setAlpha: function (D) {
        return (this._a = Te(D)), (this._roundA = s(100 * this._a) / 100), this
      },
      toHsv: function () {
        var D = x(this._r, this._g, this._b)
        return { h: D.h * 360, s: D.s, v: D.v, a: this._a }
      },
      toHsvString: function () {
        var D = x(this._r, this._g, this._b),
          q = s(D.h * 360),
          F = s(D.s * 100),
          te = s(D.v * 100)
        return this._a == 1
          ? "hsv(" + q + ", " + F + "%, " + te + "%)"
          : "hsva(" + q + ", " + F + "%, " + te + "%, " + this._roundA + ")"
      },
      toHsl: function () {
        var D = m(this._r, this._g, this._b)
        return { h: D.h * 360, s: D.s, l: D.l, a: this._a }
      },
      toHslString: function () {
        var D = m(this._r, this._g, this._b),
          q = s(D.h * 360),
          F = s(D.s * 100),
          te = s(D.l * 100)
        return this._a == 1
          ? "hsl(" + q + ", " + F + "%, " + te + "%)"
          : "hsla(" + q + ", " + F + "%, " + te + "%, " + this._roundA + ")"
      },
      toHex: function (D) {
        return C(this._r, this._g, this._b, D)
      },
      toHexString: function (D) {
        return "#" + this.toHex(D)
      },
      toHex8: function (D) {
        return M(this._r, this._g, this._b, this._a, D)
      },
      toHex8String: function (D) {
        return "#" + this.toHex8(D)
      },
      toRgb: function () {
        return { r: s(this._r), g: s(this._g), b: s(this._b), a: this._a }
      },
      toRgbString: function () {
        return this._a == 1
          ? "rgb(" + s(this._r) + ", " + s(this._g) + ", " + s(this._b) + ")"
          : "rgba(" +
              s(this._r) +
              ", " +
              s(this._g) +
              ", " +
              s(this._b) +
              ", " +
              this._roundA +
              ")"
      },
      toPercentageRgb: function () {
        return {
          r: s(Ae(this._r, 255) * 100) + "%",
          g: s(Ae(this._g, 255) * 100) + "%",
          b: s(Ae(this._b, 255) * 100) + "%",
          a: this._a,
        }
      },
      toPercentageRgbString: function () {
        return this._a == 1
          ? "rgb(" +
              s(Ae(this._r, 255) * 100) +
              "%, " +
              s(Ae(this._g, 255) * 100) +
              "%, " +
              s(Ae(this._b, 255) * 100) +
              "%)"
          : "rgba(" +
              s(Ae(this._r, 255) * 100) +
              "%, " +
              s(Ae(this._g, 255) * 100) +
              "%, " +
              s(Ae(this._b, 255) * 100) +
              "%, " +
              this._roundA +
              ")"
      },
      toName: function () {
        return this._a === 0
          ? "transparent"
          : this._a < 1
          ? !1
          : ne[C(this._r, this._g, this._b, !0)] || !1
      },
      toFilter: function (D) {
        var q = "#" + _(this._r, this._g, this._b, this._a),
          F = q,
          te = this._gradientType ? "GradientType = 1, " : ""
        if (D) {
          var oe = c(D)
          F = "#" + _(oe._r, oe._g, oe._b, oe._a)
        }
        return (
          "progid:DXImageTransform.Microsoft.gradient(" +
          te +
          "startColorstr=" +
          q +
          ",endColorstr=" +
          F +
          ")"
        )
      },
      toString: function (D) {
        var q = !!D
        D = D || this._format
        var F = !1,
          te = this._a < 1 && this._a >= 0,
          oe =
            !q &&
            te &&
            (D === "hex" ||
              D === "hex6" ||
              D === "hex3" ||
              D === "hex4" ||
              D === "hex8" ||
              D === "name")
        return oe
          ? D === "name" && this._a === 0
            ? this.toName()
            : this.toRgbString()
          : (D === "rgb" && (F = this.toRgbString()),
            D === "prgb" && (F = this.toPercentageRgbString()),
            (D === "hex" || D === "hex6") && (F = this.toHexString()),
            D === "hex3" && (F = this.toHexString(!0)),
            D === "hex4" && (F = this.toHex8String(!0)),
            D === "hex8" && (F = this.toHex8String()),
            D === "name" && (F = this.toName()),
            D === "hsl" && (F = this.toHslString()),
            D === "hsv" && (F = this.toHsvString()),
            F || this.toHexString())
      },
      clone: function () {
        return c(this.toString())
      },
      _applyModification: function (D, q) {
        var F = D.apply(null, [this].concat([].slice.call(q)))
        return (
          (this._r = F._r),
          (this._g = F._g),
          (this._b = F._b),
          this.setAlpha(F._a),
          this
        )
      },
      lighten: function () {
        return this._applyModification(B, arguments)
      },
      brighten: function () {
        return this._applyModification(k, arguments)
      },
      darken: function () {
        return this._applyModification(O, arguments)
      },
      desaturate: function () {
        return this._applyModification(R, arguments)
      },
      saturate: function () {
        return this._applyModification(T, arguments)
      },
      greyscale: function () {
        return this._applyModification(L, arguments)
      },
      spin: function () {
        return this._applyModification(W, arguments)
      },
      _applyCombination: function (D, q) {
        return D.apply(null, [this].concat([].slice.call(q)))
      },
      analogous: function () {
        return this._applyCombination(j, arguments)
      },
      complement: function () {
        return this._applyCombination(z, arguments)
      },
      monochromatic: function () {
        return this._applyCombination(V, arguments)
      },
      splitcomplement: function () {
        return this._applyCombination(G, arguments)
      },
      triad: function () {
        return this._applyCombination(P, arguments)
      },
      tetrad: function () {
        return this._applyCombination(N, arguments)
      },
    }),
      (c.fromRatio = function (D, q) {
        if (typeof D == "object") {
          var F = {}
          for (var te in D)
            D.hasOwnProperty(te) &&
              (te === "a" ? (F[te] = D[te]) : (F[te] = Oe(D[te])))
          D = F
        }
        return c(D, q)
      })
    function d(D) {
      var q = { r: 0, g: 0, b: 0 },
        F = 1,
        te = null,
        oe = null,
        ue = null,
        Ee = !1,
        Ce = !1
      return (
        typeof D == "string" && (D = Ge(D)),
        typeof D == "object" &&
          (je(D.r) && je(D.g) && je(D.b)
            ? ((q = p(D.r, D.g, D.b)),
              (Ee = !0),
              (Ce = String(D.r).substr(-1) === "%" ? "prgb" : "rgb"))
            : je(D.h) && je(D.s) && je(D.v)
            ? ((te = Oe(D.s)),
              (oe = Oe(D.v)),
              (q = S(D.h, te, oe)),
              (Ee = !0),
              (Ce = "hsv"))
            : je(D.h) &&
              je(D.s) &&
              je(D.l) &&
              ((te = Oe(D.s)),
              (ue = Oe(D.l)),
              (q = y(D.h, te, ue)),
              (Ee = !0),
              (Ce = "hsl")),
          D.hasOwnProperty("a") && (F = D.a)),
        (F = Te(F)),
        {
          ok: Ee,
          format: D.format || Ce,
          r: o(255, a(q.r, 0)),
          g: o(255, a(q.g, 0)),
          b: o(255, a(q.b, 0)),
          a: F,
        }
      )
    }
    function p(D, q, F) {
      return { r: Ae(D, 255) * 255, g: Ae(q, 255) * 255, b: Ae(F, 255) * 255 }
    }
    function m(D, q, F) {
      ;(D = Ae(D, 255)), (q = Ae(q, 255)), (F = Ae(F, 255))
      var te = a(D, q, F),
        oe = o(D, q, F),
        ue,
        Ee,
        Ce = (te + oe) / 2
      if (te == oe) ue = Ee = 0
      else {
        var Se = te - oe
        switch (((Ee = Ce > 0.5 ? Se / (2 - te - oe) : Se / (te + oe)), te)) {
          case D:
            ue = (q - F) / Se + (q < F ? 6 : 0)
            break
          case q:
            ue = (F - D) / Se + 2
            break
          case F:
            ue = (D - q) / Se + 4
            break
        }
        ue /= 6
      }
      return { h: ue, s: Ee, l: Ce }
    }
    function y(D, q, F) {
      var te, oe, ue
      ;(D = Ae(D, 360)), (q = Ae(q, 100)), (F = Ae(F, 100))
      function Ee($, Q, pe) {
        return (
          pe < 0 && (pe += 1),
          pe > 1 && (pe -= 1),
          pe < 1 / 6
            ? $ + (Q - $) * 6 * pe
            : pe < 1 / 2
            ? Q
            : pe < 2 / 3
            ? $ + (Q - $) * (2 / 3 - pe) * 6
            : $
        )
      }
      if (q === 0) te = oe = ue = F
      else {
        var Ce = F < 0.5 ? F * (1 + q) : F + q - F * q,
          Se = 2 * F - Ce
        ;(te = Ee(Se, Ce, D + 1 / 3)),
          (oe = Ee(Se, Ce, D)),
          (ue = Ee(Se, Ce, D - 1 / 3))
      }
      return { r: te * 255, g: oe * 255, b: ue * 255 }
    }
    function x(D, q, F) {
      ;(D = Ae(D, 255)), (q = Ae(q, 255)), (F = Ae(F, 255))
      var te = a(D, q, F),
        oe = o(D, q, F),
        ue,
        Ee,
        Ce = te,
        Se = te - oe
      if (((Ee = te === 0 ? 0 : Se / te), te == oe)) ue = 0
      else {
        switch (te) {
          case D:
            ue = (q - F) / Se + (q < F ? 6 : 0)
            break
          case q:
            ue = (F - D) / Se + 2
            break
          case F:
            ue = (D - q) / Se + 4
            break
        }
        ue /= 6
      }
      return { h: ue, s: Ee, v: Ce }
    }
    function S(D, q, F) {
      ;(D = Ae(D, 360) * 6), (q = Ae(q, 100)), (F = Ae(F, 100))
      var te = e.floor(D),
        oe = D - te,
        ue = F * (1 - q),
        Ee = F * (1 - oe * q),
        Ce = F * (1 - (1 - oe) * q),
        Se = te % 6,
        $ = [F, Ee, ue, ue, Ce, F][Se],
        Q = [Ce, F, F, Ee, ue, ue][Se],
        pe = [ue, ue, Ce, F, F, Ee][Se]
      return { r: $ * 255, g: Q * 255, b: pe * 255 }
    }
    function C(D, q, F, te) {
      var oe = [
        K(s(D).toString(16)),
        K(s(q).toString(16)),
        K(s(F).toString(16)),
      ]
      return te &&
        oe[0].charAt(0) == oe[0].charAt(1) &&
        oe[1].charAt(0) == oe[1].charAt(1) &&
        oe[2].charAt(0) == oe[2].charAt(1)
        ? oe[0].charAt(0) + oe[1].charAt(0) + oe[2].charAt(0)
        : oe.join("")
    }
    function M(D, q, F, te, oe) {
      var ue = [
        K(s(D).toString(16)),
        K(s(q).toString(16)),
        K(s(F).toString(16)),
        K(ve(te)),
      ]
      return oe &&
        ue[0].charAt(0) == ue[0].charAt(1) &&
        ue[1].charAt(0) == ue[1].charAt(1) &&
        ue[2].charAt(0) == ue[2].charAt(1) &&
        ue[3].charAt(0) == ue[3].charAt(1)
        ? ue[0].charAt(0) + ue[1].charAt(0) + ue[2].charAt(0) + ue[3].charAt(0)
        : ue.join("")
    }
    function _(D, q, F, te) {
      var oe = [
        K(ve(te)),
        K(s(D).toString(16)),
        K(s(q).toString(16)),
        K(s(F).toString(16)),
      ]
      return oe.join("")
    }
    ;(c.equals = function (D, q) {
      return !D || !q ? !1 : c(D).toRgbString() == c(q).toRgbString()
    }),
      (c.random = function () {
        return c.fromRatio({ r: A(), g: A(), b: A() })
      })
    function R(D, q) {
      q = q === 0 ? 0 : q || 10
      var F = c(D).toHsl()
      return (F.s -= q / 100), (F.s = ge(F.s)), c(F)
    }
    function T(D, q) {
      q = q === 0 ? 0 : q || 10
      var F = c(D).toHsl()
      return (F.s += q / 100), (F.s = ge(F.s)), c(F)
    }
    function L(D) {
      return c(D).desaturate(100)
    }
    function B(D, q) {
      q = q === 0 ? 0 : q || 10
      var F = c(D).toHsl()
      return (F.l += q / 100), (F.l = ge(F.l)), c(F)
    }
    function k(D, q) {
      q = q === 0 ? 0 : q || 10
      var F = c(D).toRgb()
      return (
        (F.r = a(0, o(255, F.r - s(255 * -(q / 100))))),
        (F.g = a(0, o(255, F.g - s(255 * -(q / 100))))),
        (F.b = a(0, o(255, F.b - s(255 * -(q / 100))))),
        c(F)
      )
    }
    function O(D, q) {
      q = q === 0 ? 0 : q || 10
      var F = c(D).toHsl()
      return (F.l -= q / 100), (F.l = ge(F.l)), c(F)
    }
    function W(D, q) {
      var F = c(D).toHsl(),
        te = (F.h + q) % 360
      return (F.h = te < 0 ? 360 + te : te), c(F)
    }
    function z(D) {
      var q = c(D).toHsl()
      return (q.h = (q.h + 180) % 360), c(q)
    }
    function P(D) {
      var q = c(D).toHsl(),
        F = q.h
      return [
        c(D),
        c({ h: (F + 120) % 360, s: q.s, l: q.l }),
        c({ h: (F + 240) % 360, s: q.s, l: q.l }),
      ]
    }
    function N(D) {
      var q = c(D).toHsl(),
        F = q.h
      return [
        c(D),
        c({ h: (F + 90) % 360, s: q.s, l: q.l }),
        c({ h: (F + 180) % 360, s: q.s, l: q.l }),
        c({ h: (F + 270) % 360, s: q.s, l: q.l }),
      ]
    }
    function G(D) {
      var q = c(D).toHsl(),
        F = q.h
      return [
        c(D),
        c({ h: (F + 72) % 360, s: q.s, l: q.l }),
        c({ h: (F + 216) % 360, s: q.s, l: q.l }),
      ]
    }
    function j(D, q, F) {
      ;(q = q || 6), (F = F || 30)
      var te = c(D).toHsl(),
        oe = 360 / F,
        ue = [c(D)]
      for (te.h = (te.h - ((oe * q) >> 1) + 720) % 360; --q; )
        (te.h = (te.h + oe) % 360), ue.push(c(te))
      return ue
    }
    function V(D, q) {
      q = q || 6
      for (
        var F = c(D).toHsv(), te = F.h, oe = F.s, ue = F.v, Ee = [], Ce = 1 / q;
        q--;

      )
        Ee.push(c({ h: te, s: oe, v: ue })), (ue = (ue + Ce) % 1)
      return Ee
    }
    ;(c.mix = function (D, q, F) {
      F = F === 0 ? 0 : F || 50
      var te = c(D).toRgb(),
        oe = c(q).toRgb(),
        ue = F / 100,
        Ee = {
          r: (oe.r - te.r) * ue + te.r,
          g: (oe.g - te.g) * ue + te.g,
          b: (oe.b - te.b) * ue + te.b,
          a: (oe.a - te.a) * ue + te.a,
        }
      return c(Ee)
    }),
      (c.readability = function (D, q) {
        var F = c(D),
          te = c(q)
        return (
          (e.max(F.getLuminance(), te.getLuminance()) + 0.05) /
          (e.min(F.getLuminance(), te.getLuminance()) + 0.05)
        )
      }),
      (c.isReadable = function (D, q, F) {
        var te = c.readability(D, q),
          oe,
          ue
        switch (((ue = !1), (oe = ye(F)), oe.level + oe.size)) {
          case "AAsmall":
          case "AAAlarge":
            ue = te >= 4.5
            break
          case "AAlarge":
            ue = te >= 3
            break
          case "AAAsmall":
            ue = te >= 7
            break
        }
        return ue
      }),
      (c.mostReadable = function (D, q, F) {
        var te = null,
          oe = 0,
          ue,
          Ee,
          Ce,
          Se
        ;(F = F || {}),
          (Ee = F.includeFallbackColors),
          (Ce = F.level),
          (Se = F.size)
        for (var $ = 0; $ < q.length; $++)
          (ue = c.readability(D, q[$])), ue > oe && ((oe = ue), (te = c(q[$])))
        return c.isReadable(D, te, { level: Ce, size: Se }) || !Ee
          ? te
          : ((F.includeFallbackColors = !1),
            c.mostReadable(D, ["#fff", "#000"], F))
      })
    var Y = (c.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32",
      }),
      ne = (c.hexNames = le(Y))
    function le(D) {
      var q = {}
      for (var F in D) D.hasOwnProperty(F) && (q[D[F]] = F)
      return q
    }
    function Te(D) {
      return (D = parseFloat(D)), (isNaN(D) || D < 0 || D > 1) && (D = 1), D
    }
    function Ae(D, q) {
      Ne(D) && (D = "100%")
      var F = Ze(D)
      return (
        (D = o(q, a(0, parseFloat(D)))),
        F && (D = parseInt(D * q, 10) / 100),
        e.abs(D - q) < 1e-6 ? 1 : (D % q) / parseFloat(q)
      )
    }
    function ge(D) {
      return o(1, a(0, D))
    }
    function Me(D) {
      return parseInt(D, 16)
    }
    function Ne(D) {
      return typeof D == "string" && D.indexOf(".") != -1 && parseFloat(D) === 1
    }
    function Ze(D) {
      return typeof D == "string" && D.indexOf("%") != -1
    }
    function K(D) {
      return D.length == 1 ? "0" + D : "" + D
    }
    function Oe(D) {
      return D <= 1 && (D = D * 100 + "%"), D
    }
    function ve(D) {
      return e.round(parseFloat(D) * 255).toString(16)
    }
    function Be(D) {
      return Me(D) / 255
    }
    var Fe = (function () {
      var D = "[-\\+]?\\d+%?",
        q = "[-\\+]?\\d*\\.\\d+%?",
        F = "(?:" + q + ")|(?:" + D + ")",
        te =
          "[\\s|\\(]+(" + F + ")[,|\\s]+(" + F + ")[,|\\s]+(" + F + ")\\s*\\)?",
        oe =
          "[\\s|\\(]+(" +
          F +
          ")[,|\\s]+(" +
          F +
          ")[,|\\s]+(" +
          F +
          ")[,|\\s]+(" +
          F +
          ")\\s*\\)?"
      return {
        CSS_UNIT: new RegExp(F),
        rgb: new RegExp("rgb" + te),
        rgba: new RegExp("rgba" + oe),
        hsl: new RegExp("hsl" + te),
        hsla: new RegExp("hsla" + oe),
        hsv: new RegExp("hsv" + te),
        hsva: new RegExp("hsva" + oe),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      }
    })()
    function je(D) {
      return !!Fe.CSS_UNIT.exec(D)
    }
    function Ge(D) {
      D = D.replace(t, "").replace(i, "").toLowerCase()
      var q = !1
      if (Y[D]) (D = Y[D]), (q = !0)
      else if (D == "transparent")
        return { r: 0, g: 0, b: 0, a: 0, format: "name" }
      var F
      return (F = Fe.rgb.exec(D))
        ? { r: F[1], g: F[2], b: F[3] }
        : (F = Fe.rgba.exec(D))
        ? { r: F[1], g: F[2], b: F[3], a: F[4] }
        : (F = Fe.hsl.exec(D))
        ? { h: F[1], s: F[2], l: F[3] }
        : (F = Fe.hsla.exec(D))
        ? { h: F[1], s: F[2], l: F[3], a: F[4] }
        : (F = Fe.hsv.exec(D))
        ? { h: F[1], s: F[2], v: F[3] }
        : (F = Fe.hsva.exec(D))
        ? { h: F[1], s: F[2], v: F[3], a: F[4] }
        : (F = Fe.hex8.exec(D))
        ? {
            r: Me(F[1]),
            g: Me(F[2]),
            b: Me(F[3]),
            a: Be(F[4]),
            format: q ? "name" : "hex8",
          }
        : (F = Fe.hex6.exec(D))
        ? { r: Me(F[1]), g: Me(F[2]), b: Me(F[3]), format: q ? "name" : "hex" }
        : (F = Fe.hex4.exec(D))
        ? {
            r: Me(F[1] + "" + F[1]),
            g: Me(F[2] + "" + F[2]),
            b: Me(F[3] + "" + F[3]),
            a: Be(F[4] + "" + F[4]),
            format: q ? "name" : "hex8",
          }
        : (F = Fe.hex3.exec(D))
        ? {
            r: Me(F[1] + "" + F[1]),
            g: Me(F[2] + "" + F[2]),
            b: Me(F[3] + "" + F[3]),
            format: q ? "name" : "hex",
          }
        : !1
    }
    function ye(D) {
      var q, F
      return (
        (D = D || { level: "AA", size: "small" }),
        (q = (D.level || "AA").toUpperCase()),
        (F = (D.size || "small").toLowerCase()),
        q !== "AA" && q !== "AAA" && (q = "AA"),
        F !== "small" && F !== "large" && (F = "small"),
        { level: q, size: F }
      )
    }
    n.exports ? (n.exports = c) : (window.tinycolor = c)
  })(Math)
})(u8)
var Q2 = u8.exports
function EU(n, e) {
  if (n == null) return {}
  var t = {},
    i = Object.keys(n),
    r,
    s
  for (s = 0; s < i.length; s++)
    (r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r])
  return t
}
function TU(n, e) {
  if (n == null) return {}
  var t = EU(n, e),
    i,
    r
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n)
    for (r = 0; r < s.length; r++)
      (i = s[r]),
        !(e.indexOf(i) >= 0) &&
          (!Object.prototype.propertyIsEnumerable.call(n, i) || (t[i] = n[i]))
  }
  return t
}
function CU(n, e) {
  return LU(n) || IU(n, e) || f8(n, e) || kU()
}
function RU(n) {
  return PU(n) || DU(n) || f8(n) || BU()
}
function PU(n) {
  if (Array.isArray(n)) return ag(n)
}
function LU(n) {
  if (Array.isArray(n)) return n
}
function DU(n) {
  if (
    (typeof Symbol != "undefined" && n[Symbol.iterator] != null) ||
    n["@@iterator"] != null
  )
    return Array.from(n)
}
function IU(n, e) {
  var t =
    n &&
    ((typeof Symbol != "undefined" && n[Symbol.iterator]) || n["@@iterator"])
  if (t != null) {
    var i = [],
      r = !0,
      s = !1,
      o,
      a
    try {
      for (
        t = t.call(n);
        !(r = (o = t.next()).done) && (i.push(o.value), !(e && i.length === e));
        r = !0
      );
    } catch (A) {
      ;(s = !0), (a = A)
    } finally {
      try {
        !r && t.return != null && t.return()
      } finally {
        if (s) throw a
      }
    }
    return i
  }
}
function f8(n, e) {
  if (!!n) {
    if (typeof n == "string") return ag(n, e)
    var t = Object.prototype.toString.call(n).slice(8, -1)
    if (
      (t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set")
    )
      return Array.from(n)
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return ag(n, e)
  }
}
function ag(n, e) {
  ;(e == null || e > n.length) && (e = n.length)
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t]
  return i
}
function BU() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function kU() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function OU(n, e) {
  if (typeof n != "object" || n === null) return n
  var t = n[Symbol.toPrimitive]
  if (t !== void 0) {
    var i = t.call(n, e || "default")
    if (typeof i != "object") return i
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (e === "string" ? String : Number)(n)
}
function qU(n) {
  var e = OU(n, "string")
  return typeof e == "symbol" ? e : String(e)
}
var lg = function () {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
    e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
    t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
    i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
    r = (e instanceof Array ? (e.length ? e : [void 0]) : [e]).map(function (
      a
    ) {
      return { keyAccessor: a, isProp: !(a instanceof Function) }
    }),
    s = n.reduce(function (a, A) {
      var c = a,
        d = A
      return (
        r.forEach(function (p, m) {
          var y = p.keyAccessor,
            x = p.isProp,
            S
          if (x) {
            var C = d,
              M = C[y],
              _ = TU(C, [y].map(qU))
            ;(S = M), (d = _)
          } else S = y(d, m)
          m + 1 < r.length
            ? (c.hasOwnProperty(S) || (c[S] = {}), (c = c[S]))
            : t
            ? (c.hasOwnProperty(S) || (c[S] = []), c[S].push(d))
            : (c[S] = d)
        }),
        a
      )
    }, {})
  t instanceof Function &&
    (function a(A) {
      var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1
      c === r.length
        ? Object.keys(A).forEach(function (d) {
            return (A[d] = t(A[d]))
          })
        : Object.values(A).forEach(function (d) {
            return a(d, c + 1)
          })
    })(s)
  var o = s
  return (
    i &&
      ((o = []),
      (function a(A) {
        var c =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : []
        c.length === r.length
          ? o.push({ keys: c, vals: A })
          : Object.entries(A).forEach(function (d) {
              var p = CU(d, 2),
                m = p[0],
                y = p[1]
              return a(y, [].concat(RU(c), [m]))
            })
      })(s),
      e instanceof Array &&
        e.length === 0 &&
        o.length === 1 &&
        (o[0].keys = [])),
    o
  )
}
function yx(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n)
    e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable
      })),
      t.push.apply(t, i)
  }
  return t
}
function FU(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? yx(Object(t), !0).forEach(function (i) {
          h8(n, i, t[i])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : yx(Object(t)).forEach(function (i) {
          Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
  }
  return n
}
function h8(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  )
}
function NU(n, e) {
  if (n == null) return {}
  var t = {},
    i = Object.keys(n),
    r,
    s
  for (s = 0; s < i.length; s++)
    (r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r])
  return t
}
function UU(n, e) {
  if (n == null) return {}
  var t = NU(n, e),
    i,
    r
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n)
    for (r = 0; r < s.length; r++)
      (i = s[r]),
        !(e.indexOf(i) >= 0) &&
          (!Object.prototype.propertyIsEnumerable.call(n, i) || (t[i] = n[i]))
  }
  return t
}
function d8(n, e) {
  return HU(n) || VU(n, e) || p8(n, e) || jU()
}
function z0(n) {
  return zU(n) || GU(n) || p8(n) || WU()
}
function zU(n) {
  if (Array.isArray(n)) return cg(n)
}
function HU(n) {
  if (Array.isArray(n)) return n
}
function GU(n) {
  if (
    (typeof Symbol != "undefined" && n[Symbol.iterator] != null) ||
    n["@@iterator"] != null
  )
    return Array.from(n)
}
function VU(n, e) {
  var t =
    n &&
    ((typeof Symbol != "undefined" && n[Symbol.iterator]) || n["@@iterator"])
  if (t != null) {
    var i = [],
      r = !0,
      s = !1,
      o,
      a
    try {
      for (
        t = t.call(n);
        !(r = (o = t.next()).done) && (i.push(o.value), !(e && i.length === e));
        r = !0
      );
    } catch (A) {
      ;(s = !0), (a = A)
    } finally {
      try {
        !r && t.return != null && t.return()
      } finally {
        if (s) throw a
      }
    }
    return i
  }
}
function p8(n, e) {
  if (!!n) {
    if (typeof n == "string") return cg(n, e)
    var t = Object.prototype.toString.call(n).slice(8, -1)
    if (
      (t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set")
    )
      return Array.from(n)
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return cg(n, e)
  }
}
function cg(n, e) {
  ;(e == null || e > n.length) && (e = n.length)
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t]
  return i
}
function WU() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function jU() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function $U(n, e, t) {
  var i = { enter: [], update: [], exit: [] }
  if (t) {
    var o = lg(n, t, !1),
      a = lg(e, t, !1),
      A = Object.assign({}, o, a)
    Object.entries(A).forEach(function (c) {
      var d = d8(c, 2),
        p = d[0],
        m = d[1],
        y = o.hasOwnProperty(p)
          ? a.hasOwnProperty(p)
            ? "update"
            : "exit"
          : "enter"
      i[y].push(y === "update" ? [o[p], a[p]] : m)
    })
  } else {
    var r = new Set(n),
      s = new Set(e)
    new Set([].concat(z0(r), z0(s))).forEach(function (c) {
      var d = r.has(c) ? (s.has(c) ? "update" : "exit") : "enter"
      i[d].push(d === "update" ? [c, c] : c)
    })
  }
  return i
}
function QU(n, e, t) {
  var i = t.objBindAttr,
    r = i === void 0 ? "__obj" : i,
    s = t.dataBindAttr,
    o = s === void 0 ? "__data" : s,
    a = t.idAccessor,
    A = t.purge,
    c = A === void 0 ? !1 : A,
    d = function (C) {
      return C.hasOwnProperty(o)
    },
    p = e.filter(function (S) {
      return !d(S)
    }),
    m = e.filter(d).map(function (S) {
      return S[o]
    }),
    y = n,
    x = c ? { enter: y, exit: m, update: [] } : $U(m, y, a)
  return (
    (x.update = x.update.map(function (S) {
      var C = d8(S, 2),
        M = C[0],
        _ = C[1]
      return M !== _ && ((_[r] = M[r]), (_[r][o] = _)), _
    })),
    (x.exit = x.exit.concat(
      p.map(function (S) {
        return h8({}, r, S)
      })
    )),
    x
  )
}
function XU(n, e, t, i, r) {
  var s = r.createObj,
    o =
      s === void 0
        ? function (O) {
            return {}
          }
        : s,
    a = r.updateObj,
    A = a === void 0 ? function (O, W) {} : a,
    c = r.exitObj,
    d = c === void 0 ? function (O) {} : c,
    p = r.objBindAttr,
    m = p === void 0 ? "__obj" : p,
    y = r.dataBindAttr,
    x = y === void 0 ? "__data" : y,
    S = UU(r, [
      "createObj",
      "updateObj",
      "exitObj",
      "objBindAttr",
      "dataBindAttr",
    ]),
    C = QU(n, e, FU({ objBindAttr: m, dataBindAttr: x }, S)),
    M = C.enter,
    _ = C.update,
    R = C.exit
  R.forEach(function (O) {
    var W = O[m]
    delete O[m], d(W), i(W)
  })
  var T = B(M),
    L = [].concat(z0(M), z0(_))
  k(L), T.forEach(t)
  function B(O) {
    var W = []
    return (
      O.forEach(function (z) {
        var P = o(z)
        P && ((P[x] = z), (z[m] = P), W.push(P))
      }),
      W
    )
  }
  function k(O) {
    O.forEach(function (W) {
      var z = W[m]
      z && ((z[x] = W), A(z, W))
    })
  }
}
var m8 = { exports: {} }
;(function (n, e) {
  ;(function (t, i) {
    n.exports = i()
  })(Gs, function () {
    return (function (t) {
      function i(s) {
        if (r[s]) return r[s].exports
        var o = (r[s] = { exports: {}, id: s, loaded: !1 })
        return t[s].call(o.exports, o, o.exports, i), (o.loaded = !0), o.exports
      }
      var r = {}
      return (i.m = t), (i.c = r), (i.p = ""), i(0)
    })([
      function (t, i, r) {
        var s = r(1),
          o = (function () {
            function a(A, c, d) {
              A === void 0 && (A = NaN),
                c === void 0 && (c = NaN),
                d === void 0 && (d = !1),
                (this._minFPS = c),
                (this._maxFPS = A),
                (this._timeScale = 1),
                (this._currentTick = 0),
                (this._currentTime = 0),
                (this._tickDeltaTime = 0),
                (this._isRunning = !1),
                (this._maxInterval = isNaN(this._minFPS)
                  ? NaN
                  : 1e3 / this._minFPS),
                (this._minInterval = isNaN(this._maxFPS)
                  ? NaN
                  : 1e3 / this._maxFPS),
                (this._onResume = new s.default()),
                (this._onPause = new s.default()),
                (this._onTick = new s.default()),
                (this._onTickOncePerFrame = new s.default()),
                d || this.resume()
            }
            return (
              (a.prototype.updateOnce = function (A) {
                A(
                  this.currentTimeSeconds,
                  this.tickDeltaTimeSeconds,
                  this.currentTick
                )
              }),
              (a.prototype.resume = function () {
                this._isRunning ||
                  ((this._isRunning = !0),
                  (this._lastTimeUpdated = this.getTimer()),
                  this._onResume.dispatch(),
                  this.animateOnce())
              }),
              (a.prototype.pause = function () {
                this._isRunning &&
                  ((this._isRunning = !1),
                  this._onPause.dispatch(),
                  window.cancelAnimationFrame(this._animationFrameHandle))
              }),
              (a.prototype.dispose = function () {
                this.pause(),
                  this._onResume.removeAll(),
                  this._onPause.removeAll(),
                  this._onTick.removeAll()
              }),
              Object.defineProperty(a.prototype, "currentTick", {
                get: function () {
                  return this._currentTick
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(a.prototype, "currentTimeSeconds", {
                get: function () {
                  return this._currentTime / 1e3
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(a.prototype, "tickDeltaTimeSeconds", {
                get: function () {
                  return this._tickDeltaTime / 1e3
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(a.prototype, "timeScale", {
                get: function () {
                  return this._timeScale
                },
                set: function (A) {
                  this._timeScale !== A && (this._timeScale = A)
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(a.prototype, "onResume", {
                get: function () {
                  return this._onResume
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(a.prototype, "onPause", {
                get: function () {
                  return this._onPause
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(a.prototype, "onTick", {
                get: function () {
                  return this._onTick
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(a.prototype, "onTickOncePerFrame", {
                get: function () {
                  return this._onTickOncePerFrame
                },
                enumerable: !0,
                configurable: !0,
              }),
              Object.defineProperty(a.prototype, "isRunning", {
                get: function () {
                  return this._isRunning
                },
                enumerable: !0,
                configurable: !0,
              }),
              (a.prototype.animateOnce = function () {
                var A = this
                this._animationFrameHandle = window.requestAnimationFrame(
                  function () {
                    return A.onFrame()
                  }
                )
              }),
              (a.prototype.onFrame = function () {
                if (
                  ((this._now = this.getTimer()),
                  (this._frameDeltaTime = this._now - this._lastTimeUpdated),
                  isNaN(this._minInterval) ||
                    this._frameDeltaTime >= this._minInterval)
                )
                  if (isNaN(this._maxInterval))
                    this.update(this._frameDeltaTime * this._timeScale, !0),
                      (this._lastTimeUpdated = this._now)
                  else
                    for (
                      this._interval = Math.min(
                        this._frameDeltaTime,
                        this._maxInterval
                      );
                      this._now >= this._lastTimeUpdated + this._interval;

                    )
                      this.update(
                        this._interval * this._timeScale,
                        this._now <=
                          this._lastTimeUpdated + 2 * this._maxInterval
                      ),
                        (this._lastTimeUpdated += this._interval)
                this._isRunning && this.animateOnce()
              }),
              (a.prototype.update = function (A, c) {
                c === void 0 && (c = !0),
                  this._currentTick++,
                  (this._currentTime += A),
                  (this._tickDeltaTime = A),
                  this._onTick.dispatch(
                    this.currentTimeSeconds,
                    this.tickDeltaTimeSeconds,
                    this.currentTick
                  ),
                  c &&
                    this._onTickOncePerFrame.dispatch(
                      this.currentTimeSeconds,
                      this.tickDeltaTimeSeconds,
                      this.currentTick
                    )
              }),
              (a.prototype.getTimer = function () {
                return Date.now()
              }),
              a
            )
          })()
        Object.defineProperty(i, "__esModule", { value: !0 }), (i.default = o)
      },
      function (t, i, r) {
        ;(function (s, o) {
          t.exports = o()
        })(this, function () {
          return (function (s) {
            function o(A) {
              if (a[A]) return a[A].exports
              var c = (a[A] = { exports: {}, id: A, loaded: !1 })
              return (
                s[A].call(c.exports, c, c.exports, o),
                (c.loaded = !0),
                c.exports
              )
            }
            var a = {}
            return (o.m = s), (o.c = a), (o.p = ""), o(0)
          })([
            function (s, o) {
              var a = (function () {
                function A() {
                  this.functions = []
                }
                return (
                  (A.prototype.add = function (c) {
                    return (
                      this.functions.indexOf(c) === -1 &&
                      (this.functions.push(c), !0)
                    )
                  }),
                  (A.prototype.remove = function (c) {
                    var d = this.functions.indexOf(c)
                    return d > -1 && (this.functions.splice(d, 1), !0)
                  }),
                  (A.prototype.removeAll = function () {
                    return (
                      this.functions.length > 0 &&
                      ((this.functions.length = 0), !0)
                    )
                  }),
                  (A.prototype.dispatch = function () {
                    for (var c = [], d = 0; d < arguments.length; d++)
                      c[d] = arguments[d]
                    var p = this.functions.concat()
                    p.forEach(function (m) {
                      m.apply(void 0, c)
                    })
                  }),
                  Object.defineProperty(A.prototype, "numItems", {
                    get: function () {
                      return this.functions.length
                    },
                    enumerable: !0,
                    configurable: !0,
                  }),
                  A
                )
              })()
              Object.defineProperty(o, "__esModule", { value: !0 }),
                (o.default = a)
            },
          ])
        })
      },
    ])
  })
})(m8)
var X2 = Eq(m8.exports)
function YU(n, e) {
  switch (arguments.length) {
    case 0:
      break
    case 1:
      this.range(n)
      break
    default:
      this.range(e).domain(n)
      break
  }
  return this
}
function Y2(n, e, t) {
  ;(n.prototype = e.prototype = t), (t.constructor = n)
}
function g8(n, e) {
  var t = Object.create(n.prototype)
  for (var i in e) t[i] = e[i]
  return t
}
function Xu() {}
var vu = 0.7,
  H0 = 1 / vu,
  oc = "\\s*([+-]?\\d+)\\s*",
  _u = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
  rs = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
  ZU = /^#([0-9a-f]{3,8})$/,
  JU = new RegExp(`^rgb\\(${oc},${oc},${oc}\\)$`),
  KU = new RegExp(`^rgb\\(${rs},${rs},${rs}\\)$`),
  ez = new RegExp(`^rgba\\(${oc},${oc},${oc},${_u}\\)$`),
  tz = new RegExp(`^rgba\\(${rs},${rs},${rs},${_u}\\)$`),
  nz = new RegExp(`^hsl\\(${_u},${rs},${rs}\\)$`),
  iz = new RegExp(`^hsla\\(${_u},${rs},${rs},${_u}\\)$`),
  vx = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  }
Y2(Xu, xu, {
  copy(n) {
    return Object.assign(new this.constructor(), this, n)
  },
  displayable() {
    return this.rgb().displayable()
  },
  hex: _x,
  formatHex: _x,
  formatHex8: rz,
  formatHsl: sz,
  formatRgb: xx,
  toString: xx,
})
function _x() {
  return this.rgb().formatHex()
}
function rz() {
  return this.rgb().formatHex8()
}
function sz() {
  return y8(this).formatHsl()
}
function xx() {
  return this.rgb().formatRgb()
}
function xu(n) {
  var e, t
  return (
    (n = (n + "").trim().toLowerCase()),
    (e = ZU.exec(n))
      ? ((t = e[1].length),
        (e = parseInt(e[1], 16)),
        t === 6
          ? bx(e)
          : t === 3
          ? new Hi(
              ((e >> 8) & 15) | ((e >> 4) & 240),
              ((e >> 4) & 15) | (e & 240),
              ((e & 15) << 4) | (e & 15),
              1
            )
          : t === 8
          ? Th(
              (e >> 24) & 255,
              (e >> 16) & 255,
              (e >> 8) & 255,
              (e & 255) / 255
            )
          : t === 4
          ? Th(
              ((e >> 12) & 15) | ((e >> 8) & 240),
              ((e >> 8) & 15) | ((e >> 4) & 240),
              ((e >> 4) & 15) | (e & 240),
              (((e & 15) << 4) | (e & 15)) / 255
            )
          : null)
      : (e = JU.exec(n))
      ? new Hi(e[1], e[2], e[3], 1)
      : (e = KU.exec(n))
      ? new Hi((e[1] * 255) / 100, (e[2] * 255) / 100, (e[3] * 255) / 100, 1)
      : (e = ez.exec(n))
      ? Th(e[1], e[2], e[3], e[4])
      : (e = tz.exec(n))
      ? Th((e[1] * 255) / 100, (e[2] * 255) / 100, (e[3] * 255) / 100, e[4])
      : (e = nz.exec(n))
      ? Sx(e[1], e[2] / 100, e[3] / 100, 1)
      : (e = iz.exec(n))
      ? Sx(e[1], e[2] / 100, e[3] / 100, e[4])
      : vx.hasOwnProperty(n)
      ? bx(vx[n])
      : n === "transparent"
      ? new Hi(NaN, NaN, NaN, 0)
      : null
  )
}
function bx(n) {
  return new Hi((n >> 16) & 255, (n >> 8) & 255, n & 255, 1)
}
function Th(n, e, t, i) {
  return i <= 0 && (n = e = t = NaN), new Hi(n, e, t, i)
}
function oz(n) {
  return (
    n instanceof Xu || (n = xu(n)),
    n ? ((n = n.rgb()), new Hi(n.r, n.g, n.b, n.opacity)) : new Hi()
  )
}
function Ag(n, e, t, i) {
  return arguments.length === 1 ? oz(n) : new Hi(n, e, t, i == null ? 1 : i)
}
function Hi(n, e, t, i) {
  ;(this.r = +n), (this.g = +e), (this.b = +t), (this.opacity = +i)
}
Y2(
  Hi,
  Ag,
  g8(Xu, {
    brighter(n) {
      return (
        (n = n == null ? H0 : Math.pow(H0, n)),
        new Hi(this.r * n, this.g * n, this.b * n, this.opacity)
      )
    },
    darker(n) {
      return (
        (n = n == null ? vu : Math.pow(vu, n)),
        new Hi(this.r * n, this.g * n, this.b * n, this.opacity)
      )
    },
    rgb() {
      return this
    },
    clamp() {
      return new Hi(Oa(this.r), Oa(this.g), Oa(this.b), G0(this.opacity))
    },
    displayable() {
      return (
        -0.5 <= this.r &&
        this.r < 255.5 &&
        -0.5 <= this.g &&
        this.g < 255.5 &&
        -0.5 <= this.b &&
        this.b < 255.5 &&
        0 <= this.opacity &&
        this.opacity <= 1
      )
    },
    hex: wx,
    formatHex: wx,
    formatHex8: az,
    formatRgb: Mx,
    toString: Mx,
  })
)
function wx() {
  return `#${Ma(this.r)}${Ma(this.g)}${Ma(this.b)}`
}
function az() {
  return `#${Ma(this.r)}${Ma(this.g)}${Ma(this.b)}${Ma(
    (isNaN(this.opacity) ? 1 : this.opacity) * 255
  )}`
}
function Mx() {
  const n = G0(this.opacity)
  return `${n === 1 ? "rgb(" : "rgba("}${Oa(this.r)}, ${Oa(this.g)}, ${Oa(
    this.b
  )}${n === 1 ? ")" : `, ${n})`}`
}
function G0(n) {
  return isNaN(n) ? 1 : Math.max(0, Math.min(1, n))
}
function Oa(n) {
  return Math.max(0, Math.min(255, Math.round(n) || 0))
}
function Ma(n) {
  return (n = Oa(n)), (n < 16 ? "0" : "") + n.toString(16)
}
function Sx(n, e, t, i) {
  return (
    i <= 0
      ? (n = e = t = NaN)
      : t <= 0 || t >= 1
      ? (n = e = NaN)
      : e <= 0 && (n = NaN),
    new Ir(n, e, t, i)
  )
}
function y8(n) {
  if (n instanceof Ir) return new Ir(n.h, n.s, n.l, n.opacity)
  if ((n instanceof Xu || (n = xu(n)), !n)) return new Ir()
  if (n instanceof Ir) return n
  n = n.rgb()
  var e = n.r / 255,
    t = n.g / 255,
    i = n.b / 255,
    r = Math.min(e, t, i),
    s = Math.max(e, t, i),
    o = NaN,
    a = s - r,
    A = (s + r) / 2
  return (
    a
      ? (e === s
          ? (o = (t - i) / a + (t < i) * 6)
          : t === s
          ? (o = (i - e) / a + 2)
          : (o = (e - t) / a + 4),
        (a /= A < 0.5 ? s + r : 2 - s - r),
        (o *= 60))
      : (a = A > 0 && A < 1 ? 0 : o),
    new Ir(o, a, A, n.opacity)
  )
}
function lz(n, e, t, i) {
  return arguments.length === 1 ? y8(n) : new Ir(n, e, t, i == null ? 1 : i)
}
function Ir(n, e, t, i) {
  ;(this.h = +n), (this.s = +e), (this.l = +t), (this.opacity = +i)
}
Y2(
  Ir,
  lz,
  g8(Xu, {
    brighter(n) {
      return (
        (n = n == null ? H0 : Math.pow(H0, n)),
        new Ir(this.h, this.s, this.l * n, this.opacity)
      )
    },
    darker(n) {
      return (
        (n = n == null ? vu : Math.pow(vu, n)),
        new Ir(this.h, this.s, this.l * n, this.opacity)
      )
    },
    rgb() {
      var n = (this.h % 360) + (this.h < 0) * 360,
        e = isNaN(n) || isNaN(this.s) ? 0 : this.s,
        t = this.l,
        i = t + (t < 0.5 ? t : 1 - t) * e,
        r = 2 * t - i
      return new Hi(
        mm(n >= 240 ? n - 240 : n + 120, r, i),
        mm(n, r, i),
        mm(n < 120 ? n + 240 : n - 120, r, i),
        this.opacity
      )
    },
    clamp() {
      return new Ir(Ex(this.h), Ch(this.s), Ch(this.l), G0(this.opacity))
    },
    displayable() {
      return (
        ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
        0 <= this.l &&
        this.l <= 1 &&
        0 <= this.opacity &&
        this.opacity <= 1
      )
    },
    formatHsl() {
      const n = G0(this.opacity)
      return `${n === 1 ? "hsl(" : "hsla("}${Ex(this.h)}, ${
        Ch(this.s) * 100
      }%, ${Ch(this.l) * 100}%${n === 1 ? ")" : `, ${n})`}`
    },
  })
)
function Ex(n) {
  return (n = (n || 0) % 360), n < 0 ? n + 360 : n
}
function Ch(n) {
  return Math.max(0, Math.min(1, n || 0))
}
function mm(n, e, t) {
  return (
    (n < 60
      ? e + ((t - e) * n) / 60
      : n < 180
      ? t
      : n < 240
      ? e + ((t - e) * (240 - n)) / 60
      : e) * 255
  )
}
var Z2 = n => () => n
function cz(n, e) {
  return function (t) {
    return n + t * e
  }
}
function Az(n, e, t) {
  return (
    (n = Math.pow(n, t)),
    (e = Math.pow(e, t) - n),
    (t = 1 / t),
    function (i) {
      return Math.pow(n + i * e, t)
    }
  )
}
function uz(n) {
  return (n = +n) == 1
    ? v8
    : function (e, t) {
        return t - e ? Az(e, t, n) : Z2(isNaN(e) ? t : e)
      }
}
function v8(n, e) {
  var t = e - n
  return t ? cz(n, t) : Z2(isNaN(n) ? e : n)
}
var Tx = (function n(e) {
  var t = uz(e)
  function i(r, s) {
    var o = t((r = Ag(r)).r, (s = Ag(s)).r),
      a = t(r.g, s.g),
      A = t(r.b, s.b),
      c = v8(r.opacity, s.opacity)
    return function (d) {
      return (
        (r.r = o(d)), (r.g = a(d)), (r.b = A(d)), (r.opacity = c(d)), r + ""
      )
    }
  }
  return (i.gamma = n), i
})(1)
function _8(n, e) {
  e || (e = [])
  var t = n ? Math.min(e.length, n.length) : 0,
    i = e.slice(),
    r
  return function (s) {
    for (r = 0; r < t; ++r) i[r] = n[r] * (1 - s) + e[r] * s
    return i
  }
}
function x8(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView)
}
function fz(n, e) {
  return (x8(e) ? _8 : b8)(n, e)
}
function b8(n, e) {
  var t = e ? e.length : 0,
    i = n ? Math.min(t, n.length) : 0,
    r = new Array(i),
    s = new Array(t),
    o
  for (o = 0; o < i; ++o) r[o] = J2(n[o], e[o])
  for (; o < t; ++o) s[o] = e[o]
  return function (a) {
    for (o = 0; o < i; ++o) s[o] = r[o](a)
    return s
  }
}
function hz(n, e) {
  var t = new Date()
  return (
    (n = +n),
    (e = +e),
    function (i) {
      return t.setTime(n * (1 - i) + e * i), t
    }
  )
}
function V0(n, e) {
  return (
    (n = +n),
    (e = +e),
    function (t) {
      return n * (1 - t) + e * t
    }
  )
}
function dz(n, e) {
  var t = {},
    i = {},
    r
  ;(n === null || typeof n != "object") && (n = {}),
    (e === null || typeof e != "object") && (e = {})
  for (r in e) r in n ? (t[r] = J2(n[r], e[r])) : (i[r] = e[r])
  return function (s) {
    for (r in t) i[r] = t[r](s)
    return i
  }
}
var ug = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
  gm = new RegExp(ug.source, "g")
function pz(n) {
  return function () {
    return n
  }
}
function mz(n) {
  return function (e) {
    return n(e) + ""
  }
}
function gz(n, e) {
  var t = (ug.lastIndex = gm.lastIndex = 0),
    i,
    r,
    s,
    o = -1,
    a = [],
    A = []
  for (n = n + "", e = e + ""; (i = ug.exec(n)) && (r = gm.exec(e)); )
    (s = r.index) > t &&
      ((s = e.slice(t, s)), a[o] ? (a[o] += s) : (a[++o] = s)),
      (i = i[0]) === (r = r[0])
        ? a[o]
          ? (a[o] += r)
          : (a[++o] = r)
        : ((a[++o] = null), A.push({ i: o, x: V0(i, r) })),
      (t = gm.lastIndex)
  return (
    t < e.length && ((s = e.slice(t)), a[o] ? (a[o] += s) : (a[++o] = s)),
    a.length < 2
      ? A[0]
        ? mz(A[0].x)
        : pz(e)
      : ((e = A.length),
        function (c) {
          for (var d = 0, p; d < e; ++d) a[(p = A[d]).i] = p.x(c)
          return a.join("")
        })
  )
}
function J2(n, e) {
  var t = typeof e,
    i
  return e == null || t === "boolean"
    ? Z2(e)
    : (t === "number"
        ? V0
        : t === "string"
        ? (i = xu(e))
          ? ((e = i), Tx)
          : gz
        : e instanceof xu
        ? Tx
        : e instanceof Date
        ? hz
        : x8(e)
        ? _8
        : Array.isArray(e)
        ? b8
        : (typeof e.valueOf != "function" && typeof e.toString != "function") ||
          isNaN(e)
        ? dz
        : V0)(n, e)
}
function yz(n, e) {
  return (
    (n = +n),
    (e = +e),
    function (t) {
      return Math.round(n * (1 - t) + e * t)
    }
  )
}
function vz(n) {
  return function () {
    return n
  }
}
function _z(n) {
  return +n
}
var Cx = [0, 1]
function jl(n) {
  return n
}
function fg(n, e) {
  return (e -= n = +n)
    ? function (t) {
        return (t - n) / e
      }
    : vz(isNaN(e) ? NaN : 0.5)
}
function xz(n, e) {
  var t
  return (
    n > e && ((t = n), (n = e), (e = t)),
    function (i) {
      return Math.max(n, Math.min(e, i))
    }
  )
}
function bz(n, e, t) {
  var i = n[0],
    r = n[1],
    s = e[0],
    o = e[1]
  return (
    r < i ? ((i = fg(r, i)), (s = t(o, s))) : ((i = fg(i, r)), (s = t(s, o))),
    function (a) {
      return s(i(a))
    }
  )
}
function wz(n, e, t) {
  var i = Math.min(n.length, e.length) - 1,
    r = new Array(i),
    s = new Array(i),
    o = -1
  for (
    n[i] < n[0] && ((n = n.slice().reverse()), (e = e.slice().reverse()));
    ++o < i;

  )
    (r[o] = fg(n[o], n[o + 1])), (s[o] = t(e[o], e[o + 1]))
  return function (a) {
    var A = cN(n, a, 1, i) - 1
    return s[A](r[A](a))
  }
}
function Mz(n, e) {
  return e
    .domain(n.domain())
    .range(n.range())
    .interpolate(n.interpolate())
    .clamp(n.clamp())
    .unknown(n.unknown())
}
function Sz() {
  var n = Cx,
    e = Cx,
    t = J2,
    i,
    r,
    s,
    o = jl,
    a,
    A,
    c
  function d() {
    var m = Math.min(n.length, e.length)
    return (
      o !== jl && (o = xz(n[0], n[m - 1])),
      (a = m > 2 ? wz : bz),
      (A = c = null),
      p
    )
  }
  function p(m) {
    return m == null || isNaN((m = +m))
      ? s
      : (A || (A = a(n.map(i), e, t)))(i(o(m)))
  }
  return (
    (p.invert = function (m) {
      return o(r((c || (c = a(e, n.map(i), V0)))(m)))
    }),
    (p.domain = function (m) {
      return arguments.length ? ((n = Array.from(m, _z)), d()) : n.slice()
    }),
    (p.range = function (m) {
      return arguments.length ? ((e = Array.from(m)), d()) : e.slice()
    }),
    (p.rangeRound = function (m) {
      return (e = Array.from(m)), (t = yz), d()
    }),
    (p.clamp = function (m) {
      return arguments.length ? ((o = m ? !0 : jl), d()) : o !== jl
    }),
    (p.interpolate = function (m) {
      return arguments.length ? ((t = m), d()) : t
    }),
    (p.unknown = function (m) {
      return arguments.length ? ((s = m), p) : s
    }),
    function (m, y) {
      return (i = m), (r = y), d()
    }
  )
}
function Ez() {
  return Sz()(jl, jl)
}
function Tz(n) {
  return Math.abs((n = Math.round(n))) >= 1e21
    ? n.toLocaleString("en").replace(/,/g, "")
    : n.toString(10)
}
function W0(n, e) {
  if (
    (t = (n = e ? n.toExponential(e - 1) : n.toExponential()).indexOf("e")) < 0
  )
    return null
  var t,
    i = n.slice(0, t)
  return [i.length > 1 ? i[0] + i.slice(2) : i, +n.slice(t + 1)]
}
function Dc(n) {
  return (n = W0(Math.abs(n))), n ? n[1] : NaN
}
function Cz(n, e) {
  return function (t, i) {
    for (
      var r = t.length, s = [], o = 0, a = n[0], A = 0;
      r > 0 &&
      a > 0 &&
      (A + a + 1 > i && (a = Math.max(1, i - A)),
      s.push(t.substring((r -= a), r + a)),
      !((A += a + 1) > i));

    )
      a = n[(o = (o + 1) % n.length)]
    return s.reverse().join(e)
  }
}
function Rz(n) {
  return function (e) {
    return e.replace(/[0-9]/g, function (t) {
      return n[+t]
    })
  }
}
var Pz =
  /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i
function j0(n) {
  if (!(e = Pz.exec(n))) throw new Error("invalid format: " + n)
  var e
  return new K2({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10],
  })
}
j0.prototype = K2.prototype
function K2(n) {
  ;(this.fill = n.fill === void 0 ? " " : n.fill + ""),
    (this.align = n.align === void 0 ? ">" : n.align + ""),
    (this.sign = n.sign === void 0 ? "-" : n.sign + ""),
    (this.symbol = n.symbol === void 0 ? "" : n.symbol + ""),
    (this.zero = !!n.zero),
    (this.width = n.width === void 0 ? void 0 : +n.width),
    (this.comma = !!n.comma),
    (this.precision = n.precision === void 0 ? void 0 : +n.precision),
    (this.trim = !!n.trim),
    (this.type = n.type === void 0 ? "" : n.type + "")
}
K2.prototype.toString = function () {
  return (
    this.fill +
    this.align +
    this.sign +
    this.symbol +
    (this.zero ? "0" : "") +
    (this.width === void 0 ? "" : Math.max(1, this.width | 0)) +
    (this.comma ? "," : "") +
    (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) +
    (this.trim ? "~" : "") +
    this.type
  )
}
function Lz(n) {
  e: for (var e = n.length, t = 1, i = -1, r; t < e; ++t)
    switch (n[t]) {
      case ".":
        i = r = t
        break
      case "0":
        i === 0 && (i = t), (r = t)
        break
      default:
        if (!+n[t]) break e
        i > 0 && (i = 0)
        break
    }
  return i > 0 ? n.slice(0, i) + n.slice(r + 1) : n
}
var w8
function Dz(n, e) {
  var t = W0(n, e)
  if (!t) return n + ""
  var i = t[0],
    r = t[1],
    s = r - (w8 = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1,
    o = i.length
  return s === o
    ? i
    : s > o
    ? i + new Array(s - o + 1).join("0")
    : s > 0
    ? i.slice(0, s) + "." + i.slice(s)
    : "0." + new Array(1 - s).join("0") + W0(n, Math.max(0, e + s - 1))[0]
}
function Rx(n, e) {
  var t = W0(n, e)
  if (!t) return n + ""
  var i = t[0],
    r = t[1]
  return r < 0
    ? "0." + new Array(-r).join("0") + i
    : i.length > r + 1
    ? i.slice(0, r + 1) + "." + i.slice(r + 1)
    : i + new Array(r - i.length + 2).join("0")
}
var Px = {
  "%": (n, e) => (n * 100).toFixed(e),
  b: n => Math.round(n).toString(2),
  c: n => n + "",
  d: Tz,
  e: (n, e) => n.toExponential(e),
  f: (n, e) => n.toFixed(e),
  g: (n, e) => n.toPrecision(e),
  o: n => Math.round(n).toString(8),
  p: (n, e) => Rx(n * 100, e),
  r: Rx,
  s: Dz,
  X: n => Math.round(n).toString(16).toUpperCase(),
  x: n => Math.round(n).toString(16),
}
function Lx(n) {
  return n
}
var Dx = Array.prototype.map,
  Ix = [
    "y",
    "z",
    "a",
    "f",
    "p",
    "n",
    "\xB5",
    "m",
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y",
  ]
function Iz(n) {
  var e =
      n.grouping === void 0 || n.thousands === void 0
        ? Lx
        : Cz(Dx.call(n.grouping, Number), n.thousands + ""),
    t = n.currency === void 0 ? "" : n.currency[0] + "",
    i = n.currency === void 0 ? "" : n.currency[1] + "",
    r = n.decimal === void 0 ? "." : n.decimal + "",
    s = n.numerals === void 0 ? Lx : Rz(Dx.call(n.numerals, String)),
    o = n.percent === void 0 ? "%" : n.percent + "",
    a = n.minus === void 0 ? "\u2212" : n.minus + "",
    A = n.nan === void 0 ? "NaN" : n.nan + ""
  function c(p) {
    p = j0(p)
    var m = p.fill,
      y = p.align,
      x = p.sign,
      S = p.symbol,
      C = p.zero,
      M = p.width,
      _ = p.comma,
      R = p.precision,
      T = p.trim,
      L = p.type
    L === "n"
      ? ((_ = !0), (L = "g"))
      : Px[L] || (R === void 0 && (R = 12), (T = !0), (L = "g")),
      (C || (m === "0" && y === "=")) && ((C = !0), (m = "0"), (y = "="))
    var B =
        S === "$"
          ? t
          : S === "#" && /[boxX]/.test(L)
          ? "0" + L.toLowerCase()
          : "",
      k = S === "$" ? i : /[%p]/.test(L) ? o : "",
      O = Px[L],
      W = /[defgprs%]/.test(L)
    R =
      R === void 0
        ? 6
        : /[gprs]/.test(L)
        ? Math.max(1, Math.min(21, R))
        : Math.max(0, Math.min(20, R))
    function z(P) {
      var N = B,
        G = k,
        j,
        V,
        Y
      if (L === "c") (G = O(P) + G), (P = "")
      else {
        P = +P
        var ne = P < 0 || 1 / P < 0
        if (
          ((P = isNaN(P) ? A : O(Math.abs(P), R)),
          T && (P = Lz(P)),
          ne && +P == 0 && x !== "+" && (ne = !1),
          (N =
            (ne ? (x === "(" ? x : a) : x === "-" || x === "(" ? "" : x) + N),
          (G =
            (L === "s" ? Ix[8 + w8 / 3] : "") +
            G +
            (ne && x === "(" ? ")" : "")),
          W)
        ) {
          for (j = -1, V = P.length; ++j < V; )
            if (((Y = P.charCodeAt(j)), 48 > Y || Y > 57)) {
              ;(G = (Y === 46 ? r + P.slice(j + 1) : P.slice(j)) + G),
                (P = P.slice(0, j))
              break
            }
        }
      }
      _ && !C && (P = e(P, 1 / 0))
      var le = N.length + P.length + G.length,
        Te = le < M ? new Array(M - le + 1).join(m) : ""
      switch (
        (_ &&
          C &&
          ((P = e(Te + P, Te.length ? M - G.length : 1 / 0)), (Te = "")),
        y)
      ) {
        case "<":
          P = N + P + G + Te
          break
        case "=":
          P = N + Te + P + G
          break
        case "^":
          P = Te.slice(0, (le = Te.length >> 1)) + N + P + G + Te.slice(le)
          break
        default:
          P = Te + N + P + G
          break
      }
      return s(P)
    }
    return (
      (z.toString = function () {
        return p + ""
      }),
      z
    )
  }
  function d(p, m) {
    var y = c(((p = j0(p)), (p.type = "f"), p)),
      x = Math.max(-8, Math.min(8, Math.floor(Dc(m) / 3))) * 3,
      S = Math.pow(10, -x),
      C = Ix[8 + x / 3]
    return function (M) {
      return y(S * M) + C
    }
  }
  return { format: c, formatPrefix: d }
}
var Rh, M8, S8
Bz({ thousands: ",", grouping: [3], currency: ["$", ""] })
function Bz(n) {
  return (Rh = Iz(n)), (M8 = Rh.format), (S8 = Rh.formatPrefix), Rh
}
function kz(n) {
  return Math.max(0, -Dc(Math.abs(n)))
}
function Oz(n, e) {
  return Math.max(
    0,
    Math.max(-8, Math.min(8, Math.floor(Dc(e) / 3))) * 3 - Dc(Math.abs(n))
  )
}
function qz(n, e) {
  return (
    (n = Math.abs(n)), (e = Math.abs(e) - n), Math.max(0, Dc(e) - Dc(n)) + 1
  )
}
function Fz(n, e, t, i) {
  var r = uN(n, e, t),
    s
  switch (((i = j0(i == null ? ",f" : i)), i.type)) {
    case "s": {
      var o = Math.max(Math.abs(n), Math.abs(e))
      return (
        i.precision == null && !isNaN((s = Oz(r, o))) && (i.precision = s),
        S8(i, o)
      )
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null &&
        !isNaN((s = qz(r, Math.max(Math.abs(n), Math.abs(e))))) &&
        (i.precision = s - (i.type === "e"))
      break
    }
    case "f":
    case "%": {
      i.precision == null &&
        !isNaN((s = kz(r))) &&
        (i.precision = s - (i.type === "%") * 2)
      break
    }
  }
  return M8(i)
}
function Nz(n) {
  var e = n.domain
  return (
    (n.ticks = function (t) {
      var i = e()
      return AN(i[0], i[i.length - 1], t == null ? 10 : t)
    }),
    (n.tickFormat = function (t, i) {
      var r = e()
      return Fz(r[0], r[r.length - 1], t == null ? 10 : t, i)
    }),
    (n.nice = function (t) {
      t == null && (t = 10)
      var i = e(),
        r = 0,
        s = i.length - 1,
        o = i[r],
        a = i[s],
        A,
        c,
        d = 10
      for (
        a < o && ((c = o), (o = a), (a = c), (c = r), (r = s), (s = c));
        d-- > 0;

      ) {
        if (((c = H6(o, a, t)), c === A)) return (i[r] = o), (i[s] = a), e(i)
        if (c > 0) (o = Math.floor(o / c) * c), (a = Math.ceil(a / c) * c)
        else if (c < 0) (o = Math.ceil(o * c) / c), (a = Math.floor(a * c) / c)
        else break
        A = c
      }
      return n
    }),
    n
  )
}
function Ic() {
  var n = Ez()
  return (
    (n.copy = function () {
      return Mz(n, Ic())
    }),
    YU.apply(n, arguments),
    Nz(n)
  )
}
const Os = 11102230246251565e-32,
  fi = 134217729,
  Uz = (3 + 8 * Os) * Os
function ym(n, e, t, i, r) {
  let s,
    o,
    a,
    A,
    c = e[0],
    d = i[0],
    p = 0,
    m = 0
  d > c == d > -c ? ((s = c), (c = e[++p])) : ((s = d), (d = i[++m]))
  let y = 0
  if (p < n && m < t)
    for (
      d > c == d > -c
        ? ((o = c + s), (a = s - (o - c)), (c = e[++p]))
        : ((o = d + s), (a = s - (o - d)), (d = i[++m])),
        s = o,
        a !== 0 && (r[y++] = a);
      p < n && m < t;

    )
      d > c == d > -c
        ? ((o = s + c), (A = o - s), (a = s - (o - A) + (c - A)), (c = e[++p]))
        : ((o = s + d), (A = o - s), (a = s - (o - A) + (d - A)), (d = i[++m])),
        (s = o),
        a !== 0 && (r[y++] = a)
  for (; p < n; )
    (o = s + c),
      (A = o - s),
      (a = s - (o - A) + (c - A)),
      (c = e[++p]),
      (s = o),
      a !== 0 && (r[y++] = a)
  for (; m < t; )
    (o = s + d),
      (A = o - s),
      (a = s - (o - A) + (d - A)),
      (d = i[++m]),
      (s = o),
      a !== 0 && (r[y++] = a)
  return (s !== 0 || y === 0) && (r[y++] = s), y
}
function zz(n, e) {
  let t = e[0]
  for (let i = 1; i < n; i++) t += e[i]
  return t
}
function Yu(n) {
  return new Float64Array(n)
}
const Hz = (3 + 16 * Os) * Os,
  Gz = (2 + 12 * Os) * Os,
  Vz = (9 + 64 * Os) * Os * Os,
  Ll = Yu(4),
  Bx = Yu(8),
  kx = Yu(12),
  Ox = Yu(16),
  bi = Yu(4)
function Wz(n, e, t, i, r, s, o) {
  let a, A, c, d, p, m, y, x, S, C, M, _, R, T, L, B, k, O
  const W = n - r,
    z = t - r,
    P = e - s,
    N = i - s
  ;(T = W * N),
    (m = fi * W),
    (y = m - (m - W)),
    (x = W - y),
    (m = fi * N),
    (S = m - (m - N)),
    (C = N - S),
    (L = x * C - (T - y * S - x * S - y * C)),
    (B = P * z),
    (m = fi * P),
    (y = m - (m - P)),
    (x = P - y),
    (m = fi * z),
    (S = m - (m - z)),
    (C = z - S),
    (k = x * C - (B - y * S - x * S - y * C)),
    (M = L - k),
    (p = L - M),
    (Ll[0] = L - (M + p) + (p - k)),
    (_ = T + M),
    (p = _ - T),
    (R = T - (_ - p) + (M - p)),
    (M = R - B),
    (p = R - M),
    (Ll[1] = R - (M + p) + (p - B)),
    (O = _ + M),
    (p = O - _),
    (Ll[2] = _ - (O - p) + (M - p)),
    (Ll[3] = O)
  let G = zz(4, Ll),
    j = Gz * o
  if (
    G >= j ||
    -G >= j ||
    ((p = n - W),
    (a = n - (W + p) + (p - r)),
    (p = t - z),
    (c = t - (z + p) + (p - r)),
    (p = e - P),
    (A = e - (P + p) + (p - s)),
    (p = i - N),
    (d = i - (N + p) + (p - s)),
    a === 0 && A === 0 && c === 0 && d === 0) ||
    ((j = Vz * o + Uz * Math.abs(G)),
    (G += W * d + N * a - (P * c + z * A)),
    G >= j || -G >= j)
  )
    return G
  ;(T = a * N),
    (m = fi * a),
    (y = m - (m - a)),
    (x = a - y),
    (m = fi * N),
    (S = m - (m - N)),
    (C = N - S),
    (L = x * C - (T - y * S - x * S - y * C)),
    (B = A * z),
    (m = fi * A),
    (y = m - (m - A)),
    (x = A - y),
    (m = fi * z),
    (S = m - (m - z)),
    (C = z - S),
    (k = x * C - (B - y * S - x * S - y * C)),
    (M = L - k),
    (p = L - M),
    (bi[0] = L - (M + p) + (p - k)),
    (_ = T + M),
    (p = _ - T),
    (R = T - (_ - p) + (M - p)),
    (M = R - B),
    (p = R - M),
    (bi[1] = R - (M + p) + (p - B)),
    (O = _ + M),
    (p = O - _),
    (bi[2] = _ - (O - p) + (M - p)),
    (bi[3] = O)
  const V = ym(4, Ll, 4, bi, Bx)
  ;(T = W * d),
    (m = fi * W),
    (y = m - (m - W)),
    (x = W - y),
    (m = fi * d),
    (S = m - (m - d)),
    (C = d - S),
    (L = x * C - (T - y * S - x * S - y * C)),
    (B = P * c),
    (m = fi * P),
    (y = m - (m - P)),
    (x = P - y),
    (m = fi * c),
    (S = m - (m - c)),
    (C = c - S),
    (k = x * C - (B - y * S - x * S - y * C)),
    (M = L - k),
    (p = L - M),
    (bi[0] = L - (M + p) + (p - k)),
    (_ = T + M),
    (p = _ - T),
    (R = T - (_ - p) + (M - p)),
    (M = R - B),
    (p = R - M),
    (bi[1] = R - (M + p) + (p - B)),
    (O = _ + M),
    (p = O - _),
    (bi[2] = _ - (O - p) + (M - p)),
    (bi[3] = O)
  const Y = ym(V, Bx, 4, bi, kx)
  ;(T = a * d),
    (m = fi * a),
    (y = m - (m - a)),
    (x = a - y),
    (m = fi * d),
    (S = m - (m - d)),
    (C = d - S),
    (L = x * C - (T - y * S - x * S - y * C)),
    (B = A * c),
    (m = fi * A),
    (y = m - (m - A)),
    (x = A - y),
    (m = fi * c),
    (S = m - (m - c)),
    (C = c - S),
    (k = x * C - (B - y * S - x * S - y * C)),
    (M = L - k),
    (p = L - M),
    (bi[0] = L - (M + p) + (p - k)),
    (_ = T + M),
    (p = _ - T),
    (R = T - (_ - p) + (M - p)),
    (M = R - B),
    (p = R - M),
    (bi[1] = R - (M + p) + (p - B)),
    (O = _ + M),
    (p = O - _),
    (bi[2] = _ - (O - p) + (M - p)),
    (bi[3] = O)
  const ne = ym(Y, kx, 4, bi, Ox)
  return Ox[ne - 1]
}
function Ph(n, e, t, i, r, s) {
  const o = (e - s) * (t - r),
    a = (n - r) * (i - s),
    A = o - a
  if (o === 0 || a === 0 || o > 0 != a > 0) return A
  const c = Math.abs(o + a)
  return Math.abs(A) >= Hz * c ? A : -Wz(n, e, t, i, r, s, c)
}
const qx = Math.pow(2, -52),
  Lh = new Uint32Array(512)
class bu {
  static from(e, t = Yz, i = Zz) {
    const r = e.length,
      s = new Float64Array(r * 2)
    for (let o = 0; o < r; o++) {
      const a = e[o]
      ;(s[2 * o] = t(a)), (s[2 * o + 1] = i(a))
    }
    return new bu(s)
  }
  constructor(e) {
    const t = e.length >> 1
    if (t > 0 && typeof e[0] != "number")
      throw new Error("Expected coords to contain numbers.")
    this.coords = e
    const i = Math.max(2 * t - 5, 0)
    ;(this._triangles = new Uint32Array(i * 3)),
      (this._halfedges = new Int32Array(i * 3)),
      (this._hashSize = Math.ceil(Math.sqrt(t))),
      (this._hullPrev = new Uint32Array(t)),
      (this._hullNext = new Uint32Array(t)),
      (this._hullTri = new Uint32Array(t)),
      (this._hullHash = new Int32Array(this._hashSize).fill(-1)),
      (this._ids = new Uint32Array(t)),
      (this._dists = new Float64Array(t)),
      this.update()
  }
  update() {
    const {
        coords: e,
        _hullPrev: t,
        _hullNext: i,
        _hullTri: r,
        _hullHash: s,
      } = this,
      o = e.length >> 1
    let a = 1 / 0,
      A = 1 / 0,
      c = -1 / 0,
      d = -1 / 0
    for (let z = 0; z < o; z++) {
      const P = e[2 * z],
        N = e[2 * z + 1]
      P < a && (a = P),
        N < A && (A = N),
        P > c && (c = P),
        N > d && (d = N),
        (this._ids[z] = z)
    }
    const p = (a + c) / 2,
      m = (A + d) / 2
    let y = 1 / 0,
      x,
      S,
      C
    for (let z = 0; z < o; z++) {
      const P = vm(p, m, e[2 * z], e[2 * z + 1])
      P < y && ((x = z), (y = P))
    }
    const M = e[2 * x],
      _ = e[2 * x + 1]
    y = 1 / 0
    for (let z = 0; z < o; z++) {
      if (z === x) continue
      const P = vm(M, _, e[2 * z], e[2 * z + 1])
      P < y && P > 0 && ((S = z), (y = P))
    }
    let R = e[2 * S],
      T = e[2 * S + 1],
      L = 1 / 0
    for (let z = 0; z < o; z++) {
      if (z === x || z === S) continue
      const P = Qz(M, _, R, T, e[2 * z], e[2 * z + 1])
      P < L && ((C = z), (L = P))
    }
    let B = e[2 * C],
      k = e[2 * C + 1]
    if (L === 1 / 0) {
      for (let N = 0; N < o; N++)
        this._dists[N] = e[2 * N] - e[0] || e[2 * N + 1] - e[1]
      $l(this._ids, this._dists, 0, o - 1)
      const z = new Uint32Array(o)
      let P = 0
      for (let N = 0, G = -1 / 0; N < o; N++) {
        const j = this._ids[N]
        this._dists[j] > G && ((z[P++] = j), (G = this._dists[j]))
      }
      ;(this.hull = z.subarray(0, P)),
        (this.triangles = new Uint32Array(0)),
        (this.halfedges = new Uint32Array(0))
      return
    }
    if (Ph(M, _, R, T, B, k) < 0) {
      const z = S,
        P = R,
        N = T
      ;(S = C), (R = B), (T = k), (C = z), (B = P), (k = N)
    }
    const O = Xz(M, _, R, T, B, k)
    ;(this._cx = O.x), (this._cy = O.y)
    for (let z = 0; z < o; z++)
      this._dists[z] = vm(e[2 * z], e[2 * z + 1], O.x, O.y)
    $l(this._ids, this._dists, 0, o - 1), (this._hullStart = x)
    let W = 3
    ;(i[x] = t[C] = S),
      (i[S] = t[x] = C),
      (i[C] = t[S] = x),
      (r[x] = 0),
      (r[S] = 1),
      (r[C] = 2),
      s.fill(-1),
      (s[this._hashKey(M, _)] = x),
      (s[this._hashKey(R, T)] = S),
      (s[this._hashKey(B, k)] = C),
      (this.trianglesLen = 0),
      this._addTriangle(x, S, C, -1, -1, -1)
    for (let z = 0, P, N; z < this._ids.length; z++) {
      const G = this._ids[z],
        j = e[2 * G],
        V = e[2 * G + 1]
      if (
        (z > 0 && Math.abs(j - P) <= qx && Math.abs(V - N) <= qx) ||
        ((P = j), (N = V), G === x || G === S || G === C)
      )
        continue
      let Y = 0
      for (
        let ge = 0, Me = this._hashKey(j, V);
        ge < this._hashSize &&
        ((Y = s[(Me + ge) % this._hashSize]), !(Y !== -1 && Y !== i[Y]));
        ge++
      );
      Y = t[Y]
      let ne = Y,
        le
      for (
        ;
        (le = i[ne]),
          Ph(j, V, e[2 * ne], e[2 * ne + 1], e[2 * le], e[2 * le + 1]) >= 0;

      )
        if (((ne = le), ne === Y)) {
          ne = -1
          break
        }
      if (ne === -1) continue
      let Te = this._addTriangle(ne, G, i[ne], -1, -1, r[ne])
      ;(r[G] = this._legalize(Te + 2)), (r[ne] = Te), W++
      let Ae = i[ne]
      for (
        ;
        (le = i[Ae]),
          Ph(j, V, e[2 * Ae], e[2 * Ae + 1], e[2 * le], e[2 * le + 1]) < 0;

      )
        (Te = this._addTriangle(Ae, G, le, r[G], -1, r[Ae])),
          (r[G] = this._legalize(Te + 2)),
          (i[Ae] = Ae),
          W--,
          (Ae = le)
      if (ne === Y)
        for (
          ;
          (le = t[ne]),
            Ph(j, V, e[2 * le], e[2 * le + 1], e[2 * ne], e[2 * ne + 1]) < 0;

        )
          (Te = this._addTriangle(le, G, ne, -1, r[ne], r[le])),
            this._legalize(Te + 2),
            (r[le] = Te),
            (i[ne] = ne),
            W--,
            (ne = le)
      ;(this._hullStart = t[G] = ne),
        (i[ne] = t[Ae] = G),
        (i[G] = Ae),
        (s[this._hashKey(j, V)] = G),
        (s[this._hashKey(e[2 * ne], e[2 * ne + 1])] = ne)
    }
    this.hull = new Uint32Array(W)
    for (let z = 0, P = this._hullStart; z < W; z++)
      (this.hull[z] = P), (P = i[P])
    ;(this.triangles = this._triangles.subarray(0, this.trianglesLen)),
      (this.halfedges = this._halfedges.subarray(0, this.trianglesLen))
  }
  _hashKey(e, t) {
    return (
      Math.floor(jz(e - this._cx, t - this._cy) * this._hashSize) %
      this._hashSize
    )
  }
  _legalize(e) {
    const { _triangles: t, _halfedges: i, coords: r } = this
    let s = 0,
      o = 0
    for (;;) {
      const a = i[e],
        A = e - (e % 3)
      if (((o = A + ((e + 2) % 3)), a === -1)) {
        if (s === 0) break
        e = Lh[--s]
        continue
      }
      const c = a - (a % 3),
        d = A + ((e + 1) % 3),
        p = c + ((a + 2) % 3),
        m = t[o],
        y = t[e],
        x = t[d],
        S = t[p]
      if (
        $z(
          r[2 * m],
          r[2 * m + 1],
          r[2 * y],
          r[2 * y + 1],
          r[2 * x],
          r[2 * x + 1],
          r[2 * S],
          r[2 * S + 1]
        )
      ) {
        ;(t[e] = S), (t[a] = m)
        const M = i[p]
        if (M === -1) {
          let R = this._hullStart
          do {
            if (this._hullTri[R] === p) {
              this._hullTri[R] = e
              break
            }
            R = this._hullPrev[R]
          } while (R !== this._hullStart)
        }
        this._link(e, M), this._link(a, i[o]), this._link(o, p)
        const _ = c + ((a + 1) % 3)
        s < Lh.length && (Lh[s++] = _)
      } else {
        if (s === 0) break
        e = Lh[--s]
      }
    }
    return o
  }
  _link(e, t) {
    ;(this._halfedges[e] = t), t !== -1 && (this._halfedges[t] = e)
  }
  _addTriangle(e, t, i, r, s, o) {
    const a = this.trianglesLen
    return (
      (this._triangles[a] = e),
      (this._triangles[a + 1] = t),
      (this._triangles[a + 2] = i),
      this._link(a, r),
      this._link(a + 1, s),
      this._link(a + 2, o),
      (this.trianglesLen += 3),
      a
    )
  }
}
function jz(n, e) {
  const t = n / (Math.abs(n) + Math.abs(e))
  return (e > 0 ? 3 - t : 1 + t) / 4
}
function vm(n, e, t, i) {
  const r = n - t,
    s = e - i
  return r * r + s * s
}
function $z(n, e, t, i, r, s, o, a) {
  const A = n - o,
    c = e - a,
    d = t - o,
    p = i - a,
    m = r - o,
    y = s - a,
    x = A * A + c * c,
    S = d * d + p * p,
    C = m * m + y * y
  return A * (p * C - S * y) - c * (d * C - S * m) + x * (d * y - p * m) < 0
}
function Qz(n, e, t, i, r, s) {
  const o = t - n,
    a = i - e,
    A = r - n,
    c = s - e,
    d = o * o + a * a,
    p = A * A + c * c,
    m = 0.5 / (o * c - a * A),
    y = (c * d - a * p) * m,
    x = (o * p - A * d) * m
  return y * y + x * x
}
function Xz(n, e, t, i, r, s) {
  const o = t - n,
    a = i - e,
    A = r - n,
    c = s - e,
    d = o * o + a * a,
    p = A * A + c * c,
    m = 0.5 / (o * c - a * A),
    y = n + (c * d - a * p) * m,
    x = e + (o * p - A * d) * m
  return { x: y, y: x }
}
function $l(n, e, t, i) {
  if (i - t <= 20)
    for (let r = t + 1; r <= i; r++) {
      const s = n[r],
        o = e[s]
      let a = r - 1
      for (; a >= t && e[n[a]] > o; ) n[a + 1] = n[a--]
      n[a + 1] = s
    }
  else {
    const r = (t + i) >> 1
    let s = t + 1,
      o = i
    hA(n, r, s),
      e[n[t]] > e[n[i]] && hA(n, t, i),
      e[n[s]] > e[n[i]] && hA(n, s, i),
      e[n[t]] > e[n[s]] && hA(n, t, s)
    const a = n[s],
      A = e[a]
    for (;;) {
      do s++
      while (e[n[s]] < A)
      do o--
      while (e[n[o]] > A)
      if (o < s) break
      hA(n, s, o)
    }
    ;(n[t + 1] = n[o]),
      (n[o] = a),
      i - s + 1 >= o - t
        ? ($l(n, e, s, i), $l(n, e, t, o - 1))
        : ($l(n, e, t, o - 1), $l(n, e, s, i))
  }
}
function hA(n, e, t) {
  const i = n[e]
  ;(n[e] = n[t]), (n[t] = i)
}
function Yz(n) {
  return n[0]
}
function Zz(n) {
  return n[1]
}
function Jz(n) {
  if (!n) throw new Error("coord is required")
  if (!Array.isArray(n)) {
    if (
      n.type === "Feature" &&
      n.geometry !== null &&
      n.geometry.type === "Point"
    )
      return n.geometry.coordinates
    if (n.type === "Point") return n.coordinates
  }
  if (
    Array.isArray(n) &&
    n.length >= 2 &&
    !Array.isArray(n[0]) &&
    !Array.isArray(n[1])
  )
    return n
  throw new Error("coord must be GeoJSON Point or an Array of numbers")
}
function Kz(n) {
  return n.type === "Feature" ? n.geometry : n
}
function eH(n, e, t) {
  if ((t === void 0 && (t = {}), !n)) throw new Error("point is required")
  if (!e) throw new Error("polygon is required")
  var i = Jz(n),
    r = Kz(e),
    s = r.type,
    o = e.bbox,
    a = r.coordinates
  if (o && tH(i, o) === !1) return !1
  s === "Polygon" && (a = [a])
  for (var A = !1, c = 0; c < a.length && !A; c++)
    if (Fx(i, a[c][0], t.ignoreBoundary)) {
      for (var d = !1, p = 1; p < a[c].length && !d; )
        Fx(i, a[c][p], !t.ignoreBoundary) && (d = !0), p++
      d || (A = !0)
    }
  return A
}
function Fx(n, e, t) {
  var i = !1
  e[0][0] === e[e.length - 1][0] &&
    e[0][1] === e[e.length - 1][1] &&
    (e = e.slice(0, e.length - 1))
  for (var r = 0, s = e.length - 1; r < e.length; s = r++) {
    var o = e[r][0],
      a = e[r][1],
      A = e[s][0],
      c = e[s][1],
      d =
        n[1] * (o - A) + a * (A - n[0]) + c * (n[0] - o) === 0 &&
        (o - n[0]) * (A - n[0]) <= 0 &&
        (a - n[1]) * (c - n[1]) <= 0
    if (d) return !t
    var p = a > n[1] != c > n[1] && n[0] < ((A - o) * (n[1] - a)) / (c - a) + o
    p && (i = !i)
  }
  return i
}
function tH(n, e) {
  return e[0] <= n[0] && e[1] <= n[1] && e[2] >= n[0] && e[3] >= n[1]
}
const Nx = 1e-6
class Sa {
  constructor() {
    ;(this._x0 = this._y0 = this._x1 = this._y1 = null), (this._ = "")
  }
  moveTo(e, t) {
    this._ += `M${(this._x0 = this._x1 = +e)},${(this._y0 = this._y1 = +t)}`
  }
  closePath() {
    this._x1 !== null &&
      ((this._x1 = this._x0), (this._y1 = this._y0), (this._ += "Z"))
  }
  lineTo(e, t) {
    this._ += `L${(this._x1 = +e)},${(this._y1 = +t)}`
  }
  arc(e, t, i) {
    ;(e = +e), (t = +t), (i = +i)
    const r = e + i,
      s = t
    if (i < 0) throw new Error("negative radius")
    this._x1 === null
      ? (this._ += `M${r},${s}`)
      : (Math.abs(this._x1 - r) > Nx || Math.abs(this._y1 - s) > Nx) &&
        (this._ += "L" + r + "," + s),
      i &&
        (this._ += `A${i},${i},0,1,1,${e - i},${t}A${i},${i},0,1,1,${(this._x1 =
          r)},${(this._y1 = s)}`)
  }
  rect(e, t, i, r) {
    this._ += `M${(this._x0 = this._x1 = +e)},${(this._y0 = this._y1 =
      +t)}h${+i}v${+r}h${-i}Z`
  }
  value() {
    return this._ || null
  }
}
class hg {
  constructor() {
    this._ = []
  }
  moveTo(e, t) {
    this._.push([e, t])
  }
  closePath() {
    this._.push(this._[0].slice())
  }
  lineTo(e, t) {
    this._.push([e, t])
  }
  value() {
    return this._.length ? this._ : null
  }
}
class nH {
  constructor(e, [t, i, r, s] = [0, 0, 960, 500]) {
    if (!((r = +r) >= (t = +t)) || !((s = +s) >= (i = +i)))
      throw new Error("invalid bounds")
    ;(this.delaunay = e),
      (this._circumcenters = new Float64Array(e.points.length * 2)),
      (this.vectors = new Float64Array(e.points.length * 2)),
      (this.xmax = r),
      (this.xmin = t),
      (this.ymax = s),
      (this.ymin = i),
      this._init()
  }
  update() {
    return this.delaunay.update(), this._init(), this
  }
  _init() {
    const {
        delaunay: { points: e, hull: t, triangles: i },
        vectors: r,
      } = this,
      s = (this.circumcenters = this._circumcenters.subarray(
        0,
        (i.length / 3) * 2
      ))
    for (let y = 0, x = 0, S = i.length, C, M; y < S; y += 3, x += 2) {
      const _ = i[y] * 2,
        R = i[y + 1] * 2,
        T = i[y + 2] * 2,
        L = e[_],
        B = e[_ + 1],
        k = e[R],
        O = e[R + 1],
        W = e[T],
        z = e[T + 1],
        P = k - L,
        N = O - B,
        G = W - L,
        j = z - B,
        V = (P * j - N * G) * 2
      if (Math.abs(V) < 1e-9) {
        let Y = 1e9
        const ne = i[0] * 2
        ;(Y *= Math.sign((e[ne] - L) * j - (e[ne + 1] - B) * G)),
          (C = (L + W) / 2 - Y * j),
          (M = (B + z) / 2 + Y * G)
      } else {
        const Y = 1 / V,
          ne = P * P + N * N,
          le = G * G + j * j
        ;(C = L + (j * ne - N * le) * Y), (M = B + (P * le - G * ne) * Y)
      }
      ;(s[x] = C), (s[x + 1] = M)
    }
    let o = t[t.length - 1],
      a,
      A = o * 4,
      c,
      d = e[2 * o],
      p,
      m = e[2 * o + 1]
    r.fill(0)
    for (let y = 0; y < t.length; ++y)
      (o = t[y]),
        (a = A),
        (c = d),
        (p = m),
        (A = o * 4),
        (d = e[2 * o]),
        (m = e[2 * o + 1]),
        (r[a + 2] = r[A] = p - m),
        (r[a + 3] = r[A + 1] = d - c)
  }
  render(e) {
    const t = e == null ? (e = new Sa()) : void 0,
      {
        delaunay: { halfedges: i, inedges: r, hull: s },
        circumcenters: o,
        vectors: a,
      } = this
    if (s.length <= 1) return null
    for (let d = 0, p = i.length; d < p; ++d) {
      const m = i[d]
      if (m < d) continue
      const y = Math.floor(d / 3) * 2,
        x = Math.floor(m / 3) * 2,
        S = o[y],
        C = o[y + 1],
        M = o[x],
        _ = o[x + 1]
      this._renderSegment(S, C, M, _, e)
    }
    let A,
      c = s[s.length - 1]
    for (let d = 0; d < s.length; ++d) {
      ;(A = c), (c = s[d])
      const p = Math.floor(r[c] / 3) * 2,
        m = o[p],
        y = o[p + 1],
        x = A * 4,
        S = this._project(m, y, a[x + 2], a[x + 3])
      S && this._renderSegment(m, y, S[0], S[1], e)
    }
    return t && t.value()
  }
  renderBounds(e) {
    const t = e == null ? (e = new Sa()) : void 0
    return (
      e.rect(
        this.xmin,
        this.ymin,
        this.xmax - this.xmin,
        this.ymax - this.ymin
      ),
      t && t.value()
    )
  }
  renderCell(e, t) {
    const i = t == null ? (t = new Sa()) : void 0,
      r = this._clip(e)
    if (r === null || !r.length) return
    t.moveTo(r[0], r[1])
    let s = r.length
    for (; r[0] === r[s - 2] && r[1] === r[s - 1] && s > 1; ) s -= 2
    for (let o = 2; o < s; o += 2)
      (r[o] !== r[o - 2] || r[o + 1] !== r[o - 1]) && t.lineTo(r[o], r[o + 1])
    return t.closePath(), i && i.value()
  }
  *cellPolygons() {
    const {
      delaunay: { points: e },
    } = this
    for (let t = 0, i = e.length / 2; t < i; ++t) {
      const r = this.cellPolygon(t)
      r && ((r.index = t), yield r)
    }
  }
  cellPolygon(e) {
    const t = new hg()
    return this.renderCell(e, t), t.value()
  }
  _renderSegment(e, t, i, r, s) {
    let o
    const a = this._regioncode(e, t),
      A = this._regioncode(i, r)
    a === 0 && A === 0
      ? (s.moveTo(e, t), s.lineTo(i, r))
      : (o = this._clipSegment(e, t, i, r, a, A)) &&
        (s.moveTo(o[0], o[1]), s.lineTo(o[2], o[3]))
  }
  contains(e, t, i) {
    return (
      (t = +t),
      t !== t || ((i = +i), i !== i) ? !1 : this.delaunay._step(e, t, i) === e
    )
  }
  *neighbors(e) {
    const t = this._clip(e)
    if (t)
      for (const i of this.delaunay.neighbors(e)) {
        const r = this._clip(i)
        if (r) {
          e: for (let s = 0, o = t.length; s < o; s += 2)
            for (let a = 0, A = r.length; a < A; a += 2)
              if (
                t[s] == r[a] &&
                t[s + 1] == r[a + 1] &&
                t[(s + 2) % o] == r[(a + A - 2) % A] &&
                t[(s + 3) % o] == r[(a + A - 1) % A]
              ) {
                yield i
                break e
              }
        }
      }
  }
  _cell(e) {
    const {
        circumcenters: t,
        delaunay: { inedges: i, halfedges: r, triangles: s },
      } = this,
      o = i[e]
    if (o === -1) return null
    const a = []
    let A = o
    do {
      const c = Math.floor(A / 3)
      if (
        (a.push(t[c * 2], t[c * 2 + 1]),
        (A = A % 3 === 2 ? A - 2 : A + 1),
        s[A] !== e)
      )
        break
      A = r[A]
    } while (A !== o && A !== -1)
    return a
  }
  _clip(e) {
    if (e === 0 && this.delaunay.hull.length === 1)
      return [
        this.xmax,
        this.ymin,
        this.xmax,
        this.ymax,
        this.xmin,
        this.ymax,
        this.xmin,
        this.ymin,
      ]
    const t = this._cell(e)
    if (t === null) return null
    const { vectors: i } = this,
      r = e * 4
    return i[r] || i[r + 1]
      ? this._clipInfinite(e, t, i[r], i[r + 1], i[r + 2], i[r + 3])
      : this._clipFinite(e, t)
  }
  _clipFinite(e, t) {
    const i = t.length
    let r = null,
      s,
      o,
      a = t[i - 2],
      A = t[i - 1],
      c,
      d = this._regioncode(a, A),
      p,
      m = 0
    for (let y = 0; y < i; y += 2)
      if (
        ((s = a),
        (o = A),
        (a = t[y]),
        (A = t[y + 1]),
        (c = d),
        (d = this._regioncode(a, A)),
        c === 0 && d === 0)
      )
        (p = m), (m = 0), r ? r.push(a, A) : (r = [a, A])
      else {
        let x, S, C, M, _
        if (c === 0) {
          if ((x = this._clipSegment(s, o, a, A, c, d)) === null) continue
          ;[S, C, M, _] = x
        } else {
          if ((x = this._clipSegment(a, A, s, o, d, c)) === null) continue
          ;([M, _, S, C] = x),
            (p = m),
            (m = this._edgecode(S, C)),
            p && m && this._edge(e, p, m, r, r.length),
            r ? r.push(S, C) : (r = [S, C])
        }
        ;(p = m),
          (m = this._edgecode(M, _)),
          p && m && this._edge(e, p, m, r, r.length),
          r ? r.push(M, _) : (r = [M, _])
      }
    if (r)
      (p = m),
        (m = this._edgecode(r[0], r[1])),
        p && m && this._edge(e, p, m, r, r.length)
    else if (
      this.contains(e, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)
    )
      return [
        this.xmax,
        this.ymin,
        this.xmax,
        this.ymax,
        this.xmin,
        this.ymax,
        this.xmin,
        this.ymin,
      ]
    return r
  }
  _clipSegment(e, t, i, r, s, o) {
    for (;;) {
      if (s === 0 && o === 0) return [e, t, i, r]
      if (s & o) return null
      let a,
        A,
        c = s || o
      c & 8
        ? ((a = e + ((i - e) * (this.ymax - t)) / (r - t)), (A = this.ymax))
        : c & 4
        ? ((a = e + ((i - e) * (this.ymin - t)) / (r - t)), (A = this.ymin))
        : c & 2
        ? ((A = t + ((r - t) * (this.xmax - e)) / (i - e)), (a = this.xmax))
        : ((A = t + ((r - t) * (this.xmin - e)) / (i - e)), (a = this.xmin)),
        s
          ? ((e = a), (t = A), (s = this._regioncode(e, t)))
          : ((i = a), (r = A), (o = this._regioncode(i, r)))
    }
  }
  _clipInfinite(e, t, i, r, s, o) {
    let a = Array.from(t),
      A
    if (
      ((A = this._project(a[0], a[1], i, r)) && a.unshift(A[0], A[1]),
      (A = this._project(a[a.length - 2], a[a.length - 1], s, o)) &&
        a.push(A[0], A[1]),
      (a = this._clipFinite(e, a)))
    )
      for (
        let c = 0, d = a.length, p, m = this._edgecode(a[d - 2], a[d - 1]);
        c < d;
        c += 2
      )
        (p = m),
          (m = this._edgecode(a[c], a[c + 1])),
          p && m && ((c = this._edge(e, p, m, a, c)), (d = a.length))
    else
      this.contains(
        e,
        (this.xmin + this.xmax) / 2,
        (this.ymin + this.ymax) / 2
      ) &&
        (a = [
          this.xmin,
          this.ymin,
          this.xmax,
          this.ymin,
          this.xmax,
          this.ymax,
          this.xmin,
          this.ymax,
        ])
    return a
  }
  _edge(e, t, i, r, s) {
    for (; t !== i; ) {
      let o, a
      switch (t) {
        case 5:
          t = 4
          continue
        case 4:
          ;(t = 6), (o = this.xmax), (a = this.ymin)
          break
        case 6:
          t = 2
          continue
        case 2:
          ;(t = 10), (o = this.xmax), (a = this.ymax)
          break
        case 10:
          t = 8
          continue
        case 8:
          ;(t = 9), (o = this.xmin), (a = this.ymax)
          break
        case 9:
          t = 1
          continue
        case 1:
          ;(t = 5), (o = this.xmin), (a = this.ymin)
          break
      }
      ;(r[s] !== o || r[s + 1] !== a) &&
        this.contains(e, o, a) &&
        (r.splice(s, 0, o, a), (s += 2))
    }
    if (r.length > 4)
      for (let o = 0; o < r.length; o += 2) {
        const a = (o + 2) % r.length,
          A = (o + 4) % r.length
        ;((r[o] === r[a] && r[a] === r[A]) ||
          (r[o + 1] === r[a + 1] && r[a + 1] === r[A + 1])) &&
          (r.splice(a, 2), (o -= 2))
      }
    return s
  }
  _project(e, t, i, r) {
    let s = 1 / 0,
      o,
      a,
      A
    if (r < 0) {
      if (t <= this.ymin) return null
      ;(o = (this.ymin - t) / r) < s && ((A = this.ymin), (a = e + (s = o) * i))
    } else if (r > 0) {
      if (t >= this.ymax) return null
      ;(o = (this.ymax - t) / r) < s && ((A = this.ymax), (a = e + (s = o) * i))
    }
    if (i > 0) {
      if (e >= this.xmax) return null
      ;(o = (this.xmax - e) / i) < s && ((a = this.xmax), (A = t + (s = o) * r))
    } else if (i < 0) {
      if (e <= this.xmin) return null
      ;(o = (this.xmin - e) / i) < s && ((a = this.xmin), (A = t + (s = o) * r))
    }
    return [a, A]
  }
  _edgecode(e, t) {
    return (
      (e === this.xmin ? 1 : e === this.xmax ? 2 : 0) |
      (t === this.ymin ? 4 : t === this.ymax ? 8 : 0)
    )
  }
  _regioncode(e, t) {
    return (
      (e < this.xmin ? 1 : e > this.xmax ? 2 : 0) |
      (t < this.ymin ? 4 : t > this.ymax ? 8 : 0)
    )
  }
}
const iH = 2 * Math.PI,
  Dl = Math.pow
function rH(n) {
  return n[0]
}
function sH(n) {
  return n[1]
}
function oH(n) {
  const { triangles: e, coords: t } = n
  for (let i = 0; i < e.length; i += 3) {
    const r = 2 * e[i],
      s = 2 * e[i + 1],
      o = 2 * e[i + 2]
    if (
      (t[o] - t[r]) * (t[s + 1] - t[r + 1]) -
        (t[s] - t[r]) * (t[o + 1] - t[r + 1]) >
      1e-10
    )
      return !1
  }
  return !0
}
function aH(n, e, t) {
  return [n + Math.sin(n + e) * t, e + Math.cos(n - e) * t]
}
class ey {
  static from(e, t = rH, i = sH, r) {
    return new ey(
      "length" in e ? lH(e, t, i, r) : Float64Array.from(cH(e, t, i, r))
    )
  }
  constructor(e) {
    ;(this._delaunator = new bu(e)),
      (this.inedges = new Int32Array(e.length / 2)),
      (this._hullIndex = new Int32Array(e.length / 2)),
      (this.points = this._delaunator.coords),
      this._init()
  }
  update() {
    return this._delaunator.update(), this._init(), this
  }
  _init() {
    const e = this._delaunator,
      t = this.points
    if (e.hull && e.hull.length > 2 && oH(e)) {
      this.collinear = Int32Array.from(
        { length: t.length / 2 },
        (m, y) => y
      ).sort((m, y) => t[2 * m] - t[2 * y] || t[2 * m + 1] - t[2 * y + 1])
      const A = this.collinear[0],
        c = this.collinear[this.collinear.length - 1],
        d = [t[2 * A], t[2 * A + 1], t[2 * c], t[2 * c + 1]],
        p = 1e-8 * Math.hypot(d[3] - d[1], d[2] - d[0])
      for (let m = 0, y = t.length / 2; m < y; ++m) {
        const x = aH(t[2 * m], t[2 * m + 1], p)
        ;(t[2 * m] = x[0]), (t[2 * m + 1] = x[1])
      }
      this._delaunator = new bu(t)
    } else delete this.collinear
    const i = (this.halfedges = this._delaunator.halfedges),
      r = (this.hull = this._delaunator.hull),
      s = (this.triangles = this._delaunator.triangles),
      o = this.inedges.fill(-1),
      a = this._hullIndex.fill(-1)
    for (let A = 0, c = i.length; A < c; ++A) {
      const d = s[A % 3 === 2 ? A - 2 : A + 1]
      ;(i[A] === -1 || o[d] === -1) && (o[d] = A)
    }
    for (let A = 0, c = r.length; A < c; ++A) a[r[A]] = A
    r.length <= 2 &&
      r.length > 0 &&
      ((this.triangles = new Int32Array(3).fill(-1)),
      (this.halfedges = new Int32Array(3).fill(-1)),
      (this.triangles[0] = r[0]),
      (o[r[0]] = 1),
      r.length === 2 &&
        ((o[r[1]] = 0), (this.triangles[1] = r[1]), (this.triangles[2] = r[1])))
  }
  voronoi(e) {
    return new nH(this, e)
  }
  *neighbors(e) {
    const {
      inedges: t,
      hull: i,
      _hullIndex: r,
      halfedges: s,
      triangles: o,
      collinear: a,
    } = this
    if (a) {
      const p = a.indexOf(e)
      p > 0 && (yield a[p - 1]), p < a.length - 1 && (yield a[p + 1])
      return
    }
    const A = t[e]
    if (A === -1) return
    let c = A,
      d = -1
    do {
      if ((yield (d = o[c]), (c = c % 3 === 2 ? c - 2 : c + 1), o[c] !== e))
        return
      if (((c = s[c]), c === -1)) {
        const p = i[(r[e] + 1) % i.length]
        p !== d && (yield p)
        return
      }
    } while (c !== A)
  }
  find(e, t, i = 0) {
    if (((e = +e), e !== e || ((t = +t), t !== t))) return -1
    const r = i
    let s
    for (; (s = this._step(i, e, t)) >= 0 && s !== i && s !== r; ) i = s
    return s
  }
  _step(e, t, i) {
    const {
      inedges: r,
      hull: s,
      _hullIndex: o,
      halfedges: a,
      triangles: A,
      points: c,
    } = this
    if (r[e] === -1 || !c.length) return (e + 1) % (c.length >> 1)
    let d = e,
      p = Dl(t - c[e * 2], 2) + Dl(i - c[e * 2 + 1], 2)
    const m = r[e]
    let y = m
    do {
      let x = A[y]
      const S = Dl(t - c[x * 2], 2) + Dl(i - c[x * 2 + 1], 2)
      if (
        (S < p && ((p = S), (d = x)),
        (y = y % 3 === 2 ? y - 2 : y + 1),
        A[y] !== e)
      )
        break
      if (((y = a[y]), y === -1)) {
        if (
          ((y = s[(o[e] + 1) % s.length]),
          y !== x && Dl(t - c[y * 2], 2) + Dl(i - c[y * 2 + 1], 2) < p)
        )
          return y
        break
      }
    } while (y !== m)
    return d
  }
  render(e) {
    const t = e == null ? (e = new Sa()) : void 0,
      { points: i, halfedges: r, triangles: s } = this
    for (let o = 0, a = r.length; o < a; ++o) {
      const A = r[o]
      if (A < o) continue
      const c = s[o] * 2,
        d = s[A] * 2
      e.moveTo(i[c], i[c + 1]), e.lineTo(i[d], i[d + 1])
    }
    return this.renderHull(e), t && t.value()
  }
  renderPoints(e, t) {
    t === void 0 &&
      (!e || typeof e.moveTo != "function") &&
      ((t = e), (e = null)),
      (t = t == null ? 2 : +t)
    const i = e == null ? (e = new Sa()) : void 0,
      { points: r } = this
    for (let s = 0, o = r.length; s < o; s += 2) {
      const a = r[s],
        A = r[s + 1]
      e.moveTo(a + t, A), e.arc(a, A, t, 0, iH)
    }
    return i && i.value()
  }
  renderHull(e) {
    const t = e == null ? (e = new Sa()) : void 0,
      { hull: i, points: r } = this,
      s = i[0] * 2,
      o = i.length
    e.moveTo(r[s], r[s + 1])
    for (let a = 1; a < o; ++a) {
      const A = 2 * i[a]
      e.lineTo(r[A], r[A + 1])
    }
    return e.closePath(), t && t.value()
  }
  hullPolygon() {
    const e = new hg()
    return this.renderHull(e), e.value()
  }
  renderTriangle(e, t) {
    const i = t == null ? (t = new Sa()) : void 0,
      { points: r, triangles: s } = this,
      o = s[(e *= 3)] * 2,
      a = s[e + 1] * 2,
      A = s[e + 2] * 2
    return (
      t.moveTo(r[o], r[o + 1]),
      t.lineTo(r[a], r[a + 1]),
      t.lineTo(r[A], r[A + 1]),
      t.closePath(),
      i && i.value()
    )
  }
  *trianglePolygons() {
    const { triangles: e } = this
    for (let t = 0, i = e.length / 3; t < i; ++t) yield this.trianglePolygon(t)
  }
  trianglePolygon(e) {
    const t = new hg()
    return this.renderTriangle(e, t), t.value()
  }
}
function lH(n, e, t, i) {
  const r = n.length,
    s = new Float64Array(r * 2)
  for (let o = 0; o < r; ++o) {
    const a = n[o]
    ;(s[o * 2] = e.call(i, a, o, n)), (s[o * 2 + 1] = t.call(i, a, o, n))
  }
  return s
}
function* cH(n, e, t, i) {
  let r = 0
  for (const s of n) yield e.call(i, s, r, n), yield t.call(i, s, r, n), ++r
}
const ty = Math.PI,
  Ux = ty / 2,
  zx = 180 / ty,
  Hx = ty / 180,
  AH = Math.atan2,
  Gx = Math.cos,
  uH = Math.max,
  fH = Math.min,
  Vx = Math.sin,
  hH =
    Math.sign ||
    function (n) {
      return n > 0 ? 1 : n < 0 ? -1 : 0
    },
  E8 = Math.sqrt
function dH(n) {
  return n > 1 ? Ux : n < -1 ? -Ux : Math.asin(n)
}
function T8(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2]
}
function Zi(n, e) {
  return [
    n[1] * e[2] - n[2] * e[1],
    n[2] * e[0] - n[0] * e[2],
    n[0] * e[1] - n[1] * e[0],
  ]
}
function $0(n, e) {
  return [n[0] + e[0], n[1] + e[1], n[2] + e[2]]
}
function Q0(n) {
  var e = E8(n[0] * n[0] + n[1] * n[1] + n[2] * n[2])
  return [n[0] / e, n[1] / e, n[2] / e]
}
function ny(n) {
  return [AH(n[1], n[0]) * zx, dH(uH(-1, fH(1, n[2]))) * zx]
}
function ss(n) {
  const e = n[0] * Hx,
    t = n[1] * Hx,
    i = Gx(t)
  return [i * Gx(e), i * Vx(e), Vx(t)]
}
function iy(n) {
  return (n = n.map(e => ss(e))), T8(n[0], Zi(n[2], n[1]))
}
function pH(n) {
  const e = gH(n),
    t = vH(e),
    i = yH(t, n),
    r = xH(t, n.length),
    s = mH(r, n),
    o = _H(t, n),
    { polygons: a, centers: A } = bH(o, t, n),
    c = wH(a),
    d = SH(t, n),
    p = MH(i, t)
  return {
    delaunay: e,
    edges: i,
    triangles: t,
    centers: A,
    neighbors: r,
    polygons: a,
    mesh: c,
    hull: d,
    urquhart: p,
    find: s,
  }
}
function mH(n, e) {
  function t(i, r) {
    let s = i[0] - r[0],
      o = i[1] - r[1],
      a = i[2] - r[2]
    return s * s + o * o + a * a
  }
  return function (r, s, o) {
    o === void 0 && (o = 0)
    let a,
      A,
      c = o
    const d = ss([r, s])
    do
      (a = o),
        (o = null),
        (A = t(d, ss(e[a]))),
        n[a].forEach(p => {
          let m = t(d, ss(e[p]))
          if (m < A) {
            ;(A = m), (o = p), (c = p)
            return
          }
        })
    while (o !== null)
    return c
  }
}
function gH(n) {
  if (n.length < 2) return {}
  let e = 0
  for (; isNaN(n[e][0] + n[e][1]) && e++ < n.length; );
  const t = TN(n[e]),
    i = aU()
      .translate([0, 0])
      .scale(1)
      .rotate(t.invert([180, 0]))
  n = n.map(i)
  const r = []
  let s = 1
  for (let p = 0, m = n.length; p < m; p++) {
    let y = n[p][0] ** 2 + n[p][1] ** 2
    !isFinite(y) || y > 1e32 ? r.push(p) : y > s && (s = y)
  }
  const o = 1e6 * E8(s)
  r.forEach(p => (n[p] = [o, 0])),
    n.push([0, o]),
    n.push([-o, 0]),
    n.push([0, -o])
  const a = ey.from(n)
  a.projection = i
  const { triangles: A, halfedges: c, inedges: d } = a
  for (let p = 0, m = c.length; p < m; p++)
    if (c[p] < 0) {
      const y = p % 3 == 2 ? p - 2 : p + 1,
        x = p % 3 == 0 ? p + 2 : p - 1,
        S = c[y],
        C = c[x]
      ;(c[S] = C),
        (c[C] = S),
        (c[y] = c[x] = -1),
        (A[p] = A[y] = A[x] = e),
        (d[A[S]] = S % 3 == 0 ? S + 2 : S - 1),
        (d[A[C]] = C % 3 == 0 ? C + 2 : C - 1),
        (p += 2 - (p % 3))
    } else A[p] > n.length - 3 - 1 && (A[p] = e)
  return a
}
function yH(n, e) {
  const t = new Set()
  return e.length === 2
    ? [[0, 1]]
    : (n.forEach(i => {
        if (i[0] !== i[1] && !(iy(i.map(r => e[r])) < 0))
          for (let r = 0, s; r < 3; r++)
            (s = (r + 1) % 3), t.add(w0([i[r], i[s]]).join("-"))
      }),
      Array.from(t, i => i.split("-").map(Number)))
}
function vH(n) {
  const { triangles: e } = n
  if (!e) return []
  const t = []
  for (let i = 0, r = e.length / 3; i < r; i++) {
    const s = e[3 * i],
      o = e[3 * i + 1],
      a = e[3 * i + 2]
    s !== o && o !== a && t.push([s, a, o])
  }
  return t
}
function _H(n, e) {
  return n.map(t => {
    const i = t.map(s => e[s]).map(ss),
      r = $0($0(Zi(i[1], i[0]), Zi(i[2], i[1])), Zi(i[0], i[2]))
    return ny(Q0(r))
  })
}
function xH(n, e) {
  const t = []
  return (
    n.forEach(i => {
      for (let r = 0; r < 3; r++) {
        const s = i[r],
          o = i[(r + 1) % 3]
        ;(t[s] = t[s] || []), t[s].push(o)
      }
    }),
    n.length === 0 &&
      (e === 2 ? ((t[0] = [1]), (t[1] = [0])) : e === 1 && (t[0] = [])),
    t
  )
}
function bH(n, e, t) {
  const i = [],
    r = n.slice()
  if (e.length === 0) {
    if (t.length < 2) return { polygons: i, centers: r }
    if (t.length === 2) {
      const a = ss(t[0]),
        A = ss(t[1]),
        c = Q0($0(a, A)),
        d = Q0(Zi(a, A)),
        p = Zi(c, d),
        m = [c, Zi(c, p), Zi(Zi(c, p), p), Zi(Zi(Zi(c, p), p), p)]
          .map(ny)
          .map(o)
      return i.push(m), i.push(m.slice().reverse()), { polygons: i, centers: r }
    }
  }
  e.forEach((a, A) => {
    for (let c = 0; c < 3; c++) {
      const d = a[c],
        p = a[(c + 1) % 3],
        m = a[(c + 2) % 3]
      ;(i[d] = i[d] || []), i[d].push([p, m, A, [d, p, m]])
    }
  })
  const s = i.map(a => {
    const A = [a[0][2]]
    let c = a[0][1]
    for (let d = 1; d < a.length; d++)
      for (let p = 0; p < a.length; p++)
        if (a[p][0] == c) {
          ;(c = a[p][1]), A.push(a[p][2])
          break
        }
    if (A.length > 2) return A
    if (A.length == 2) {
      const d = Wx(t[a[0][3][0]], t[a[0][3][1]], r[A[0]]),
        p = Wx(t[a[0][3][2]], t[a[0][3][0]], r[A[0]]),
        m = o(d),
        y = o(p)
      return [A[0], y, A[1], m]
    }
  })
  function o(a) {
    let A = -1
    return (
      r.slice(e.length, 1 / 0).forEach((c, d) => {
        c[0] === a[0] && c[1] === a[1] && (A = d + e.length)
      }),
      A < 0 && ((A = r.length), r.push(a)),
      A
    )
  }
  return { polygons: s, centers: r }
}
function Wx(n, e, t) {
  ;(n = ss(n)), (e = ss(e)), (t = ss(t))
  const i = hH(T8(Zi(e, n), t))
  return ny(Q0($0(n, e)).map(r => i * r))
}
function wH(n) {
  const e = []
  return (
    n.forEach(t => {
      if (!t) return
      let i = t[t.length - 1]
      for (let r of t) r > i && e.push([i, r]), (i = r)
    }),
    e
  )
}
function MH(n, e) {
  return function (t) {
    const i = new Map(),
      r = new Map()
    return (
      n.forEach((s, o) => {
        const a = s.join("-")
        i.set(a, t[o]), r.set(a, !0)
      }),
      e.forEach(s => {
        let o = 0,
          a = -1
        for (let A = 0; A < 3; A++) {
          let c = w0([s[A], s[(A + 1) % 3]]).join("-")
          i.get(c) > o && ((o = i.get(c)), (a = c))
        }
        r.set(a, !1)
      }),
      n.map(s => r.get(s.join("-")))
    )
  }
}
function SH(n, e) {
  const t = new Set(),
    i = []
  n.map(a => {
    if (!(iy(a.map(A => e[A > e.length ? 0 : A])) > 1e-12))
      for (let A = 0; A < 3; A++) {
        let c = [a[A], a[(A + 1) % 3]],
          d = `${c[0]}-${c[1]}`
        t.has(d) ? t.delete(d) : t.add(`${c[1]}-${c[0]}`)
      }
  })
  const r = new Map()
  let s
  if (
    (t.forEach(a => {
      ;(a = a.split("-").map(Number)), r.set(a[0], a[1]), (s = a[0])
    }),
    s === void 0)
  )
    return i
  let o = s
  do {
    i.push(o)
    let a = r.get(o)
    r.set(o, -1), (o = a)
  } while (o > -1 && o !== s)
  return i
}
function EH(n) {
  const e = function (t) {
    if (
      ((e.delaunay = null),
      (e._data = t),
      typeof e._data == "object" &&
        e._data.type === "FeatureCollection" &&
        (e._data = e._data.features),
      typeof e._data == "object")
    ) {
      const i = e._data
        .map(r => [e._vx(r), e._vy(r), r])
        .filter(r => isFinite(r[0] + r[1]))
      ;(e.points = i.map(r => [r[0], r[1]])),
        (e.valid = i.map(r => r[2])),
        (e.delaunay = pH(e.points))
    }
    return e
  }
  return (
    (e._vx = function (t) {
      if (typeof t == "object" && "type" in t) return Y3(t)[0]
      if (0 in t) return t[0]
    }),
    (e._vy = function (t) {
      if (typeof t == "object" && "type" in t) return Y3(t)[1]
      if (1 in t) return t[1]
    }),
    (e.x = function (t) {
      return t ? ((e._vx = t), e) : e._vx
    }),
    (e.y = function (t) {
      return t ? ((e._vy = t), e) : e._vy
    }),
    (e.polygons = function (t) {
      if ((t !== void 0 && e(t), !e.delaunay)) return !1
      const i = { type: "FeatureCollection", features: [] }
      return (
        e.valid.length === 0 ||
          (e.delaunay.polygons.forEach((r, s) =>
            i.features.push({
              type: "Feature",
              geometry: r
                ? {
                    type: "Polygon",
                    coordinates: [[...r, r[0]].map(o => e.delaunay.centers[o])],
                  }
                : null,
              properties: {
                site: e.valid[s],
                sitecoordinates: e.points[s],
                neighbours: e.delaunay.neighbors[s],
              },
            })
          ),
          e.valid.length === 1 &&
            i.features.push({
              type: "Feature",
              geometry: { type: "Sphere" },
              properties: {
                site: e.valid[0],
                sitecoordinates: e.points[0],
                neighbours: [],
              },
            })),
        i
      )
    }),
    (e.triangles = function (t) {
      return (
        t !== void 0 && e(t),
        e.delaunay
          ? {
              type: "FeatureCollection",
              features: e.delaunay.triangles
                .map(
                  (i, r) => (
                    (i = i.map(s => e.points[s])),
                    (i.center = e.delaunay.centers[r]),
                    i
                  )
                )
                .filter(i => iy(i) > 0)
                .map(i => ({
                  type: "Feature",
                  properties: { circumcenter: i.center },
                  geometry: { type: "Polygon", coordinates: [[...i, i[0]]] },
                })),
            }
          : !1
      )
    }),
    (e.links = function (t) {
      if ((t !== void 0 && e(t), !e.delaunay)) return !1
      const i = e.delaunay.edges.map(s => Ho(e.points[s[0]], e.points[s[1]])),
        r = e.delaunay.urquhart(i)
      return {
        type: "FeatureCollection",
        features: e.delaunay.edges.map((s, o) => ({
          type: "Feature",
          properties: {
            source: e.valid[s[0]],
            target: e.valid[s[1]],
            length: i[o],
            urquhart: !!r[o],
          },
          geometry: {
            type: "LineString",
            coordinates: [e.points[s[0]], e.points[s[1]]],
          },
        })),
      }
    }),
    (e.mesh = function (t) {
      return (
        t !== void 0 && e(t),
        e.delaunay
          ? {
              type: "MultiLineString",
              coordinates: e.delaunay.edges.map(i => [
                e.points[i[0]],
                e.points[i[1]],
              ]),
            }
          : !1
      )
    }),
    (e.cellMesh = function (t) {
      if ((t !== void 0 && e(t), !e.delaunay)) return !1
      const { centers: i, polygons: r } = e.delaunay,
        s = []
      for (const o of r)
        if (!!o)
          for (
            let a = o.length, A = o[a - 1], c = o[0], d = 0;
            d < a;
            A = c, c = o[++d]
          )
            c > A && s.push([i[A], i[c]])
      return { type: "MultiLineString", coordinates: s }
    }),
    (e._found = void 0),
    (e.find = function (t, i, r) {
      if (
        ((e._found = e.delaunay.find(t, i, e._found)),
        !r || Ho([t, i], e.points[e._found]) < r)
      )
        return e._found
    }),
    (e.hull = function (t) {
      t !== void 0 && e(t)
      const i = e.delaunay.hull,
        r = e.points
      return i.length === 0
        ? null
        : { type: "Polygon", coordinates: [[...i.map(s => r[s]), r[i[0]]]] }
    }),
    n ? e(n) : e
  )
}
function TH(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function")
}
function jx(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t]
    ;(i.enumerable = i.enumerable || !1),
      (i.configurable = !0),
      "value" in i && (i.writable = !0),
      Object.defineProperty(n, i.key, i)
  }
}
function CH(n, e, t) {
  return (
    e && jx(n.prototype, e),
    t && jx(n, t),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    n
  )
}
function RH(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 },
  })),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    e && dg(n, e)
}
function X0(n) {
  return (
    (X0 = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    X0(n)
  )
}
function dg(n, e) {
  return (
    (dg =
      Object.setPrototypeOf ||
      function (i, r) {
        return (i.__proto__ = r), i
      }),
    dg(n, e)
  )
}
function PH() {
  if (
    typeof Reflect == "undefined" ||
    !Reflect.construct ||
    Reflect.construct.sham
  )
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function LH(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function DH(n, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e
  if (e !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return LH(n)
}
function IH(n) {
  var e = PH()
  return function () {
    var i = X0(n),
      r
    if (e) {
      var s = X0(this).constructor
      r = Reflect.construct(i, arguments, s)
    } else r = i.apply(this, arguments)
    return DH(this, r)
  }
}
function Jr(n, e) {
  return kH(n) || qH(n, e) || C8(n, e) || NH()
}
function _m(n) {
  return BH(n) || OH(n) || C8(n) || FH()
}
function BH(n) {
  if (Array.isArray(n)) return pg(n)
}
function kH(n) {
  if (Array.isArray(n)) return n
}
function OH(n) {
  if (
    (typeof Symbol != "undefined" && n[Symbol.iterator] != null) ||
    n["@@iterator"] != null
  )
    return Array.from(n)
}
function qH(n, e) {
  var t =
    n == null
      ? null
      : (typeof Symbol != "undefined" && n[Symbol.iterator]) || n["@@iterator"]
  if (t != null) {
    var i = [],
      r = !0,
      s = !1,
      o,
      a
    try {
      for (
        t = t.call(n);
        !(r = (o = t.next()).done) && (i.push(o.value), !(e && i.length === e));
        r = !0
      );
    } catch (A) {
      ;(s = !0), (a = A)
    } finally {
      try {
        !r && t.return != null && t.return()
      } finally {
        if (s) throw a
      }
    }
    return i
  }
}
function C8(n, e) {
  if (!!n) {
    if (typeof n == "string") return pg(n, e)
    var t = Object.prototype.toString.call(n).slice(8, -1)
    if (
      (t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set")
    )
      return Array.from(n)
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return pg(n, e)
  }
}
function pg(n, e) {
  ;(e == null || e > n.length) && (e = n.length)
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t]
  return i
}
function FH() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function NH() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function UH(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
    t = e.resolution,
    i = t === void 0 ? 1 / 0 : t,
    r = zH(n, i),
    s = gu(r),
    o = HH(n, i),
    a = [].concat(_m(s), _m(o)),
    A = { type: "Polygon", coordinates: n },
    c = Z6(A),
    d = Jr(c, 2),
    p = Jr(d[0], 2),
    m = p[0],
    y = p[1],
    x = Jr(d[1], 2),
    S = x[0],
    C = x[1],
    M = m > S || C >= 89 || y <= -89,
    _ = []
  if (M) {
    var R = EH(a).triangles(),
      T = new Map(
        a.map(function (G, j) {
          var V = Jr(G, 2),
            Y = V[0],
            ne = V[1]
          return ["".concat(Y, "-").concat(ne), j]
        })
      )
    R.features.forEach(function (G) {
      var j,
        V = G.geometry.coordinates[0].slice(0, 3).reverse(),
        Y = []
      if (
        (V.forEach(function (le) {
          var Te = Jr(le, 2),
            Ae = Te[0],
            ge = Te[1],
            Me = "".concat(Ae, "-").concat(ge)
          T.has(Me) && Y.push(T.get(Me))
        }),
        Y.length === 3)
      ) {
        if (
          Y.some(function (le) {
            return le < s.length
          })
        ) {
          var ne = G.properties.circumcenter
          if (!mg(ne, A, M)) return
        }
        ;(j = _).push.apply(j, Y)
      }
    })
  } else if (o.length)
    (function () {
      for (
        var G = bu.from(a),
          j = function (Te, Ae) {
            var ge,
              Me = [2, 1, 0].map(function (K) {
                return G.triangles[Te + K]
              }),
              Ne = Me.map(function (K) {
                return a[K]
              })
            if (
              Me.some(function (K) {
                return K < s.length
              })
            ) {
              var Ze = [0, 1].map(function (K) {
                return fN(Ne, function (Oe) {
                  return Oe[K]
                })
              })
              if (!mg(Ze, A, M)) return "continue"
            }
            ;(ge = _).push.apply(ge, _m(Me))
          },
          V = 0,
          Y = G.triangles.length;
        V < Y;
        V += 3
      )
        var ne = j(V)
    })()
  else {
    var L = mu.flatten(r),
      B = L.vertices,
      k = L.holes,
      O = k === void 0 ? [] : k
    _ = mu(B, O, 2)
  }
  var W = Ic(
      w0(a, function (G) {
        return G[0]
      }),
      [0, 1]
    ),
    z = Ic(
      w0(a, function (G) {
        return G[1]
      }),
      [0, 1]
    ),
    P = a.map(function (G) {
      var j = Jr(G, 2),
        V = j[0],
        Y = j[1]
      return [W(V), z(Y)]
    }),
    N = { points: a, indices: _, uvs: P }
  return { contour: r, triangles: N }
}
function zH(n, e) {
  return n.map(function (t) {
    var i = [],
      r
    return (
      t.forEach(function (s) {
        if (r) {
          var o = (Ho(s, r) * 180) / Math.PI
          if (o > e)
            for (var a = V2(r, s), A = 1 / Math.ceil(o / e), c = A; c < 1; )
              i.push(a(c)), (c += A)
        }
        i.push((r = s))
      }),
      i
    )
  })
}
function HH(n, e) {
  var t = { type: "Polygon", coordinates: n },
    i = Z6(t),
    r = Jr(i, 2),
    s = Jr(r[0], 2),
    o = s[0],
    a = s[1],
    A = Jr(r[1], 2),
    c = A[0],
    d = A[1]
  if (Math.min(Math.abs(c - o), Math.abs(d - a)) < e) return []
  var p = o > c || d >= 89 || a <= -89
  return GH(e, { minLng: o, maxLng: c, minLat: a, maxLat: d }).filter(function (
    m
  ) {
    return mg(m, t, p)
  })
}
function GH(n) {
  for (
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      t = e.minLng,
      i = e.maxLng,
      r = e.minLat,
      s = e.maxLat,
      o = Math.round(Math.pow(360 / n, 2) / Math.PI),
      a = (1 + Math.sqrt(5)) / 2,
      A = function (M) {
        return (((M / a) * 360) % 360) - 180
      },
      c = function (M) {
        return (Math.acos((2 * M) / o - 1) / Math.PI) * 180 - 90
      },
      d = function (M) {
        return (o * (Math.cos(((M + 90) * Math.PI) / 180) + 1)) / 2
      },
      p = [
        s !== void 0 ? Math.ceil(d(s)) : 0,
        r !== void 0 ? Math.floor(d(r)) : o - 1,
      ],
      m =
        t === void 0 && i === void 0
          ? function () {
              return !0
            }
          : t === void 0
          ? function (C) {
              return C <= i
            }
          : i === void 0
          ? function (C) {
              return C >= t
            }
          : i >= t
          ? function (C) {
              return C >= t && C <= i
            }
          : function (C) {
              return C >= t || C <= i
            },
      y = [],
      x = p[0];
    x <= p[1];
    x++
  ) {
    var S = A(x)
    m(S) && y.push([S, c(x)])
  }
  return y
}
function mg(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1
  return t ? VN(e, n) : eH(n, e)
}
var Jh = window.THREE
    ? window.THREE
    : { BufferGeometry: yt, Float32BufferAttribute: ut },
  $x = new Jh.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute",
  ry = (function (n) {
    RH(t, n)
    var e = IH(t)
    function t(i, r, s, o, a, A, c) {
      var d
      TH(this, t),
        (d = e.call(this)),
        (d.type = "ConicPolygonBufferGeometry"),
        (d.parameters = {
          polygonGeoJson: i,
          startHeight: r,
          endHeight: s,
          closedBottom: o,
          closedTop: a,
          includeSides: A,
          curvatureResolution: c,
        }),
        (r = r || 0),
        (s = s || 1),
        (o = o !== void 0 ? o : !0),
        (a = a !== void 0 ? a : !0),
        (A = A !== void 0 ? A : !0),
        (c = c || 5)
      var p = UH(i, { resolution: c }),
        m = p.contour,
        y = p.triangles,
        x = gu(y.uvs),
        S = [],
        C = [],
        M = [],
        _ = 0,
        R = function (O) {
          var W = Math.round(S.length / 3),
            z = M.length
          ;(S = S.concat(O.vertices)),
            (C = C.concat(O.uvs)),
            (M = M.concat(
              W
                ? O.indices.map(function (P) {
                    return P + W
                  })
                : O.indices
            )),
            d.addGroup(z, M.length - z, _++)
        }
      A && R(L()),
        o && R(B(r, !1)),
        a && R(B(s, !0)),
        d.setIndex(M),
        d[$x]("position", new Jh.Float32BufferAttribute(S, 3)),
        d[$x]("uv", new Jh.Float32BufferAttribute(C, 2)),
        d.computeVertexNormals()
      function T(k, O) {
        var W = k.map(function (z) {
          return z.map(function (P) {
            var N = Jr(P, 2),
              G = N[0],
              j = N[1]
            return VH(j, G, O)
          })
        })
        return mu.flatten(W)
      }
      function L() {
        for (
          var k = T(m, r),
            O = k.vertices,
            W = k.holes,
            z = T(m, s),
            P = z.vertices,
            N = gu([P, O]),
            G = Math.round(P.length / 3),
            j = new Set(W),
            V = 0,
            Y = [],
            ne = 0;
          ne < G;
          ne++
        ) {
          var le = ne + 1
          if (le === G) le = V
          else if (j.has(le)) {
            var Te = le
            ;(le = V), (V = Te)
          }
          Y.push(ne, ne + G, le + G), Y.push(le + G, le, ne)
        }
        for (var Ae = [], ge = 1; ge >= 0; ge--)
          for (var Me = 0; Me < G; Me += 1) Ae.push(Me / (G - 1), ge)
        return { indices: Y, vertices: N, uvs: Ae }
      }
      function B(k) {
        var O =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
        return {
          indices: O ? y.indices : y.indices.slice().reverse(),
          vertices: T([y.points], k).vertices,
          uvs: x,
        }
      }
      return d
    }
    return CH(t)
  })(Jh.BufferGeometry)
function VH(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
    i = ((90 - n) * Math.PI) / 180,
    r = ((90 - e) * Math.PI) / 180
  return [
    t * Math.sin(i) * Math.cos(r),
    t * Math.cos(i),
    t * Math.sin(i) * Math.sin(r),
  ]
}
var $t = (function (n) {
    n = n || {}
    var e = typeof n != "undefined" ? n : {},
      t = {},
      i
    for (i in e) e.hasOwnProperty(i) && (t[i] = e[i])
    var r = ""
    function s(J) {
      return e.locateFile ? e.locateFile(J, r) : r + J
    }
    var o
    document.currentScript && (r = document.currentScript.src),
      r.indexOf("blob:") !== 0
        ? (r = r.substr(0, r.lastIndexOf("/") + 1))
        : (r = ""),
      (o = function (ae, ke, Ve) {
        var u = new XMLHttpRequest()
        u.open("GET", ae, !0),
          (u.responseType = "arraybuffer"),
          (u.onload = function () {
            if (u.status == 200 || (u.status == 0 && u.response)) {
              ke(u.response)
              return
            }
            var gt = an(ae)
            if (gt) {
              ke(gt.buffer)
              return
            }
            Ve()
          }),
          (u.onerror = Ve),
          u.send(null)
      })
    var a = e.print || console.log.bind(console),
      A = e.printErr || console.warn.bind(console)
    for (i in t) t.hasOwnProperty(i) && (e[i] = t[i])
    ;(t = null), e.arguments && e.arguments
    var c = 0,
      d = function (J) {
        c = J
      },
      p = function () {
        return c
      },
      m = 8
    function y(J, ae, ke, Ve) {
      switch (
        ((ke = ke || "i8"),
        ke.charAt(ke.length - 1) === "*" && (ke = "i32"),
        ke)
      ) {
        case "i1":
          N[J >> 0] = ae
          break
        case "i8":
          N[J >> 0] = ae
          break
        case "i16":
          j[J >> 1] = ae
          break
        case "i32":
          V[J >> 2] = ae
          break
        case "i64":
          ;(Re = [
            ae >>> 0,
            ((pe = ae),
            +D(pe) >= 1
              ? pe > 0
                ? (te(+F(pe / 4294967296), 4294967295) | 0) >>> 0
                : ~~+q((pe - +(~~pe >>> 0)) / 4294967296) >>> 0
              : 0),
          ]),
            (V[J >> 2] = Re[0]),
            (V[(J + 4) >> 2] = Re[1])
          break
        case "float":
          Y[J >> 2] = ae
          break
        case "double":
          ne[J >> 3] = ae
          break
        default:
          Le("invalid type for setValue: " + ke)
      }
    }
    function x(J, ae, ke) {
      switch (
        ((ae = ae || "i8"),
        ae.charAt(ae.length - 1) === "*" && (ae = "i32"),
        ae)
      ) {
        case "i1":
          return N[J >> 0]
        case "i8":
          return N[J >> 0]
        case "i16":
          return j[J >> 1]
        case "i32":
          return V[J >> 2]
        case "i64":
          return V[J >> 2]
        case "float":
          return Y[J >> 2]
        case "double":
          return ne[J >> 3]
        default:
          Le("invalid type for getValue: " + ae)
      }
      return null
    }
    var S = !1
    function C(J, ae) {
      J || Le("Assertion failed: " + ae)
    }
    function M(J) {
      var ae = e["_" + J]
      return (
        C(
          ae,
          "Cannot call unknown function " + J + ", make sure it is exported"
        ),
        ae
      )
    }
    function _(J, ae, ke, Ve, u) {
      var Z = {
        string: function (tn) {
          var sn = 0
          if (tn != null && tn !== 0) {
            var _i = (tn.length << 2) + 1
            ;(sn = Xo(_i)), O(tn, sn, _i)
          }
          return sn
        },
        array: function (tn) {
          var sn = Xo(tn.length)
          return W(tn, sn), sn
        },
      }
      function gt(tn) {
        return ae === "string" ? B(tn) : ae === "boolean" ? Boolean(tn) : tn
      }
      var pt = M(J),
        lt = [],
        _t = 0
      if (Ve)
        for (var ln = 0; ln < Ve.length; ln++) {
          var Nt = Z[ke[ln]]
          Nt
            ? (_t === 0 && (_t = $c()), (lt[ln] = Nt(Ve[ln])))
            : (lt[ln] = Ve[ln])
        }
      var dt = pt.apply(null, lt)
      return (dt = gt(dt)), _t !== 0 && Kd(_t), dt
    }
    function R(J, ae, ke, Ve) {
      ke = ke || []
      var u = ke.every(function (gt) {
          return gt === "number"
        }),
        Z = ae !== "string"
      return Z && u && !Ve
        ? M(J)
        : function () {
            return _(J, ae, ke, arguments)
          }
    }
    var T = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0
    function L(J, ae, ke) {
      for (var Ve = ae + ke, u = ae; J[u] && !(u >= Ve); ) ++u
      if (u - ae > 16 && J.subarray && T) return T.decode(J.subarray(ae, u))
      for (var Z = ""; ae < u; ) {
        var gt = J[ae++]
        if (!(gt & 128)) {
          Z += String.fromCharCode(gt)
          continue
        }
        var pt = J[ae++] & 63
        if ((gt & 224) == 192) {
          Z += String.fromCharCode(((gt & 31) << 6) | pt)
          continue
        }
        var lt = J[ae++] & 63
        if (
          ((gt & 240) == 224
            ? (gt = ((gt & 15) << 12) | (pt << 6) | lt)
            : (gt = ((gt & 7) << 18) | (pt << 12) | (lt << 6) | (J[ae++] & 63)),
          gt < 65536)
        )
          Z += String.fromCharCode(gt)
        else {
          var _t = gt - 65536
          Z += String.fromCharCode(55296 | (_t >> 10), 56320 | (_t & 1023))
        }
      }
      return Z
    }
    function B(J, ae) {
      return J ? L(G, J, ae) : ""
    }
    function k(J, ae, ke, Ve) {
      if (!(Ve > 0)) return 0
      for (var u = ke, Z = ke + Ve - 1, gt = 0; gt < J.length; ++gt) {
        var pt = J.charCodeAt(gt)
        if (pt >= 55296 && pt <= 57343) {
          var lt = J.charCodeAt(++gt)
          pt = (65536 + ((pt & 1023) << 10)) | (lt & 1023)
        }
        if (pt <= 127) {
          if (ke >= Z) break
          ae[ke++] = pt
        } else if (pt <= 2047) {
          if (ke + 1 >= Z) break
          ;(ae[ke++] = 192 | (pt >> 6)), (ae[ke++] = 128 | (pt & 63))
        } else if (pt <= 65535) {
          if (ke + 2 >= Z) break
          ;(ae[ke++] = 224 | (pt >> 12)),
            (ae[ke++] = 128 | ((pt >> 6) & 63)),
            (ae[ke++] = 128 | (pt & 63))
        } else {
          if (ke + 3 >= Z) break
          ;(ae[ke++] = 240 | (pt >> 18)),
            (ae[ke++] = 128 | ((pt >> 12) & 63)),
            (ae[ke++] = 128 | ((pt >> 6) & 63)),
            (ae[ke++] = 128 | (pt & 63))
        }
      }
      return (ae[ke] = 0), ke - u
    }
    function O(J, ae, ke) {
      return k(J, G, ae, ke)
    }
    typeof TextDecoder != "undefined" && new TextDecoder("utf-16le")
    function W(J, ae) {
      N.set(J, ae)
    }
    function z(J, ae) {
      return J % ae > 0 && (J += ae - (J % ae)), J
    }
    var P, N, G, j, V, Y, ne
    function le(J) {
      ;(P = J),
        (e.HEAP8 = N = new Int8Array(J)),
        (e.HEAP16 = j = new Int16Array(J)),
        (e.HEAP32 = V = new Int32Array(J)),
        (e.HEAPU8 = G = new Uint8Array(J)),
        (e.HEAPU16 = new Uint16Array(J)),
        (e.HEAPU32 = new Uint32Array(J)),
        (e.HEAPF32 = Y = new Float32Array(J)),
        (e.HEAPF64 = ne = new Float64Array(J))
    }
    var Te = 5266928,
      Ae = 24016,
      ge = e.TOTAL_MEMORY || 33554432
    e.buffer ? (P = e.buffer) : (P = new ArrayBuffer(ge)),
      (ge = P.byteLength),
      le(P),
      (V[Ae >> 2] = Te)
    function Me(J) {
      for (; J.length > 0; ) {
        var ae = J.shift()
        if (typeof ae == "function") {
          ae()
          continue
        }
        var ke = ae.func
        typeof ke == "number"
          ? ae.arg === void 0
            ? e.dynCall_v(ke)
            : e.dynCall_vi(ke, ae.arg)
          : ke(ae.arg === void 0 ? null : ae.arg)
      }
    }
    var Ne = [],
      Ze = [],
      K = [],
      Oe = []
    function ve() {
      if (e.preRun)
        for (
          typeof e.preRun == "function" && (e.preRun = [e.preRun]);
          e.preRun.length;

        )
          Ge(e.preRun.shift())
      Me(Ne)
    }
    function Be() {
      Me(Ze)
    }
    function Fe() {
      Me(K)
    }
    function je() {
      if (e.postRun)
        for (
          typeof e.postRun == "function" && (e.postRun = [e.postRun]);
          e.postRun.length;

        )
          ye(e.postRun.shift())
      Me(Oe)
    }
    function Ge(J) {
      Ne.unshift(J)
    }
    function ye(J) {
      Oe.unshift(J)
    }
    var D = Math.abs,
      q = Math.ceil,
      F = Math.floor,
      te = Math.min,
      oe = 0,
      ue = null
    function Ee(J) {
      oe++, e.monitorRunDependencies && e.monitorRunDependencies(oe)
    }
    function Ce(J) {
      if (
        (oe--,
        e.monitorRunDependencies && e.monitorRunDependencies(oe),
        oe == 0 && ue)
      ) {
        var ae = ue
        ;(ue = null), ae()
      }
    }
    ;(e.preloadedImages = {}), (e.preloadedAudios = {})
    var Se = null,
      $ = "data:application/octet-stream;base64,"
    function Q(J) {
      return String.prototype.startsWith ? J.startsWith($) : J.indexOf($) === 0
    }
    var pe, Re
    Se =
      "data:application/octet-stream;base64,AAAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAABAAAAAMAAAAGAAAABQAAAAIAAAAAAAAAAgAAAAMAAAABAAAABAAAAAYAAAAAAAAABQAAAAMAAAAGAAAABAAAAAUAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAABAAAABQAAAAIAAAAAAAAAAQAAAAMAAAAGAAAABAAAAAYAAAAAAAAABQAAAAIAAAABAAAABAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAgAAAAMAAAAAAAAAAAAAAAIAAAAAAAAAAQAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAABgAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAAAAAAAAAAAAAAAAAIAAAAAAAAABgAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAAAAAACAAAAAwAAAAQAAAAFAAAABgAAAAAAAAABAAAAAwAAAAQAAAAFAAAABgAAAAAAAAABAAAAAgAAAAQAAAAFAAAABgAAAAAAAAABAAAAAgAAAAMAAAAFAAAABgAAAAAAAAABAAAAAgAAAAMAAAAEAAAABgAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAAAAAAAAAAABgAAAAAAAAADAAAAAgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAUAAAAEAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAEAAAAAAAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAUAAAACAAAABAAAAAMAAAAIAAAAAQAAAAcAAAAGAAAACQAAAAAAAAADAAAAAgAAAAIAAAAGAAAACgAAAAsAAAAAAAAAAQAAAAUAAAADAAAADQAAAAEAAAAHAAAABAAAAAwAAAAAAAAABAAAAH8AAAAPAAAACAAAAAMAAAAAAAAADAAAAAUAAAACAAAAEgAAAAoAAAAIAAAAAAAAABAAAAAGAAAADgAAAAsAAAARAAAAAQAAAAkAAAACAAAABwAAABUAAAAJAAAAEwAAAAMAAAANAAAAAQAAAAgAAAAFAAAAFgAAABAAAAAEAAAAAAAAAA8AAAAJAAAAEwAAAA4AAAAUAAAAAQAAAAcAAAAGAAAACgAAAAsAAAAYAAAAFwAAAAUAAAACAAAAEgAAAAsAAAARAAAAFwAAABkAAAACAAAABgAAAAoAAAAMAAAAHAAAAA0AAAAaAAAABAAAAA8AAAADAAAADQAAABoAAAAVAAAAHQAAAAMAAAAMAAAABwAAAA4AAAB/AAAAEQAAABsAAAAJAAAAFAAAAAYAAAAPAAAAFgAAABwAAAAfAAAABAAAAAgAAAAMAAAAEAAAABIAAAAhAAAAHgAAAAgAAAAFAAAAFgAAABEAAAALAAAADgAAAAYAAAAjAAAAGQAAABsAAAASAAAAGAAAAB4AAAAgAAAABQAAAAoAAAAQAAAAEwAAACIAAAAUAAAAJAAAAAcAAAAVAAAACQAAABQAAAAOAAAAEwAAAAkAAAAoAAAAGwAAACQAAAAVAAAAJgAAABMAAAAiAAAADQAAAB0AAAAHAAAAFgAAABAAAAApAAAAIQAAAA8AAAAIAAAAHwAAABcAAAAYAAAACwAAAAoAAAAnAAAAJQAAABkAAAAYAAAAfwAAACAAAAAlAAAACgAAABcAAAASAAAAGQAAABcAAAARAAAACwAAAC0AAAAnAAAAIwAAABoAAAAqAAAAHQAAACsAAAAMAAAAHAAAAA0AAAAbAAAAKAAAACMAAAAuAAAADgAAABQAAAARAAAAHAAAAB8AAAAqAAAALAAAAAwAAAAPAAAAGgAAAB0AAAArAAAAJgAAAC8AAAANAAAAGgAAABUAAAAeAAAAIAAAADAAAAAyAAAAEAAAABIAAAAhAAAAHwAAACkAAAAsAAAANQAAAA8AAAAWAAAAHAAAACAAAAAeAAAAGAAAABIAAAA0AAAAMgAAACUAAAAhAAAAHgAAADEAAAAwAAAAFgAAABAAAAApAAAAIgAAABMAAAAmAAAAFQAAADYAAAAkAAAAMwAAACMAAAAuAAAALQAAADgAAAARAAAAGwAAABkAAAAkAAAAFAAAACIAAAATAAAANwAAACgAAAA2AAAAJQAAACcAAAA0AAAAOQAAABgAAAAXAAAAIAAAACYAAAB/AAAAIgAAADMAAAAdAAAALwAAABUAAAAnAAAAJQAAABkAAAAXAAAAOwAAADkAAAAtAAAAKAAAABsAAAAkAAAAFAAAADwAAAAuAAAANwAAACkAAAAxAAAANQAAAD0AAAAWAAAAIQAAAB8AAAAqAAAAOgAAACsAAAA+AAAAHAAAACwAAAAaAAAAKwAAAD4AAAAvAAAAQAAAABoAAAAqAAAAHQAAACwAAAA1AAAAOgAAAEEAAAAcAAAAHwAAACoAAAAtAAAAJwAAACMAAAAZAAAAPwAAADsAAAA4AAAALgAAADwAAAA4AAAARAAAABsAAAAoAAAAIwAAAC8AAAAmAAAAKwAAAB0AAABFAAAAMwAAAEAAAAAwAAAAMQAAAB4AAAAhAAAAQwAAAEIAAAAyAAAAMQAAAH8AAAA9AAAAQgAAACEAAAAwAAAAKQAAADIAAAAwAAAAIAAAAB4AAABGAAAAQwAAADQAAAAzAAAARQAAADYAAABHAAAAJgAAAC8AAAAiAAAANAAAADkAAABGAAAASgAAACAAAAAlAAAAMgAAADUAAAA9AAAAQQAAAEsAAAAfAAAAKQAAACwAAAA2AAAARwAAADcAAABJAAAAIgAAADMAAAAkAAAANwAAACgAAAA2AAAAJAAAAEgAAAA8AAAASQAAADgAAABEAAAAPwAAAE0AAAAjAAAALgAAAC0AAAA5AAAAOwAAAEoAAABOAAAAJQAAACcAAAA0AAAAOgAAAH8AAAA+AAAATAAAACwAAABBAAAAKgAAADsAAAA/AAAATgAAAE8AAAAnAAAALQAAADkAAAA8AAAASAAAAEQAAABQAAAAKAAAADcAAAAuAAAAPQAAADUAAAAxAAAAKQAAAFEAAABLAAAAQgAAAD4AAAArAAAAOgAAACoAAABSAAAAQAAAAEwAAAA/AAAAfwAAADgAAAAtAAAATwAAADsAAABNAAAAQAAAAC8AAAA+AAAAKwAAAFQAAABFAAAAUgAAAEEAAAA6AAAANQAAACwAAABWAAAATAAAAEsAAABCAAAAQwAAAFEAAABVAAAAMQAAADAAAAA9AAAAQwAAAEIAAAAyAAAAMAAAAFcAAABVAAAARgAAAEQAAAA4AAAAPAAAAC4AAABaAAAATQAAAFAAAABFAAAAMwAAAEAAAAAvAAAAWQAAAEcAAABUAAAARgAAAEMAAAA0AAAAMgAAAFMAAABXAAAASgAAAEcAAABZAAAASQAAAFsAAAAzAAAARQAAADYAAABIAAAAfwAAAEkAAAA3AAAAUAAAADwAAABYAAAASQAAAFsAAABIAAAAWAAAADYAAABHAAAANwAAAEoAAABOAAAAUwAAAFwAAAA0AAAAOQAAAEYAAABLAAAAQQAAAD0AAAA1AAAAXgAAAFYAAABRAAAATAAAAFYAAABSAAAAYAAAADoAAABBAAAAPgAAAE0AAAA/AAAARAAAADgAAABdAAAATwAAAFoAAABOAAAASgAAADsAAAA5AAAAXwAAAFwAAABPAAAATwAAAE4AAAA/AAAAOwAAAF0AAABfAAAATQAAAFAAAABEAAAASAAAADwAAABjAAAAWgAAAFgAAABRAAAAVQAAAF4AAABlAAAAPQAAAEIAAABLAAAAUgAAAGAAAABUAAAAYgAAAD4AAABMAAAAQAAAAFMAAAB/AAAASgAAAEYAAABkAAAAVwAAAFwAAABUAAAARQAAAFIAAABAAAAAYQAAAFkAAABiAAAAVQAAAFcAAABlAAAAZgAAAEIAAABDAAAAUQAAAFYAAABMAAAASwAAAEEAAABoAAAAYAAAAF4AAABXAAAAUwAAAGYAAABkAAAAQwAAAEYAAABVAAAAWAAAAEgAAABbAAAASQAAAGMAAABQAAAAaQAAAFkAAABhAAAAWwAAAGcAAABFAAAAVAAAAEcAAABaAAAATQAAAFAAAABEAAAAagAAAF0AAABjAAAAWwAAAEkAAABZAAAARwAAAGkAAABYAAAAZwAAAFwAAABTAAAATgAAAEoAAABsAAAAZAAAAF8AAABdAAAATwAAAFoAAABNAAAAbQAAAF8AAABqAAAAXgAAAFYAAABRAAAASwAAAGsAAABoAAAAZQAAAF8AAABcAAAATwAAAE4AAABtAAAAbAAAAF0AAABgAAAAaAAAAGIAAABuAAAATAAAAFYAAABSAAAAYQAAAH8AAABiAAAAVAAAAGcAAABZAAAAbwAAAGIAAABuAAAAYQAAAG8AAABSAAAAYAAAAFQAAABjAAAAUAAAAGkAAABYAAAAagAAAFoAAABxAAAAZAAAAGYAAABTAAAAVwAAAGwAAAByAAAAXAAAAGUAAABmAAAAawAAAHAAAABRAAAAVQAAAF4AAABmAAAAZQAAAFcAAABVAAAAcgAAAHAAAABkAAAAZwAAAFsAAABhAAAAWQAAAHQAAABpAAAAbwAAAGgAAABrAAAAbgAAAHMAAABWAAAAXgAAAGAAAABpAAAAWAAAAGcAAABbAAAAcQAAAGMAAAB0AAAAagAAAF0AAABjAAAAWgAAAHUAAABtAAAAcQAAAGsAAAB/AAAAZQAAAF4AAABzAAAAaAAAAHAAAABsAAAAZAAAAF8AAABcAAAAdgAAAHIAAABtAAAAbQAAAGwAAABdAAAAXwAAAHUAAAB2AAAAagAAAG4AAABiAAAAaAAAAGAAAAB3AAAAbwAAAHMAAABvAAAAYQAAAG4AAABiAAAAdAAAAGcAAAB3AAAAcAAAAGsAAABmAAAAZQAAAHgAAABzAAAAcgAAAHEAAABjAAAAdAAAAGkAAAB1AAAAagAAAHkAAAByAAAAcAAAAGQAAABmAAAAdgAAAHgAAABsAAAAcwAAAG4AAABrAAAAaAAAAHgAAAB3AAAAcAAAAHQAAABnAAAAdwAAAG8AAABxAAAAaQAAAHkAAAB1AAAAfwAAAG0AAAB2AAAAcQAAAHkAAABqAAAAdgAAAHgAAABsAAAAcgAAAHUAAAB5AAAAbQAAAHcAAABvAAAAcwAAAG4AAAB5AAAAdAAAAHgAAAB4AAAAcwAAAHIAAABwAAAAeQAAAHcAAAB2AAAAeQAAAHQAAAB4AAAAdwAAAHUAAABxAAAAdgAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAQAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAADAAAABQAAAAEAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAgAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAABQAAAAUAAAAAAAAAAAAAAP////8BAAAAAAAAAAMAAAAEAAAAAgAAAAAAAAAAAAAAAQAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAQAAAP//////////AQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAIAAAAAAAAAAAAAAAEAAAACAAAABgAAAAQAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAoAAAACAAAAAAAAAAAAAAABAAAAAQAAAAUAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAAAAAAAAAAAAAEAAAADAAAABwAAAAYAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAHAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAgAAAAAAAAAAAAAAAQAAAAAAAAAJAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAAAAAAAAAAAAQAAAAQAAAAIAAAACgAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAAAAAAAAAAABAAAACwAAAA8AAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA4AAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAgAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAAAAAAAAAAABAAAADAAAABAAAAAMAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAEAAAAKAAAAEwAAAAgAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAJAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAgAAAAAAAAAAAAAAAQAAAA0AAAARAAAADQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAIAAAAAAAAAAAAAAAEAAAAOAAAAEgAAAA8AAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAAAAAABAAAA//////////8TAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABIAAAAAAAAAGAAAAAAAAAAhAAAAAAAAAB4AAAAAAAAAIAAAAAMAAAAxAAAAAQAAADAAAAADAAAAMgAAAAMAAAAIAAAAAAAAAAUAAAAFAAAACgAAAAUAAAAWAAAAAAAAABAAAAAAAAAAEgAAAAAAAAApAAAAAQAAACEAAAAAAAAAHgAAAAAAAAAEAAAAAAAAAAAAAAAFAAAAAgAAAAUAAAAPAAAAAQAAAAgAAAAAAAAABQAAAAUAAAAfAAAAAQAAABYAAAAAAAAAEAAAAAAAAAACAAAAAAAAAAYAAAAAAAAADgAAAAAAAAAKAAAAAAAAAAsAAAAAAAAAEQAAAAMAAAAYAAAAAQAAABcAAAADAAAAGQAAAAMAAAAAAAAAAAAAAAEAAAAFAAAACQAAAAUAAAAFAAAAAAAAAAIAAAAAAAAABgAAAAAAAAASAAAAAQAAAAoAAAAAAAAACwAAAAAAAAAEAAAAAQAAAAMAAAAFAAAABwAAAAUAAAAIAAAAAQAAAAAAAAAAAAAAAQAAAAUAAAAQAAAAAQAAAAUAAAAAAAAAAgAAAAAAAAAHAAAAAAAAABUAAAAAAAAAJgAAAAAAAAAJAAAAAAAAABMAAAAAAAAAIgAAAAMAAAAOAAAAAQAAABQAAAADAAAAJAAAAAMAAAADAAAAAAAAAA0AAAAFAAAAHQAAAAUAAAABAAAAAAAAAAcAAAAAAAAAFQAAAAAAAAAGAAAAAQAAAAkAAAAAAAAAEwAAAAAAAAAEAAAAAgAAAAwAAAAFAAAAGgAAAAUAAAAAAAAAAQAAAAMAAAAAAAAADQAAAAUAAAACAAAAAQAAAAEAAAAAAAAABwAAAAAAAAAaAAAAAAAAACoAAAAAAAAAOgAAAAAAAAAdAAAAAAAAACsAAAAAAAAAPgAAAAMAAAAmAAAAAQAAAC8AAAADAAAAQAAAAAMAAAAMAAAAAAAAABwAAAAFAAAALAAAAAUAAAANAAAAAAAAABoAAAAAAAAAKgAAAAAAAAAVAAAAAQAAAB0AAAAAAAAAKwAAAAAAAAAEAAAAAwAAAA8AAAAFAAAAHwAAAAUAAAADAAAAAQAAAAwAAAAAAAAAHAAAAAUAAAAHAAAAAQAAAA0AAAAAAAAAGgAAAAAAAAAfAAAAAAAAACkAAAAAAAAAMQAAAAAAAAAsAAAAAAAAADUAAAAAAAAAPQAAAAMAAAA6AAAAAQAAAEEAAAADAAAASwAAAAMAAAAPAAAAAAAAABYAAAAFAAAAIQAAAAUAAAAcAAAAAAAAAB8AAAAAAAAAKQAAAAAAAAAqAAAAAQAAACwAAAAAAAAANQAAAAAAAAAEAAAABAAAAAgAAAAFAAAAEAAAAAUAAAAMAAAAAQAAAA8AAAAAAAAAFgAAAAUAAAAaAAAAAQAAABwAAAAAAAAAHwAAAAAAAAAyAAAAAAAAADAAAAAAAAAAMQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAIQAAAAMAAAAYAAAAAwAAABIAAAADAAAAEAAAAAMAAABGAAAAAAAAAEMAAAAAAAAAQgAAAAMAAAA0AAAAAwAAADIAAAAAAAAAMAAAAAAAAAAlAAAAAwAAACAAAAAAAAAAHgAAAAMAAABTAAAAAAAAAFcAAAADAAAAVQAAAAMAAABKAAAAAwAAAEYAAAAAAAAAQwAAAAAAAAA5AAAAAQAAADQAAAADAAAAMgAAAAAAAAAZAAAAAAAAABcAAAAAAAAAGAAAAAMAAAARAAAAAAAAAAsAAAADAAAACgAAAAMAAAAOAAAAAwAAAAYAAAADAAAAAgAAAAMAAAAtAAAAAAAAACcAAAAAAAAAJQAAAAMAAAAjAAAAAwAAABkAAAAAAAAAFwAAAAAAAAAbAAAAAwAAABEAAAAAAAAACwAAAAMAAAA/AAAAAAAAADsAAAADAAAAOQAAAAMAAAA4AAAAAwAAAC0AAAAAAAAAJwAAAAAAAAAuAAAAAwAAACMAAAADAAAAGQAAAAAAAAAkAAAAAAAAABQAAAAAAAAADgAAAAMAAAAiAAAAAAAAABMAAAADAAAACQAAAAMAAAAmAAAAAwAAABUAAAADAAAABwAAAAMAAAA3AAAAAAAAACgAAAAAAAAAGwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAFAAAAAAAAAAzAAAAAwAAACIAAAAAAAAAEwAAAAMAAABIAAAAAAAAADwAAAADAAAALgAAAAMAAABJAAAAAwAAADcAAAAAAAAAKAAAAAAAAABHAAAAAwAAADYAAAADAAAAJAAAAAAAAABAAAAAAAAAAC8AAAAAAAAAJgAAAAMAAAA+AAAAAAAAACsAAAADAAAAHQAAAAMAAAA6AAAAAwAAACoAAAADAAAAGgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAMwAAAAMAAABSAAAAAwAAAEAAAAAAAAAALwAAAAAAAABMAAAAAwAAAD4AAAAAAAAAKwAAAAMAAABhAAAAAAAAAFkAAAADAAAARwAAAAMAAABiAAAAAwAAAFQAAAAAAAAARQAAAAAAAABgAAAAAwAAAFIAAAADAAAAQAAAAAAAAABLAAAAAAAAAEEAAAAAAAAAOgAAAAMAAAA9AAAAAAAAADUAAAADAAAALAAAAAMAAAAxAAAAAwAAACkAAAADAAAAHwAAAAMAAABeAAAAAAAAAFYAAAAAAAAATAAAAAMAAABRAAAAAwAAAEsAAAAAAAAAQQAAAAAAAABCAAAAAwAAAD0AAAAAAAAANQAAAAMAAABrAAAAAAAAAGgAAAADAAAAYAAAAAMAAABlAAAAAwAAAF4AAAAAAAAAVgAAAAAAAABVAAAAAwAAAFEAAAADAAAASwAAAAAAAAA5AAAAAAAAADsAAAAAAAAAPwAAAAMAAABKAAAAAAAAAE4AAAADAAAATwAAAAMAAABTAAAAAwAAAFwAAAADAAAAXwAAAAMAAAAlAAAAAAAAACcAAAADAAAALQAAAAMAAAA0AAAAAAAAADkAAAAAAAAAOwAAAAAAAABGAAAAAwAAAEoAAAAAAAAATgAAAAMAAAAYAAAAAAAAABcAAAADAAAAGQAAAAMAAAAgAAAAAwAAACUAAAAAAAAAJwAAAAMAAAAyAAAAAwAAADQAAAAAAAAAOQAAAAAAAAAuAAAAAAAAADwAAAAAAAAASAAAAAMAAAA4AAAAAAAAAEQAAAADAAAAUAAAAAMAAAA/AAAAAwAAAE0AAAADAAAAWgAAAAMAAAAbAAAAAAAAACgAAAADAAAANwAAAAMAAAAjAAAAAAAAAC4AAAAAAAAAPAAAAAAAAAAtAAAAAwAAADgAAAAAAAAARAAAAAMAAAAOAAAAAAAAABQAAAADAAAAJAAAAAMAAAARAAAAAwAAABsAAAAAAAAAKAAAAAMAAAAZAAAAAwAAACMAAAAAAAAALgAAAAAAAABHAAAAAAAAAFkAAAAAAAAAYQAAAAMAAABJAAAAAAAAAFsAAAADAAAAZwAAAAMAAABIAAAAAwAAAFgAAAADAAAAaQAAAAMAAAAzAAAAAAAAAEUAAAADAAAAVAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAWQAAAAAAAAA3AAAAAwAAAEkAAAAAAAAAWwAAAAMAAAAmAAAAAAAAAC8AAAADAAAAQAAAAAMAAAAiAAAAAwAAADMAAAAAAAAARQAAAAMAAAAkAAAAAwAAADYAAAAAAAAARwAAAAAAAABgAAAAAAAAAGgAAAAAAAAAawAAAAMAAABiAAAAAAAAAG4AAAADAAAAcwAAAAMAAABhAAAAAwAAAG8AAAADAAAAdwAAAAMAAABMAAAAAAAAAFYAAAADAAAAXgAAAAMAAABSAAAAAAAAAGAAAAAAAAAAaAAAAAAAAABUAAAAAwAAAGIAAAAAAAAAbgAAAAMAAAA6AAAAAAAAAEEAAAADAAAASwAAAAMAAAA+AAAAAwAAAEwAAAAAAAAAVgAAAAMAAABAAAAAAwAAAFIAAAAAAAAAYAAAAAAAAABVAAAAAAAAAFcAAAAAAAAAUwAAAAMAAABlAAAAAAAAAGYAAAADAAAAZAAAAAMAAABrAAAAAwAAAHAAAAADAAAAcgAAAAMAAABCAAAAAAAAAEMAAAADAAAARgAAAAMAAABRAAAAAAAAAFUAAAAAAAAAVwAAAAAAAABeAAAAAwAAAGUAAAAAAAAAZgAAAAMAAAAxAAAAAAAAADAAAAADAAAAMgAAAAMAAAA9AAAAAwAAAEIAAAAAAAAAQwAAAAMAAABLAAAAAwAAAFEAAAAAAAAAVQAAAAAAAABfAAAAAAAAAFwAAAAAAAAAUwAAAAAAAABPAAAAAAAAAE4AAAAAAAAASgAAAAMAAAA/AAAAAQAAADsAAAADAAAAOQAAAAMAAABtAAAAAAAAAGwAAAAAAAAAZAAAAAUAAABdAAAAAQAAAF8AAAAAAAAAXAAAAAAAAABNAAAAAQAAAE8AAAAAAAAATgAAAAAAAAB1AAAABAAAAHYAAAAFAAAAcgAAAAUAAABqAAAAAQAAAG0AAAAAAAAAbAAAAAAAAABaAAAAAQAAAF0AAAABAAAAXwAAAAAAAABaAAAAAAAAAE0AAAAAAAAAPwAAAAAAAABQAAAAAAAAAEQAAAAAAAAAOAAAAAMAAABIAAAAAQAAADwAAAADAAAALgAAAAMAAABqAAAAAAAAAF0AAAAAAAAATwAAAAUAAABjAAAAAQAAAFoAAAAAAAAATQAAAAAAAABYAAAAAQAAAFAAAAAAAAAARAAAAAAAAAB1AAAAAwAAAG0AAAAFAAAAXwAAAAUAAABxAAAAAQAAAGoAAAAAAAAAXQAAAAAAAABpAAAAAQAAAGMAAAABAAAAWgAAAAAAAABpAAAAAAAAAFgAAAAAAAAASAAAAAAAAABnAAAAAAAAAFsAAAAAAAAASQAAAAMAAABhAAAAAQAAAFkAAAADAAAARwAAAAMAAABxAAAAAAAAAGMAAAAAAAAAUAAAAAUAAAB0AAAAAQAAAGkAAAAAAAAAWAAAAAAAAABvAAAAAQAAAGcAAAAAAAAAWwAAAAAAAAB1AAAAAgAAAGoAAAAFAAAAWgAAAAUAAAB5AAAAAQAAAHEAAAAAAAAAYwAAAAAAAAB3AAAAAQAAAHQAAAABAAAAaQAAAAAAAAB3AAAAAAAAAG8AAAAAAAAAYQAAAAAAAABzAAAAAAAAAG4AAAAAAAAAYgAAAAMAAABrAAAAAQAAAGgAAAADAAAAYAAAAAMAAAB5AAAAAAAAAHQAAAAAAAAAZwAAAAUAAAB4AAAAAQAAAHcAAAAAAAAAbwAAAAAAAABwAAAAAQAAAHMAAAAAAAAAbgAAAAAAAAB1AAAAAQAAAHEAAAAFAAAAaQAAAAUAAAB2AAAAAQAAAHkAAAAAAAAAdAAAAAAAAAByAAAAAQAAAHgAAAABAAAAdwAAAAAAAAByAAAAAAAAAHAAAAAAAAAAawAAAAAAAABkAAAAAAAAAGYAAAAAAAAAZQAAAAMAAABTAAAAAQAAAFcAAAADAAAAVQAAAAMAAAB2AAAAAAAAAHgAAAAAAAAAcwAAAAUAAABsAAAAAQAAAHIAAAAAAAAAcAAAAAAAAABcAAAAAQAAAGQAAAAAAAAAZgAAAAAAAAB1AAAAAAAAAHkAAAAFAAAAdwAAAAUAAABtAAAAAQAAAHYAAAAAAAAAeAAAAAAAAABfAAAAAQAAAGwAAAABAAAAcgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAAAAAABAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAB+ogX28rbpPxqumpJv+fM/165tC4ns9D+XaEnTqUsEQFrOtNlC4PA/3U+0XG6P9b9TdUUBxTTjP4PUp8ex1ty/B1rD/EN43z+lcDi6LLrZP/a45NWEHMY/oJ5ijLDZ+j/xw3rjxWPjP2B8A46ioQdAotff3wla2z+FMSpA1jj+v6b5Y1mtPbS/cIu8K0F457/2esiyJpDNv98k5Ts2NeA/pvljWa09tD88ClUJ60MDQPZ6yLImkM0/4ONKxa0UBcD2uOTVhBzGv5G7JRxGave/8cN648Vj47+HCwtkjAXIv6LX398JWtu/qyheaCAL9D9TdUUBxTTjv4gyTxslhwVAB1rD/EN4378EH/28teoFwH6iBfbytum/F6ztFYdK/r/Xrm0Liez0vwcS6wNGWeO/Ws602ULg8L9TCtRLiLT8P8pi5RexJsw/BlIKPVwR5T95Wyu0/QjnP5PjoT7YYcu/mBhKZ6zrwj8wRYS7NebuP3qW6geh+Ls/SLrixebL3r+pcyymN9XrPwmkNHp7xec/GWNMZVAA17+82s+x2BLiPwn2ytbJ9ek/LgEH1sMS1j8yp/2LhTfeP+SnWwtQBbu/d38gkp5X7z8ytsuHaADGPzUYObdf1+m/7IauECWhwz+cjSACjzniP76Z+wUhN9K/1+GEKzup67+/GYr/04baPw6idWOvsuc/ZedTWsRa5b/EJQOuRzi0v/OncYhHPes/h49PixY53j+i8wWfC03Nvw2idWOvsue/ZedTWsRa5T/EJQOuRzi0P/KncYhHPeu/iY9PixY53r+i8wWfC03NP9anWwtQBbs/d38gkp5X778ytsuHaADGvzUYObdf1+k/74auECWhw7+cjSACjzniv8CZ+wUhN9I/1uGEKzup6z+/GYr/04bavwmkNHp7xee/F2NMZVAA1z+82s+x2BLivwr2ytbJ9em/KwEH1sMS1r8yp/2LhTfev81i5RexJsy/BlIKPVwR5b95Wyu0/Qjnv5DjoT7YYcs/nBhKZ6zrwr8wRYS7Nebuv3OW6geh+Lu/SLrixebL3j+pcyymN9Xrv8rHIFfWehZAMBwUdlo0DECTUc17EOb2PxpVB1SWChdAzjbhb9pTDUDQhmdvECX5P9FlMKCC9+g/IIAzjELgE0DajDngMv8GQFhWDmDPjNs/y1guLh96EkAxPi8k7DIEQJCc4URlhRhA3eLKKLwkEECqpNAyTBD/P6xpjXcDiwVAFtl//cQm4z+Ibt3XKiYTQM7mCLUb3QdAoM1t8yVv7D8aLZv2Nk8UQEAJPV5nQwxAtSsfTCoE9z9TPjXLXIIWQBVanC5W9AtAYM3d7Adm9j++5mQz1FoWQBUThyaVBghAwH5muQsV7T89Q1qv82MUQJoWGOfNuBdAzrkClkmwDkDQjKq77t37Py+g0dtitsE/ZwAMTwVPEUBojepluNwBQGYbtuW+t9w/HNWIJs6MEkDTNuQUSlgEQKxktPP5TcQ/ixbLB8JjEUCwuWjXMQYCQAS/R09FkRdAowpiZjhhDkB7LmlczD/7P01iQmhhsAVAnrtTwDy84z/Z6jfQ2TgTQChOCXMnWwpAhrW3daoz8z/HYJvVPI4VQLT3ik5FcA5Angi7LOZd+z+NNVzDy5gXQBXdvVTFUA1AYNMgOeYe+T8+qHXGCwkXQKQTOKwa5AJA8gFVoEMW0T+FwzJyttIRQAEAAAD/////BwAAAP////8xAAAA/////1cBAAD/////YQkAAP////+nQQAA/////5HLAQD/////95AMAP/////B9lcAAAAAAAAAAAAAAAAAAgAAAP////8OAAAA/////2IAAAD/////rgIAAP/////CEgAA/////06DAAD/////IpcDAP/////uIRkA/////4LtrwAAAAAAAAAAAAAAAAAAAAAAAgAAAP//////////AQAAAAMAAAD//////////////////////////////////////////////////////////////////////////wEAAAAAAAAAAgAAAP///////////////wMAAAD//////////////////////////////////////////////////////////////////////////wEAAAAAAAAAAgAAAP///////////////wMAAAD//////////////////////////////////////////////////////////////////////////wEAAAAAAAAAAgAAAP///////////////wMAAAD//////////////////////////////////////////////////////////wIAAAD//////////wEAAAAAAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA/////////////////////wEAAAD///////////////8CAAAA////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAA////////////////AgAAAAEAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AQAAAAIAAAD///////////////8AAAAA/////////////////////wMAAAD///////////////////////////////8CAAAA////////////////AQAAAP////////////////////8AAAAA/////////////////////wMAAAD/////////////////////////////////////////////////////AwAAAP////////////////////8AAAAAAQAAAP//////////AgAAAP//////////////////////////////////////////////////////////AwAAAP///////////////wIAAAAAAAAAAQAAAP//////////////////////////////////////////////////////////////////////////AwAAAP///////////////wIAAAAAAAAAAQAAAP//////////////////////////////////////////////////////////////////////////AwAAAP///////////////wIAAAAAAAAAAQAAAP//////////////////////////////////////////////////////////////////////////AwAAAAEAAAD//////////wIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAgAAAAAAAAACAAAAAQAAAAEAAAACAAAAAgAAAAAAAAAFAAAABQAAAAAAAAACAAAAAgAAAAMAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAIAAAABAAAAAgAAAAIAAAACAAAAAAAAAAUAAAAGAAAAAAAAAAIAAAACAAAAAwAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAAAAAAAAgAAAAEAAAADAAAAAgAAAAIAAAAAAAAABQAAAAcAAAAAAAAAAgAAAAIAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAgAAAAAAAAACAAAAAQAAAAQAAAACAAAAAgAAAAAAAAAFAAAACAAAAAAAAAACAAAAAgAAAAMAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAACAAAAAAAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAUAAAAJAAAAAAAAAAIAAAACAAAAAwAAAAUAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAIAAAACAAAAAAAAAAMAAAAOAAAAAgAAAAAAAAACAAAAAwAAAAAAAAAAAAAAAgAAAAIAAAADAAAABgAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAgAAAAIAAAAAAAAAAwAAAAoAAAACAAAAAAAAAAIAAAADAAAAAQAAAAAAAAACAAAAAgAAAAMAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAgAAAAAAAAADAAAACwAAAAIAAAAAAAAAAgAAAAMAAAACAAAAAAAAAAIAAAACAAAAAwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAACAAAAAAAAAAMAAAAMAAAAAgAAAAAAAAACAAAAAwAAAAMAAAAAAAAAAgAAAAIAAAADAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAgAAAAIAAAAAAAAAAwAAAA0AAAACAAAAAAAAAAIAAAADAAAABAAAAAAAAAACAAAAAgAAAAMAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAgAAAAAAAAADAAAABgAAAAIAAAAAAAAAAgAAAAMAAAAPAAAAAAAAAAIAAAACAAAAAwAAAAsAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAIAAAACAAAAAAAAAAMAAAAHAAAAAgAAAAAAAAACAAAAAwAAABAAAAAAAAAAAgAAAAIAAAADAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAIAAAAAAAAAAwAAAAgAAAACAAAAAAAAAAIAAAADAAAAEQAAAAAAAAACAAAAAgAAAAMAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAACAAAAAgAAAAAAAAADAAAACQAAAAIAAAAAAAAAAgAAAAMAAAASAAAAAAAAAAIAAAACAAAAAwAAAA4AAAAAAAAAAAAAAAAAAAAAAAAACQAAAAIAAAACAAAAAAAAAAMAAAAFAAAAAgAAAAAAAAACAAAAAwAAABMAAAAAAAAAAgAAAAIAAAADAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAgAAAAAAAAACAAAAAQAAABMAAAACAAAAAgAAAAAAAAAFAAAACgAAAAAAAAACAAAAAgAAAAMAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABEAAAACAAAAAAAAAAIAAAABAAAADwAAAAIAAAACAAAAAAAAAAUAAAALAAAAAAAAAAIAAAACAAAAAwAAABEAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAIAAAAAAAAAAgAAAAEAAAAQAAAAAgAAAAIAAAAAAAAABQAAAAwAAAAAAAAAAgAAAAIAAAADAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAACAAAAAQAAABEAAAACAAAAAgAAAAAAAAAFAAAADQAAAAAAAAACAAAAAgAAAAMAAAATAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAACAAAAAAAAAAIAAAABAAAAEgAAAAIAAAACAAAAAAAAAAUAAAAOAAAAAAAAAAIAAAACAAAAAwAAAAIAAAABAAAAAAAAAAEAAAACAAAAAAAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAEAAAAAAAAAAgAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAAAAAAAAAAABQAAAAQAAAAAAAAAAQAAAAUAAAAEAAAAAAAAAAUAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAgAAAAAAAAABAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAAAAAAAAAAABQAAAAQAAAAAAAAAAQAAAAUAAAAEAAAAAAAAAAUAAAAFAAAAAAAAAAEAAAAAAAAAAAAAAMuhRbbsNlBBYqHW9OmHIkF9XBuqnS31QAK37uYhNMhAOSo3UUupm0DC+6pc6JxvQHV9eseEEEJAzURsCyqlFEB8BQ4NMJjnPyy3tBoS97o/xawXQznRjj89J2K2CZxhP6vX43RIIDQ/S8isgygEBz+LvFHQkmzaPjFFFO7wMq4+AADMLkTtjkIAAOgkJqxhQgAAU7B0MjRCAADwpBcVB0IAAACYP2HaQQAAAIn/Ja5BzczM4Eg6gUHNzMxMU7BTQTMzMzNfgCZBAAAAAEi3+UAAAAAAwGPNQDMzMzMzy6BAmpmZmZkxc0AzMzMzM/NFQDMzMzMzMxlAzczMzMzM7D+ygXSx2U6RQKimJOvQKnpA23hmONTHY0A/AGcxyudNQNb3K647mzZA+S56rrwWIUAm4kUQ+9UJQKre9hGzh/M/BLvoy9WG3T+LmqMf8VHGP2m3nYNV37A/gbFHcyeCmT+cBPWBckiDP61tZACjKW0/q2RbYVUYVj8uDypVyLNAP6jGS5cA5zBBwcqhBdCNGUEGEhQ/JVEDQT6WPnRbNO1AB/AWSJgT1kDfUWNCNLDAQNk+5C33OqlAchWL34QSk0DKvtDIrNV8QNF0G3kFzGVASSeWhBl6UED+/0mNGuk4QGjA/dm/1CJALPLPMql6DEDSHoDrwpP1P2jouzWST+A/egAAAAAAAABKAwAAAAAAAPoWAAAAAAAAyqAAAAAAAAB6ZQQAAAAAAErGHgAAAAAA+mvXAAAAAADK8+MFAAAAAHqqOykAAAAASqmhIAEAAAD6oGvkBwAAAMpm8T43AAAAes+ZuIIBAABKrDQMkwoAAPq1cFUFSgAAyvkUViUGAgAAAAAAAwAAAAYAAAACAAAABQAAAAEAAAAEAAAAAAAAAAAAAAAFAAAAAwAAAAEAAAAGAAAABAAAAAIAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAA/////wAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAP////8AAAAAAAAAAAEAAAABAAAAAAAAAAAAAAD/////AAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAA/////wUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAUAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAQAAAAAAAAAFAAAAAQAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAAAAAABAAEAAAEBAAAAAAABAAAAAQAAAAEAAQAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAHAAAABwAAAAEAAAACAAAABAAAAAMAAAAAAAAAAAAAAAcAAAADAAAAAQAAAAIAAAAFAAAABAAAAAAAAAAAAAAAYWxnb3MuYwBfcG9seWZpbGxJbnRlcm5hbABhZGphY2VudEZhY2VEaXJbdG1wRmlqay5mYWNlXVtmaWprLmZhY2VdID09IEtJAGZhY2VpamsuYwBfZmFjZUlqa1BlbnRUb0dlb0JvdW5kYXJ5AGFkamFjZW50RmFjZURpcltjZW50ZXJJSksuZmFjZV1bZmFjZTJdID09IEtJAF9mYWNlSWprVG9HZW9Cb3VuZGFyeQBwb2x5Z29uLT5uZXh0ID09IE5VTEwAbGlua2VkR2VvLmMAYWRkTmV3TGlua2VkUG9seWdvbgBuZXh0ICE9IE5VTEwAbG9vcCAhPSBOVUxMAGFkZE5ld0xpbmtlZExvb3AAcG9seWdvbi0+Zmlyc3QgPT0gTlVMTABhZGRMaW5rZWRMb29wAGNvb3JkICE9IE5VTEwAYWRkTGlua2VkQ29vcmQAbG9vcC0+Zmlyc3QgPT0gTlVMTABpbm5lckxvb3BzICE9IE5VTEwAbm9ybWFsaXplTXVsdGlQb2x5Z29uAGJib3hlcyAhPSBOVUxMAGNhbmRpZGF0ZXMgIT0gTlVMTABmaW5kUG9seWdvbkZvckhvbGUAY2FuZGlkYXRlQkJveGVzICE9IE5VTEwAcmV2RGlyICE9IElOVkFMSURfRElHSVQAbG9jYWxpai5jAGgzVG9Mb2NhbElqawBiYXNlQ2VsbCAhPSBvcmlnaW5CYXNlQ2VsbAAhKG9yaWdpbk9uUGVudCAmJiBpbmRleE9uUGVudCkAcGVudGFnb25Sb3RhdGlvbnMgPj0gMABkaXJlY3Rpb25Sb3RhdGlvbnMgPj0gMABiYXNlQ2VsbCA9PSBvcmlnaW5CYXNlQ2VsbABiYXNlQ2VsbCAhPSBJTlZBTElEX0JBU0VfQ0VMTABsb2NhbElqa1RvSDMAIV9pc0Jhc2VDZWxsUGVudGFnb24oYmFzZUNlbGwpAGJhc2VDZWxsUm90YXRpb25zID49IDAAd2l0aGluUGVudGFnb25Sb3RhdGlvbnMgPj0gMABncmFwaC0+YnVja2V0cyAhPSBOVUxMAHZlcnRleEdyYXBoLmMAaW5pdFZlcnRleEdyYXBoAG5vZGUgIT0gTlVMTABhZGRWZXJ0ZXhOb2Rl"
    var Ue = 24032
    function _e(J) {
      return J
    }
    function Xe(J) {
      var ae = /\b__Z[\w\d_]+/g
      return J.replace(ae, function (ke) {
        var Ve = ke
        return ke === Ve ? ke : Ve + " [" + ke + "]"
      })
    }
    function se() {
      var J = new Error()
      if (!J.stack) {
        try {
          throw new Error(0)
        } catch (ae) {
          J = ae
        }
        if (!J.stack) return "(no stack trace available)"
      }
      return J.stack.toString()
    }
    function be() {
      var J = se()
      return (
        e.extraStackTrace &&
          (J +=
            `
` + e.extraStackTrace()),
        Xe(J)
      )
    }
    function ze(J, ae, ke, Ve) {
      Le(
        "Assertion failed: " +
          B(J) +
          ", at: " +
          [ae ? B(ae) : "unknown filename", ke, Ve ? B(Ve) : "unknown function"]
      )
    }
    function at() {
      return N.length
    }
    function de(J, ae, ke) {
      G.set(G.subarray(ae, ae + ke), J)
    }
    function it(J) {
      return e.___errno_location && (V[e.___errno_location() >> 2] = J), J
    }
    function tt(J) {
      Le("OOM")
    }
    function ft(J) {
      try {
        var ae = new ArrayBuffer(J)
        return ae.byteLength != J
          ? void 0
          : (new Int8Array(ae).set(N), Er(ae), le(ae), 1)
      } catch {}
    }
    function De(J) {
      var ae = at(),
        ke = 16777216,
        Ve = 2147483648 - ke
      if (J > Ve) return !1
      for (var u = 16777216, Z = Math.max(ae, u); Z < J; )
        Z <= 536870912
          ? (Z = z(2 * Z, ke))
          : (Z = Math.min(z((3 * Z + 2147483648) / 4, ke), Ve))
      var gt = ft(Z)
      return !!gt
    }
    var ht =
      typeof atob == "function"
        ? atob
        : function (J) {
            var ae =
                "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
              ke = "",
              Ve,
              u,
              Z,
              gt,
              pt,
              lt,
              _t,
              ln = 0
            J = J.replace(/[^A-Za-z0-9\+\/\=]/g, "")
            do
              (gt = ae.indexOf(J.charAt(ln++))),
                (pt = ae.indexOf(J.charAt(ln++))),
                (lt = ae.indexOf(J.charAt(ln++))),
                (_t = ae.indexOf(J.charAt(ln++))),
                (Ve = (gt << 2) | (pt >> 4)),
                (u = ((pt & 15) << 4) | (lt >> 2)),
                (Z = ((lt & 3) << 6) | _t),
                (ke = ke + String.fromCharCode(Ve)),
                lt !== 64 && (ke = ke + String.fromCharCode(u)),
                _t !== 64 && (ke = ke + String.fromCharCode(Z))
            while (ln < J.length)
            return ke
          }
    function Ft(J) {
      try {
        for (
          var ae = ht(J), ke = new Uint8Array(ae.length), Ve = 0;
          Ve < ae.length;
          ++Ve
        )
          ke[Ve] = ae.charCodeAt(Ve)
        return ke
      } catch {
        throw new Error("Converting base64 string to bytes failed.")
      }
    }
    function an(J) {
      if (!!Q(J)) return Ft(J.slice($.length))
    }
    var vi = {
        Math,
        Int8Array,
        Int32Array,
        Uint8Array,
        Float32Array,
        Float64Array,
      },
      yn = {
        a: Le,
        b: d,
        c: p,
        d: ze,
        e: it,
        f: at,
        g: de,
        h: De,
        i: tt,
        j: _e,
        k: Xe,
        l: ft,
        m: se,
        n: be,
        o: Ue,
        p: Ae,
      },
      We = (function (J, ae, ke) {
        var Ve = new globalThis.Int8Array(ke),
          u = new globalThis.Int32Array(ke),
          Z = new globalThis.Float64Array(ke),
          gt = ae.p | 0,
          pt = J.Math.floor,
          lt = J.Math.abs,
          _t = J.Math.sqrt,
          ln = J.Math.pow,
          Nt = J.Math.cos,
          dt = J.Math.sin,
          tn = J.Math.tan,
          sn = J.Math.acos,
          _i = J.Math.asin,
          Js = J.Math.atan,
          bn = J.Math.atan2,
          Di = J.Math.ceil,
          un = J.Math.imul,
          Yo = J.Math.min,
          Wn = J.Math.clz32,
          Ct = ae.b,
          ce = ae.c,
          Yt = ae.d,
          uy = ae.e,
          cM = ae.f,
          AM = ae.g,
          uM = ae.h,
          fM = ae.i,
          ie = 24048
        function hM(l) {
          return (
            (Ve = new Int8Array(l)),
            (u = new Int32Array(l)),
            (Z = new Float64Array(l)),
            (ke = l),
            !0
          )
        }
        function dM(l) {
          l = l | 0
          var f = 0
          return (f = ie), (ie = (ie + l) | 0), (ie = (ie + 15) & -16), f | 0
        }
        function pM() {
          return ie | 0
        }
        function mM(l) {
          ;(l = l | 0), (ie = l)
        }
        function gM(l, f) {
          ;(l = l | 0), (ie = l)
        }
        function yM(l) {
          return (l = l | 0), ((un((l * 3) | 0, (l + 1) | 0) | 0) + 1) | 0
        }
        function fy(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0
          !(ep(l, f, h, g, 0) | 0) ||
            ((w = ((un((h * 3) | 0, (h + 1) | 0) | 0) + 1) | 0),
            Cr(g | 0, 0, (w << 3) | 0) | 0,
            (v = Tr(w, 4) | 0),
            v && (Gr(l, f, h, g, v, w, 0), Lt(v)))
        }
        function vM(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0
          if (!!(ep(l, f, h, g, v) | 0)) {
            if (
              ((w = ((un((h * 3) | 0, (h + 1) | 0) | 0) + 1) | 0),
              Cr(g | 0, 0, (w << 3) | 0) | 0,
              v | 0)
            ) {
              Cr(v | 0, 0, (w << 2) | 0) | 0, Gr(l, f, h, g, v, w, 0)
              return
            }
            ;(v = Tr(w, 4) | 0), v && (Gr(l, f, h, g, v, w, 0), Lt(v))
          }
        }
        function ep(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0
          if (
            ((me = ie),
            (ie = (ie + 16) | 0),
            (fe = me),
            (w = g),
            (u[w >> 2] = l),
            (u[(w + 4) >> 2] = f),
            (w = (v | 0) != 0),
            w && (u[v >> 2] = 0),
            jn(l, f) | 0)
          )
            return (fe = 1), (ie = me), fe | 0
          u[fe >> 2] = 0
          e: do
            if ((h | 0) >= 1)
              if (w)
                for (U = 0, H = 1, re = 1, b = 0, w = l; ; ) {
                  if (!(b | U)) {
                    if (
                      ((w = Un(w, f, 4, fe) | 0),
                      (f = ce() | 0),
                      ((w | 0) == 0) & ((f | 0) == 0))
                    ) {
                      w = 2
                      break e
                    }
                    if (jn(w, f) | 0) {
                      w = 1
                      break e
                    }
                  }
                  if (
                    ((w = Un(w, f, u[(16 + (U << 2)) >> 2] | 0, fe) | 0),
                    (f = ce() | 0),
                    ((w | 0) == 0) & ((f | 0) == 0))
                  ) {
                    w = 2
                    break e
                  }
                  if (
                    ((l = (g + (re << 3)) | 0),
                    (u[l >> 2] = w),
                    (u[(l + 4) >> 2] = f),
                    (u[(v + (re << 2)) >> 2] = H),
                    (b = (b + 1) | 0),
                    (l = (b | 0) == (H | 0)),
                    (E = (U + 1) | 0),
                    (I = (E | 0) == 6),
                    jn(w, f) | 0)
                  ) {
                    w = 1
                    break e
                  }
                  if (((H = (H + (I & l & 1)) | 0), (H | 0) > (h | 0))) {
                    w = 0
                    break
                  } else
                    (U = l ? (I ? 0 : E) : U),
                      (re = (re + 1) | 0),
                      (b = l ? 0 : b)
                }
              else
                for (U = 0, H = 1, re = 1, b = 0, w = l; ; ) {
                  if (!(b | U)) {
                    if (
                      ((w = Un(w, f, 4, fe) | 0),
                      (f = ce() | 0),
                      ((w | 0) == 0) & ((f | 0) == 0))
                    ) {
                      w = 2
                      break e
                    }
                    if (jn(w, f) | 0) {
                      w = 1
                      break e
                    }
                  }
                  if (
                    ((w = Un(w, f, u[(16 + (U << 2)) >> 2] | 0, fe) | 0),
                    (f = ce() | 0),
                    ((w | 0) == 0) & ((f | 0) == 0))
                  ) {
                    w = 2
                    break e
                  }
                  if (
                    ((l = (g + (re << 3)) | 0),
                    (u[l >> 2] = w),
                    (u[(l + 4) >> 2] = f),
                    (b = (b + 1) | 0),
                    (l = (b | 0) == (H | 0)),
                    (E = (U + 1) | 0),
                    (I = (E | 0) == 6),
                    jn(w, f) | 0)
                  ) {
                    w = 1
                    break e
                  }
                  if (((H = (H + (I & l & 1)) | 0), (H | 0) > (h | 0))) {
                    w = 0
                    break
                  } else
                    (U = l ? (I ? 0 : E) : U),
                      (re = (re + 1) | 0),
                      (b = l ? 0 : b)
                }
            else w = 0
          while (0)
          return (fe = w), (ie = me), fe | 0
        }
        function Gr(l, f, h, g, v, w, b) {
          ;(l = l | 0),
            (f = f | 0),
            (h = h | 0),
            (g = g | 0),
            (v = v | 0),
            (w = w | 0),
            (b = b | 0)
          var E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0
          if (
            ((re = ie),
            (ie = (ie + 16) | 0),
            (H = re),
            ((l | 0) == 0) & ((f | 0) == 0))
          ) {
            ie = re
            return
          }
          if (
            ((E =
              to(l | 0, f | 0, w | 0, ((((w | 0) < 0) << 31) >> 31) | 0) | 0),
            ce() | 0,
            (I = (g + (E << 3)) | 0),
            (fe = I),
            (me = u[fe >> 2] | 0),
            (fe = u[(fe + 4) >> 2] | 0),
            (U = ((me | 0) == (l | 0)) & ((fe | 0) == (f | 0))),
            !((((me | 0) == 0) & ((fe | 0) == 0)) | U))
          )
            do
              (E = ((E + 1) | 0) % (w | 0) | 0),
                (I = (g + (E << 3)) | 0),
                (me = I),
                (fe = u[me >> 2] | 0),
                (me = u[(me + 4) >> 2] | 0),
                (U = ((fe | 0) == (l | 0)) & ((me | 0) == (f | 0)))
            while (!((((fe | 0) == 0) & ((me | 0) == 0)) | U))
          if (((E = (v + (E << 2)) | 0), U && (u[E >> 2] | 0) <= (b | 0))) {
            ie = re
            return
          }
          if (
            ((me = I),
            (u[me >> 2] = l),
            (u[(me + 4) >> 2] = f),
            (u[E >> 2] = b),
            (b | 0) >= (h | 0))
          ) {
            ie = re
            return
          }
          ;(me = (b + 1) | 0),
            (u[H >> 2] = 0),
            (fe = Un(l, f, 2, H) | 0),
            Gr(fe, ce() | 0, h, g, v, w, me),
            (u[H >> 2] = 0),
            (fe = Un(l, f, 3, H) | 0),
            Gr(fe, ce() | 0, h, g, v, w, me),
            (u[H >> 2] = 0),
            (fe = Un(l, f, 1, H) | 0),
            Gr(fe, ce() | 0, h, g, v, w, me),
            (u[H >> 2] = 0),
            (fe = Un(l, f, 5, H) | 0),
            Gr(fe, ce() | 0, h, g, v, w, me),
            (u[H >> 2] = 0),
            (fe = Un(l, f, 4, H) | 0),
            Gr(fe, ce() | 0, h, g, v, w, me),
            (u[H >> 2] = 0),
            (fe = Un(l, f, 6, H) | 0),
            Gr(fe, ce() | 0, h, g, v, w, me),
            (ie = re)
        }
        function Un(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0
          if ((u[g >> 2] | 0) > 0) {
            v = 0
            do (h = Ko(h) | 0), (v = (v + 1) | 0)
            while ((v | 0) < (u[g >> 2] | 0))
          }
          ;(E = $e(l | 0, f | 0, 45) | 0),
            ce() | 0,
            (I = E & 127),
            (w = Bi(l, f) | 0),
            (v = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (v = v & 15)
          e: do
            if (!v) b = 6
            else
              for (;;) {
                if (
                  ((re = (((15 - v) | 0) * 3) | 0),
                  (fe = $e(l | 0, f | 0, re | 0) | 0),
                  ce() | 0,
                  (fe = fe & 7),
                  (me = (ur(v) | 0) == 0),
                  (v = (v + -1) | 0),
                  (H = rt(7, 0, re | 0) | 0),
                  (f = f & ~(ce() | 0)),
                  (re =
                    rt(
                      u[((me ? 464 : 48) + ((fe * 28) | 0) + (h << 2)) >> 2] |
                        0,
                      0,
                      re | 0
                    ) | 0),
                  (U = ce() | 0),
                  (h =
                    u[((me ? 672 : 256) + ((fe * 28) | 0) + (h << 2)) >> 2] |
                    0),
                  (l = re | (l & ~H)),
                  (f = U | f),
                  !h)
                ) {
                  h = 0
                  break e
                }
                if (!v) {
                  b = 6
                  break
                }
              }
          while (0)
          ;(b | 0) == 6 &&
            ((me = u[(880 + ((I * 28) | 0) + (h << 2)) >> 2] | 0),
            (fe = rt(me | 0, 0, 45) | 0),
            (l = fe | l),
            (f = ce() | 0 | (f & -1040385)),
            (h = u[(4304 + ((I * 28) | 0) + (h << 2)) >> 2] | 0),
            ((me & 127) | 0) == 127 &&
              ((me = rt(u[(880 + ((I * 28) | 0) + 20) >> 2] | 0, 0, 45) | 0),
              (f = ce() | 0 | (f & -1040385)),
              (h = u[(4304 + ((I * 28) | 0) + 20) >> 2] | 0),
              (l = eo(me | l, f) | 0),
              (f = ce() | 0),
              (u[g >> 2] = (u[g >> 2] | 0) + 1))),
            (b = $e(l | 0, f | 0, 45) | 0),
            ce() | 0,
            (b = b & 127)
          e: do
            if (vn(b) | 0) {
              t: do
                if ((Bi(l, f) | 0) == 1) {
                  if ((I | 0) != (b | 0))
                    if (py(b, u[(7728 + ((I * 28) | 0)) >> 2] | 0) | 0) {
                      ;(l = Ap(l, f) | 0), (w = 1), (f = ce() | 0)
                      break
                    } else {
                      ;(l = eo(l, f) | 0), (w = 1), (f = ce() | 0)
                      break
                    }
                  switch (w | 0) {
                    case 5: {
                      ;(l = Ap(l, f) | 0),
                        (f = ce() | 0),
                        (u[g >> 2] = (u[g >> 2] | 0) + 5),
                        (w = 0)
                      break t
                    }
                    case 3: {
                      ;(l = eo(l, f) | 0),
                        (f = ce() | 0),
                        (u[g >> 2] = (u[g >> 2] | 0) + 1),
                        (w = 0)
                      break t
                    }
                    default:
                      return (fe = 0), (me = 0), Ct(fe | 0), me | 0
                  }
                } else w = 0
              while (0)
              if ((h | 0) > 0) {
                v = 0
                do (l = cp(l, f) | 0), (f = ce() | 0), (v = (v + 1) | 0)
                while ((v | 0) != (h | 0))
              }
              if ((I | 0) != (b | 0)) {
                if (!(tp(b) | 0)) {
                  if (((w | 0) != 0) | ((Bi(l, f) | 0) != 5)) break
                  u[g >> 2] = (u[g >> 2] | 0) + 1
                  break
                }
                switch (E & 127) {
                  case 8:
                  case 118:
                    break e
                }
                ;(Bi(l, f) | 0) != 3 && (u[g >> 2] = (u[g >> 2] | 0) + 1)
              }
            } else if ((h | 0) > 0) {
              v = 0
              do (l = eo(l, f) | 0), (f = ce() | 0), (v = (v + 1) | 0)
              while ((v | 0) != (h | 0))
            }
          while (0)
          return (
            (u[g >> 2] = (((u[g >> 2] | 0) + h) | 0) % 6 | 0),
            (fe = f),
            (me = l),
            Ct(fe | 0),
            me | 0
          )
        }
        function _M(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0
          if (((re = ie), (ie = (ie + 16) | 0), (H = re), !h))
            return (
              (H = g),
              (u[H >> 2] = l),
              (u[(H + 4) >> 2] = f),
              (H = 0),
              (ie = re),
              H | 0
            )
          u[H >> 2] = 0
          e: do
            if (jn(l, f) | 0) l = 1
            else {
              if (((w = (h | 0) > 0), w)) {
                ;(v = 0), (U = l)
                do {
                  if (
                    ((U = Un(U, f, 4, H) | 0),
                    (f = ce() | 0),
                    ((U | 0) == 0) & ((f | 0) == 0))
                  ) {
                    l = 2
                    break e
                  }
                  if (((v = (v + 1) | 0), jn(U, f) | 0)) {
                    l = 1
                    break e
                  }
                } while ((v | 0) < (h | 0))
                if (
                  ((I = g),
                  (u[I >> 2] = U),
                  (u[(I + 4) >> 2] = f),
                  (I = (h + -1) | 0),
                  w)
                ) {
                  ;(w = 0), (b = 1), (v = U), (l = f)
                  do {
                    if (
                      ((v = Un(v, l, 2, H) | 0),
                      (l = ce() | 0),
                      ((v | 0) == 0) & ((l | 0) == 0))
                    ) {
                      l = 2
                      break e
                    }
                    if (
                      ((E = (g + (b << 3)) | 0),
                      (u[E >> 2] = v),
                      (u[(E + 4) >> 2] = l),
                      (b = (b + 1) | 0),
                      jn(v, l) | 0)
                    ) {
                      l = 1
                      break e
                    }
                    w = (w + 1) | 0
                  } while ((w | 0) < (h | 0))
                  ;(E = 0), (w = b)
                  do {
                    if (
                      ((v = Un(v, l, 3, H) | 0),
                      (l = ce() | 0),
                      ((v | 0) == 0) & ((l | 0) == 0))
                    ) {
                      l = 2
                      break e
                    }
                    if (
                      ((b = (g + (w << 3)) | 0),
                      (u[b >> 2] = v),
                      (u[(b + 4) >> 2] = l),
                      (w = (w + 1) | 0),
                      jn(v, l) | 0)
                    ) {
                      l = 1
                      break e
                    }
                    E = (E + 1) | 0
                  } while ((E | 0) < (h | 0))
                  b = 0
                  do {
                    if (
                      ((v = Un(v, l, 1, H) | 0),
                      (l = ce() | 0),
                      ((v | 0) == 0) & ((l | 0) == 0))
                    ) {
                      l = 2
                      break e
                    }
                    if (
                      ((E = (g + (w << 3)) | 0),
                      (u[E >> 2] = v),
                      (u[(E + 4) >> 2] = l),
                      (w = (w + 1) | 0),
                      jn(v, l) | 0)
                    ) {
                      l = 1
                      break e
                    }
                    b = (b + 1) | 0
                  } while ((b | 0) < (h | 0))
                  b = 0
                  do {
                    if (
                      ((v = Un(v, l, 5, H) | 0),
                      (l = ce() | 0),
                      ((v | 0) == 0) & ((l | 0) == 0))
                    ) {
                      l = 2
                      break e
                    }
                    if (
                      ((E = (g + (w << 3)) | 0),
                      (u[E >> 2] = v),
                      (u[(E + 4) >> 2] = l),
                      (w = (w + 1) | 0),
                      jn(v, l) | 0)
                    ) {
                      l = 1
                      break e
                    }
                    b = (b + 1) | 0
                  } while ((b | 0) < (h | 0))
                  b = 0
                  do {
                    if (
                      ((v = Un(v, l, 4, H) | 0),
                      (l = ce() | 0),
                      ((v | 0) == 0) & ((l | 0) == 0))
                    ) {
                      l = 2
                      break e
                    }
                    if (
                      ((E = (g + (w << 3)) | 0),
                      (u[E >> 2] = v),
                      (u[(E + 4) >> 2] = l),
                      (w = (w + 1) | 0),
                      jn(v, l) | 0)
                    ) {
                      l = 1
                      break e
                    }
                    b = (b + 1) | 0
                  } while ((b | 0) < (h | 0))
                  for (b = 0; ; ) {
                    if (
                      ((v = Un(v, l, 6, H) | 0),
                      (l = ce() | 0),
                      ((v | 0) == 0) & ((l | 0) == 0))
                    ) {
                      l = 2
                      break e
                    }
                    if ((b | 0) != (I | 0))
                      if (
                        ((E = (g + (w << 3)) | 0),
                        (u[E >> 2] = v),
                        (u[(E + 4) >> 2] = l),
                        !(jn(v, l) | 0))
                      )
                        w = (w + 1) | 0
                      else {
                        l = 1
                        break e
                      }
                    if (((b = (b + 1) | 0), (b | 0) >= (h | 0))) {
                      ;(b = U), (w = f)
                      break
                    }
                  }
                } else (b = U), (v = U), (w = f), (l = f)
              } else
                (b = g),
                  (u[b >> 2] = l),
                  (u[(b + 4) >> 2] = f),
                  (b = l),
                  (v = l),
                  (w = f),
                  (l = f)
              l = (((b | 0) != (v | 0)) | ((w | 0) != (l | 0))) & 1
            }
          while (0)
          return (H = l), (ie = re), H | 0
        }
        function xM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          if (
            ((w = ie),
            (ie = (ie + 48) | 0),
            (v = (w + 8) | 0),
            (g = w),
            (E = l),
            (b = u[(E + 4) >> 2] | 0),
            (h = g),
            (u[h >> 2] = u[E >> 2]),
            (u[(h + 4) >> 2] = b),
            hp(g, v),
            (v = rp(v, f) | 0),
            (f = u[g >> 2] | 0),
            (g = u[(l + 8) >> 2] | 0),
            (g | 0) <= 0)
          )
            return (
              (E = f),
              (b = (v | 0) < (E | 0)),
              (E = b ? E : v),
              (E = (E + 12) | 0),
              (ie = w),
              E | 0
            )
          ;(h = u[(l + 12) >> 2] | 0), (l = 0)
          do (f = ((u[(h + (l << 3)) >> 2] | 0) + f) | 0), (l = (l + 1) | 0)
          while ((l | 0) < (g | 0))
          return (
            (E = (v | 0) < (f | 0)),
            (E = E ? f : v),
            (E = (E + 12) | 0),
            (ie = w),
            E | 0
          )
        }
        function bM(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0
          if (
            ((E = ie),
            (ie = (ie + 48) | 0),
            (g = (E + 8) | 0),
            (v = E),
            !(wM(l, f, h) | 0))
          ) {
            ie = E
            return
          }
          if (
            ((I = l),
            (w = u[(I + 4) >> 2] | 0),
            (b = v),
            (u[b >> 2] = u[I >> 2]),
            (u[(b + 4) >> 2] = w),
            hp(v, g),
            (b = rp(g, f) | 0),
            (f = u[v >> 2] | 0),
            (w = u[(l + 8) >> 2] | 0),
            (w | 0) > 0)
          ) {
            ;(v = u[(l + 12) >> 2] | 0), (g = 0)
            do (f = ((u[(v + (g << 3)) >> 2] | 0) + f) | 0), (g = (g + 1) | 0)
            while ((g | 0) != (w | 0))
          }
          if (((f = (b | 0) < (f | 0) ? f : b), (f | 0) <= -12)) {
            ie = E
            return
          }
          ;(I = (f + 11) | 0),
            Cr(h | 0, 0, ((((I | 0) > 0 ? I : 0) << 3) + 8) | 0) | 0,
            (ie = E)
        }
        function wM(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0,
            He = 0,
            he = 0,
            ot = 0,
            ct = 0,
            Je = 0,
            nt = 0,
            Rt = 0,
            Zt = 0,
            Qt = 0,
            on = 0,
            Wt = 0,
            fn = 0,
            hn = 0,
            Mt = 0
          if (
            ((Mt = ie),
            (ie = (ie + 112) | 0),
            (on = (Mt + 80) | 0),
            (I = (Mt + 72) | 0),
            (Wt = Mt),
            (fn = (Mt + 56) | 0),
            (U = (l + 8) | 0),
            (hn = Vr(((u[U >> 2] << 5) + 32) | 0) | 0),
            hn || Yt(22848, 22448, 800, 22456),
            TS(l, hn),
            (w = l),
            (g = u[(w + 4) >> 2] | 0),
            (E = I),
            (u[E >> 2] = u[w >> 2]),
            (u[(E + 4) >> 2] = g),
            hp(I, on),
            (E = rp(on, f) | 0),
            (g = u[I >> 2] | 0),
            (w = u[U >> 2] | 0),
            (w | 0) > 0)
          ) {
            ;(b = u[(l + 12) >> 2] | 0), (v = 0)
            do (g = ((u[(b + (v << 3)) >> 2] | 0) + g) | 0), (v = (v + 1) | 0)
            while ((v | 0) != (w | 0))
          }
          if (
            ((E = (E | 0) < (g | 0) ? g : E),
            (Qt = (E + 12) | 0),
            (v = Tr(Qt, 8) | 0),
            (H = Tr(Qt, 8) | 0),
            (u[on >> 2] = 0),
            (Rt = l),
            (Zt = u[(Rt + 4) >> 2] | 0),
            (g = I),
            (u[g >> 2] = u[Rt >> 2]),
            (u[(g + 4) >> 2] = Zt),
            (g = hy(I, Qt, f, on, v, H) | 0),
            g | 0)
          )
            return Lt(v), Lt(H), Lt(hn), (hn = g), (ie = Mt), hn | 0
          e: do
            if ((u[U >> 2] | 0) > 0) {
              for (
                w = (l + 12) | 0, g = 0;
                (b = hy(((u[w >> 2] | 0) + (g << 3)) | 0, Qt, f, on, v, H) | 0),
                  (g = (g + 1) | 0),
                  !(b | 0);

              )
                if ((g | 0) >= (u[U >> 2] | 0)) break e
              return Lt(v), Lt(H), Lt(hn), (hn = b), (ie = Mt), hn | 0
            }
          while (0)
          ;(E | 0) > -12 && Cr(H | 0, 0, (((Qt | 0) > 1 ? Qt : 1) << 3) | 0) | 0
          e: do
            if ((u[on >> 2] | 0) > 0) {
              ;(Zt = (((Qt | 0) < 0) << 31) >> 31),
                (he = v),
                (ot = H),
                (ct = v),
                (Je = v),
                (nt = H),
                (Rt = v),
                (g = v),
                (Qe = v),
                (st = H),
                (we = H),
                (He = H),
                (v = H)
              t: for (;;) {
                for (Ie = u[on >> 2] | 0, me = 0, Pe = 0, w = 0; ; ) {
                  ;(b = Wt), (E = (b + 56) | 0)
                  do (u[b >> 2] = 0), (b = (b + 4) | 0)
                  while ((b | 0) < (E | 0))
                  if (
                    ((f = (he + (me << 3)) | 0),
                    (I = u[f >> 2] | 0),
                    (f = u[(f + 4) >> 2] | 0),
                    ep(I, f, 1, Wt, 0) | 0)
                  ) {
                    ;(b = Wt), (E = (b + 56) | 0)
                    do (u[b >> 2] = 0), (b = (b + 4) | 0)
                    while ((b | 0) < (E | 0))
                    ;(b = Tr(7, 4) | 0),
                      b | 0 && (Gr(I, f, 1, Wt, b, 7, 0), Lt(b))
                  }
                  fe = 0
                  do {
                    ;(re = (Wt + (fe << 3)) | 0),
                      (H = u[re >> 2] | 0),
                      (re = u[(re + 4) >> 2] | 0)
                    n: do
                      if (!(((H | 0) == 0) & ((re | 0) == 0))) {
                        if (
                          ((I = to(H | 0, re | 0, Qt | 0, Zt | 0) | 0),
                          ce() | 0,
                          (b = (h + (I << 3)) | 0),
                          (E = b),
                          (f = u[E >> 2] | 0),
                          (E = u[(E + 4) >> 2] | 0),
                          !(((f | 0) == 0) & ((E | 0) == 0)))
                        )
                          for (U = 0; ; ) {
                            if ((U | 0) > (Qt | 0)) break t
                            if (((f | 0) == (H | 0)) & ((E | 0) == (re | 0)))
                              break n
                            if (
                              ((I = ((I + 1) | 0) % (Qt | 0) | 0),
                              (b = (h + (I << 3)) | 0),
                              (E = b),
                              (f = u[E >> 2] | 0),
                              (E = u[(E + 4) >> 2] | 0),
                              ((f | 0) == 0) & ((E | 0) == 0))
                            )
                              break
                            U = (U + 1) | 0
                          }
                        ;((H | 0) == 0) & ((re | 0) == 0) ||
                          (ea(H, re, fn),
                          CS(l, hn, fn) | 0 &&
                            ((U = b),
                            (u[U >> 2] = H),
                            (u[(U + 4) >> 2] = re),
                            (U = (ot + (w << 3)) | 0),
                            (u[U >> 2] = H),
                            (u[(U + 4) >> 2] = re),
                            (w = (w + 1) | 0)))
                      }
                    while (0)
                    fe = (fe + 1) | 0
                  } while (fe >>> 0 < 7)
                  if (((Pe = (Pe + 1) | 0), (Pe | 0) >= (Ie | 0))) break
                  me = (me + 1) | 0
                }
                if (
                  ((Ie | 0) > 0 && Cr(ct | 0, 0, (Ie << 3) | 0) | 0,
                  (u[on >> 2] = w),
                  (w | 0) > 0)
                )
                  (H = v),
                    (re = He),
                    (fe = Rt),
                    (me = we),
                    (Pe = st),
                    (Ie = ot),
                    (v = Qe),
                    (He = g),
                    (we = Je),
                    (st = ct),
                    (Qe = H),
                    (g = re),
                    (Rt = nt),
                    (nt = fe),
                    (Je = me),
                    (ct = Pe),
                    (ot = he),
                    (he = Ie)
                else break e
              }
              return Lt(Je), Lt(nt), Lt(hn), (hn = -1), (ie = Mt), hn | 0
            } else g = H
          while (0)
          return Lt(hn), Lt(v), Lt(g), (hn = 0), (ie = Mt), hn | 0
        }
        function hy(l, f, h, g, v, w) {
          ;(l = l | 0),
            (f = f | 0),
            (h = h | 0),
            (g = g | 0),
            (v = v | 0),
            (w = w | 0)
          var b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0,
            He = 0,
            he = 0,
            ot = 0,
            ct = 0,
            Je = 0,
            nt = 0,
            Rt = 0,
            Zt = 0,
            Qt = 0,
            on = 0
          if (
            ((Zt = ie),
            (ie = (ie + 48) | 0),
            (ct = (Zt + 32) | 0),
            (Je = (Zt + 16) | 0),
            (nt = Zt),
            (b = u[l >> 2] | 0),
            (b | 0) <= 0)
          )
            return (Rt = 0), (ie = Zt), Rt | 0
          ;(st = (l + 4) | 0),
            (we = (ct + 8) | 0),
            (He = (Je + 8) | 0),
            (he = (nt + 8) | 0),
            (ot = (((f | 0) < 0) << 31) >> 31),
            (Qe = 0)
          e: for (;;) {
            ;(E = u[st >> 2] | 0),
              (Pe = (E + (Qe << 4)) | 0),
              (u[ct >> 2] = u[Pe >> 2]),
              (u[(ct + 4) >> 2] = u[(Pe + 4) >> 2]),
              (u[(ct + 8) >> 2] = u[(Pe + 8) >> 2]),
              (u[(ct + 12) >> 2] = u[(Pe + 12) >> 2]),
              (Qe | 0) == ((b + -1) | 0)
                ? ((u[Je >> 2] = u[E >> 2]),
                  (u[(Je + 4) >> 2] = u[(E + 4) >> 2]),
                  (u[(Je + 8) >> 2] = u[(E + 8) >> 2]),
                  (u[(Je + 12) >> 2] = u[(E + 12) >> 2]))
                : ((Pe = (E + ((Qe + 1) << 4)) | 0),
                  (u[Je >> 2] = u[Pe >> 2]),
                  (u[(Je + 4) >> 2] = u[(Pe + 4) >> 2]),
                  (u[(Je + 8) >> 2] = u[(Pe + 8) >> 2]),
                  (u[(Je + 12) >> 2] = u[(Pe + 12) >> 2])),
              (Pe = LM(ct, Je, h) | 0)
            t: do
              if ((Pe | 0) > 0) {
                ;(Ie = +(Pe | 0)), (me = 0)
                n: for (;;) {
                  ;(on = +((Pe - me) | 0)),
                    (Qt = +(me | 0)),
                    (Z[nt >> 3] =
                      (+Z[ct >> 3] * on) / Ie + (+Z[Je >> 3] * Qt) / Ie),
                    (Z[he >> 3] =
                      (+Z[we >> 3] * on) / Ie + (+Z[He >> 3] * Qt) / Ie),
                    (re = Ly(nt, h) | 0),
                    (fe = ce() | 0),
                    (E = to(re | 0, fe | 0, f | 0, ot | 0) | 0),
                    ce() | 0,
                    (b = (w + (E << 3)) | 0),
                    (I = b),
                    (U = u[I >> 2] | 0),
                    (I = u[(I + 4) >> 2] | 0)
                  i: do
                    if (((U | 0) == 0) & ((I | 0) == 0)) Rt = 14
                    else
                      for (H = 0; ; ) {
                        if ((H | 0) > (f | 0)) {
                          b = 1
                          break i
                        }
                        if (((U | 0) == (re | 0)) & ((I | 0) == (fe | 0))) {
                          b = 7
                          break i
                        }
                        if (
                          ((E = ((E + 1) | 0) % (f | 0) | 0),
                          (b = (w + (E << 3)) | 0),
                          (I = b),
                          (U = u[I >> 2] | 0),
                          (I = u[(I + 4) >> 2] | 0),
                          ((U | 0) == 0) & ((I | 0) == 0))
                        ) {
                          Rt = 14
                          break
                        } else H = (H + 1) | 0
                      }
                  while (0)
                  switch (
                    ((Rt | 0) == 14 &&
                      ((Rt = 0),
                      ((re | 0) == 0) & ((fe | 0) == 0)
                        ? (b = 7)
                        : ((u[b >> 2] = re),
                          (u[(b + 4) >> 2] = fe),
                          (b = u[g >> 2] | 0),
                          (H = (v + (b << 3)) | 0),
                          (u[H >> 2] = re),
                          (u[(H + 4) >> 2] = fe),
                          (u[g >> 2] = b + 1),
                          (b = 0))),
                    b & 7)
                  ) {
                    case 7:
                    case 0:
                      break
                    default:
                      break n
                  }
                  if (((me = (me + 1) | 0), (Pe | 0) <= (me | 0))) {
                    Rt = 8
                    break t
                  }
                }
                if (b | 0) {
                  ;(b = -1), (Rt = 20)
                  break e
                }
              } else Rt = 8
            while (0)
            if (
              ((Rt | 0) == 8 && (Rt = 0),
              (Qe = (Qe + 1) | 0),
              (b = u[l >> 2] | 0),
              (Qe | 0) >= (b | 0))
            ) {
              ;(b = 0), (Rt = 20)
              break
            }
          }
          return (Rt | 0) == 20 ? ((ie = Zt), b | 0) : 0
        }
        function MM(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0
          if (((U = ie), (ie = (ie + 176) | 0), (I = U), (f | 0) < 1)) {
            Uy(h, 0, 0), (ie = U)
            return
          }
          ;(b = l),
            (b = $e(u[b >> 2] | 0, u[(b + 4) >> 2] | 0, 52) | 0),
            ce() | 0,
            Uy(h, (f | 0) > 6 ? f : 6, b & 15),
            (b = 0)
          do {
            if (
              ((g = (l + (b << 3)) | 0),
              ta(u[g >> 2] | 0, u[(g + 4) >> 2] | 0, I),
              (g = u[I >> 2] | 0),
              (g | 0) > 0)
            ) {
              E = 0
              do
                (w = (I + 8 + (E << 4)) | 0),
                  (E = (E + 1) | 0),
                  (g = (I + 8 + (((E | 0) % (g | 0) | 0) << 4)) | 0),
                  (v = zS(h, g, w) | 0),
                  v ? Gy(h, v) | 0 : US(h, w, g) | 0,
                  (g = u[I >> 2] | 0)
              while ((E | 0) < (g | 0))
            }
            b = (b + 1) | 0
          } while ((b | 0) != (f | 0))
          ie = U
        }
        function SM(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0
          if (
            ((w = ie),
            (ie = (ie + 32) | 0),
            (g = w),
            (v = (w + 16) | 0),
            MM(l, f, v),
            (u[h >> 2] = 0),
            (u[(h + 4) >> 2] = 0),
            (u[(h + 8) >> 2] = 0),
            (l = Hy(v) | 0),
            !l)
          ) {
            By(h) | 0, zy(v), (ie = w)
            return
          }
          do {
            f = vS(h) | 0
            do
              _S(f, l) | 0,
                (b = (l + 16) | 0),
                (u[g >> 2] = u[b >> 2]),
                (u[(g + 4) >> 2] = u[(b + 4) >> 2]),
                (u[(g + 8) >> 2] = u[(b + 8) >> 2]),
                (u[(g + 12) >> 2] = u[(b + 12) >> 2]),
                Gy(v, l) | 0,
                (l = HS(v, g) | 0)
            while ((l | 0) != 0)
            l = Hy(v) | 0
          } while ((l | 0) != 0)
          By(h) | 0, zy(v), (ie = w)
        }
        function vn(l) {
          return (l = l | 0), u[(7728 + ((l * 28) | 0) + 16) >> 2] | 0
        }
        function tp(l) {
          return (l = l | 0), ((l | 0) == 4) | ((l | 0) == 117) | 0
        }
        function dy(l) {
          return (
            (l = l | 0),
            u[
              (11152 +
                (((u[l >> 2] | 0) * 216) | 0) +
                (((u[(l + 4) >> 2] | 0) * 72) | 0) +
                (((u[(l + 8) >> 2] | 0) * 24) | 0) +
                (u[(l + 12) >> 2] << 3)) >>
                2
            ] | 0
          )
        }
        function EM(l) {
          return (
            (l = l | 0),
            u[
              (11152 +
                (((u[l >> 2] | 0) * 216) | 0) +
                (((u[(l + 4) >> 2] | 0) * 72) | 0) +
                (((u[(l + 8) >> 2] | 0) * 24) | 0) +
                (u[(l + 12) >> 2] << 3) +
                4) >>
                2
            ] | 0
          )
        }
        function TM(l, f) {
          ;(l = l | 0),
            (f = f | 0),
            (l = (7728 + ((l * 28) | 0)) | 0),
            (u[f >> 2] = u[l >> 2]),
            (u[(f + 4) >> 2] = u[(l + 4) >> 2]),
            (u[(f + 8) >> 2] = u[(l + 8) >> 2]),
            (u[(f + 12) >> 2] = u[(l + 12) >> 2])
        }
        function CM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0
          if (f >>> 0 > 20) return (f = -1), f | 0
          do
            if ((u[(11152 + ((f * 216) | 0)) >> 2] | 0) != (l | 0))
              if ((u[(11152 + ((f * 216) | 0) + 8) >> 2] | 0) != (l | 0))
                if ((u[(11152 + ((f * 216) | 0) + 16) >> 2] | 0) != (l | 0))
                  if ((u[(11152 + ((f * 216) | 0) + 24) >> 2] | 0) != (l | 0))
                    if ((u[(11152 + ((f * 216) | 0) + 32) >> 2] | 0) != (l | 0))
                      if (
                        (u[(11152 + ((f * 216) | 0) + 40) >> 2] | 0) !=
                        (l | 0)
                      )
                        if (
                          (u[(11152 + ((f * 216) | 0) + 48) >> 2] | 0) !=
                          (l | 0)
                        )
                          if (
                            (u[(11152 + ((f * 216) | 0) + 56) >> 2] | 0) !=
                            (l | 0)
                          )
                            if (
                              (u[(11152 + ((f * 216) | 0) + 64) >> 2] | 0) !=
                              (l | 0)
                            )
                              if (
                                (u[(11152 + ((f * 216) | 0) + 72) >> 2] | 0) !=
                                (l | 0)
                              )
                                if (
                                  (u[(11152 + ((f * 216) | 0) + 80) >> 2] |
                                    0) !=
                                  (l | 0)
                                )
                                  if (
                                    (u[(11152 + ((f * 216) | 0) + 88) >> 2] |
                                      0) !=
                                    (l | 0)
                                  )
                                    if (
                                      (u[(11152 + ((f * 216) | 0) + 96) >> 2] |
                                        0) !=
                                      (l | 0)
                                    )
                                      if (
                                        (u[
                                          (11152 + ((f * 216) | 0) + 104) >> 2
                                        ] |
                                          0) !=
                                        (l | 0)
                                      )
                                        if (
                                          (u[
                                            (11152 + ((f * 216) | 0) + 112) >> 2
                                          ] |
                                            0) !=
                                          (l | 0)
                                        )
                                          if (
                                            (u[
                                              (11152 + ((f * 216) | 0) + 120) >>
                                                2
                                            ] |
                                              0) !=
                                            (l | 0)
                                          )
                                            if (
                                              (u[
                                                (11152 +
                                                  ((f * 216) | 0) +
                                                  128) >>
                                                  2
                                              ] |
                                                0) !=
                                              (l | 0)
                                            )
                                              if (
                                                (u[
                                                  (11152 +
                                                    ((f * 216) | 0) +
                                                    136) >>
                                                    2
                                                ] |
                                                  0) ==
                                                (l | 0)
                                              )
                                                (l = 2), (h = 1), (g = 2)
                                              else {
                                                if (
                                                  (u[
                                                    (11152 +
                                                      ((f * 216) | 0) +
                                                      144) >>
                                                      2
                                                  ] |
                                                    0) ==
                                                  (l | 0)
                                                ) {
                                                  ;(l = 0), (h = 2), (g = 0)
                                                  break
                                                }
                                                if (
                                                  (u[
                                                    (11152 +
                                                      ((f * 216) | 0) +
                                                      152) >>
                                                      2
                                                  ] |
                                                    0) ==
                                                  (l | 0)
                                                ) {
                                                  ;(l = 0), (h = 2), (g = 1)
                                                  break
                                                }
                                                if (
                                                  (u[
                                                    (11152 +
                                                      ((f * 216) | 0) +
                                                      160) >>
                                                      2
                                                  ] |
                                                    0) ==
                                                  (l | 0)
                                                ) {
                                                  ;(l = 0), (h = 2), (g = 2)
                                                  break
                                                }
                                                if (
                                                  (u[
                                                    (11152 +
                                                      ((f * 216) | 0) +
                                                      168) >>
                                                      2
                                                  ] |
                                                    0) ==
                                                  (l | 0)
                                                ) {
                                                  ;(l = 1), (h = 2), (g = 0)
                                                  break
                                                }
                                                if (
                                                  (u[
                                                    (11152 +
                                                      ((f * 216) | 0) +
                                                      176) >>
                                                      2
                                                  ] |
                                                    0) ==
                                                  (l | 0)
                                                ) {
                                                  ;(l = 1), (h = 2), (g = 1)
                                                  break
                                                }
                                                if (
                                                  (u[
                                                    (11152 +
                                                      ((f * 216) | 0) +
                                                      184) >>
                                                      2
                                                  ] |
                                                    0) ==
                                                  (l | 0)
                                                ) {
                                                  ;(l = 1), (h = 2), (g = 2)
                                                  break
                                                }
                                                if (
                                                  (u[
                                                    (11152 +
                                                      ((f * 216) | 0) +
                                                      192) >>
                                                      2
                                                  ] |
                                                    0) ==
                                                  (l | 0)
                                                ) {
                                                  ;(l = 2), (h = 2), (g = 0)
                                                  break
                                                }
                                                if (
                                                  (u[
                                                    (11152 +
                                                      ((f * 216) | 0) +
                                                      200) >>
                                                      2
                                                  ] |
                                                    0) ==
                                                  (l | 0)
                                                ) {
                                                  ;(l = 2), (h = 2), (g = 1)
                                                  break
                                                }
                                                if (
                                                  (u[
                                                    (11152 +
                                                      ((f * 216) | 0) +
                                                      208) >>
                                                      2
                                                  ] |
                                                    0) ==
                                                  (l | 0)
                                                ) {
                                                  ;(l = 2), (h = 2), (g = 2)
                                                  break
                                                } else l = -1
                                                return l | 0
                                              }
                                            else (l = 2), (h = 1), (g = 1)
                                          else (l = 2), (h = 1), (g = 0)
                                        else (l = 1), (h = 1), (g = 2)
                                      else (l = 1), (h = 1), (g = 1)
                                    else (l = 1), (h = 1), (g = 0)
                                  else (l = 0), (h = 1), (g = 2)
                                else (l = 0), (h = 1), (g = 1)
                              else (l = 0), (h = 1), (g = 0)
                            else (l = 2), (h = 0), (g = 2)
                          else (l = 2), (h = 0), (g = 1)
                        else (l = 2), (h = 0), (g = 0)
                      else (l = 1), (h = 0), (g = 2)
                    else (l = 1), (h = 0), (g = 1)
                  else (l = 1), (h = 0), (g = 0)
                else (l = 0), (h = 0), (g = 2)
              else (l = 0), (h = 0), (g = 1)
            else (l = 0), (h = 0), (g = 0)
          while (0)
          return (
            (f =
              u[
                (11152 +
                  ((f * 216) | 0) +
                  ((h * 72) | 0) +
                  ((l * 24) | 0) +
                  (g << 3) +
                  4) >>
                  2
              ] | 0),
            f | 0
          )
        }
        function py(l, f) {
          return (
            (l = l | 0),
            (f = f | 0),
            (u[(7728 + ((l * 28) | 0) + 20) >> 2] | 0) == (f | 0)
              ? ((f = 1), f | 0)
              : ((f = (u[(7728 + ((l * 28) | 0) + 24) >> 2] | 0) == (f | 0)),
                f | 0)
          )
        }
        function np(l, f) {
          return (
            (l = l | 0),
            (f = f | 0),
            u[(880 + ((l * 28) | 0) + (f << 2)) >> 2] | 0
          )
        }
        function ip(l, f) {
          return (
            (l = l | 0),
            (f = f | 0),
            (u[(880 + ((l * 28) | 0)) >> 2] | 0) == (f | 0)
              ? ((f = 0), f | 0)
              : (u[(880 + ((l * 28) | 0) + 4) >> 2] | 0) == (f | 0)
              ? ((f = 1), f | 0)
              : (u[(880 + ((l * 28) | 0) + 8) >> 2] | 0) == (f | 0)
              ? ((f = 2), f | 0)
              : (u[(880 + ((l * 28) | 0) + 12) >> 2] | 0) == (f | 0)
              ? ((f = 3), f | 0)
              : (u[(880 + ((l * 28) | 0) + 16) >> 2] | 0) == (f | 0)
              ? ((f = 4), f | 0)
              : (u[(880 + ((l * 28) | 0) + 20) >> 2] | 0) == (f | 0)
              ? ((f = 5), f | 0)
              : ((u[(880 + ((l * 28) | 0) + 24) >> 2] | 0) == (f | 0) ? 6 : 7) |
                0
          )
        }
        function RM() {
          return 122
        }
        function PM(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0
          f = 0
          do
            rt(f | 0, 0, 45) | 0,
              (g = ce() | 0 | 134225919),
              (h = (l + (f << 3)) | 0),
              (u[h >> 2] = -1),
              (u[(h + 4) >> 2] = g),
              (f = (f + 1) | 0)
          while ((f | 0) != 122)
        }
        function my(l) {
          return (l = l | 0), (+Z[(l + 16) >> 3] < +Z[(l + 24) >> 3]) | 0
        }
        function gy(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0
          return (
            (h = +Z[f >> 3]),
            !(h >= +Z[(l + 8) >> 3]) || !(h <= +Z[l >> 3])
              ? ((f = 0), f | 0)
              : ((g = +Z[(l + 16) >> 3]),
                (h = +Z[(l + 24) >> 3]),
                (v = +Z[(f + 8) >> 3]),
                (f = v >= h),
                (l = (v <= g) & 1),
                g < h ? f && (l = 1) : f || (l = 0),
                (f = (l | 0) != 0),
                f | 0)
          )
        }
        function rp(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0
          ;(b = ie),
            (ie = (ie + 288) | 0),
            (h = (b + 264) | 0),
            (g = (b + 96) | 0),
            (v = b),
            (w = v),
            (E = (w + 96) | 0)
          do (u[w >> 2] = 0), (w = (w + 4) | 0)
          while ((w | 0) < (E | 0))
          return (
            fp(f, v),
            (w = v),
            (E = u[w >> 2] | 0),
            (w = u[(w + 4) >> 2] | 0),
            ea(E, w, h),
            ta(E, w, g),
            (I = +Yc(h, (g + 8) | 0)),
            (Z[h >> 3] = +Z[l >> 3]),
            (w = (h + 8) | 0),
            (Z[w >> 3] = +Z[(l + 16) >> 3]),
            (Z[g >> 3] = +Z[(l + 8) >> 3]),
            (E = (g + 8) | 0),
            (Z[E >> 3] = +Z[(l + 24) >> 3]),
            (U = +Yc(h, g)),
            (E = ~~+Di(
              +(
                (U * U) /
                +Wy(
                  +(+lt(
                    +((+Z[w >> 3] - +Z[E >> 3]) / (+Z[h >> 3] - +Z[g >> 3]))
                  )),
                  3
                ) /
                (I * (I * 2.59807621135) * 0.8)
              )
            )),
            (ie = b),
            ((E | 0) == 0 ? 1 : E) | 0
          )
        }
        function LM(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0
          ;(E = ie),
            (ie = (ie + 288) | 0),
            (g = (E + 264) | 0),
            (v = (E + 96) | 0),
            (w = E),
            (b = w),
            (I = (b + 96) | 0)
          do (u[b >> 2] = 0), (b = (b + 4) | 0)
          while ((b | 0) < (I | 0))
          return (
            fp(h, w),
            (I = w),
            (b = u[I >> 2] | 0),
            (I = u[(I + 4) >> 2] | 0),
            ea(b, I, g),
            ta(b, I, v),
            (U = +Yc(g, (v + 8) | 0)),
            (I = ~~+Di(+(+Yc(l, f) / (U * 2)))),
            (ie = E),
            ((I | 0) == 0 ? 1 : I) | 0
          )
        }
        function DM(l, f, h, g) {
          ;(l = l | 0),
            (f = f | 0),
            (h = h | 0),
            (g = g | 0),
            (u[l >> 2] = f),
            (u[(l + 4) >> 2] = h),
            (u[(l + 8) >> 2] = g)
        }
        function IM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0
          ;(re = (f + 8) | 0),
            (u[re >> 2] = 0),
            (I = +Z[l >> 3]),
            (b = +lt(+I)),
            (U = +Z[(l + 8) >> 3]),
            (E = +lt(+U) / 0.8660254037844386),
            (b = b + E * 0.5),
            (h = ~~b),
            (l = ~~E),
            (b = b - +(h | 0)),
            (E = E - +(l | 0))
          do
            if (b < 0.5)
              if (b < 0.3333333333333333)
                if (((u[f >> 2] = h), E < (b + 1) * 0.5)) {
                  u[(f + 4) >> 2] = l
                  break
                } else {
                  ;(l = (l + 1) | 0), (u[(f + 4) >> 2] = l)
                  break
                }
              else if (
                ((fe = 1 - b),
                (l = ((!(E < fe) & 1) + l) | 0),
                (u[(f + 4) >> 2] = l),
                (fe <= E) & (E < b * 2))
              ) {
                ;(h = (h + 1) | 0), (u[f >> 2] = h)
                break
              } else {
                u[f >> 2] = h
                break
              }
            else {
              if (!(b < 0.6666666666666666))
                if (((h = (h + 1) | 0), (u[f >> 2] = h), E < b * 0.5)) {
                  u[(f + 4) >> 2] = l
                  break
                } else {
                  ;(l = (l + 1) | 0), (u[(f + 4) >> 2] = l)
                  break
                }
              if (E < 1 - b) {
                if (((u[(f + 4) >> 2] = l), b * 2 + -1 < E)) {
                  u[f >> 2] = h
                  break
                }
              } else (l = (l + 1) | 0), (u[(f + 4) >> 2] = l)
              ;(h = (h + 1) | 0), (u[f >> 2] = h)
            }
          while (0)
          do
            if (I < 0)
              if (l & 1) {
                ;(H = (((l + 1) | 0) / 2) | 0),
                  (H =
                    Jc(
                      h | 0,
                      ((((h | 0) < 0) << 31) >> 31) | 0,
                      H | 0,
                      ((((H | 0) < 0) << 31) >> 31) | 0
                    ) | 0),
                  (h = ~~(
                    +(h | 0) -
                    ((+(H >>> 0) + 4294967296 * +(ce() | 0)) * 2 + 1)
                  )),
                  (u[f >> 2] = h)
                break
              } else {
                ;(H = ((l | 0) / 2) | 0),
                  (H =
                    Jc(
                      h | 0,
                      ((((h | 0) < 0) << 31) >> 31) | 0,
                      H | 0,
                      ((((H | 0) < 0) << 31) >> 31) | 0
                    ) | 0),
                  (h = ~~(
                    +(h | 0) -
                    (+(H >>> 0) + 4294967296 * +(ce() | 0)) * 2
                  )),
                  (u[f >> 2] = h)
                break
              }
          while (0)
          ;(H = (f + 4) | 0),
            U < 0 &&
              ((h = (h - ((((l << 1) | 1 | 0) / 2) | 0)) | 0),
              (u[f >> 2] = h),
              (l = (0 - l) | 0),
              (u[H >> 2] = l)),
            (g = (l - h) | 0),
            (h | 0) < 0
              ? ((v = (0 - h) | 0),
                (u[H >> 2] = g),
                (u[re >> 2] = v),
                (u[f >> 2] = 0),
                (l = g),
                (h = 0))
              : (v = 0),
            (l | 0) < 0 &&
              ((h = (h - l) | 0),
              (u[f >> 2] = h),
              (v = (v - l) | 0),
              (u[re >> 2] = v),
              (u[H >> 2] = 0),
              (l = 0)),
            (w = (h - v) | 0),
            (g = (l - v) | 0),
            (v | 0) < 0 &&
              ((u[f >> 2] = w),
              (u[H >> 2] = g),
              (u[re >> 2] = 0),
              (l = g),
              (h = w),
              (v = 0)),
            (g = (l | 0) < (h | 0) ? l : h),
            (g = (v | 0) < (g | 0) ? v : g),
            !((g | 0) <= 0) &&
              ((u[f >> 2] = h - g), (u[H >> 2] = l - g), (u[re >> 2] = v - g))
        }
        function ui(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0
          ;(f = u[l >> 2] | 0),
            (b = (l + 4) | 0),
            (h = u[b >> 2] | 0),
            (f | 0) < 0 &&
              ((h = (h - f) | 0),
              (u[b >> 2] = h),
              (w = (l + 8) | 0),
              (u[w >> 2] = (u[w >> 2] | 0) - f),
              (u[l >> 2] = 0),
              (f = 0)),
            (h | 0) < 0
              ? ((f = (f - h) | 0),
                (u[l >> 2] = f),
                (w = (l + 8) | 0),
                (v = ((u[w >> 2] | 0) - h) | 0),
                (u[w >> 2] = v),
                (u[b >> 2] = 0),
                (h = 0))
              : ((v = (l + 8) | 0), (w = v), (v = u[v >> 2] | 0)),
            (v | 0) < 0 &&
              ((f = (f - v) | 0),
              (u[l >> 2] = f),
              (h = (h - v) | 0),
              (u[b >> 2] = h),
              (u[w >> 2] = 0),
              (v = 0)),
            (g = (h | 0) < (f | 0) ? h : f),
            (g = (v | 0) < (g | 0) ? v : g),
            !((g | 0) <= 0) &&
              ((u[l >> 2] = f - g), (u[b >> 2] = h - g), (u[w >> 2] = v - g))
        }
        function Zo(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0
          ;(g = u[(l + 8) >> 2] | 0),
            (h = +(((u[(l + 4) >> 2] | 0) - g) | 0)),
            (Z[f >> 3] = +(((u[l >> 2] | 0) - g) | 0) - h * 0.5),
            (Z[(f + 8) >> 3] = h * 0.8660254037844386)
        }
        function xi(l, f, h) {
          ;(l = l | 0),
            (f = f | 0),
            (h = h | 0),
            (u[h >> 2] = (u[f >> 2] | 0) + (u[l >> 2] | 0)),
            (u[(h + 4) >> 2] = (u[(f + 4) >> 2] | 0) + (u[(l + 4) >> 2] | 0)),
            (u[(h + 8) >> 2] = (u[(f + 8) >> 2] | 0) + (u[(l + 8) >> 2] | 0))
        }
        function sp(l, f, h) {
          ;(l = l | 0),
            (f = f | 0),
            (h = h | 0),
            (u[h >> 2] = (u[l >> 2] | 0) - (u[f >> 2] | 0)),
            (u[(h + 4) >> 2] = (u[(l + 4) >> 2] | 0) - (u[(f + 4) >> 2] | 0)),
            (u[(h + 8) >> 2] = (u[(l + 8) >> 2] | 0) - (u[(f + 8) >> 2] | 0))
        }
        function yy(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0
          ;(h = un(u[l >> 2] | 0, f) | 0),
            (u[l >> 2] = h),
            (h = (l + 4) | 0),
            (g = un(u[h >> 2] | 0, f) | 0),
            (u[h >> 2] = g),
            (l = (l + 8) | 0),
            (f = un(u[l >> 2] | 0, f) | 0),
            (u[l >> 2] = f)
        }
        function ef(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(b = u[l >> 2] | 0),
            (E = (b | 0) < 0),
            (g = ((u[(l + 4) >> 2] | 0) - (E ? b : 0)) | 0),
            (w = (g | 0) < 0),
            (v =
              ((w ? (0 - g) | 0 : 0) + ((u[(l + 8) >> 2] | 0) - (E ? b : 0))) |
              0),
            (h = (v | 0) < 0),
            (l = h ? 0 : v),
            (f = ((w ? 0 : g) - (h ? v : 0)) | 0),
            (v = ((E ? 0 : b) - (w ? g : 0) - (h ? v : 0)) | 0),
            (h = (f | 0) < (v | 0) ? f : v),
            (h = (l | 0) < (h | 0) ? l : h),
            (g = (h | 0) > 0),
            (l = (l - (g ? h : 0)) | 0),
            (f = (f - (g ? h : 0)) | 0)
          e: do
            switch ((v - (g ? h : 0)) | 0) {
              case 0:
                switch (f | 0) {
                  case 0:
                    return (E = (l | 0) == 0 ? 0 : (l | 0) == 1 ? 1 : 7), E | 0
                  case 1:
                    return (E = (l | 0) == 0 ? 2 : (l | 0) == 1 ? 3 : 7), E | 0
                  default:
                    break e
                }
              case 1:
                switch (f | 0) {
                  case 0:
                    return (E = (l | 0) == 0 ? 4 : (l | 0) == 1 ? 5 : 7), E | 0
                  case 1: {
                    if (!l) l = 6
                    else break e
                    return l | 0
                  }
                  default:
                    break e
                }
            }
          while (0)
          return (E = 7), E | 0
        }
        function vy(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(b = (l + 8) | 0),
            (h = u[b >> 2] | 0),
            (f = ((u[l >> 2] | 0) - h) | 0),
            (E = (l + 4) | 0),
            (h = ((u[E >> 2] | 0) - h) | 0),
            (g = of(+((((f * 3) | 0) - h) | 0) / 7) | 0),
            (u[l >> 2] = g),
            (f = of(+(((h << 1) + f) | 0) / 7) | 0),
            (u[E >> 2] = f),
            (u[b >> 2] = 0),
            (h = (f - g) | 0),
            (g | 0) < 0
              ? ((w = (0 - g) | 0),
                (u[E >> 2] = h),
                (u[b >> 2] = w),
                (u[l >> 2] = 0),
                (f = h),
                (g = 0),
                (h = w))
              : (h = 0),
            (f | 0) < 0 &&
              ((g = (g - f) | 0),
              (u[l >> 2] = g),
              (h = (h - f) | 0),
              (u[b >> 2] = h),
              (u[E >> 2] = 0),
              (f = 0)),
            (w = (g - h) | 0),
            (v = (f - h) | 0),
            (h | 0) < 0
              ? ((u[l >> 2] = w),
                (u[E >> 2] = v),
                (u[b >> 2] = 0),
                (f = v),
                (v = w),
                (h = 0))
              : (v = g),
            (g = (f | 0) < (v | 0) ? f : v),
            (g = (h | 0) < (g | 0) ? h : g),
            !((g | 0) <= 0) &&
              ((u[l >> 2] = v - g), (u[E >> 2] = f - g), (u[b >> 2] = h - g))
        }
        function op(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(b = (l + 8) | 0),
            (h = u[b >> 2] | 0),
            (f = ((u[l >> 2] | 0) - h) | 0),
            (E = (l + 4) | 0),
            (h = ((u[E >> 2] | 0) - h) | 0),
            (g = of(+(((f << 1) + h) | 0) / 7) | 0),
            (u[l >> 2] = g),
            (f = of(+((((h * 3) | 0) - f) | 0) / 7) | 0),
            (u[E >> 2] = f),
            (u[b >> 2] = 0),
            (h = (f - g) | 0),
            (g | 0) < 0
              ? ((w = (0 - g) | 0),
                (u[E >> 2] = h),
                (u[b >> 2] = w),
                (u[l >> 2] = 0),
                (f = h),
                (g = 0),
                (h = w))
              : (h = 0),
            (f | 0) < 0 &&
              ((g = (g - f) | 0),
              (u[l >> 2] = g),
              (h = (h - f) | 0),
              (u[b >> 2] = h),
              (u[E >> 2] = 0),
              (f = 0)),
            (w = (g - h) | 0),
            (v = (f - h) | 0),
            (h | 0) < 0
              ? ((u[l >> 2] = w),
                (u[E >> 2] = v),
                (u[b >> 2] = 0),
                (f = v),
                (v = w),
                (h = 0))
              : (v = g),
            (g = (f | 0) < (v | 0) ? f : v),
            (g = (h | 0) < (g | 0) ? h : g),
            !((g | 0) <= 0) &&
              ((u[l >> 2] = v - g), (u[E >> 2] = f - g), (u[b >> 2] = h - g))
        }
        function tf(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(f = u[l >> 2] | 0),
            (b = (l + 4) | 0),
            (h = u[b >> 2] | 0),
            (E = (l + 8) | 0),
            (g = u[E >> 2] | 0),
            (v = (h + ((f * 3) | 0)) | 0),
            (u[l >> 2] = v),
            (h = (g + ((h * 3) | 0)) | 0),
            (u[b >> 2] = h),
            (f = (((g * 3) | 0) + f) | 0),
            (u[E >> 2] = f),
            (g = (h - v) | 0),
            (v | 0) < 0
              ? ((f = (f - v) | 0),
                (u[b >> 2] = g),
                (u[E >> 2] = f),
                (u[l >> 2] = 0),
                (h = g),
                (g = 0))
              : (g = v),
            (h | 0) < 0 &&
              ((g = (g - h) | 0),
              (u[l >> 2] = g),
              (f = (f - h) | 0),
              (u[E >> 2] = f),
              (u[b >> 2] = 0),
              (h = 0)),
            (w = (g - f) | 0),
            (v = (h - f) | 0),
            (f | 0) < 0
              ? ((u[l >> 2] = w),
                (u[b >> 2] = v),
                (u[E >> 2] = 0),
                (g = w),
                (f = 0))
              : (v = h),
            (h = (v | 0) < (g | 0) ? v : g),
            (h = (f | 0) < (h | 0) ? f : h),
            !((h | 0) <= 0) &&
              ((u[l >> 2] = g - h), (u[b >> 2] = v - h), (u[E >> 2] = f - h))
        }
        function Jo(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(v = u[l >> 2] | 0),
            (b = (l + 4) | 0),
            (f = u[b >> 2] | 0),
            (E = (l + 8) | 0),
            (h = u[E >> 2] | 0),
            (g = (((f * 3) | 0) + v) | 0),
            (v = (h + ((v * 3) | 0)) | 0),
            (u[l >> 2] = v),
            (u[b >> 2] = g),
            (f = (((h * 3) | 0) + f) | 0),
            (u[E >> 2] = f),
            (h = (g - v) | 0),
            (v | 0) < 0
              ? ((f = (f - v) | 0),
                (u[b >> 2] = h),
                (u[E >> 2] = f),
                (u[l >> 2] = 0),
                (v = 0))
              : (h = g),
            (h | 0) < 0 &&
              ((v = (v - h) | 0),
              (u[l >> 2] = v),
              (f = (f - h) | 0),
              (u[E >> 2] = f),
              (u[b >> 2] = 0),
              (h = 0)),
            (w = (v - f) | 0),
            (g = (h - f) | 0),
            (f | 0) < 0
              ? ((u[l >> 2] = w),
                (u[b >> 2] = g),
                (u[E >> 2] = 0),
                (v = w),
                (f = 0))
              : (g = h),
            (h = (g | 0) < (v | 0) ? g : v),
            (h = (f | 0) < (h | 0) ? f : h),
            !((h | 0) <= 0) &&
              ((u[l >> 2] = v - h), (u[b >> 2] = g - h), (u[E >> 2] = f - h))
        }
        function _y(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;((f + -1) | 0) >>> 0 >= 6 ||
            ((v =
              ((u[(15472 + ((f * 12) | 0)) >> 2] | 0) + (u[l >> 2] | 0)) | 0),
            (u[l >> 2] = v),
            (E = (l + 4) | 0),
            (g =
              ((u[(15472 + ((f * 12) | 0) + 4) >> 2] | 0) + (u[E >> 2] | 0)) |
              0),
            (u[E >> 2] = g),
            (b = (l + 8) | 0),
            (f =
              ((u[(15472 + ((f * 12) | 0) + 8) >> 2] | 0) + (u[b >> 2] | 0)) |
              0),
            (u[b >> 2] = f),
            (h = (g - v) | 0),
            (v | 0) < 0
              ? ((f = (f - v) | 0),
                (u[E >> 2] = h),
                (u[b >> 2] = f),
                (u[l >> 2] = 0),
                (g = 0))
              : ((h = g), (g = v)),
            (h | 0) < 0 &&
              ((g = (g - h) | 0),
              (u[l >> 2] = g),
              (f = (f - h) | 0),
              (u[b >> 2] = f),
              (u[E >> 2] = 0),
              (h = 0)),
            (w = (g - f) | 0),
            (v = (h - f) | 0),
            (f | 0) < 0
              ? ((u[l >> 2] = w),
                (u[E >> 2] = v),
                (u[b >> 2] = 0),
                (g = w),
                (f = 0))
              : (v = h),
            (h = (v | 0) < (g | 0) ? v : g),
            (h = (f | 0) < (h | 0) ? f : h),
            !((h | 0) <= 0) &&
              ((u[l >> 2] = g - h), (u[E >> 2] = v - h), (u[b >> 2] = f - h)))
        }
        function xy(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(v = u[l >> 2] | 0),
            (b = (l + 4) | 0),
            (f = u[b >> 2] | 0),
            (E = (l + 8) | 0),
            (h = u[E >> 2] | 0),
            (g = (f + v) | 0),
            (v = (h + v) | 0),
            (u[l >> 2] = v),
            (u[b >> 2] = g),
            (f = (h + f) | 0),
            (u[E >> 2] = f),
            (h = (g - v) | 0),
            (v | 0) < 0
              ? ((f = (f - v) | 0),
                (u[b >> 2] = h),
                (u[E >> 2] = f),
                (u[l >> 2] = 0),
                (g = 0))
              : ((h = g), (g = v)),
            (h | 0) < 0 &&
              ((g = (g - h) | 0),
              (u[l >> 2] = g),
              (f = (f - h) | 0),
              (u[E >> 2] = f),
              (u[b >> 2] = 0),
              (h = 0)),
            (w = (g - f) | 0),
            (v = (h - f) | 0),
            (f | 0) < 0
              ? ((u[l >> 2] = w),
                (u[b >> 2] = v),
                (u[E >> 2] = 0),
                (g = w),
                (f = 0))
              : (v = h),
            (h = (v | 0) < (g | 0) ? v : g),
            (h = (f | 0) < (h | 0) ? f : h),
            !((h | 0) <= 0) &&
              ((u[l >> 2] = g - h), (u[b >> 2] = v - h), (u[E >> 2] = f - h))
        }
        function nf(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(f = u[l >> 2] | 0),
            (b = (l + 4) | 0),
            (g = u[b >> 2] | 0),
            (E = (l + 8) | 0),
            (h = u[E >> 2] | 0),
            (v = (g + f) | 0),
            (u[l >> 2] = v),
            (g = (h + g) | 0),
            (u[b >> 2] = g),
            (f = (h + f) | 0),
            (u[E >> 2] = f),
            (h = (g - v) | 0),
            (v | 0) < 0
              ? ((f = (f - v) | 0),
                (u[b >> 2] = h),
                (u[E >> 2] = f),
                (u[l >> 2] = 0),
                (g = 0))
              : ((h = g), (g = v)),
            (h | 0) < 0 &&
              ((g = (g - h) | 0),
              (u[l >> 2] = g),
              (f = (f - h) | 0),
              (u[E >> 2] = f),
              (u[b >> 2] = 0),
              (h = 0)),
            (w = (g - f) | 0),
            (v = (h - f) | 0),
            (f | 0) < 0
              ? ((u[l >> 2] = w),
                (u[b >> 2] = v),
                (u[E >> 2] = 0),
                (g = w),
                (f = 0))
              : (v = h),
            (h = (v | 0) < (g | 0) ? v : g),
            (h = (f | 0) < (h | 0) ? f : h),
            !((h | 0) <= 0) &&
              ((u[l >> 2] = g - h), (u[b >> 2] = v - h), (u[E >> 2] = f - h))
        }
        function Ko(l) {
          switch (((l = l | 0), l | 0)) {
            case 1: {
              l = 5
              break
            }
            case 5: {
              l = 4
              break
            }
            case 4: {
              l = 6
              break
            }
            case 6: {
              l = 2
              break
            }
            case 2: {
              l = 3
              break
            }
            case 3: {
              l = 1
              break
            }
          }
          return l | 0
        }
        function Ks(l) {
          switch (((l = l | 0), l | 0)) {
            case 1: {
              l = 3
              break
            }
            case 3: {
              l = 2
              break
            }
            case 2: {
              l = 6
              break
            }
            case 6: {
              l = 4
              break
            }
            case 4: {
              l = 5
              break
            }
            case 5: {
              l = 1
              break
            }
          }
          return l | 0
        }
        function by(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(f = u[l >> 2] | 0),
            (b = (l + 4) | 0),
            (h = u[b >> 2] | 0),
            (E = (l + 8) | 0),
            (g = u[E >> 2] | 0),
            (v = (h + (f << 1)) | 0),
            (u[l >> 2] = v),
            (h = (g + (h << 1)) | 0),
            (u[b >> 2] = h),
            (f = ((g << 1) + f) | 0),
            (u[E >> 2] = f),
            (g = (h - v) | 0),
            (v | 0) < 0
              ? ((f = (f - v) | 0),
                (u[b >> 2] = g),
                (u[E >> 2] = f),
                (u[l >> 2] = 0),
                (h = g),
                (g = 0))
              : (g = v),
            (h | 0) < 0 &&
              ((g = (g - h) | 0),
              (u[l >> 2] = g),
              (f = (f - h) | 0),
              (u[E >> 2] = f),
              (u[b >> 2] = 0),
              (h = 0)),
            (w = (g - f) | 0),
            (v = (h - f) | 0),
            (f | 0) < 0
              ? ((u[l >> 2] = w),
                (u[b >> 2] = v),
                (u[E >> 2] = 0),
                (g = w),
                (f = 0))
              : (v = h),
            (h = (v | 0) < (g | 0) ? v : g),
            (h = (f | 0) < (h | 0) ? f : h),
            !((h | 0) <= 0) &&
              ((u[l >> 2] = g - h), (u[b >> 2] = v - h), (u[E >> 2] = f - h))
        }
        function wy(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(v = u[l >> 2] | 0),
            (b = (l + 4) | 0),
            (f = u[b >> 2] | 0),
            (E = (l + 8) | 0),
            (h = u[E >> 2] | 0),
            (g = ((f << 1) + v) | 0),
            (v = (h + (v << 1)) | 0),
            (u[l >> 2] = v),
            (u[b >> 2] = g),
            (f = ((h << 1) + f) | 0),
            (u[E >> 2] = f),
            (h = (g - v) | 0),
            (v | 0) < 0
              ? ((f = (f - v) | 0),
                (u[b >> 2] = h),
                (u[E >> 2] = f),
                (u[l >> 2] = 0),
                (v = 0))
              : (h = g),
            (h | 0) < 0 &&
              ((v = (v - h) | 0),
              (u[l >> 2] = v),
              (f = (f - h) | 0),
              (u[E >> 2] = f),
              (u[b >> 2] = 0),
              (h = 0)),
            (w = (v - f) | 0),
            (g = (h - f) | 0),
            (f | 0) < 0
              ? ((u[l >> 2] = w),
                (u[b >> 2] = g),
                (u[E >> 2] = 0),
                (v = w),
                (f = 0))
              : (g = h),
            (h = (g | 0) < (v | 0) ? g : v),
            (h = (f | 0) < (h | 0) ? f : h),
            !((h | 0) <= 0) &&
              ((u[l >> 2] = v - h), (u[b >> 2] = g - h), (u[E >> 2] = f - h))
        }
        function ap(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          return (
            (b = ((u[l >> 2] | 0) - (u[f >> 2] | 0)) | 0),
            (E = (b | 0) < 0),
            (g =
              ((u[(l + 4) >> 2] | 0) - (u[(f + 4) >> 2] | 0) - (E ? b : 0)) |
              0),
            (w = (g | 0) < 0),
            (v =
              ((E ? (0 - b) | 0 : 0) +
                (u[(l + 8) >> 2] | 0) -
                (u[(f + 8) >> 2] | 0) +
                (w ? (0 - g) | 0 : 0)) |
              0),
            (l = (v | 0) < 0),
            (f = l ? 0 : v),
            (h = ((w ? 0 : g) - (l ? v : 0)) | 0),
            (v = ((E ? 0 : b) - (w ? g : 0) - (l ? v : 0)) | 0),
            (l = (h | 0) < (v | 0) ? h : v),
            (l = (f | 0) < (l | 0) ? f : l),
            (g = (l | 0) > 0),
            (f = (f - (g ? l : 0)) | 0),
            (h = (h - (g ? l : 0)) | 0),
            (l = (v - (g ? l : 0)) | 0),
            (l = (l | 0) > -1 ? l : (0 - l) | 0),
            (h = (h | 0) > -1 ? h : (0 - h) | 0),
            (f = (f | 0) > -1 ? f : (0 - f) | 0),
            (f = (h | 0) > (f | 0) ? h : f),
            ((l | 0) > (f | 0) ? l : f) | 0
          )
        }
        function BM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0
          ;(h = u[(l + 8) >> 2] | 0),
            (u[f >> 2] = (u[l >> 2] | 0) - h),
            (u[(f + 4) >> 2] = (u[(l + 4) >> 2] | 0) - h)
        }
        function kM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(g = u[l >> 2] | 0),
            (u[f >> 2] = g),
            (l = u[(l + 4) >> 2] | 0),
            (b = (f + 4) | 0),
            (u[b >> 2] = l),
            (E = (f + 8) | 0),
            (u[E >> 2] = 0),
            (h = (l - g) | 0),
            (g | 0) < 0
              ? ((l = (0 - g) | 0),
                (u[b >> 2] = h),
                (u[E >> 2] = l),
                (u[f >> 2] = 0),
                (g = 0))
              : ((h = l), (l = 0)),
            (h | 0) < 0 &&
              ((g = (g - h) | 0),
              (u[f >> 2] = g),
              (l = (l - h) | 0),
              (u[E >> 2] = l),
              (u[b >> 2] = 0),
              (h = 0)),
            (w = (g - l) | 0),
            (v = (h - l) | 0),
            (l | 0) < 0
              ? ((u[f >> 2] = w),
                (u[b >> 2] = v),
                (u[E >> 2] = 0),
                (h = v),
                (v = w),
                (l = 0))
              : (v = g),
            (g = (h | 0) < (v | 0) ? h : v),
            (g = (l | 0) < (g | 0) ? l : g),
            !((g | 0) <= 0) &&
              ((u[f >> 2] = v - g), (u[b >> 2] = h - g), (u[E >> 2] = l - g))
        }
        function My(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0
          ;(f = (l + 8) | 0),
            (v = u[f >> 2] | 0),
            (h = (v - (u[l >> 2] | 0)) | 0),
            (u[l >> 2] = h),
            (g = (l + 4) | 0),
            (l = ((u[g >> 2] | 0) - v) | 0),
            (u[g >> 2] = l),
            (u[f >> 2] = 0 - (l + h))
        }
        function OM(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(h = u[l >> 2] | 0),
            (f = (0 - h) | 0),
            (u[l >> 2] = f),
            (b = (l + 8) | 0),
            (u[b >> 2] = 0),
            (E = (l + 4) | 0),
            (g = u[E >> 2] | 0),
            (v = (g + h) | 0),
            (h | 0) > 0
              ? ((u[E >> 2] = v),
                (u[b >> 2] = h),
                (u[l >> 2] = 0),
                (f = 0),
                (g = v))
              : (h = 0),
            (g | 0) < 0
              ? ((w = (f - g) | 0),
                (u[l >> 2] = w),
                (h = (h - g) | 0),
                (u[b >> 2] = h),
                (u[E >> 2] = 0),
                (v = (w - h) | 0),
                (f = (0 - h) | 0),
                (h | 0) < 0
                  ? ((u[l >> 2] = v),
                    (u[E >> 2] = f),
                    (u[b >> 2] = 0),
                    (g = f),
                    (h = 0))
                  : ((g = 0), (v = w)))
              : (v = f),
            (f = (g | 0) < (v | 0) ? g : v),
            (f = (h | 0) < (f | 0) ? h : f),
            !((f | 0) <= 0) &&
              ((u[l >> 2] = v - f), (u[E >> 2] = g - f), (u[b >> 2] = h - f))
        }
        function qM(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0
          ;(g = ie),
            (ie = (ie + 16) | 0),
            (v = g),
            FM(l, f, h, v),
            IM(v, (h + 4) | 0),
            (ie = g)
        }
        function FM(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0
          if (
            ((I = ie),
            (ie = (ie + 32) | 0),
            (w = I),
            qS(l, w),
            (u[h >> 2] = 0),
            (v = +zn(15888, w)),
            (b = +zn(15912, w)),
            b < v && ((u[h >> 2] = 1), (v = b)),
            (b = +zn(15936, w)),
            b < v && ((u[h >> 2] = 2), (v = b)),
            (b = +zn(15960, w)),
            b < v && ((u[h >> 2] = 3), (v = b)),
            (b = +zn(15984, w)),
            b < v && ((u[h >> 2] = 4), (v = b)),
            (b = +zn(16008, w)),
            b < v && ((u[h >> 2] = 5), (v = b)),
            (b = +zn(16032, w)),
            b < v && ((u[h >> 2] = 6), (v = b)),
            (b = +zn(16056, w)),
            b < v && ((u[h >> 2] = 7), (v = b)),
            (b = +zn(16080, w)),
            b < v && ((u[h >> 2] = 8), (v = b)),
            (b = +zn(16104, w)),
            b < v && ((u[h >> 2] = 9), (v = b)),
            (b = +zn(16128, w)),
            b < v && ((u[h >> 2] = 10), (v = b)),
            (b = +zn(16152, w)),
            b < v && ((u[h >> 2] = 11), (v = b)),
            (b = +zn(16176, w)),
            b < v && ((u[h >> 2] = 12), (v = b)),
            (b = +zn(16200, w)),
            b < v && ((u[h >> 2] = 13), (v = b)),
            (b = +zn(16224, w)),
            b < v && ((u[h >> 2] = 14), (v = b)),
            (b = +zn(16248, w)),
            b < v && ((u[h >> 2] = 15), (v = b)),
            (b = +zn(16272, w)),
            b < v && ((u[h >> 2] = 16), (v = b)),
            (b = +zn(16296, w)),
            b < v && ((u[h >> 2] = 17), (v = b)),
            (b = +zn(16320, w)),
            b < v && ((u[h >> 2] = 18), (v = b)),
            (b = +zn(16344, w)),
            b < v && ((u[h >> 2] = 19), (v = b)),
            (b = +sn(+(1 - v * 0.5))),
            b < 1e-16)
          ) {
            ;(u[g >> 2] = 0),
              (u[(g + 4) >> 2] = 0),
              (u[(g + 8) >> 2] = 0),
              (u[(g + 12) >> 2] = 0),
              (ie = I)
            return
          }
          if (
            ((h = u[h >> 2] | 0),
            (v = +Z[(16368 + ((h * 24) | 0)) >> 3]),
            (v = +Xc(v - +Xc(+GM((15568 + (h << 4)) | 0, l)))),
            ur(f) | 0 ? (E = +Xc(v + -0.3334731722518321)) : (E = v),
            (v = +tn(+b) / 0.381966011250105),
            (f | 0) > 0)
          ) {
            w = 0
            do (v = v * 2.6457513110645907), (w = (w + 1) | 0)
            while ((w | 0) != (f | 0))
          }
          ;(b = +Nt(+E) * v),
            (Z[g >> 3] = b),
            (E = +dt(+E) * v),
            (Z[(g + 8) >> 3] = E),
            (ie = I)
        }
        function Qc(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0,
            b = 0
          if (((w = +OS(l)), w < 1e-16)) {
            ;(f = (15568 + (f << 4)) | 0),
              (u[v >> 2] = u[f >> 2]),
              (u[(v + 4) >> 2] = u[(f + 4) >> 2]),
              (u[(v + 8) >> 2] = u[(f + 8) >> 2]),
              (u[(v + 12) >> 2] = u[(f + 12) >> 2])
            return
          }
          if (((b = +bn(+(+Z[(l + 8) >> 3]), +(+Z[l >> 3]))), (h | 0) > 0)) {
            l = 0
            do (w = w / 2.6457513110645907), (l = (l + 1) | 0)
            while ((l | 0) != (h | 0))
          }
          g
            ? ((w = w / 3),
              (h = (ur(h) | 0) == 0),
              (w = +Js(
                +((h ? w : w / 2.6457513110645907) * 0.381966011250105)
              )))
            : ((w = +Js(+(w * 0.381966011250105))),
              ur(h) | 0 && (b = +Xc(b + 0.3334731722518321))),
            VM(
              (15568 + (f << 4)) | 0,
              +Xc(+Z[(16368 + ((f * 24) | 0)) >> 3] - b),
              w,
              v
            )
        }
        function NM(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0
          ;(g = ie),
            (ie = (ie + 16) | 0),
            (v = g),
            Zo((l + 4) | 0, v),
            Qc(v, u[l >> 2] | 0, f, 0, h),
            (ie = g)
        }
        function Sy(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0,
            He = 0,
            he = 0,
            ot = 0,
            ct = 0,
            Je = 0,
            nt = 0,
            Rt = 0,
            Zt = 0,
            Qt = 0,
            on = 0,
            Wt = 0,
            fn = 0,
            hn = 0,
            Mt = 0
          if (
            ((fn = ie),
            (ie = (ie + 272) | 0),
            (w = (fn + 256) | 0),
            (we = (fn + 240) | 0),
            (Qt = fn),
            (on = (fn + 224) | 0),
            (Wt = (fn + 208) | 0),
            (He = (fn + 176) | 0),
            (he = (fn + 160) | 0),
            (ot = (fn + 192) | 0),
            (ct = (fn + 144) | 0),
            (Je = (fn + 128) | 0),
            (nt = (fn + 112) | 0),
            (Rt = (fn + 96) | 0),
            (Zt = (fn + 80) | 0),
            (u[w >> 2] = f),
            (u[we >> 2] = u[l >> 2]),
            (u[(we + 4) >> 2] = u[(l + 4) >> 2]),
            (u[(we + 8) >> 2] = u[(l + 8) >> 2]),
            (u[(we + 12) >> 2] = u[(l + 12) >> 2]),
            Ey(we, w, Qt),
            (u[v >> 2] = 0),
            (we = (g + h + (((g | 0) == 5) & 1)) | 0),
            (we | 0) <= (h | 0))
          ) {
            ie = fn
            return
          }
          ;(I = u[w >> 2] | 0),
            (U = (on + 4) | 0),
            (H = (He + 4) | 0),
            (re = (h + 5) | 0),
            (fe = (16848 + (I << 2)) | 0),
            (me = (16928 + (I << 2)) | 0),
            (Pe = (Je + 8) | 0),
            (Ie = (nt + 8) | 0),
            (Qe = (Rt + 8) | 0),
            (st = (Wt + 4) | 0),
            (E = h)
          e: for (;;) {
            ;(b = (Qt + (((E | 0) % 5 | 0) << 4)) | 0),
              (u[Wt >> 2] = u[b >> 2]),
              (u[(Wt + 4) >> 2] = u[(b + 4) >> 2]),
              (u[(Wt + 8) >> 2] = u[(b + 8) >> 2]),
              (u[(Wt + 12) >> 2] = u[(b + 12) >> 2])
            do;
            while ((ll(Wt, I, 0, 1) | 0) == 2)
            if (((E | 0) > (h | 0)) & ((ur(f) | 0) != 0)) {
              if (
                ((u[He >> 2] = u[Wt >> 2]),
                (u[(He + 4) >> 2] = u[(Wt + 4) >> 2]),
                (u[(He + 8) >> 2] = u[(Wt + 8) >> 2]),
                (u[(He + 12) >> 2] = u[(Wt + 12) >> 2]),
                Zo(U, he),
                (g = u[He >> 2] | 0),
                (w = u[(17008 + ((g * 80) | 0) + (u[on >> 2] << 2)) >> 2] | 0),
                (u[He >> 2] =
                  u[(18608 + ((g * 80) | 0) + ((w * 20) | 0)) >> 2]),
                (b =
                  u[(18608 + ((g * 80) | 0) + ((w * 20) | 0) + 16) >> 2] | 0),
                (b | 0) > 0)
              ) {
                l = 0
                do xy(H), (l = (l + 1) | 0)
                while ((l | 0) < (b | 0))
              }
              switch (
                ((b = (18608 + ((g * 80) | 0) + ((w * 20) | 0) + 4) | 0),
                (u[ot >> 2] = u[b >> 2]),
                (u[(ot + 4) >> 2] = u[(b + 4) >> 2]),
                (u[(ot + 8) >> 2] = u[(b + 8) >> 2]),
                yy(ot, ((u[fe >> 2] | 0) * 3) | 0),
                xi(H, ot, H),
                ui(H),
                Zo(H, ct),
                (hn = +(u[me >> 2] | 0)),
                (Z[Je >> 3] = hn * 3),
                (Z[Pe >> 3] = 0),
                (Mt = hn * -1.5),
                (Z[nt >> 3] = Mt),
                (Z[Ie >> 3] = hn * 2.598076211353316),
                (Z[Rt >> 3] = Mt),
                (Z[Qe >> 3] = hn * -2.598076211353316),
                u[
                  (17008 + (((u[He >> 2] | 0) * 80) | 0) + (u[Wt >> 2] << 2)) >>
                    2
                ] | 0)
              ) {
                case 1: {
                  ;(l = nt), (g = Je)
                  break
                }
                case 3: {
                  ;(l = Rt), (g = nt)
                  break
                }
                case 2: {
                  ;(l = Je), (g = Rt)
                  break
                }
                default: {
                  l = 12
                  break e
                }
              }
              Fy(he, ct, g, l, Zt),
                Qc(Zt, u[He >> 2] | 0, I, 1, (v + 8 + (u[v >> 2] << 4)) | 0),
                (u[v >> 2] = (u[v >> 2] | 0) + 1)
            }
            if (
              ((E | 0) < (re | 0) &&
                (Zo(st, He),
                Qc(He, u[Wt >> 2] | 0, I, 1, (v + 8 + (u[v >> 2] << 4)) | 0),
                (u[v >> 2] = (u[v >> 2] | 0) + 1)),
              (u[on >> 2] = u[Wt >> 2]),
              (u[(on + 4) >> 2] = u[(Wt + 4) >> 2]),
              (u[(on + 8) >> 2] = u[(Wt + 8) >> 2]),
              (u[(on + 12) >> 2] = u[(Wt + 12) >> 2]),
              (E = (E + 1) | 0),
              (E | 0) >= (we | 0))
            ) {
              l = 3
              break
            }
          }
          if ((l | 0) == 3) {
            ie = fn
            return
          } else (l | 0) == 12 && Yt(22474, 22521, 581, 22531)
        }
        function Ey(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0
          ;(I = ie),
            (ie = (ie + 128) | 0),
            (g = (I + 64) | 0),
            (v = I),
            (w = g),
            (b = 20208),
            (E = (w + 60) | 0)
          do (u[w >> 2] = u[b >> 2]), (w = (w + 4) | 0), (b = (b + 4) | 0)
          while ((w | 0) < (E | 0))
          ;(w = v), (b = 20272), (E = (w + 60) | 0)
          do (u[w >> 2] = u[b >> 2]), (w = (w + 4) | 0), (b = (b + 4) | 0)
          while ((w | 0) < (E | 0))
          ;(E = (ur(u[f >> 2] | 0) | 0) == 0),
            (g = E ? g : v),
            (v = (l + 4) | 0),
            by(v),
            wy(v),
            ur(u[f >> 2] | 0) | 0 && (Jo(v), (u[f >> 2] = (u[f >> 2] | 0) + 1)),
            (u[h >> 2] = u[l >> 2]),
            (f = (h + 4) | 0),
            xi(v, g, f),
            ui(f),
            (u[(h + 16) >> 2] = u[l >> 2]),
            (f = (h + 20) | 0),
            xi(v, (g + 12) | 0, f),
            ui(f),
            (u[(h + 32) >> 2] = u[l >> 2]),
            (f = (h + 36) | 0),
            xi(v, (g + 24) | 0, f),
            ui(f),
            (u[(h + 48) >> 2] = u[l >> 2]),
            (f = (h + 52) | 0),
            xi(v, (g + 36) | 0, f),
            ui(f),
            (u[(h + 64) >> 2] = u[l >> 2]),
            (h = (h + 68) | 0),
            xi(v, (g + 48) | 0, h),
            ui(h),
            (ie = I)
        }
        function ll(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0
          if (
            ((Pe = ie),
            (ie = (ie + 32) | 0),
            (fe = (Pe + 12) | 0),
            (E = Pe),
            (me = (l + 4) | 0),
            (re = u[(16928 + (f << 2)) >> 2] | 0),
            (H = (g | 0) != 0),
            (re = H ? (re * 3) | 0 : re),
            (v = u[me >> 2] | 0),
            (U = (l + 8) | 0),
            (b = u[U >> 2] | 0),
            H)
          ) {
            if (
              ((w = (l + 12) | 0),
              (g = u[w >> 2] | 0),
              (v = (b + v + g) | 0),
              (v | 0) == (re | 0))
            )
              return (me = 1), (ie = Pe), me | 0
            I = w
          } else (I = (l + 12) | 0), (g = u[I >> 2] | 0), (v = (b + v + g) | 0)
          if ((v | 0) <= (re | 0)) return (me = 0), (ie = Pe), me | 0
          do
            if ((g | 0) > 0) {
              if (((g = u[l >> 2] | 0), (b | 0) > 0)) {
                ;(w = (18608 + ((g * 80) | 0) + 60) | 0), (g = l)
                break
              }
              ;(g = (18608 + ((g * 80) | 0) + 40) | 0),
                h
                  ? (DM(fe, re, 0, 0),
                    sp(me, fe, E),
                    nf(E),
                    xi(E, fe, me),
                    (w = g),
                    (g = l))
                  : ((w = g), (g = l))
            } else
              (w = (18608 + (((u[l >> 2] | 0) * 80) | 0) + 20) | 0), (g = l)
          while (0)
          if (
            ((u[g >> 2] = u[w >> 2]), (v = (w + 16) | 0), (u[v >> 2] | 0) > 0)
          ) {
            g = 0
            do xy(me), (g = (g + 1) | 0)
            while ((g | 0) < (u[v >> 2] | 0))
          }
          return (
            (l = (w + 4) | 0),
            (u[fe >> 2] = u[l >> 2]),
            (u[(fe + 4) >> 2] = u[(l + 4) >> 2]),
            (u[(fe + 8) >> 2] = u[(l + 8) >> 2]),
            (f = u[(16848 + (f << 2)) >> 2] | 0),
            yy(fe, H ? (f * 3) | 0 : f),
            xi(me, fe, me),
            ui(me),
            H
              ? (g =
                  (((u[U >> 2] | 0) + (u[me >> 2] | 0) + (u[I >> 2] | 0)) |
                    0) ==
                  (re | 0)
                    ? 1
                    : 2)
              : (g = 2),
            (me = g),
            (ie = Pe),
            me | 0
          )
        }
        function UM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0
          do h = ll(l, f, 0, 1) | 0
          while ((h | 0) == 2)
          return h | 0
        }
        function Ty(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0,
            He = 0,
            he = 0,
            ot = 0,
            ct = 0,
            Je = 0,
            nt = 0,
            Rt = 0,
            Zt = 0,
            Qt = 0
          if (
            ((Rt = ie),
            (ie = (ie + 240) | 0),
            (w = (Rt + 224) | 0),
            (ot = (Rt + 208) | 0),
            (ct = Rt),
            (Je = (Rt + 192) | 0),
            (nt = (Rt + 176) | 0),
            (Qe = (Rt + 160) | 0),
            (st = (Rt + 144) | 0),
            (we = (Rt + 128) | 0),
            (He = (Rt + 112) | 0),
            (he = (Rt + 96) | 0),
            (u[w >> 2] = f),
            (u[ot >> 2] = u[l >> 2]),
            (u[(ot + 4) >> 2] = u[(l + 4) >> 2]),
            (u[(ot + 8) >> 2] = u[(l + 8) >> 2]),
            (u[(ot + 12) >> 2] = u[(l + 12) >> 2]),
            Cy(ot, w, ct),
            (u[v >> 2] = 0),
            (Ie = (g + h + (((g | 0) == 6) & 1)) | 0),
            (Ie | 0) <= (h | 0))
          ) {
            ie = Rt
            return
          }
          ;(I = u[w >> 2] | 0),
            (U = (h + 6) | 0),
            (H = (16928 + (I << 2)) | 0),
            (re = (st + 8) | 0),
            (fe = (we + 8) | 0),
            (me = (He + 8) | 0),
            (Pe = (Je + 4) | 0),
            (b = 0),
            (E = h),
            (g = -1)
          e: for (;;) {
            if (
              ((w = (E | 0) % 6 | 0),
              (l = (ct + (w << 4)) | 0),
              (u[Je >> 2] = u[l >> 2]),
              (u[(Je + 4) >> 2] = u[(l + 4) >> 2]),
              (u[(Je + 8) >> 2] = u[(l + 8) >> 2]),
              (u[(Je + 12) >> 2] = u[(l + 12) >> 2]),
              (l = b),
              (b = ll(Je, I, 0, 1) | 0),
              ((E | 0) > (h | 0)) & ((ur(f) | 0) != 0) &&
                (l | 0) != 1 &&
                (u[Je >> 2] | 0) != (g | 0))
            ) {
              switch (
                (Zo((ct + ((((w + 5) | 0) % 6 | 0) << 4) + 4) | 0, nt),
                Zo((ct + (w << 4) + 4) | 0, Qe),
                (Zt = +(u[H >> 2] | 0)),
                (Z[st >> 3] = Zt * 3),
                (Z[re >> 3] = 0),
                (Qt = Zt * -1.5),
                (Z[we >> 3] = Qt),
                (Z[fe >> 3] = Zt * 2.598076211353316),
                (Z[He >> 3] = Qt),
                (Z[me >> 3] = Zt * -2.598076211353316),
                (w = u[ot >> 2] | 0),
                u[
                  (17008 +
                    ((w * 80) | 0) +
                    (((g | 0) == (w | 0) ? u[Je >> 2] | 0 : g) << 2)) >>
                    2
                ] | 0)
              ) {
                case 1: {
                  ;(l = we), (g = st)
                  break
                }
                case 3: {
                  ;(l = He), (g = we)
                  break
                }
                case 2: {
                  ;(l = st), (g = He)
                  break
                }
                default: {
                  l = 8
                  break e
                }
              }
              Fy(nt, Qe, g, l, he),
                !(Ny(nt, he) | 0) &&
                  !(Ny(Qe, he) | 0) &&
                  (Qc(he, u[ot >> 2] | 0, I, 1, (v + 8 + (u[v >> 2] << 4)) | 0),
                  (u[v >> 2] = (u[v >> 2] | 0) + 1))
            }
            if (
              ((E | 0) < (U | 0) &&
                (Zo(Pe, nt),
                Qc(nt, u[Je >> 2] | 0, I, 1, (v + 8 + (u[v >> 2] << 4)) | 0),
                (u[v >> 2] = (u[v >> 2] | 0) + 1)),
              (E = (E + 1) | 0),
              (E | 0) >= (Ie | 0))
            ) {
              l = 3
              break
            } else g = u[Je >> 2] | 0
          }
          if ((l | 0) == 3) {
            ie = Rt
            return
          } else (l | 0) == 8 && Yt(22557, 22521, 746, 22602)
        }
        function Cy(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0
          ;(I = ie),
            (ie = (ie + 160) | 0),
            (g = (I + 80) | 0),
            (v = I),
            (w = g),
            (b = 20336),
            (E = (w + 72) | 0)
          do (u[w >> 2] = u[b >> 2]), (w = (w + 4) | 0), (b = (b + 4) | 0)
          while ((w | 0) < (E | 0))
          ;(w = v), (b = 20416), (E = (w + 72) | 0)
          do (u[w >> 2] = u[b >> 2]), (w = (w + 4) | 0), (b = (b + 4) | 0)
          while ((w | 0) < (E | 0))
          ;(E = (ur(u[f >> 2] | 0) | 0) == 0),
            (g = E ? g : v),
            (v = (l + 4) | 0),
            by(v),
            wy(v),
            ur(u[f >> 2] | 0) | 0 && (Jo(v), (u[f >> 2] = (u[f >> 2] | 0) + 1)),
            (u[h >> 2] = u[l >> 2]),
            (f = (h + 4) | 0),
            xi(v, g, f),
            ui(f),
            (u[(h + 16) >> 2] = u[l >> 2]),
            (f = (h + 20) | 0),
            xi(v, (g + 12) | 0, f),
            ui(f),
            (u[(h + 32) >> 2] = u[l >> 2]),
            (f = (h + 36) | 0),
            xi(v, (g + 24) | 0, f),
            ui(f),
            (u[(h + 48) >> 2] = u[l >> 2]),
            (f = (h + 52) | 0),
            xi(v, (g + 36) | 0, f),
            ui(f),
            (u[(h + 64) >> 2] = u[l >> 2]),
            (f = (h + 68) | 0),
            xi(v, (g + 48) | 0, f),
            ui(f),
            (u[(h + 80) >> 2] = u[l >> 2]),
            (h = (h + 84) | 0),
            xi(v, (g + 60) | 0, h),
            ui(h),
            (ie = I)
        }
        function Xc(l) {
          l = +l
          var f = 0
          return (
            (f = l < 0 ? l + 6.283185307179586 : l),
            +(l >= 6.283185307179586 ? f + -6.283185307179586 : f)
          )
        }
        function cl(l, f) {
          return (
            (l = l | 0),
            (f = f | 0),
            +lt(+(+Z[l >> 3] - +Z[f >> 3])) < 17453292519943298e-27
              ? ((f =
                  +lt(+(+Z[(l + 8) >> 3] - +Z[(f + 8) >> 3])) <
                  17453292519943298e-27),
                f | 0)
              : ((f = 0), f | 0)
          )
        }
        function zM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0
          return (
            (v = +Z[f >> 3]),
            (g = +Z[l >> 3]),
            (w = +dt(+((v - g) * 0.5))),
            (h = +dt(+((+Z[(f + 8) >> 3] - +Z[(l + 8) >> 3]) * 0.5))),
            (h = w * w + h * (+Nt(+v) * +Nt(+g) * h)),
            +(+bn(+(+_t(+h)), +(+_t(+(1 - h)))) * 2)
          )
        }
        function Yc(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0
          return (
            (v = +Z[f >> 3]),
            (g = +Z[l >> 3]),
            (w = +dt(+((v - g) * 0.5))),
            (h = +dt(+((+Z[(f + 8) >> 3] - +Z[(l + 8) >> 3]) * 0.5))),
            (h = w * w + h * (+Nt(+v) * +Nt(+g) * h)),
            +(+bn(+(+_t(+h)), +(+_t(+(1 - h)))) * 2 * 6371.007180918475)
          )
        }
        function HM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0
          return (
            (v = +Z[f >> 3]),
            (g = +Z[l >> 3]),
            (w = +dt(+((v - g) * 0.5))),
            (h = +dt(+((+Z[(f + 8) >> 3] - +Z[(l + 8) >> 3]) * 0.5))),
            (h = w * w + h * (+Nt(+v) * +Nt(+g) * h)),
            +(+bn(+(+_t(+h)), +(+_t(+(1 - h)))) * 2 * 6371.007180918475 * 1e3)
          )
        }
        function GM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0
          return (
            (w = +Z[f >> 3]),
            (g = +Nt(+w)),
            (v = +Z[(f + 8) >> 3] - +Z[(l + 8) >> 3]),
            (b = g * +dt(+v)),
            (h = +Z[l >> 3]),
            +(+bn(+b, +(+dt(+w) * +Nt(+h) - +Nt(+v) * (g * +dt(+h)))))
          )
        }
        function VM(l, f, h, g) {
          ;(l = l | 0), (f = +f), (h = +h), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0,
            E = 0
          if (h < 1e-16) {
            ;(u[g >> 2] = u[l >> 2]),
              (u[(g + 4) >> 2] = u[(l + 4) >> 2]),
              (u[(g + 8) >> 2] = u[(l + 8) >> 2]),
              (u[(g + 12) >> 2] = u[(l + 12) >> 2])
            return
          }
          ;(w = f < 0 ? f + 6.283185307179586 : f),
            (w = f >= 6.283185307179586 ? w + -6.283185307179586 : w)
          do
            if (w < 1e-16) (f = +Z[l >> 3] + h), (Z[g >> 3] = f), (v = g)
            else {
              if (
                ((v = +lt(+(w + -3.141592653589793)) < 1e-16),
                (f = +Z[l >> 3]),
                v)
              ) {
                ;(f = f - h), (Z[g >> 3] = f), (v = g)
                break
              }
              if (
                ((b = +Nt(+h)),
                (h = +dt(+h)),
                (f = b * +dt(+f) + +Nt(+w) * (h * +Nt(+f))),
                (f = f > 1 ? 1 : f),
                (f = +_i(+(f < -1 ? -1 : f))),
                (Z[g >> 3] = f),
                +lt(+(f + -1.5707963267948966)) < 1e-16)
              ) {
                ;(Z[g >> 3] = 1.5707963267948966), (Z[(g + 8) >> 3] = 0)
                return
              }
              if (+lt(+(f + 1.5707963267948966)) < 1e-16) {
                ;(Z[g >> 3] = -1.5707963267948966), (Z[(g + 8) >> 3] = 0)
                return
              }
              if (
                ((E = +Nt(+f)),
                (w = (h * +dt(+w)) / E),
                (h = +Z[l >> 3]),
                (f = (b - +dt(+f) * +dt(+h)) / +Nt(+h) / E),
                (b = w > 1 ? 1 : w),
                (f = f > 1 ? 1 : f),
                (f =
                  +Z[(l + 8) >> 3] +
                  +bn(+(b < -1 ? -1 : b), +(f < -1 ? -1 : f))),
                f > 3.141592653589793)
              )
                do f = f + -6.283185307179586
                while (f > 3.141592653589793)
              if (f < -3.141592653589793)
                do f = f + 6.283185307179586
                while (f < -3.141592653589793)
              Z[(g + 8) >> 3] = f
              return
            }
          while (0)
          if (+lt(+(f + -1.5707963267948966)) < 1e-16) {
            ;(Z[v >> 3] = 1.5707963267948966), (Z[(g + 8) >> 3] = 0)
            return
          }
          if (+lt(+(f + 1.5707963267948966)) < 1e-16) {
            ;(Z[v >> 3] = -1.5707963267948966), (Z[(g + 8) >> 3] = 0)
            return
          }
          if (((f = +Z[(l + 8) >> 3]), f > 3.141592653589793))
            do f = f + -6.283185307179586
            while (f > 3.141592653589793)
          if (f < -3.141592653589793)
            do f = f + 6.283185307179586
            while (f < -3.141592653589793)
          Z[(g + 8) >> 3] = f
        }
        function WM(l) {
          return (l = l | 0), +(+Z[(20496 + (l << 3)) >> 3])
        }
        function jM(l) {
          return (l = l | 0), +(+Z[(20624 + (l << 3)) >> 3])
        }
        function $M(l) {
          return (l = l | 0), +(+Z[(20752 + (l << 3)) >> 3])
        }
        function QM(l) {
          return (l = l | 0), +(+Z[(20880 + (l << 3)) >> 3])
        }
        function XM(l) {
          l = l | 0
          var f = 0
          return (
            (f = (21008 + (l << 3)) | 0),
            (l = u[f >> 2] | 0),
            Ct(u[(f + 4) >> 2] | 0),
            l | 0
          )
        }
        function Al(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0
          return (
            (fe = +Z[f >> 3]),
            (H = +Z[l >> 3]),
            (I = +dt(+((fe - H) * 0.5))),
            (w = +Z[(f + 8) >> 3]),
            (U = +Z[(l + 8) >> 3]),
            (b = +dt(+((w - U) * 0.5))),
            (E = +Nt(+H)),
            (re = +Nt(+fe)),
            (b = I * I + b * (re * E * b)),
            (b = +bn(+(+_t(+b)), +(+_t(+(1 - b)))) * 2),
            (I = +Z[h >> 3]),
            (fe = +dt(+((I - fe) * 0.5))),
            (g = +Z[(h + 8) >> 3]),
            (w = +dt(+((g - w) * 0.5))),
            (v = +Nt(+I)),
            (w = fe * fe + w * (re * v * w)),
            (w = +bn(+(+_t(+w)), +(+_t(+(1 - w)))) * 2),
            (I = +dt(+((H - I) * 0.5))),
            (g = +dt(+((U - g) * 0.5))),
            (g = I * I + g * (E * v * g)),
            (g = +bn(+(+_t(+g)), +(+_t(+(1 - g)))) * 2),
            (v = (b + w + g) * 0.5),
            +(
              +Js(
                +(+_t(
                  +(
                    +tn(+(v * 0.5)) *
                    +tn(+((v - b) * 0.5)) *
                    +tn(+((v - w) * 0.5)) *
                    +tn(+((v - g) * 0.5))
                  )
                ))
              ) * 4
            )
          )
        }
        function YM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0
          if (
            ((w = ie),
            (ie = (ie + 192) | 0),
            (g = (w + 168) | 0),
            (v = w),
            ea(l, f, g),
            ta(l, f, v),
            (f = u[v >> 2] | 0),
            (f | 0) <= 0)
          )
            return (h = 0), (ie = w), +h
          if (
            ((h =
              +Al((v + 8) | 0, (v + 8 + ((((f | 0) != 1) & 1) << 4)) | 0, g) +
              0),
            (f | 0) == 1)
          )
            return (ie = w), +h
          l = 1
          do
            (b = l),
              (l = (l + 1) | 0),
              (h =
                h +
                +Al(
                  (v + 8 + (b << 4)) | 0,
                  (v + 8 + (((l | 0) % (f | 0) | 0) << 4)) | 0,
                  g
                ))
          while ((l | 0) < (f | 0))
          return (ie = w), +h
        }
        function ZM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0
          if (
            ((w = ie),
            (ie = (ie + 192) | 0),
            (g = (w + 168) | 0),
            (v = w),
            ea(l, f, g),
            ta(l, f, v),
            (f = u[v >> 2] | 0),
            (f | 0) > 0)
          ) {
            if (
              ((h =
                +Al((v + 8) | 0, (v + 8 + ((((f | 0) != 1) & 1) << 4)) | 0, g) +
                0),
              (f | 0) != 1)
            ) {
              l = 1
              do
                (b = l),
                  (l = (l + 1) | 0),
                  (h =
                    h +
                    +Al(
                      (v + 8 + (b << 4)) | 0,
                      (v + 8 + (((l | 0) % (f | 0) | 0) << 4)) | 0,
                      g
                    ))
              while ((l | 0) < (f | 0))
            }
          } else h = 0
          return (ie = w), +(h * 6371.007180918475 * 6371.007180918475)
        }
        function JM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0
          if (
            ((w = ie),
            (ie = (ie + 192) | 0),
            (g = (w + 168) | 0),
            (v = w),
            ea(l, f, g),
            ta(l, f, v),
            (f = u[v >> 2] | 0),
            (f | 0) > 0)
          ) {
            if (
              ((h =
                +Al((v + 8) | 0, (v + 8 + ((((f | 0) != 1) & 1) << 4)) | 0, g) +
                0),
              (f | 0) != 1)
            ) {
              l = 1
              do
                (b = l),
                  (l = (l + 1) | 0),
                  (h =
                    h +
                    +Al(
                      (v + 8 + (b << 4)) | 0,
                      (v + 8 + (((l | 0) % (f | 0) | 0) << 4)) | 0,
                      g
                    ))
              while ((l | 0) < (f | 0))
            }
          } else h = 0
          return (
            (ie = w), +(h * 6371.007180918475 * 6371.007180918475 * 1e3 * 1e3)
          )
        }
        function KM(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0
          if (
            ((b = ie),
            (ie = (ie + 176) | 0),
            (w = b),
            rf(l, f, w),
            (l = u[w >> 2] | 0),
            (l | 0) <= 1)
          )
            return (v = 0), (ie = b), +v
          ;(f = (l + -1) | 0),
            (l = 0),
            (h = 0),
            (g = +Z[(w + 8) >> 3]),
            (v = +Z[(w + 16) >> 3])
          do
            (l = (l + 1) | 0),
              (I = g),
              (g = +Z[(w + 8 + (l << 4)) >> 3]),
              (U = +dt(+((g - I) * 0.5))),
              (E = v),
              (v = +Z[(w + 8 + (l << 4) + 8) >> 3]),
              (E = +dt(+((v - E) * 0.5))),
              (E = U * U + E * (+Nt(+g) * +Nt(+I) * E)),
              (h = h + +bn(+(+_t(+E)), +(+_t(+(1 - E)))) * 2)
          while ((l | 0) < (f | 0))
          return (ie = b), +h
        }
        function eS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0
          if (
            ((b = ie),
            (ie = (ie + 176) | 0),
            (w = b),
            rf(l, f, w),
            (l = u[w >> 2] | 0),
            (l | 0) <= 1)
          )
            return (v = 0), (ie = b), +v
          ;(f = (l + -1) | 0),
            (l = 0),
            (h = 0),
            (g = +Z[(w + 8) >> 3]),
            (v = +Z[(w + 16) >> 3])
          do
            (l = (l + 1) | 0),
              (I = g),
              (g = +Z[(w + 8 + (l << 4)) >> 3]),
              (U = +dt(+((g - I) * 0.5))),
              (E = v),
              (v = +Z[(w + 8 + (l << 4) + 8) >> 3]),
              (E = +dt(+((v - E) * 0.5))),
              (E = U * U + E * (+Nt(+I) * +Nt(+g) * E)),
              (h = h + +bn(+(+_t(+E)), +(+_t(+(1 - E)))) * 2)
          while ((l | 0) != (f | 0))
          return (U = h * 6371.007180918475), (ie = b), +U
        }
        function tS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0
          if (
            ((b = ie),
            (ie = (ie + 176) | 0),
            (w = b),
            rf(l, f, w),
            (l = u[w >> 2] | 0),
            (l | 0) <= 1)
          )
            return (v = 0), (ie = b), +v
          ;(f = (l + -1) | 0),
            (l = 0),
            (h = 0),
            (g = +Z[(w + 8) >> 3]),
            (v = +Z[(w + 16) >> 3])
          do
            (l = (l + 1) | 0),
              (I = g),
              (g = +Z[(w + 8 + (l << 4)) >> 3]),
              (U = +dt(+((g - I) * 0.5))),
              (E = v),
              (v = +Z[(w + 8 + (l << 4) + 8) >> 3]),
              (E = +dt(+((v - E) * 0.5))),
              (E = U * U + E * (+Nt(+I) * +Nt(+g) * E)),
              (h = h + +bn(+(+_t(+E)), +(+_t(+(1 - E)))) * 2)
          while ((l | 0) != (f | 0))
          return (U = h * 6371.007180918475 * 1e3), (ie = b), +U
        }
        function nS(l, f) {
          return (
            (l = l | 0),
            (f = f | 0),
            (f = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (f & 15) | 0
          )
        }
        function Ry(l, f) {
          return (
            (l = l | 0),
            (f = f | 0),
            (f = $e(l | 0, f | 0, 45) | 0),
            ce() | 0,
            (f & 127) | 0
          )
        }
        function Py(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          if (
            !(!0 & (((f & -16777216) | 0) == 134217728)) ||
            ((b = $e(l | 0, f | 0, 45) | 0),
            ce() | 0,
            (b = b & 127),
            b >>> 0 > 121)
          )
            return (f = 0), f | 0
          ;(h = $e(l | 0, f | 0, 52) | 0), ce() | 0, (h = h & 15)
          do
            if (h | 0) {
              for (v = 1, g = 0; ; ) {
                if (
                  ((w = $e(l | 0, f | 0, (((15 - v) | 0) * 3) | 0) | 0),
                  ce() | 0,
                  (w = w & 7),
                  ((w | 0) != 0) & (g ^ 1))
                )
                  if (((w | 0) == 1) & ((vn(b) | 0) != 0)) {
                    ;(E = 0), (g = 13)
                    break
                  } else g = 1
                if ((w | 0) == 7) {
                  ;(E = 0), (g = 13)
                  break
                }
                if (v >>> 0 < h >>> 0) v = (v + 1) | 0
                else {
                  g = 9
                  break
                }
              }
              if ((g | 0) == 9) {
                if ((h | 0) == 15) E = 1
                else break
                return E | 0
              } else if ((g | 0) == 13) return E | 0
            }
          while (0)
          for (;;) {
            if (
              ((E = $e(l | 0, f | 0, (((14 - h) | 0) * 3) | 0) | 0),
              ce() | 0,
              !((((E & 7) | 0) == 7) & !0))
            ) {
              ;(E = 0), (g = 13)
              break
            }
            if (h >>> 0 < 14) h = (h + 1) | 0
            else {
              ;(E = 1), (g = 13)
              break
            }
          }
          return (g | 0) == 13 ? E | 0 : 0
        }
        function lp(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0
          if (
            ((g = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (g = g & 15),
            (g | 0) >= (h | 0))
          ) {
            if ((g | 0) != (h | 0))
              if (h >>> 0 <= 15) {
                if (
                  ((v = rt(h | 0, 0, 52) | 0),
                  (l = v | l),
                  (f = ce() | 0 | (f & -15728641)),
                  (g | 0) > (h | 0))
                )
                  do
                    (v = rt(7, 0, (((14 - h) | 0) * 3) | 0) | 0),
                      (h = (h + 1) | 0),
                      (l = v | l),
                      (f = ce() | 0 | f)
                  while ((h | 0) < (g | 0))
              } else (f = 0), (l = 0)
          } else (f = 0), (l = 0)
          return Ct(f | 0), l | 0
        }
        function iS(l, f, h) {
          return (
            (l = l | 0),
            (f = f | 0),
            (h = h | 0),
            (l = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (l = l & 15),
            ((h | 0) < 16) & ((l | 0) <= (h | 0))
              ? ((h = sf(7, (h - l) | 0) | 0), h | 0)
              : ((h = 0), h | 0)
          )
        }
        function Ii(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0
          if (
            ((b = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (b = b & 15),
            !!(((h | 0) < 16) & ((b | 0) <= (h | 0))))
          ) {
            if ((b | 0) == (h | 0)) {
              ;(h = g), (u[h >> 2] = l), (u[(h + 4) >> 2] = f)
              return
            }
            if (
              ((I = sf(7, (h - b) | 0) | 0),
              (U = ((I | 0) / 7) | 0),
              (E = $e(l | 0, f | 0, 45) | 0),
              ce() | 0,
              !(vn(E & 127) | 0))
            )
              w = 0
            else {
              e: do
                if (!b) v = 0
                else
                  for (w = 1; ; ) {
                    if (
                      ((v = $e(l | 0, f | 0, (((15 - w) | 0) * 3) | 0) | 0),
                      ce() | 0,
                      (v = v & 7),
                      v | 0)
                    )
                      break e
                    if (w >>> 0 < b >>> 0) w = (w + 1) | 0
                    else {
                      v = 0
                      break
                    }
                  }
              while (0)
              w = (v | 0) == 0
            }
            if (
              ((H = rt((b + 1) | 0, 0, 52) | 0),
              (v = ce() | 0 | (f & -15728641)),
              (E = (((14 - b) | 0) * 3) | 0),
              (f = rt(7, 0, E | 0) | 0),
              (f = (H | l) & ~f),
              (b = v & ~(ce() | 0)),
              Ii(f, b, h, g),
              (v = (g + (U << 3)) | 0),
              !w)
            ) {
              ;(H = rt(1, 0, E | 0) | 0),
                Ii(H | f, ce() | 0 | b, h, v),
                (H = (v + (U << 3)) | 0),
                (I = rt(2, 0, E | 0) | 0),
                Ii(I | f, ce() | 0 | b, h, H),
                (H = (H + (U << 3)) | 0),
                (I = rt(3, 0, E | 0) | 0),
                Ii(I | f, ce() | 0 | b, h, H),
                (H = (H + (U << 3)) | 0),
                (I = rt(4, 0, E | 0) | 0),
                Ii(I | f, ce() | 0 | b, h, H),
                (H = (H + (U << 3)) | 0),
                (I = rt(5, 0, E | 0) | 0),
                Ii(I | f, ce() | 0 | b, h, H),
                (I = rt(6, 0, E | 0) | 0),
                Ii(I | f, ce() | 0 | b, h, (H + (U << 3)) | 0)
              return
            }
            ;(w = (v + (U << 3)) | 0),
              (I | 0) > 6 &&
                ((I = (v + 8) | 0),
                (H = ((w >>> 0 > I >>> 0 ? w : I) + -1 + (0 - v)) | 0),
                Cr(v | 0, 0, ((H + 8) & -8) | 0) | 0,
                (v = (I + ((H >>> 3) << 3)) | 0)),
              (H = rt(2, 0, E | 0) | 0),
              Ii(H | f, ce() | 0 | b, h, v),
              (H = (v + (U << 3)) | 0),
              (I = rt(3, 0, E | 0) | 0),
              Ii(I | f, ce() | 0 | b, h, H),
              (H = (H + (U << 3)) | 0),
              (I = rt(4, 0, E | 0) | 0),
              Ii(I | f, ce() | 0 | b, h, H),
              (H = (H + (U << 3)) | 0),
              (I = rt(5, 0, E | 0) | 0),
              Ii(I | f, ce() | 0 | b, h, H),
              (I = rt(6, 0, E | 0) | 0),
              Ii(I | f, ce() | 0 | b, h, (H + (U << 3)) | 0)
          }
        }
        function jn(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0
          if (((v = $e(l | 0, f | 0, 45) | 0), ce() | 0, !(vn(v & 127) | 0)))
            return (v = 0), v | 0
          ;(v = $e(l | 0, f | 0, 52) | 0), ce() | 0, (v = v & 15)
          e: do
            if (!v) h = 0
            else
              for (g = 1; ; ) {
                if (
                  ((h = $e(l | 0, f | 0, (((15 - g) | 0) * 3) | 0) | 0),
                  ce() | 0,
                  (h = h & 7),
                  h | 0)
                )
                  break e
                if (g >>> 0 < v >>> 0) g = (g + 1) | 0
                else {
                  h = 0
                  break
                }
              }
          while (0)
          return (v = ((h | 0) == 0) & 1), v | 0
        }
        function rS(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0
          if (
            ((g = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (g = g & 15),
            ((h | 0) < 16) & ((g | 0) <= (h | 0)))
          ) {
            if (
              (g | 0) != (h | 0) &&
              ((v = rt(h | 0, 0, 52) | 0),
              (l = v | l),
              (f = ce() | 0 | (f & -15728641)),
              (g | 0) < (h | 0))
            )
              do
                (v = rt(7, 0, (((14 - g) | 0) * 3) | 0) | 0),
                  (g = (g + 1) | 0),
                  (l = l & ~v),
                  (f = f & ~(ce() | 0))
              while ((g | 0) < (h | 0))
          } else (f = 0), (l = 0)
          return Ct(f | 0), l | 0
        }
        function sS(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0,
            He = 0,
            he = 0,
            ot = 0,
            ct = 0,
            Je = 0,
            nt = 0
          if (!h) return (Je = 0), Je | 0
          if (
            ((v = l),
            (g = u[v >> 2] | 0),
            (v = u[(v + 4) >> 2] | 0),
            !0 & (((v & 15728640) | 0) == 0))
          ) {
            if (
              (h | 0) <= 0 ||
              ((Je = f), (u[Je >> 2] = g), (u[(Je + 4) >> 2] = v), (h | 0) == 1)
            )
              return (Je = 0), Je | 0
            g = 1
            do
              (ot = (l + (g << 3)) | 0),
                (ct = u[(ot + 4) >> 2] | 0),
                (Je = (f + (g << 3)) | 0),
                (u[Je >> 2] = u[ot >> 2]),
                (u[(Je + 4) >> 2] = ct),
                (g = (g + 1) | 0)
            while ((g | 0) != (h | 0))
            return (g = 0), g | 0
          }
          if (((ot = h << 3), (ct = Vr(ot) | 0), !ct)) return (Je = -3), Je | 0
          if ((lf(ct | 0, l | 0, ot | 0) | 0, (he = Tr(h, 8) | 0), !he))
            return Lt(ct), (Je = -3), Je | 0
          g = h
          e: for (;;) {
            ;(b = ct),
              (H = u[b >> 2] | 0),
              (b = u[(b + 4) >> 2] | 0),
              (we = $e(H | 0, b | 0, 52) | 0),
              ce() | 0,
              (we = we & 15),
              (He = (we + -1) | 0),
              (st = (g | 0) > 0)
            t: do
              if (st) {
                if (
                  ((Qe = (((g | 0) < 0) << 31) >> 31),
                  (Pe = rt(He | 0, 0, 52) | 0),
                  (Ie = ce() | 0),
                  He >>> 0 > 15)
                )
                  for (v = 0, l = H, h = b; ; ) {
                    if (!(((l | 0) == 0) & ((h | 0) == 0))) {
                      if (
                        ((w = $e(l | 0, h | 0, 52) | 0),
                        ce() | 0,
                        (w = w & 15),
                        (E = (w | 0) < (He | 0)),
                        (w = (w | 0) == (He | 0)),
                        (U = E ? 0 : w ? l : 0),
                        (l = E ? 0 : w ? h : 0),
                        (h = to(U | 0, l | 0, g | 0, Qe | 0) | 0),
                        ce() | 0,
                        (w = (he + (h << 3)) | 0),
                        (E = w),
                        (I = u[E >> 2] | 0),
                        (E = u[(E + 4) >> 2] | 0),
                        ((I | 0) == 0) & ((E | 0) == 0))
                      )
                        h = U
                      else
                        for (Pe = 0, me = h, fe = E, h = U; ; ) {
                          if ((Pe | 0) > (g | 0)) {
                            Je = 41
                            break e
                          }
                          if (
                            ((I | 0) == (h | 0)) &
                            (((fe & -117440513) | 0) == (l | 0))
                          ) {
                            ;(U = $e(I | 0, fe | 0, 56) | 0),
                              ce() | 0,
                              (U = U & 7),
                              (re = (U + 1) | 0),
                              (Ie = $e(I | 0, fe | 0, 45) | 0),
                              ce() | 0
                            n: do
                              if (!(vn(Ie & 127) | 0)) E = 7
                              else {
                                if (
                                  ((I = $e(I | 0, fe | 0, 52) | 0),
                                  ce() | 0,
                                  (I = I & 15),
                                  !I)
                                ) {
                                  E = 6
                                  break
                                }
                                for (E = 1; ; ) {
                                  if (
                                    ((Ie =
                                      rt(7, 0, (((15 - E) | 0) * 3) | 0) | 0),
                                    !(
                                      (((Ie & h) | 0) == 0) &
                                      ((((ce() | 0) & l) | 0) == 0)
                                    ))
                                  ) {
                                    E = 7
                                    break n
                                  }
                                  if (E >>> 0 < I >>> 0) E = (E + 1) | 0
                                  else {
                                    E = 6
                                    break
                                  }
                                }
                              }
                            while (0)
                            if (((U + 2) | 0) >>> 0 > E >>> 0) {
                              Je = 51
                              break e
                            }
                            ;(Ie = rt(re | 0, 0, 56) | 0),
                              (l = ce() | 0 | (l & -117440513)),
                              (E = w),
                              (u[E >> 2] = 0),
                              (u[(E + 4) >> 2] = 0),
                              (E = me),
                              (h = Ie | h)
                          } else E = ((me + 1) | 0) % (g | 0) | 0
                          if (
                            ((w = (he + (E << 3)) | 0),
                            (fe = w),
                            (I = u[fe >> 2] | 0),
                            (fe = u[(fe + 4) >> 2] | 0),
                            ((I | 0) == 0) & ((fe | 0) == 0))
                          )
                            break
                          ;(Pe = (Pe + 1) | 0), (me = E)
                        }
                      ;(Ie = w), (u[Ie >> 2] = h), (u[(Ie + 4) >> 2] = l)
                    }
                    if (((v = (v + 1) | 0), (v | 0) >= (g | 0))) break t
                    ;(h = (ct + (v << 3)) | 0),
                      (l = u[h >> 2] | 0),
                      (h = u[(h + 4) >> 2] | 0)
                  }
                for (v = 0, l = H, h = b; ; ) {
                  if (!(((l | 0) == 0) & ((h | 0) == 0))) {
                    if (
                      ((E = $e(l | 0, h | 0, 52) | 0),
                      ce() | 0,
                      (E = E & 15),
                      (E | 0) >= (He | 0))
                    ) {
                      if (
                        (E | 0) != (He | 0) &&
                        ((l = l | Pe),
                        (h = (h & -15728641) | Ie),
                        E >>> 0 >= we >>> 0)
                      ) {
                        w = He
                        do
                          (me = rt(7, 0, (((14 - w) | 0) * 3) | 0) | 0),
                            (w = (w + 1) | 0),
                            (l = me | l),
                            (h = ce() | 0 | h)
                        while (w >>> 0 < E >>> 0)
                      }
                    } else (l = 0), (h = 0)
                    if (
                      ((E = to(l | 0, h | 0, g | 0, Qe | 0) | 0),
                      ce() | 0,
                      (w = (he + (E << 3)) | 0),
                      (I = w),
                      (U = u[I >> 2] | 0),
                      (I = u[(I + 4) >> 2] | 0),
                      !(((U | 0) == 0) & ((I | 0) == 0)))
                    )
                      for (me = 0; ; ) {
                        if ((me | 0) > (g | 0)) {
                          Je = 41
                          break e
                        }
                        if (
                          ((U | 0) == (l | 0)) &
                          (((I & -117440513) | 0) == (h | 0))
                        ) {
                          ;(re = $e(U | 0, I | 0, 56) | 0),
                            ce() | 0,
                            (re = re & 7),
                            (fe = (re + 1) | 0),
                            (nt = $e(U | 0, I | 0, 45) | 0),
                            ce() | 0
                          n: do
                            if (!(vn(nt & 127) | 0)) I = 7
                            else {
                              if (
                                ((U = $e(U | 0, I | 0, 52) | 0),
                                ce() | 0,
                                (U = U & 15),
                                !U)
                              ) {
                                I = 6
                                break
                              }
                              for (I = 1; ; ) {
                                if (
                                  ((nt =
                                    rt(7, 0, (((15 - I) | 0) * 3) | 0) | 0),
                                  !(
                                    (((nt & l) | 0) == 0) &
                                    ((((ce() | 0) & h) | 0) == 0)
                                  ))
                                ) {
                                  I = 7
                                  break n
                                }
                                if (I >>> 0 < U >>> 0) I = (I + 1) | 0
                                else {
                                  I = 6
                                  break
                                }
                              }
                            }
                          while (0)
                          if (((re + 2) | 0) >>> 0 > I >>> 0) {
                            Je = 51
                            break e
                          }
                          ;(nt = rt(fe | 0, 0, 56) | 0),
                            (h = ce() | 0 | (h & -117440513)),
                            (fe = w),
                            (u[fe >> 2] = 0),
                            (u[(fe + 4) >> 2] = 0),
                            (l = nt | l)
                        } else E = ((E + 1) | 0) % (g | 0) | 0
                        if (
                          ((w = (he + (E << 3)) | 0),
                          (I = w),
                          (U = u[I >> 2] | 0),
                          (I = u[(I + 4) >> 2] | 0),
                          ((U | 0) == 0) & ((I | 0) == 0))
                        )
                          break
                        me = (me + 1) | 0
                      }
                    ;(nt = w), (u[nt >> 2] = l), (u[(nt + 4) >> 2] = h)
                  }
                  if (((v = (v + 1) | 0), (v | 0) >= (g | 0))) break t
                  ;(h = (ct + (v << 3)) | 0),
                    (l = u[h >> 2] | 0),
                    (h = u[(h + 4) >> 2] | 0)
                }
              }
            while (0)
            if (((g + 5) | 0) >>> 0 < 11) {
              Je = 99
              break
            }
            if (((Ie = Tr(((g | 0) / 6) | 0, 8) | 0), !Ie)) {
              Je = 58
              break
            }
            t: do
              if (st) {
                ;(me = 0), (fe = 0)
                do {
                  if (
                    ((E = (he + (me << 3)) | 0),
                    (l = E),
                    (v = u[l >> 2] | 0),
                    (l = u[(l + 4) >> 2] | 0),
                    !(((v | 0) == 0) & ((l | 0) == 0)))
                  ) {
                    ;(I = $e(v | 0, l | 0, 56) | 0),
                      ce() | 0,
                      (I = I & 7),
                      (h = (I + 1) | 0),
                      (U = l & -117440513),
                      (nt = $e(v | 0, l | 0, 45) | 0),
                      ce() | 0
                    n: do
                      if (vn(nt & 127) | 0) {
                        if (
                          ((re = $e(v | 0, l | 0, 52) | 0),
                          ce() | 0,
                          (re = re & 15),
                          re | 0)
                        )
                          for (w = 1; ; ) {
                            if (
                              ((nt = rt(7, 0, (((15 - w) | 0) * 3) | 0) | 0),
                              !(
                                (((v & nt) | 0) == 0) &
                                (((U & (ce() | 0)) | 0) == 0)
                              ))
                            )
                              break n
                            if (w >>> 0 < re >>> 0) w = (w + 1) | 0
                            else break
                          }
                        ;(l = rt(h | 0, 0, 56) | 0),
                          (v = l | v),
                          (l = ce() | 0 | U),
                          (h = E),
                          (u[h >> 2] = v),
                          (u[(h + 4) >> 2] = l),
                          (h = (I + 2) | 0)
                      }
                    while (0)
                    ;(h | 0) == 7 &&
                      ((nt = (Ie + (fe << 3)) | 0),
                      (u[nt >> 2] = v),
                      (u[(nt + 4) >> 2] = l & -117440513),
                      (fe = (fe + 1) | 0))
                  }
                  me = (me + 1) | 0
                } while ((me | 0) != (g | 0))
                if (st) {
                  if (
                    ((Pe = (((g | 0) < 0) << 31) >> 31),
                    (re = rt(He | 0, 0, 52) | 0),
                    (me = ce() | 0),
                    He >>> 0 > 15)
                  )
                    for (l = 0, v = 0; ; ) {
                      do
                        if (!(((H | 0) == 0) & ((b | 0) == 0))) {
                          for (
                            I = $e(H | 0, b | 0, 52) | 0,
                              ce() | 0,
                              I = I & 15,
                              w = (I | 0) < (He | 0),
                              I = (I | 0) == (He | 0),
                              E = w ? 0 : I ? H : 0,
                              I = w ? 0 : I ? b : 0,
                              w = to(E | 0, I | 0, g | 0, Pe | 0) | 0,
                              ce() | 0,
                              h = 0;
                            ;

                          ) {
                            if ((h | 0) > (g | 0)) {
                              Je = 98
                              break e
                            }
                            if (
                              ((nt = (he + (w << 3)) | 0),
                              (U = u[(nt + 4) >> 2] | 0),
                              ((U & -117440513) | 0) == (I | 0) &&
                                (u[nt >> 2] | 0) == (E | 0))
                            ) {
                              Je = 70
                              break
                            }
                            if (
                              ((w = ((w + 1) | 0) % (g | 0) | 0),
                              (nt = (he + (w << 3)) | 0),
                              (u[nt >> 2] | 0) == (E | 0) &&
                                (u[(nt + 4) >> 2] | 0) == (I | 0))
                            )
                              break
                            h = (h + 1) | 0
                          }
                          if (
                            (Je | 0) == 70 &&
                            ((Je = 0),
                            !0 & (((U & 117440512) | 0) == 100663296))
                          )
                            break
                          ;(nt = (f + (v << 3)) | 0),
                            (u[nt >> 2] = H),
                            (u[(nt + 4) >> 2] = b),
                            (v = (v + 1) | 0)
                        }
                      while (0)
                      if (((l = (l + 1) | 0), (l | 0) >= (g | 0))) {
                        g = fe
                        break t
                      }
                      ;(b = (ct + (l << 3)) | 0),
                        (H = u[b >> 2] | 0),
                        (b = u[(b + 4) >> 2] | 0)
                    }
                  for (l = 0, v = 0; ; ) {
                    do
                      if (!(((H | 0) == 0) & ((b | 0) == 0))) {
                        if (
                          ((I = $e(H | 0, b | 0, 52) | 0),
                          ce() | 0,
                          (I = I & 15),
                          (I | 0) >= (He | 0))
                        )
                          if ((I | 0) != (He | 0))
                            if (
                              ((h = H | re),
                              (w = (b & -15728641) | me),
                              I >>> 0 < we >>> 0)
                            )
                              I = w
                            else {
                              E = He
                              do
                                (nt = rt(7, 0, (((14 - E) | 0) * 3) | 0) | 0),
                                  (E = (E + 1) | 0),
                                  (h = nt | h),
                                  (w = ce() | 0 | w)
                              while (E >>> 0 < I >>> 0)
                              I = w
                            }
                          else (h = H), (I = b)
                        else (h = 0), (I = 0)
                        for (
                          E = to(h | 0, I | 0, g | 0, Pe | 0) | 0,
                            ce() | 0,
                            w = 0;
                          ;

                        ) {
                          if ((w | 0) > (g | 0)) {
                            Je = 98
                            break e
                          }
                          if (
                            ((nt = (he + (E << 3)) | 0),
                            (U = u[(nt + 4) >> 2] | 0),
                            ((U & -117440513) | 0) == (I | 0) &&
                              (u[nt >> 2] | 0) == (h | 0))
                          ) {
                            Je = 93
                            break
                          }
                          if (
                            ((E = ((E + 1) | 0) % (g | 0) | 0),
                            (nt = (he + (E << 3)) | 0),
                            (u[nt >> 2] | 0) == (h | 0) &&
                              (u[(nt + 4) >> 2] | 0) == (I | 0))
                          )
                            break
                          w = (w + 1) | 0
                        }
                        if (
                          (Je | 0) == 93 &&
                          ((Je = 0), !0 & (((U & 117440512) | 0) == 100663296))
                        )
                          break
                        ;(nt = (f + (v << 3)) | 0),
                          (u[nt >> 2] = H),
                          (u[(nt + 4) >> 2] = b),
                          (v = (v + 1) | 0)
                      }
                    while (0)
                    if (((l = (l + 1) | 0), (l | 0) >= (g | 0))) {
                      g = fe
                      break t
                    }
                    ;(b = (ct + (l << 3)) | 0),
                      (H = u[b >> 2] | 0),
                      (b = u[(b + 4) >> 2] | 0)
                  }
                } else (v = 0), (g = fe)
              } else (v = 0), (g = 0)
            while (0)
            if (
              (Cr(he | 0, 0, ot | 0) | 0,
              lf(ct | 0, Ie | 0, (g << 3) | 0) | 0,
              Lt(Ie),
              g)
            )
              f = (f + (v << 3)) | 0
            else break
          }
          return (Je | 0) == 41
            ? (Lt(ct), Lt(he), (nt = -1), nt | 0)
            : (Je | 0) == 51
            ? (Lt(ct), Lt(he), (nt = -2), nt | 0)
            : (Je | 0) == 58
            ? (Lt(ct), Lt(he), (nt = -3), nt | 0)
            : (Je | 0) == 98
            ? (Lt(Ie), Lt(ct), Lt(he), (nt = -1), nt | 0)
            : ((Je | 0) == 99 && lf(f | 0, ct | 0, (g << 3) | 0) | 0,
              Lt(ct),
              Lt(he),
              (nt = 0),
              nt | 0)
        }
        function oS(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0
          if ((f | 0) <= 0) return (v = 0), v | 0
          if ((v | 0) >= 16) {
            for (w = 0; ; ) {
              if (
                ((H = (l + (w << 3)) | 0),
                !(((u[H >> 2] | 0) == 0) & ((u[(H + 4) >> 2] | 0) == 0)))
              ) {
                w = 14
                break
              }
              if (((w = (w + 1) | 0), (w | 0) >= (f | 0))) {
                ;(b = 0), (w = 16)
                break
              }
            }
            if ((w | 0) == 14) return ((g | 0) > 0 ? -2 : -1) | 0
            if ((w | 0) == 16) return b | 0
          }
          ;(w = 0), (H = 0)
          e: for (;;) {
            ;(U = (l + (H << 3)) | 0),
              (E = U),
              (b = u[E >> 2] | 0),
              (E = u[(E + 4) >> 2] | 0)
            do
              if (!(((b | 0) == 0) & ((E | 0) == 0))) {
                if ((w | 0) >= (g | 0)) {
                  ;(b = -1), (w = 16)
                  break e
                }
                if (
                  ((I = $e(b | 0, E | 0, 52) | 0),
                  ce() | 0,
                  (I = I & 15),
                  (I | 0) > (v | 0))
                ) {
                  ;(b = -2), (w = 16)
                  break e
                }
                if ((I | 0) == (v | 0)) {
                  ;(U = (h + (w << 3)) | 0),
                    (u[U >> 2] = b),
                    (u[(U + 4) >> 2] = E),
                    (w = (w + 1) | 0)
                  break
                }
                if (
                  ((b = ((sf(7, (v - I) | 0) | 0) + w) | 0), (b | 0) > (g | 0))
                ) {
                  ;(b = -1), (w = 16)
                  break e
                }
                Ii(u[U >> 2] | 0, u[(U + 4) >> 2] | 0, v, (h + (w << 3)) | 0),
                  (w = b)
              }
            while (0)
            if (((H = (H + 1) | 0), (H | 0) >= (f | 0))) {
              ;(b = 0), (w = 16)
              break
            }
          }
          return (w | 0) == 16 ? b | 0 : 0
        }
        function aS(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0
          if ((f | 0) <= 0) return (h = 0), h | 0
          if ((h | 0) >= 16) {
            for (g = 0; ; ) {
              if (
                ((b = (l + (g << 3)) | 0),
                !(((u[b >> 2] | 0) == 0) & ((u[(b + 4) >> 2] | 0) == 0)))
              ) {
                ;(g = -1), (v = 13)
                break
              }
              if (((g = (g + 1) | 0), (g | 0) >= (f | 0))) {
                ;(g = 0), (v = 13)
                break
              }
            }
            if ((v | 0) == 13) return g | 0
          }
          ;(g = 0), (b = 0)
          e: for (;;) {
            ;(v = (l + (b << 3)) | 0),
              (w = u[v >> 2] | 0),
              (v = u[(v + 4) >> 2] | 0)
            do
              if (!(((w | 0) == 0) & ((v | 0) == 0))) {
                if (
                  ((v = $e(w | 0, v | 0, 52) | 0),
                  ce() | 0,
                  (v = v & 15),
                  (v | 0) > (h | 0))
                ) {
                  ;(g = -1), (v = 13)
                  break e
                }
                if ((v | 0) == (h | 0)) {
                  g = (g + 1) | 0
                  break
                } else {
                  g = ((sf(7, (h - v) | 0) | 0) + g) | 0
                  break
                }
              }
            while (0)
            if (((b = (b + 1) | 0), (b | 0) >= (f | 0))) {
              v = 13
              break
            }
          }
          return (v | 0) == 13 ? g | 0 : 0
        }
        function lS(l, f) {
          return (
            (l = l | 0),
            (f = f | 0),
            (f = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (f & 1) | 0
          )
        }
        function Bi(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0
          if (((v = $e(l | 0, f | 0, 52) | 0), ce() | 0, (v = v & 15), !v))
            return (v = 0), v | 0
          for (g = 1; ; ) {
            if (
              ((h = $e(l | 0, f | 0, (((15 - g) | 0) * 3) | 0) | 0),
              ce() | 0,
              (h = h & 7),
              h | 0)
            ) {
              g = 5
              break
            }
            if (g >>> 0 < v >>> 0) g = (g + 1) | 0
            else {
              ;(h = 0), (g = 5)
              break
            }
          }
          return (g | 0) == 5 ? h | 0 : 0
        }
        function cp(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0
          if (((I = $e(l | 0, f | 0, 52) | 0), ce() | 0, (I = I & 15), !I))
            return (E = f), (I = l), Ct(E | 0), I | 0
          for (E = 1, h = 0; ; ) {
            ;(w = (((15 - E) | 0) * 3) | 0),
              (g = rt(7, 0, w | 0) | 0),
              (v = ce() | 0),
              (b = $e(l | 0, f | 0, w | 0) | 0),
              ce() | 0,
              (w = rt(Ko(b & 7) | 0, 0, w | 0) | 0),
              (b = ce() | 0),
              (l = w | (l & ~g)),
              (f = b | (f & ~v))
            e: do
              if (!h)
                if ((((w & g) | 0) == 0) & (((b & v) | 0) == 0)) h = 0
                else if (
                  ((g = $e(l | 0, f | 0, 52) | 0), ce() | 0, (g = g & 15), !g)
                )
                  h = 1
                else {
                  h = 1
                  t: for (;;) {
                    switch (
                      ((b = $e(l | 0, f | 0, (((15 - h) | 0) * 3) | 0) | 0),
                      ce() | 0,
                      b & 7)
                    ) {
                      case 1:
                        break t
                      case 0:
                        break
                      default: {
                        h = 1
                        break e
                      }
                    }
                    if (h >>> 0 < g >>> 0) h = (h + 1) | 0
                    else {
                      h = 1
                      break e
                    }
                  }
                  for (h = 1; ; )
                    if (
                      ((b = (((15 - h) | 0) * 3) | 0),
                      (v = $e(l | 0, f | 0, b | 0) | 0),
                      ce() | 0,
                      (w = rt(7, 0, b | 0) | 0),
                      (f = f & ~(ce() | 0)),
                      (b = rt(Ko(v & 7) | 0, 0, b | 0) | 0),
                      (l = (l & ~w) | b),
                      (f = f | (ce() | 0)),
                      h >>> 0 < g >>> 0)
                    )
                      h = (h + 1) | 0
                    else {
                      h = 1
                      break
                    }
                }
            while (0)
            if (E >>> 0 < I >>> 0) E = (E + 1) | 0
            else break
          }
          return Ct(f | 0), l | 0
        }
        function eo(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0
          if (((g = $e(l | 0, f | 0, 52) | 0), ce() | 0, (g = g & 15), !g))
            return (h = f), (g = l), Ct(h | 0), g | 0
          for (
            h = 1;
            (w = (((15 - h) | 0) * 3) | 0),
              (b = $e(l | 0, f | 0, w | 0) | 0),
              ce() | 0,
              (v = rt(7, 0, w | 0) | 0),
              (f = f & ~(ce() | 0)),
              (w = rt(Ko(b & 7) | 0, 0, w | 0) | 0),
              (l = w | (l & ~v)),
              (f = ce() | 0 | f),
              h >>> 0 < g >>> 0;

          )
            h = (h + 1) | 0
          return Ct(f | 0), l | 0
        }
        function cS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0
          if (((I = $e(l | 0, f | 0, 52) | 0), ce() | 0, (I = I & 15), !I))
            return (E = f), (I = l), Ct(E | 0), I | 0
          for (E = 1, h = 0; ; ) {
            ;(w = (((15 - E) | 0) * 3) | 0),
              (g = rt(7, 0, w | 0) | 0),
              (v = ce() | 0),
              (b = $e(l | 0, f | 0, w | 0) | 0),
              ce() | 0,
              (w = rt(Ks(b & 7) | 0, 0, w | 0) | 0),
              (b = ce() | 0),
              (l = w | (l & ~g)),
              (f = b | (f & ~v))
            e: do
              if (!h)
                if ((((w & g) | 0) == 0) & (((b & v) | 0) == 0)) h = 0
                else if (
                  ((g = $e(l | 0, f | 0, 52) | 0), ce() | 0, (g = g & 15), !g)
                )
                  h = 1
                else {
                  h = 1
                  t: for (;;) {
                    switch (
                      ((b = $e(l | 0, f | 0, (((15 - h) | 0) * 3) | 0) | 0),
                      ce() | 0,
                      b & 7)
                    ) {
                      case 1:
                        break t
                      case 0:
                        break
                      default: {
                        h = 1
                        break e
                      }
                    }
                    if (h >>> 0 < g >>> 0) h = (h + 1) | 0
                    else {
                      h = 1
                      break e
                    }
                  }
                  for (h = 1; ; )
                    if (
                      ((v = (((15 - h) | 0) * 3) | 0),
                      (w = rt(7, 0, v | 0) | 0),
                      (b = f & ~(ce() | 0)),
                      (f = $e(l | 0, f | 0, v | 0) | 0),
                      ce() | 0,
                      (f = rt(Ks(f & 7) | 0, 0, v | 0) | 0),
                      (l = (l & ~w) | f),
                      (f = b | (ce() | 0)),
                      h >>> 0 < g >>> 0)
                    )
                      h = (h + 1) | 0
                    else {
                      h = 1
                      break
                    }
                }
            while (0)
            if (E >>> 0 < I >>> 0) E = (E + 1) | 0
            else break
          }
          return Ct(f | 0), l | 0
        }
        function Ap(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0
          if (((g = $e(l | 0, f | 0, 52) | 0), ce() | 0, (g = g & 15), !g))
            return (h = f), (g = l), Ct(h | 0), g | 0
          for (
            h = 1;
            (b = (((15 - h) | 0) * 3) | 0),
              (w = rt(7, 0, b | 0) | 0),
              (v = f & ~(ce() | 0)),
              (f = $e(l | 0, f | 0, b | 0) | 0),
              ce() | 0,
              (f = rt(Ks(f & 7) | 0, 0, b | 0) | 0),
              (l = f | (l & ~w)),
              (f = ce() | 0 | v),
              h >>> 0 < g >>> 0;

          )
            h = (h + 1) | 0
          return Ct(f | 0), l | 0
        }
        function AS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0
          if (
            ((I = ie),
            (ie = (ie + 64) | 0),
            (E = (I + 40) | 0),
            (g = (I + 24) | 0),
            (v = (I + 12) | 0),
            (w = I),
            rt(f | 0, 0, 52) | 0,
            (h = ce() | 0 | 134225919),
            !f)
          )
            return (u[(l + 4) >> 2] | 0) > 2 ||
              (u[(l + 8) >> 2] | 0) > 2 ||
              (u[(l + 12) >> 2] | 0) > 2
              ? ((b = 0), (E = 0), Ct(b | 0), (ie = I), E | 0)
              : (rt(dy(l) | 0, 0, 45) | 0,
                (b = ce() | 0 | h),
                (E = -1),
                Ct(b | 0),
                (ie = I),
                E | 0)
          if (
            ((u[E >> 2] = u[l >> 2]),
            (u[(E + 4) >> 2] = u[(l + 4) >> 2]),
            (u[(E + 8) >> 2] = u[(l + 8) >> 2]),
            (u[(E + 12) >> 2] = u[(l + 12) >> 2]),
            (b = (E + 4) | 0),
            (f | 0) > 0)
          )
            for (
              l = -1;
              (u[g >> 2] = u[b >> 2]),
                (u[(g + 4) >> 2] = u[(b + 4) >> 2]),
                (u[(g + 8) >> 2] = u[(b + 8) >> 2]),
                f & 1
                  ? (vy(b),
                    (u[v >> 2] = u[b >> 2]),
                    (u[(v + 4) >> 2] = u[(b + 4) >> 2]),
                    (u[(v + 8) >> 2] = u[(b + 8) >> 2]),
                    tf(v))
                  : (op(b),
                    (u[v >> 2] = u[b >> 2]),
                    (u[(v + 4) >> 2] = u[(b + 4) >> 2]),
                    (u[(v + 8) >> 2] = u[(b + 8) >> 2]),
                    Jo(v)),
                sp(g, v, w),
                ui(w),
                (H = (((15 - f) | 0) * 3) | 0),
                (U = rt(7, 0, H | 0) | 0),
                (h = h & ~(ce() | 0)),
                (H = rt(ef(w) | 0, 0, H | 0) | 0),
                (l = H | (l & ~U)),
                (h = ce() | 0 | h),
                (f | 0) > 1;

            )
              f = (f + -1) | 0
          else l = -1
          e: do
            if (
              (u[b >> 2] | 0) <= 2 &&
              (u[(E + 8) >> 2] | 0) <= 2 &&
              (u[(E + 12) >> 2] | 0) <= 2
            ) {
              if (
                ((g = dy(E) | 0),
                (f = rt(g | 0, 0, 45) | 0),
                (f = f | l),
                (l = ce() | 0 | (h & -1040385)),
                (w = EM(E) | 0),
                !(vn(g) | 0))
              ) {
                if ((w | 0) <= 0) break
                for (v = 0; ; ) {
                  if (
                    ((g = $e(f | 0, l | 0, 52) | 0), ce() | 0, (g = g & 15), g)
                  )
                    for (
                      h = 1;
                      (H = (((15 - h) | 0) * 3) | 0),
                        (E = $e(f | 0, l | 0, H | 0) | 0),
                        ce() | 0,
                        (U = rt(7, 0, H | 0) | 0),
                        (l = l & ~(ce() | 0)),
                        (H = rt(Ko(E & 7) | 0, 0, H | 0) | 0),
                        (f = (f & ~U) | H),
                        (l = l | (ce() | 0)),
                        h >>> 0 < g >>> 0;

                    )
                      h = (h + 1) | 0
                  if (((v = (v + 1) | 0), (v | 0) == (w | 0))) break e
                }
              }
              ;(v = $e(f | 0, l | 0, 52) | 0), ce() | 0, (v = v & 15)
              t: do
                if (v) {
                  h = 1
                  n: for (;;) {
                    switch (
                      ((H = $e(f | 0, l | 0, (((15 - h) | 0) * 3) | 0) | 0),
                      ce() | 0,
                      H & 7)
                    ) {
                      case 1:
                        break n
                      case 0:
                        break
                      default:
                        break t
                    }
                    if (h >>> 0 < v >>> 0) h = (h + 1) | 0
                    else break t
                  }
                  if (py(g, u[E >> 2] | 0) | 0)
                    for (
                      h = 1;
                      (E = (((15 - h) | 0) * 3) | 0),
                        (U = rt(7, 0, E | 0) | 0),
                        (H = l & ~(ce() | 0)),
                        (l = $e(f | 0, l | 0, E | 0) | 0),
                        ce() | 0,
                        (l = rt(Ks(l & 7) | 0, 0, E | 0) | 0),
                        (f = (f & ~U) | l),
                        (l = H | (ce() | 0)),
                        h >>> 0 < v >>> 0;

                    )
                      h = (h + 1) | 0
                  else
                    for (
                      h = 1;
                      (H = (((15 - h) | 0) * 3) | 0),
                        (E = $e(f | 0, l | 0, H | 0) | 0),
                        ce() | 0,
                        (U = rt(7, 0, H | 0) | 0),
                        (l = l & ~(ce() | 0)),
                        (H = rt(Ko(E & 7) | 0, 0, H | 0) | 0),
                        (f = (f & ~U) | H),
                        (l = l | (ce() | 0)),
                        h >>> 0 < v >>> 0;

                    )
                      h = (h + 1) | 0
                }
              while (0)
              if ((w | 0) > 0) {
                h = 0
                do (f = cp(f, l) | 0), (l = ce() | 0), (h = (h + 1) | 0)
                while ((h | 0) != (w | 0))
              }
            } else (f = 0), (l = 0)
          while (0)
          return (U = l), (H = f), Ct(U | 0), (ie = I), H | 0
        }
        function ur(l) {
          return (l = l | 0), (l | 0) % 2 | 0 | 0
        }
        function Ly(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0
          return (
            (g = ie),
            (ie = (ie + 16) | 0),
            (h = g),
            f >>> 0 <= 15 &&
            ((u[(l + 4) >> 2] & 2146435072) | 0) != 2146435072 &&
            ((u[(l + 8 + 4) >> 2] & 2146435072) | 0) != 2146435072
              ? (qM(l, f, h), (f = AS(h, f) | 0), (l = ce() | 0))
              : ((l = 0), (f = 0)),
            Ct(l | 0),
            (ie = g),
            f | 0
          )
        }
        function up(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0
          if (
            ((v = (h + 4) | 0),
            (w = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (w = w & 15),
            (b = $e(l | 0, f | 0, 45) | 0),
            ce() | 0,
            (g = (w | 0) == 0),
            vn(b & 127) | 0)
          ) {
            if (g) return (b = 1), b | 0
            g = 1
          } else {
            if (g) return (b = 0), b | 0
            ;(u[v >> 2] | 0) == 0 && (u[(h + 8) >> 2] | 0) == 0
              ? (g = ((u[(h + 12) >> 2] | 0) != 0) & 1)
              : (g = 1)
          }
          for (
            h = 1;
            h & 1 ? tf(v) : Jo(v),
              (b = $e(l | 0, f | 0, (((15 - h) | 0) * 3) | 0) | 0),
              ce() | 0,
              _y(v, b & 7),
              h >>> 0 < w >>> 0;

          )
            h = (h + 1) | 0
          return g | 0
        }
        function Zc(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0
          ;(H = ie),
            (ie = (ie + 16) | 0),
            (I = H),
            (U = $e(l | 0, f | 0, 45) | 0),
            ce() | 0,
            (U = U & 127)
          e: do
            if (
              (vn(U) | 0) != 0 &&
              ((w = $e(l | 0, f | 0, 52) | 0),
              ce() | 0,
              (w = w & 15),
              (w | 0) != 0)
            ) {
              g = 1
              t: for (;;) {
                switch (
                  ((E = $e(l | 0, f | 0, (((15 - g) | 0) * 3) | 0) | 0),
                  ce() | 0,
                  E & 7)
                ) {
                  case 5:
                    break t
                  case 0:
                    break
                  default: {
                    g = f
                    break e
                  }
                }
                if (g >>> 0 < w >>> 0) g = (g + 1) | 0
                else {
                  g = f
                  break e
                }
              }
              for (
                v = 1, g = f;
                (f = (((15 - v) | 0) * 3) | 0),
                  (b = rt(7, 0, f | 0) | 0),
                  (E = g & ~(ce() | 0)),
                  (g = $e(l | 0, g | 0, f | 0) | 0),
                  ce() | 0,
                  (g = rt(Ks(g & 7) | 0, 0, f | 0) | 0),
                  (l = (l & ~b) | g),
                  (g = E | (ce() | 0)),
                  v >>> 0 < w >>> 0;

              )
                v = (v + 1) | 0
            } else g = f
          while (0)
          if (
            ((E = (7728 + ((U * 28) | 0)) | 0),
            (u[h >> 2] = u[E >> 2]),
            (u[(h + 4) >> 2] = u[(E + 4) >> 2]),
            (u[(h + 8) >> 2] = u[(E + 8) >> 2]),
            (u[(h + 12) >> 2] = u[(E + 12) >> 2]),
            !(up(l, g, h) | 0))
          ) {
            ie = H
            return
          }
          if (
            ((b = (h + 4) | 0),
            (u[I >> 2] = u[b >> 2]),
            (u[(I + 4) >> 2] = u[(b + 4) >> 2]),
            (u[(I + 8) >> 2] = u[(b + 8) >> 2]),
            (w = $e(l | 0, g | 0, 52) | 0),
            ce() | 0,
            (E = w & 15),
            w & 1 ? (Jo(b), (w = (E + 1) | 0)) : (w = E),
            !(vn(U) | 0))
          )
            g = 0
          else {
            e: do
              if (!E) g = 0
              else
                for (f = 1; ; ) {
                  if (
                    ((v = $e(l | 0, g | 0, (((15 - f) | 0) * 3) | 0) | 0),
                    ce() | 0,
                    (v = v & 7),
                    v | 0)
                  ) {
                    g = v
                    break e
                  }
                  if (f >>> 0 < E >>> 0) f = (f + 1) | 0
                  else {
                    g = 0
                    break
                  }
                }
            while (0)
            g = ((g | 0) == 4) & 1
          }
          if (!(ll(h, w, g, 0) | 0))
            (w | 0) != (E | 0) &&
              ((u[b >> 2] = u[I >> 2]),
              (u[(b + 4) >> 2] = u[(I + 4) >> 2]),
              (u[(b + 8) >> 2] = u[(I + 8) >> 2]))
          else {
            if (vn(U) | 0)
              do;
              while ((ll(h, w, 0, 0) | 0) != 0)
            ;(w | 0) != (E | 0) && op(b)
          }
          ie = H
        }
        function ea(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0
          ;(g = ie),
            (ie = (ie + 16) | 0),
            (v = g),
            Zc(l, f, v),
            (f = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            NM(v, f & 15, h),
            (ie = g)
        }
        function ta(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(b = ie),
            (ie = (ie + 16) | 0),
            (w = b),
            Zc(l, f, w),
            (g = $e(l | 0, f | 0, 45) | 0),
            ce() | 0,
            (g = (vn(g & 127) | 0) == 0),
            (v = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (v = v & 15)
          e: do
            if (!g) {
              if (v | 0)
                for (g = 1; ; ) {
                  if (
                    ((E = rt(7, 0, (((15 - g) | 0) * 3) | 0) | 0),
                    !((((E & l) | 0) == 0) & ((((ce() | 0) & f) | 0) == 0)))
                  )
                    break e
                  if (g >>> 0 < v >>> 0) g = (g + 1) | 0
                  else break
                }
              Sy(w, v, 0, 5, h), (ie = b)
              return
            }
          while (0)
          Ty(w, v, 0, 6, h), (ie = b)
        }
        function uS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0
          if (((g = $e(l | 0, f | 0, 45) | 0), ce() | 0, !(vn(g & 127) | 0)))
            return (g = 2), g | 0
          if (((g = $e(l | 0, f | 0, 52) | 0), ce() | 0, (g = g & 15), !g))
            return (g = 5), g | 0
          for (h = 1; ; ) {
            if (
              ((v = rt(7, 0, (((15 - h) | 0) * 3) | 0) | 0),
              !((((v & l) | 0) == 0) & ((((ce() | 0) & f) | 0) == 0)))
            ) {
              ;(h = 2), (l = 6)
              break
            }
            if (h >>> 0 < g >>> 0) h = (h + 1) | 0
            else {
              ;(h = 5), (l = 6)
              break
            }
          }
          return (l | 0) == 6 ? h | 0 : 0
        }
        function Dy(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0
          ;(re = ie),
            (ie = (ie + 128) | 0),
            (U = (re + 112) | 0),
            (w = (re + 96) | 0),
            (H = re),
            (v = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (E = v & 15),
            (u[U >> 2] = E),
            (b = $e(l | 0, f | 0, 45) | 0),
            ce() | 0,
            (b = b & 127)
          e: do
            if (vn(b) | 0) {
              if (E | 0)
                for (g = 1; ; ) {
                  if (
                    ((I = rt(7, 0, (((15 - g) | 0) * 3) | 0) | 0),
                    !((((I & l) | 0) == 0) & ((((ce() | 0) & f) | 0) == 0)))
                  ) {
                    v = 0
                    break e
                  }
                  if (g >>> 0 < E >>> 0) g = (g + 1) | 0
                  else break
                }
              if (v & 1) v = 1
              else {
                ;(I = rt((E + 1) | 0, 0, 52) | 0),
                  (H = ce() | 0 | (f & -15728641)),
                  (U = rt(7, 0, (((14 - E) | 0) * 3) | 0) | 0),
                  Dy((I | l) & ~U, H & ~(ce() | 0), h),
                  (ie = re)
                return
              }
            } else v = 0
          while (0)
          Zc(l, f, w), v ? (Ey(w, U, H), (I = 5)) : (Cy(w, U, H), (I = 6))
          e: do
            if (vn(b) | 0)
              if (!E) g = 20
              else
                for (g = 1; ; ) {
                  if (
                    ((b = rt(7, 0, (((15 - g) | 0) * 3) | 0) | 0),
                    !((((b & l) | 0) == 0) & ((((ce() | 0) & f) | 0) == 0)))
                  ) {
                    g = 8
                    break e
                  }
                  if (g >>> 0 < E >>> 0) g = (g + 1) | 0
                  else {
                    g = 20
                    break
                  }
                }
            else g = 8
          while (0)
          if ((Cr(h | 0, -1, g | 0) | 0, v)) {
            v = 0
            do {
              for (
                w = (H + (v << 4)) | 0,
                  UM(w, u[U >> 2] | 0) | 0,
                  w = u[w >> 2] | 0,
                  g = 0;
                (b = (h + (g << 2)) | 0),
                  (E = u[b >> 2] | 0),
                  !(((E | 0) == -1) | ((E | 0) == (w | 0)));

              )
                g = (g + 1) | 0
              ;(u[b >> 2] = w), (v = (v + 1) | 0)
            } while ((v | 0) != (I | 0))
          } else {
            v = 0
            do {
              for (
                w = (H + (v << 4)) | 0,
                  ll(w, u[U >> 2] | 0, 0, 1) | 0,
                  w = u[w >> 2] | 0,
                  g = 0;
                (b = (h + (g << 2)) | 0),
                  (E = u[b >> 2] | 0),
                  !(((E | 0) == -1) | ((E | 0) == (w | 0)));

              )
                g = (g + 1) | 0
              ;(u[b >> 2] = w), (v = (v + 1) | 0)
            } while ((v | 0) != (I | 0))
          }
          ie = re
        }
        function fS() {
          return 12
        }
        function fp(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0
          if ((rt(l | 0, 0, 52) | 0, (E = ce() | 0 | 134225919), (l | 0) < 1)) {
            ;(g = 0), (h = 0)
            do
              vn(g) | 0 &&
                (rt(g | 0, 0, 45) | 0,
                (b = E | (ce() | 0)),
                (l = (f + (h << 3)) | 0),
                (u[l >> 2] = -1),
                (u[(l + 4) >> 2] = b),
                (h = (h + 1) | 0)),
                (g = (g + 1) | 0)
            while ((g | 0) != 122)
            return
          }
          ;(b = 0), (h = 0)
          do {
            if (vn(b) | 0) {
              for (
                rt(b | 0, 0, 45) | 0, g = 1, v = -1, w = E | (ce() | 0);
                (I = rt(7, 0, (((15 - g) | 0) * 3) | 0) | 0),
                  (v = v & ~I),
                  (w = w & ~(ce() | 0)),
                  (g | 0) != (l | 0);

              )
                g = (g + 1) | 0
              ;(I = (f + (h << 3)) | 0),
                (u[I >> 2] = v),
                (u[(I + 4) >> 2] = w),
                (h = (h + 1) | 0)
            }
            b = (b + 1) | 0
          } while ((b | 0) != 122)
        }
        function Iy(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0
          if (
            ((E = ie),
            (ie = (ie + 64) | 0),
            (b = E),
            (((l | 0) == (h | 0)) & ((f | 0) == (g | 0))) |
              (!1 |
                (((f & 2013265920) | 0) != 134217728) |
                (!1 | (((g & 2013265920) | 0) != 134217728))) ||
              ((v = $e(l | 0, f | 0, 52) | 0),
              ce() | 0,
              (v = v & 15),
              (w = $e(h | 0, g | 0, 52) | 0),
              ce() | 0,
              (v | 0) != ((w & 15) | 0)))
          )
            return (b = 0), (ie = E), b | 0
          if (
            ((w = (v + -1) | 0),
            v >>> 0 > 1 &&
              ((U = lp(l, f, w) | 0),
              (I = ce() | 0),
              (w = lp(h, g, w) | 0),
              ((U | 0) == (w | 0)) & ((I | 0) == (ce() | 0))) &&
              ((w = ((v ^ 15) * 3) | 0),
              (v = $e(l | 0, f | 0, w | 0) | 0),
              ce() | 0,
              (v = v & 7),
              (w = $e(h | 0, g | 0, w | 0) | 0),
              ce() | 0,
              (w = w & 7),
              ((v | 0) == 0) | ((w | 0) == 0) ||
                (u[(21136 + (v << 2)) >> 2] | 0) == (w | 0) ||
                (u[(21168 + (v << 2)) >> 2] | 0) == (w | 0)))
          )
            return (U = 1), (ie = E), U | 0
          ;(v = b), (w = (v + 56) | 0)
          do (u[v >> 2] = 0), (v = (v + 4) | 0)
          while ((v | 0) < (w | 0))
          return (
            fy(l, f, 1, b),
            (U = b),
            !((u[U >> 2] | 0) == (h | 0) && (u[(U + 4) >> 2] | 0) == (g | 0)) &&
            ((U = (b + 8) | 0),
            !(
              (u[U >> 2] | 0) == (h | 0) && (u[(U + 4) >> 2] | 0) == (g | 0)
            )) &&
            ((U = (b + 16) | 0),
            !(
              (u[U >> 2] | 0) == (h | 0) && (u[(U + 4) >> 2] | 0) == (g | 0)
            )) &&
            ((U = (b + 24) | 0),
            !(
              (u[U >> 2] | 0) == (h | 0) && (u[(U + 4) >> 2] | 0) == (g | 0)
            )) &&
            ((U = (b + 32) | 0),
            !(
              (u[U >> 2] | 0) == (h | 0) && (u[(U + 4) >> 2] | 0) == (g | 0)
            )) &&
            ((U = (b + 40) | 0),
            !((u[U >> 2] | 0) == (h | 0) && (u[(U + 4) >> 2] | 0) == (g | 0)))
              ? ((v = (b + 48) | 0),
                (v =
                  ((u[v >> 2] | 0) == (h | 0)
                    ? (u[(v + 4) >> 2] | 0) == (g | 0)
                    : 0) & 1))
              : (v = 1),
            (U = v),
            (ie = E),
            U | 0
          )
        }
        function hS(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0
          if (((U = ie), (ie = (ie + 16) | 0), (b = U), !(Iy(l, f, h, g) | 0)))
            return (E = 0), (I = 0), Ct(E | 0), (ie = U), I | 0
          for (
            E = f & -2130706433, v = (jn(l, f) | 0) == 0, v = v ? 1 : 2;
            (u[b >> 2] = 0),
              (H = Un(l, f, v, b) | 0),
              (w = (v + 1) | 0),
              !(((H | 0) == (h | 0)) & ((ce() | 0) == (g | 0)));

          )
            if (w >>> 0 < 7) v = w
            else {
              ;(v = 0), (l = 0), (I = 6)
              break
            }
          return (I | 0) == 6
            ? (Ct(v | 0), (ie = U), l | 0)
            : ((H = rt(v | 0, 0, 56) | 0),
              (I = E | (ce() | 0) | 268435456),
              (H = l | H),
              Ct(I | 0),
              (ie = U),
              H | 0)
        }
        function dS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0
          return (
            (h = !0 & (((f & 2013265920) | 0) == 268435456)),
            Ct((h ? (f & -2130706433) | 134217728 : 0) | 0),
            (h ? l : 0) | 0
          )
        }
        function pS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0
          return (
            (g = ie),
            (ie = (ie + 16) | 0),
            (h = g),
            !0 & (((f & 2013265920) | 0) == 268435456)
              ? ((v = $e(l | 0, f | 0, 56) | 0),
                ce() | 0,
                (u[h >> 2] = 0),
                (h = Un(l, (f & -2130706433) | 134217728, v & 7, h) | 0),
                (f = ce() | 0),
                Ct(f | 0),
                (ie = g),
                h | 0)
              : ((f = 0), (h = 0), Ct(f | 0), (ie = g), h | 0)
          )
        }
        function mS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0
          if (!(!0 & (((f & 2013265920) | 0) == 268435456)))
            return (h = 0), h | 0
          switch (((h = $e(l | 0, f | 0, 56) | 0), ce() | 0, h & 7)) {
            case 0:
            case 7:
              return (h = 0), h | 0
          }
          return (
            (h = (f & -2130706433) | 134217728),
            !0 & (((f & 117440512) | 0) == 16777216) & ((jn(l, h) | 0) != 0)
              ? ((h = 0), h | 0)
              : ((h = Py(l, h) | 0), h | 0)
          )
        }
        function gS(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(w = ie),
            (ie = (ie + 16) | 0),
            (g = w),
            (b = !0 & (((f & 2013265920) | 0) == 268435456)),
            (v = (f & -2130706433) | 134217728),
            (E = h),
            (u[E >> 2] = b ? l : 0),
            (u[(E + 4) >> 2] = b ? v : 0),
            b
              ? ((f = $e(l | 0, f | 0, 56) | 0),
                ce() | 0,
                (u[g >> 2] = 0),
                (l = Un(l, v, f & 7, g) | 0),
                (f = ce() | 0))
              : ((l = 0), (f = 0)),
            (E = (h + 8) | 0),
            (u[E >> 2] = l),
            (u[(E + 4) >> 2] = f),
            (ie = w)
        }
        function yS(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0
          ;(v = (jn(l, f) | 0) == 0),
            (f = f & -2130706433),
            (g = h),
            (u[g >> 2] = v ? l : 0),
            (u[(g + 4) >> 2] = v ? f | 285212672 : 0),
            (g = (h + 8) | 0),
            (u[g >> 2] = l),
            (u[(g + 4) >> 2] = f | 301989888),
            (g = (h + 16) | 0),
            (u[g >> 2] = l),
            (u[(g + 4) >> 2] = f | 318767104),
            (g = (h + 24) | 0),
            (u[g >> 2] = l),
            (u[(g + 4) >> 2] = f | 335544320),
            (g = (h + 32) | 0),
            (u[g >> 2] = l),
            (u[(g + 4) >> 2] = f | 352321536),
            (h = (h + 40) | 0),
            (u[h >> 2] = l),
            (u[(h + 4) >> 2] = f | 369098752)
        }
        function rf(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          if (
            ((b = ie),
            (ie = (ie + 16) | 0),
            (w = b),
            (g = $e(l | 0, f | 0, 56) | 0),
            ce() | 0,
            (E = !0 & (((f & 2013265920) | 0) == 268435456)),
            (v = E ? l : 0),
            (l = E ? (f & -2130706433) | 134217728 : 0),
            (f = NS(v, l, g & 7) | 0),
            (f | 0) == -1)
          ) {
            ;(u[h >> 2] = 0), (ie = b)
            return
          }
          Zc(v, l, w),
            (g = $e(v | 0, l | 0, 52) | 0),
            ce() | 0,
            (g = g & 15),
            jn(v, l) | 0 ? Sy(w, g, f, 2, h) : Ty(w, g, f, 2, h),
            (ie = b)
        }
        function vS(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0
          return (
            (f = Tr(1, 12) | 0),
            f || Yt(22691, 22646, 49, 22704),
            (h = (l + 4) | 0),
            (g = u[h >> 2] | 0),
            g | 0
              ? ((g = (g + 8) | 0), (u[g >> 2] = f), (u[h >> 2] = f), f | 0)
              : (u[l >> 2] | 0 && Yt(22721, 22646, 61, 22744),
                (g = l),
                (u[g >> 2] = f),
                (u[h >> 2] = f),
                f | 0)
          )
        }
        function _S(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0
          return (
            (g = Vr(24) | 0),
            g || Yt(22758, 22646, 78, 22772),
            (u[g >> 2] = u[f >> 2]),
            (u[(g + 4) >> 2] = u[(f + 4) >> 2]),
            (u[(g + 8) >> 2] = u[(f + 8) >> 2]),
            (u[(g + 12) >> 2] = u[(f + 12) >> 2]),
            (u[(g + 16) >> 2] = 0),
            (f = (l + 4) | 0),
            (h = u[f >> 2] | 0),
            h | 0
              ? ((u[(h + 16) >> 2] = g), (u[f >> 2] = g), g | 0)
              : (u[l >> 2] | 0 && Yt(22787, 22646, 82, 22772),
                (u[l >> 2] = g),
                (u[f >> 2] = g),
                g | 0)
          )
        }
        function xS(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0
          if (!!l)
            for (g = 1; ; ) {
              if (((f = u[l >> 2] | 0), f | 0))
                do {
                  if (((h = u[f >> 2] | 0), h | 0))
                    do (v = h), (h = u[(h + 16) >> 2] | 0), Lt(v)
                    while ((h | 0) != 0)
                  ;(v = f), (f = u[(f + 8) >> 2] | 0), Lt(v)
                } while ((f | 0) != 0)
              if (((f = l), (l = u[(l + 8) >> 2] | 0), g || Lt(f), l)) g = 0
              else break
            }
        }
        function By(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0,
            He = 0,
            he = 0,
            ot = 0,
            ct = 0,
            Je = 0,
            nt = 0,
            Rt = 0,
            Zt = 0,
            Qt = 0,
            on = 0,
            Wt = 0,
            fn = 0,
            hn = 0,
            Mt = 0
          if (((v = (l + 8) | 0), u[v >> 2] | 0)) return (Mt = 1), Mt | 0
          if (((g = u[l >> 2] | 0), !g)) return (Mt = 0), Mt | 0
          ;(f = g), (h = 0)
          do (h = (h + 1) | 0), (f = u[(f + 8) >> 2] | 0)
          while ((f | 0) != 0)
          if (h >>> 0 < 2) return (Mt = 0), Mt | 0
          ;(fn = Vr(h << 2) | 0),
            fn || Yt(22807, 22646, 317, 22826),
            (Wt = Vr(h << 5) | 0),
            Wt || Yt(22848, 22646, 321, 22826),
            (u[l >> 2] = 0),
            (ct = (l + 4) | 0),
            (u[ct >> 2] = 0),
            (u[v >> 2] = 0),
            (h = 0),
            (on = 0),
            (ot = 0),
            (re = 0)
          e: for (;;) {
            if (((H = u[g >> 2] | 0), H)) {
              ;(w = 0), (b = H)
              do {
                if (
                  ((I = +Z[(b + 8) >> 3]),
                  (f = b),
                  (b = u[(b + 16) >> 2] | 0),
                  (U = (b | 0) == 0),
                  (v = U ? H : b),
                  (E = +Z[(v + 8) >> 3]),
                  +lt(+(I - E)) > 3.141592653589793)
                ) {
                  Mt = 14
                  break
                }
                w = w + (E - I) * (+Z[f >> 3] + +Z[v >> 3])
              } while (!U)
              if ((Mt | 0) == 14) {
                ;(Mt = 0), (w = 0), (f = H)
                do
                  (he = +Z[(f + 8) >> 3]),
                    (Qt = (f + 16) | 0),
                    (Zt = u[Qt >> 2] | 0),
                    (Zt = (Zt | 0) == 0 ? H : Zt),
                    (He = +Z[(Zt + 8) >> 3]),
                    (w =
                      w +
                      (+Z[f >> 3] + +Z[Zt >> 3]) *
                        ((He < 0 ? He + 6.283185307179586 : He) -
                          (he < 0 ? he + 6.283185307179586 : he))),
                    (f = u[((f | 0) == 0 ? g : Qt) >> 2] | 0)
                while ((f | 0) != 0)
              }
              w > 0
                ? ((u[(fn + (on << 2)) >> 2] = g),
                  (on = (on + 1) | 0),
                  (v = ot),
                  (f = re))
                : (Mt = 19)
            } else Mt = 19
            if ((Mt | 0) == 19) {
              Mt = 0
              do
                if (h) {
                  if (((f = (h + 8) | 0), u[f >> 2] | 0)) {
                    Mt = 21
                    break e
                  }
                  if (((h = Tr(1, 12) | 0), !h)) {
                    Mt = 23
                    break e
                  }
                  ;(u[f >> 2] = h), (v = (h + 4) | 0), (b = h), (f = re)
                } else if (re) {
                  ;(v = ct), (b = (re + 8) | 0), (f = g), (h = l)
                  break
                } else if (u[l >> 2] | 0) {
                  Mt = 27
                  break e
                } else {
                  ;(v = ct), (b = l), (f = g), (h = l)
                  break
                }
              while (0)
              if (
                ((u[b >> 2] = g),
                (u[v >> 2] = g),
                (b = (Wt + (ot << 5)) | 0),
                (U = u[g >> 2] | 0),
                U)
              ) {
                for (
                  H = (Wt + (ot << 5) + 8) | 0,
                    Z[H >> 3] = 17976931348623157e292,
                    re = (Wt + (ot << 5) + 24) | 0,
                    Z[re >> 3] = 17976931348623157e292,
                    Z[b >> 3] = -17976931348623157e292,
                    fe = (Wt + (ot << 5) + 16) | 0,
                    Z[fe >> 3] = -17976931348623157e292,
                    st = 17976931348623157e292,
                    we = -17976931348623157e292,
                    v = 0,
                    me = U,
                    I = 17976931348623157e292,
                    Ie = 17976931348623157e292,
                    Qe = -17976931348623157e292,
                    E = -17976931348623157e292;
                  (w = +Z[me >> 3]),
                    (he = +Z[(me + 8) >> 3]),
                    (me = u[(me + 16) >> 2] | 0),
                    (Pe = (me | 0) == 0),
                    (He = +Z[((Pe ? U : me) + 8) >> 3]),
                    w < I && ((Z[H >> 3] = w), (I = w)),
                    he < Ie && ((Z[re >> 3] = he), (Ie = he)),
                    w > Qe ? (Z[b >> 3] = w) : (w = Qe),
                    he > E && ((Z[fe >> 3] = he), (E = he)),
                    (st = (he > 0) & (he < st) ? he : st),
                    (we = (he < 0) & (he > we) ? he : we),
                    (v = v | (+lt(+(he - He)) > 3.141592653589793)),
                    !Pe;

                )
                  Qe = w
                v && ((Z[fe >> 3] = we), (Z[re >> 3] = st))
              } else
                (u[b >> 2] = 0),
                  (u[(b + 4) >> 2] = 0),
                  (u[(b + 8) >> 2] = 0),
                  (u[(b + 12) >> 2] = 0),
                  (u[(b + 16) >> 2] = 0),
                  (u[(b + 20) >> 2] = 0),
                  (u[(b + 24) >> 2] = 0),
                  (u[(b + 28) >> 2] = 0)
              v = (ot + 1) | 0
            }
            if (((Qt = (g + 8) | 0), (g = u[Qt >> 2] | 0), (u[Qt >> 2] = 0), g))
              (ot = v), (re = f)
            else {
              Mt = 45
              break
            }
          }
          if ((Mt | 0) == 21) Yt(22624, 22646, 35, 22658)
          else if ((Mt | 0) == 23) Yt(22678, 22646, 37, 22658)
          else if ((Mt | 0) == 27) Yt(22721, 22646, 61, 22744)
          else if ((Mt | 0) == 45) {
            e: do
              if ((on | 0) > 0) {
                for (
                  Qt = (v | 0) == 0,
                    Rt = v << 2,
                    Zt = (l | 0) == 0,
                    nt = 0,
                    f = 0;
                  ;

                ) {
                  if (((Je = u[(fn + (nt << 2)) >> 2] | 0), Qt)) Mt = 73
                  else {
                    if (((ot = Vr(Rt) | 0), !ot)) {
                      Mt = 50
                      break
                    }
                    if (((ct = Vr(Rt) | 0), !ct)) {
                      Mt = 52
                      break
                    }
                    t: do
                      if (Zt) h = 0
                      else {
                        for (
                          v = 0, h = 0, b = l;
                          (g = (Wt + (v << 5)) | 0),
                            ky(u[b >> 2] | 0, g, u[Je >> 2] | 0) | 0
                              ? ((u[(ot + (h << 2)) >> 2] = b),
                                (u[(ct + (h << 2)) >> 2] = g),
                                (Pe = (h + 1) | 0))
                              : (Pe = h),
                            (b = u[(b + 8) >> 2] | 0),
                            b;

                        )
                          (v = (v + 1) | 0), (h = Pe)
                        if ((Pe | 0) > 0)
                          if (((g = u[ot >> 2] | 0), (Pe | 0) == 1)) h = g
                          else
                            for (fe = 0, me = -1, h = g, re = g; ; ) {
                              for (
                                U = u[re >> 2] | 0, g = 0, b = 0;
                                (v = u[u[(ot + (b << 2)) >> 2] >> 2] | 0),
                                  (v | 0) == (U | 0)
                                    ? (H = g)
                                    : (H =
                                        (g +
                                          ((ky(
                                            v,
                                            u[(ct + (b << 2)) >> 2] | 0,
                                            u[U >> 2] | 0
                                          ) |
                                            0) &
                                            1)) |
                                        0),
                                  (b = (b + 1) | 0),
                                  (b | 0) != (Pe | 0);

                              )
                                g = H
                              if (
                                ((v = (H | 0) > (me | 0)),
                                (h = v ? re : h),
                                (g = (fe + 1) | 0),
                                (g | 0) == (Pe | 0))
                              )
                                break t
                              ;(fe = g),
                                (me = v ? H : me),
                                (re = u[(ot + (g << 2)) >> 2] | 0)
                            }
                        else h = 0
                      }
                    while (0)
                    if ((Lt(ot), Lt(ct), h)) {
                      if (((v = (h + 4) | 0), (g = u[v >> 2] | 0), g))
                        h = (g + 8) | 0
                      else if (u[h >> 2] | 0) {
                        Mt = 70
                        break
                      }
                      ;(u[h >> 2] = Je), (u[v >> 2] = Je)
                    } else Mt = 73
                  }
                  if ((Mt | 0) == 73) {
                    if (((Mt = 0), (f = u[Je >> 2] | 0), f | 0))
                      do (ct = f), (f = u[(f + 16) >> 2] | 0), Lt(ct)
                      while ((f | 0) != 0)
                    Lt(Je), (f = 2)
                  }
                  if (((nt = (nt + 1) | 0), (nt | 0) >= (on | 0))) {
                    hn = f
                    break e
                  }
                }
                ;(Mt | 0) == 50
                  ? Yt(22863, 22646, 249, 22882)
                  : (Mt | 0) == 52
                  ? Yt(22901, 22646, 252, 22882)
                  : (Mt | 0) == 70 && Yt(22721, 22646, 61, 22744)
              } else hn = 0
            while (0)
            return Lt(fn), Lt(Wt), (Mt = hn), Mt | 0
          }
          return 0
        }
        function ky(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0
          if (
            !(gy(f, h) | 0) ||
            ((f = my(f) | 0),
            (U = +Z[h >> 3]),
            (g = +Z[(h + 8) >> 3]),
            (g = f & (g < 0) ? g + 6.283185307179586 : g),
            (l = u[l >> 2] | 0),
            !l)
          )
            return (l = 0), l | 0
          if (f) {
            ;(f = 0), (h = l)
            e: for (;;) {
              for (
                ;
                (b = +Z[h >> 3]),
                  (I = +Z[(h + 8) >> 3]),
                  (h = (h + 16) | 0),
                  (H = u[h >> 2] | 0),
                  (H = (H | 0) == 0 ? l : H),
                  (w = +Z[H >> 3]),
                  (v = +Z[(H + 8) >> 3]),
                  b > w
                    ? ((E = b), (b = I))
                    : ((E = w), (w = b), (b = v), (v = I)),
                  !!((U < w) | (U > E));

              )
                if (((h = u[h >> 2] | 0), !h)) {
                  h = 22
                  break e
                }
              if (
                ((I = v < 0 ? v + 6.283185307179586 : v),
                (b = b < 0 ? b + 6.283185307179586 : b),
                (g = (b == g) | (I == g) ? g + -2220446049250313e-31 : g),
                (I = I + ((U - w) / (E - w)) * (b - I)),
                (I < 0 ? I + 6.283185307179586 : I) > g && (f = f ^ 1),
                (h = u[h >> 2] | 0),
                !h)
              ) {
                h = 22
                break
              }
            }
            if ((h | 0) == 22) return f | 0
          } else {
            ;(f = 0), (h = l)
            e: for (;;) {
              for (
                ;
                (b = +Z[h >> 3]),
                  (I = +Z[(h + 8) >> 3]),
                  (h = (h + 16) | 0),
                  (H = u[h >> 2] | 0),
                  (H = (H | 0) == 0 ? l : H),
                  (w = +Z[H >> 3]),
                  (v = +Z[(H + 8) >> 3]),
                  b > w
                    ? ((E = b), (b = I))
                    : ((E = w), (w = b), (b = v), (v = I)),
                  !!((U < w) | (U > E));

              )
                if (((h = u[h >> 2] | 0), !h)) {
                  h = 22
                  break e
                }
              if (
                ((g = (b == g) | (v == g) ? g + -2220446049250313e-31 : g),
                v + ((U - w) / (E - w)) * (b - v) > g && (f = f ^ 1),
                (h = u[h >> 2] | 0),
                !h)
              ) {
                h = 22
                break
              }
            }
            if ((h | 0) == 22) return f | 0
          }
          return 0
        }
        function ms(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0
          if (
            ((we = ie),
            (ie = (ie + 32) | 0),
            (st = (we + 16) | 0),
            (Qe = we),
            (w = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (w = w & 15),
            (me = $e(h | 0, g | 0, 52) | 0),
            ce() | 0,
            (w | 0) != ((me & 15) | 0))
          )
            return (st = 1), (ie = we), st | 0
          if (
            ((U = $e(l | 0, f | 0, 45) | 0),
            ce() | 0,
            (U = U & 127),
            (H = $e(h | 0, g | 0, 45) | 0),
            ce() | 0,
            (H = H & 127),
            (me = (U | 0) != (H | 0)),
            me)
          ) {
            if (((E = ip(U, H) | 0), (E | 0) == 7))
              return (st = 2), (ie = we), st | 0
            ;(I = ip(H, U) | 0),
              (I | 0) == 7 ? Yt(22925, 22949, 151, 22959) : ((Pe = E), (b = I))
          } else (Pe = 0), (b = 0)
          ;(re = vn(U) | 0),
            (fe = vn(H) | 0),
            (u[st >> 2] = 0),
            (u[(st + 4) >> 2] = 0),
            (u[(st + 8) >> 2] = 0),
            (u[(st + 12) >> 2] = 0)
          do
            if (Pe) {
              if (
                ((H = u[(4304 + ((U * 28) | 0) + (Pe << 2)) >> 2] | 0),
                (E = (H | 0) > 0),
                fe)
              )
                if (E) {
                  ;(U = 0), (I = h), (E = g)
                  do
                    (I = cS(I, E) | 0),
                      (E = ce() | 0),
                      (b = Ks(b) | 0),
                      (b | 0) == 1 && (b = Ks(1) | 0),
                      (U = (U + 1) | 0)
                  while ((U | 0) != (H | 0))
                  ;(H = b), (U = I), (I = E)
                } else (H = b), (U = h), (I = g)
              else if (E) {
                ;(U = 0), (I = h), (E = g)
                do
                  (I = Ap(I, E) | 0),
                    (E = ce() | 0),
                    (b = Ks(b) | 0),
                    (U = (U + 1) | 0)
                while ((U | 0) != (H | 0))
                ;(H = b), (U = I), (I = E)
              } else (H = b), (U = h), (I = g)
              if (
                (up(U, I, st) | 0,
                me || Yt(22972, 22949, 181, 22959),
                (E = (re | 0) != 0),
                (b = (fe | 0) != 0),
                E & b && Yt(22999, 22949, 182, 22959),
                E)
              ) {
                if (
                  ((b = Bi(l, f) | 0),
                  Ve[(22032 + ((b * 7) | 0) + Pe) >> 0] | 0)
                ) {
                  w = 3
                  break
                }
                ;(I = u[(21200 + ((b * 28) | 0) + (Pe << 2)) >> 2] | 0),
                  (U = I),
                  (Ie = 26)
              } else if (b) {
                if (
                  ((b = Bi(U, I) | 0), Ve[(22032 + ((b * 7) | 0) + H) >> 0] | 0)
                ) {
                  w = 4
                  break
                }
                ;(U = 0),
                  (I = u[(21200 + ((H * 28) | 0) + (b << 2)) >> 2] | 0),
                  (Ie = 26)
              } else b = 0
              if ((Ie | 0) == 26)
                if (
                  ((I | 0) <= -1 && Yt(23030, 22949, 212, 22959),
                  (U | 0) <= -1 && Yt(23053, 22949, 213, 22959),
                  (I | 0) > 0)
                ) {
                  ;(E = (st + 4) | 0), (b = 0)
                  do nf(E), (b = (b + 1) | 0)
                  while ((b | 0) != (I | 0))
                  b = U
                } else b = U
              if (
                ((u[Qe >> 2] = 0),
                (u[(Qe + 4) >> 2] = 0),
                (u[(Qe + 8) >> 2] = 0),
                _y(Qe, Pe),
                w | 0)
              )
                for (; ur(w) | 0 ? tf(Qe) : Jo(Qe), (w | 0) > 1; )
                  w = (w + -1) | 0
              if ((b | 0) > 0) {
                w = 0
                do nf(Qe), (w = (w + 1) | 0)
                while ((w | 0) != (b | 0))
              }
              ;(Ie = (st + 4) | 0), xi(Ie, Qe, Ie), ui(Ie), (Ie = 50)
            } else if ((up(h, g, st) | 0, ((re | 0) != 0) & ((fe | 0) != 0)))
              if (
                ((H | 0) != (U | 0) && Yt(23077, 22949, 243, 22959),
                (b = Bi(l, f) | 0),
                (w = Bi(h, g) | 0),
                Ve[(22032 + ((b * 7) | 0) + w) >> 0] | 0)
              )
                w = 5
              else if (
                ((b = u[(21200 + ((b * 28) | 0) + (w << 2)) >> 2] | 0),
                (b | 0) > 0)
              ) {
                ;(E = (st + 4) | 0), (w = 0)
                do nf(E), (w = (w + 1) | 0)
                while ((w | 0) != (b | 0))
                Ie = 50
              } else Ie = 50
            else Ie = 50
          while (0)
          return (
            (Ie | 0) == 50 &&
              ((w = (st + 4) | 0),
              (u[v >> 2] = u[w >> 2]),
              (u[(v + 4) >> 2] = u[(w + 4) >> 2]),
              (u[(v + 8) >> 2] = u[(w + 8) >> 2]),
              (w = 0)),
            (st = w),
            (ie = we),
            st | 0
          )
        }
        function Oy(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0
          if (
            ((Pe = ie),
            (ie = (ie + 48) | 0),
            (b = (Pe + 36) | 0),
            (E = (Pe + 24) | 0),
            (I = (Pe + 12) | 0),
            (U = Pe),
            (w = $e(l | 0, f | 0, 52) | 0),
            ce() | 0,
            (w = w & 15),
            (fe = $e(l | 0, f | 0, 45) | 0),
            ce() | 0,
            (fe = fe & 127),
            (H = vn(fe) | 0),
            rt(w | 0, 0, 52) | 0,
            (Qe = ce() | 0 | 134225919),
            (Ie = g),
            (u[Ie >> 2] = -1),
            (u[(Ie + 4) >> 2] = Qe),
            !w)
          )
            return (u[h >> 2] | 0) > 1 ||
              (u[(h + 4) >> 2] | 0) > 1 ||
              (u[(h + 8) >> 2] | 0) > 1 ||
              ((v = np(fe, ef(h) | 0) | 0), (v | 0) == 127)
              ? ((Qe = 1), (ie = Pe), Qe | 0)
              : ((me = rt(v | 0, 0, 45) | 0),
                (Ie = ce() | 0),
                (fe = g),
                (Ie = (u[(fe + 4) >> 2] & -1040385) | Ie),
                (Qe = g),
                (u[Qe >> 2] = u[fe >> 2] | me),
                (u[(Qe + 4) >> 2] = Ie),
                (Qe = 0),
                (ie = Pe),
                Qe | 0)
          for (
            u[b >> 2] = u[h >> 2],
              u[(b + 4) >> 2] = u[(h + 4) >> 2],
              u[(b + 8) >> 2] = u[(h + 8) >> 2];
            (u[E >> 2] = u[b >> 2]),
              (u[(E + 4) >> 2] = u[(b + 4) >> 2]),
              (u[(E + 8) >> 2] = u[(b + 8) >> 2]),
              ur(w) | 0
                ? (vy(b),
                  (u[I >> 2] = u[b >> 2]),
                  (u[(I + 4) >> 2] = u[(b + 4) >> 2]),
                  (u[(I + 8) >> 2] = u[(b + 8) >> 2]),
                  tf(I))
                : (op(b),
                  (u[I >> 2] = u[b >> 2]),
                  (u[(I + 4) >> 2] = u[(b + 4) >> 2]),
                  (u[(I + 8) >> 2] = u[(b + 8) >> 2]),
                  Jo(I)),
              sp(E, I, U),
              ui(U),
              (Ie = g),
              (st = u[Ie >> 2] | 0),
              (Ie = u[(Ie + 4) >> 2] | 0),
              (we = (((15 - w) | 0) * 3) | 0),
              (h = rt(7, 0, we | 0) | 0),
              (Ie = Ie & ~(ce() | 0)),
              (we = rt(ef(U) | 0, 0, we | 0) | 0),
              (Ie = ce() | 0 | Ie),
              (Qe = g),
              (u[Qe >> 2] = we | (st & ~h)),
              (u[(Qe + 4) >> 2] = Ie),
              (w | 0) > 1;

          )
            w = (w + -1) | 0
          e: do
            if (
              (u[b >> 2] | 0) <= 1 &&
              (u[(b + 4) >> 2] | 0) <= 1 &&
              (u[(b + 8) >> 2] | 0) <= 1
            ) {
              ;(w = ef(b) | 0),
                (E = np(fe, w) | 0),
                (E | 0) == 127 ? (U = 0) : (U = vn(E) | 0)
              t: do
                if (w) {
                  if (H) {
                    if (
                      ((b =
                        (21408 + (((Bi(l, f) | 0) * 28) | 0) + (w << 2)) | 0),
                      (b = u[b >> 2] | 0),
                      (b | 0) > 0)
                    ) {
                      h = 0
                      do (w = Ko(w) | 0), (h = (h + 1) | 0)
                      while ((h | 0) != (b | 0))
                    }
                    if ((w | 0) == 1) {
                      v = 3
                      break e
                    }
                    ;(h = np(fe, w) | 0),
                      (h | 0) == 127 && Yt(23104, 22949, 376, 23134),
                      vn(h) | 0
                        ? Yt(23147, 22949, 377, 23134)
                        : ((me = b), (re = w), (v = h))
                  } else (me = 0), (re = w), (v = E)
                  if (
                    ((I = u[(4304 + ((fe * 28) | 0) + (re << 2)) >> 2] | 0),
                    (I | 0) <= -1 && Yt(23178, 22949, 384, 23134),
                    !U)
                  ) {
                    if (
                      ((me | 0) <= -1 && Yt(23030, 22949, 417, 23134), me | 0)
                    ) {
                      ;(b = g),
                        (w = 0),
                        (h = u[b >> 2] | 0),
                        (b = u[(b + 4) >> 2] | 0)
                      do
                        (h = eo(h, b) | 0),
                          (b = ce() | 0),
                          (we = g),
                          (u[we >> 2] = h),
                          (u[(we + 4) >> 2] = b),
                          (w = (w + 1) | 0)
                      while ((w | 0) < (me | 0))
                    }
                    if ((I | 0) <= 0) {
                      w = 54
                      break
                    }
                    for (
                      b = g, w = 0, h = u[b >> 2] | 0, b = u[(b + 4) >> 2] | 0;
                      ;

                    )
                      if (
                        ((h = eo(h, b) | 0),
                        (b = ce() | 0),
                        (we = g),
                        (u[we >> 2] = h),
                        (u[(we + 4) >> 2] = b),
                        (w = (w + 1) | 0),
                        (w | 0) == (I | 0))
                      ) {
                        w = 54
                        break t
                      }
                  }
                  if (
                    ((E = ip(v, fe) | 0),
                    (E | 0) == 7 && Yt(22925, 22949, 393, 23134),
                    (w = g),
                    (h = u[w >> 2] | 0),
                    (w = u[(w + 4) >> 2] | 0),
                    (I | 0) > 0)
                  ) {
                    b = 0
                    do
                      (h = eo(h, w) | 0),
                        (w = ce() | 0),
                        (we = g),
                        (u[we >> 2] = h),
                        (u[(we + 4) >> 2] = w),
                        (b = (b + 1) | 0)
                    while ((b | 0) != (I | 0))
                  }
                  if (
                    ((h = Bi(h, w) | 0),
                    (we = tp(v) | 0),
                    (h =
                      u[
                        ((we ? 21824 : 21616) + ((E * 28) | 0) + (h << 2)) >> 2
                      ] | 0),
                    (h | 0) <= -1 && Yt(23030, 22949, 412, 23134),
                    !h)
                  )
                    w = 54
                  else {
                    ;(E = g),
                      (w = 0),
                      (b = u[E >> 2] | 0),
                      (E = u[(E + 4) >> 2] | 0)
                    do
                      (b = cp(b, E) | 0),
                        (E = ce() | 0),
                        (we = g),
                        (u[we >> 2] = b),
                        (u[(we + 4) >> 2] = E),
                        (w = (w + 1) | 0)
                    while ((w | 0) < (h | 0))
                    w = 54
                  }
                } else if (((H | 0) != 0) & ((U | 0) != 0))
                  if (
                    ((we = Bi(l, f) | 0),
                    (w = g),
                    (w =
                      (21408 +
                        ((we * 28) | 0) +
                        ((Bi(u[w >> 2] | 0, u[(w + 4) >> 2] | 0) | 0) << 2)) |
                      0),
                    (w = u[w >> 2] | 0),
                    (w | 0) <= -1 && Yt(23201, 22949, 433, 23134),
                    !w)
                  )
                    (v = E), (w = 55)
                  else {
                    ;(b = g),
                      (v = 0),
                      (h = u[b >> 2] | 0),
                      (b = u[(b + 4) >> 2] | 0)
                    do
                      (h = eo(h, b) | 0),
                        (b = ce() | 0),
                        (we = g),
                        (u[we >> 2] = h),
                        (u[(we + 4) >> 2] = b),
                        (v = (v + 1) | 0)
                    while ((v | 0) < (w | 0))
                    ;(v = E), (w = 54)
                  }
                else (v = E), (w = 54)
              while (0)
              if (
                ((w | 0) == 54 && U && (w = 55),
                (w | 0) == 55 &&
                  ((we = g),
                  (Bi(u[we >> 2] | 0, u[(we + 4) >> 2] | 0) | 0) == 1))
              ) {
                v = 4
                break
              }
              ;(we = g),
                (Qe = u[we >> 2] | 0),
                (we = u[(we + 4) >> 2] & -1040385),
                (st = rt(v | 0, 0, 45) | 0),
                (we = we | (ce() | 0)),
                (v = g),
                (u[v >> 2] = Qe | st),
                (u[(v + 4) >> 2] = we),
                (v = 0)
            } else v = 2
          while (0)
          return (we = v), (ie = Pe), we | 0
        }
        function bS(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0,
            b = 0
          return (
            (b = ie),
            (ie = (ie + 16) | 0),
            (w = b),
            (l = ms(l, f, h, g, w) | 0),
            l || (BM(w, v), (l = 0)),
            (ie = b),
            l | 0
          )
        }
        function wS(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0
          return (
            (v = ie),
            (ie = (ie + 16) | 0),
            (w = v),
            kM(h, w),
            (g = Oy(l, f, w, g) | 0),
            (ie = v),
            g | 0
          )
        }
        function MS(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0
          return (
            (b = ie),
            (ie = (ie + 32) | 0),
            (v = (b + 12) | 0),
            (w = b),
            (ms(l, f, l, f, v) | 0) == 0 && (ms(l, f, h, g, w) | 0) == 0
              ? (l = ap(v, w) | 0)
              : (l = -1),
            (ie = b),
            l | 0
          )
        }
        function SS(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0,
            b = 0
          return (
            (b = ie),
            (ie = (ie + 32) | 0),
            (v = (b + 12) | 0),
            (w = b),
            (ms(l, f, l, f, v) | 0) == 0 && (ms(l, f, h, g, w) | 0) == 0
              ? (l = ap(v, w) | 0)
              : (l = -1),
            (ie = b),
            (((l >>> 31) ^ 1) + l) | 0
          )
        }
        function ES(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0,
            He = 0,
            he = 0,
            ot = 0,
            ct = 0
          if (
            ((ot = ie),
            (ie = (ie + 48) | 0),
            (w = (ot + 24) | 0),
            (b = (ot + 12) | 0),
            (he = ot),
            (ms(l, f, l, f, w) | 0) == 0 && (ms(l, f, h, g, b) | 0) == 0)
          ) {
            if (((He = ap(w, b) | 0), (He | 0) < 0))
              return (he = He), (ie = ot), he | 0
            for (
              u[w >> 2] = 0,
                u[(w + 4) >> 2] = 0,
                u[(w + 8) >> 2] = 0,
                u[b >> 2] = 0,
                u[(b + 4) >> 2] = 0,
                u[(b + 8) >> 2] = 0,
                ms(l, f, l, f, w) | 0,
                ms(l, f, h, g, b) | 0,
                My(w),
                My(b),
                He
                  ? ((H = u[w >> 2] | 0),
                    (me = +(He | 0)),
                    (Qe = (w + 4) | 0),
                    (re = u[Qe >> 2] | 0),
                    (st = (w + 8) | 0),
                    (fe = u[st >> 2] | 0),
                    (we = w),
                    (h = H),
                    (g = re),
                    (w = fe),
                    (Pe = +(((u[b >> 2] | 0) - H) | 0) / me),
                    (Ie = +(((u[(b + 4) >> 2] | 0) - re) | 0) / me),
                    (me = +(((u[(b + 8) >> 2] | 0) - fe) | 0) / me))
                  : ((g = (w + 4) | 0),
                    (fe = (w + 8) | 0),
                    (Qe = g),
                    (st = fe),
                    (we = w),
                    (h = u[w >> 2] | 0),
                    (g = u[g >> 2] | 0),
                    (w = u[fe >> 2] | 0),
                    (Pe = 0),
                    (Ie = 0),
                    (me = 0)),
                u[he >> 2] = h,
                fe = (he + 4) | 0,
                u[fe >> 2] = g,
                re = (he + 8) | 0,
                u[re >> 2] = w,
                H = 0;
              ;

            ) {
              ;(I = +(H | 0)),
                (ct = Pe * I + +(h | 0)),
                (E = Ie * I + +(u[Qe >> 2] | 0)),
                (I = me * I + +(u[st >> 2] | 0)),
                (g = ~~+af(+ct)),
                (b = ~~+af(+E)),
                (h = ~~+af(+I)),
                (ct = +lt(+(+(g | 0) - ct))),
                (E = +lt(+(+(b | 0) - E))),
                (I = +lt(+(+(h | 0) - I)))
              do
                if ((ct > E) & (ct > I)) (g = (0 - (b + h)) | 0), (w = b)
                else if (((U = (0 - g) | 0), E > I)) {
                  w = (U - h) | 0
                  break
                } else {
                  ;(w = b), (h = (U - b) | 0)
                  break
                }
              while (0)
              if (
                ((u[he >> 2] = g),
                (u[fe >> 2] = w),
                (u[re >> 2] = h),
                OM(he),
                Oy(l, f, he, (v + (H << 3)) | 0) | 0,
                (H | 0) == (He | 0))
              )
                break
              ;(H = (H + 1) | 0), (h = u[we >> 2] | 0)
            }
            return (he = 0), (ie = ot), he | 0
          }
          return (he = -1), (ie = ot), he | 0
        }
        function sf(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0
          if (!f) return (h = 1), h | 0
          ;(h = l), (l = 1)
          do
            (l = un(((f & 1) | 0) == 0 ? 1 : h, l) | 0),
              (f = f >> 1),
              (h = un(h, h) | 0)
          while ((f | 0) != 0)
          return l | 0
        }
        function qy(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0
          if (
            !(gy(f, h) | 0) ||
            ((f = my(f) | 0),
            (fe = +Z[h >> 3]),
            (g = +Z[(h + 8) >> 3]),
            (g = f & (g < 0) ? g + 6.283185307179586 : g),
            (re = u[l >> 2] | 0),
            (re | 0) <= 0)
          )
            return (re = 0), re | 0
          if (((H = u[(l + 4) >> 2] | 0), f)) {
            ;(f = 0), (h = -1), (l = 0)
            e: for (;;) {
              for (
                U = l;
                (b = +Z[(H + (U << 4)) >> 3]),
                  (I = +Z[(H + (U << 4) + 8) >> 3]),
                  (l = ((h + 2) | 0) % (re | 0) | 0),
                  (w = +Z[(H + (l << 4)) >> 3]),
                  (v = +Z[(H + (l << 4) + 8) >> 3]),
                  b > w
                    ? ((E = b), (b = I))
                    : ((E = w), (w = b), (b = v), (v = I)),
                  !!((fe < w) | (fe > E));

              )
                if (((h = (U + 1) | 0), (h | 0) < (re | 0)))
                  (l = U), (U = h), (h = l)
                else {
                  h = 22
                  break e
                }
              if (
                ((I = v < 0 ? v + 6.283185307179586 : v),
                (b = b < 0 ? b + 6.283185307179586 : b),
                (g = (b == g) | (I == g) ? g + -2220446049250313e-31 : g),
                (I = I + ((fe - w) / (E - w)) * (b - I)),
                (I < 0 ? I + 6.283185307179586 : I) > g && (f = f ^ 1),
                (l = (U + 1) | 0),
                (l | 0) >= (re | 0))
              ) {
                h = 22
                break
              } else h = U
            }
            if ((h | 0) == 22) return f | 0
          } else {
            ;(f = 0), (h = -1), (l = 0)
            e: for (;;) {
              for (
                U = l;
                (b = +Z[(H + (U << 4)) >> 3]),
                  (I = +Z[(H + (U << 4) + 8) >> 3]),
                  (l = ((h + 2) | 0) % (re | 0) | 0),
                  (w = +Z[(H + (l << 4)) >> 3]),
                  (v = +Z[(H + (l << 4) + 8) >> 3]),
                  b > w
                    ? ((E = b), (b = I))
                    : ((E = w), (w = b), (b = v), (v = I)),
                  !!((fe < w) | (fe > E));

              )
                if (((h = (U + 1) | 0), (h | 0) < (re | 0)))
                  (l = U), (U = h), (h = l)
                else {
                  h = 22
                  break e
                }
              if (
                ((g = (b == g) | (v == g) ? g + -2220446049250313e-31 : g),
                v + ((fe - w) / (E - w)) * (b - v) > g && (f = f ^ 1),
                (l = (U + 1) | 0),
                (l | 0) >= (re | 0))
              ) {
                h = 22
                break
              } else h = U
            }
            if ((h | 0) == 22) return f | 0
          }
          return 0
        }
        function hp(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0
          if (((Pe = u[l >> 2] | 0), !Pe)) {
            ;(u[f >> 2] = 0),
              (u[(f + 4) >> 2] = 0),
              (u[(f + 8) >> 2] = 0),
              (u[(f + 12) >> 2] = 0),
              (u[(f + 16) >> 2] = 0),
              (u[(f + 20) >> 2] = 0),
              (u[(f + 24) >> 2] = 0),
              (u[(f + 28) >> 2] = 0)
            return
          }
          if (
            ((Ie = (f + 8) | 0),
            (Z[Ie >> 3] = 17976931348623157e292),
            (Qe = (f + 24) | 0),
            (Z[Qe >> 3] = 17976931348623157e292),
            (Z[f >> 3] = -17976931348623157e292),
            (st = (f + 16) | 0),
            (Z[st >> 3] = -17976931348623157e292),
            !((Pe | 0) <= 0))
          ) {
            for (
              fe = u[(l + 4) >> 2] | 0,
                U = 17976931348623157e292,
                H = -17976931348623157e292,
                re = 0,
                l = -1,
                w = 17976931348623157e292,
                b = 17976931348623157e292,
                I = -17976931348623157e292,
                g = -17976931348623157e292,
                me = 0;
              (h = +Z[(fe + (me << 4)) >> 3]),
                (E = +Z[(fe + (me << 4) + 8) >> 3]),
                (l = (l + 2) | 0),
                (v = +Z[(fe + (((l | 0) == (Pe | 0) ? 0 : l) << 4) + 8) >> 3]),
                h < w && ((Z[Ie >> 3] = h), (w = h)),
                E < b && ((Z[Qe >> 3] = E), (b = E)),
                h > I ? (Z[f >> 3] = h) : (h = I),
                E > g && ((Z[st >> 3] = E), (g = E)),
                (U = (E > 0) & (E < U) ? E : U),
                (H = (E < 0) & (E > H) ? E : H),
                (re = re | (+lt(+(E - v)) > 3.141592653589793)),
                (l = (me + 1) | 0),
                (l | 0) != (Pe | 0);

            )
              (we = me), (I = h), (me = l), (l = we)
            !re || ((Z[st >> 3] = H), (Z[Qe >> 3] = U))
          }
        }
        function TS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0,
            He = 0,
            he = 0,
            ot = 0,
            ct = 0,
            Je = 0
          if (((Pe = u[l >> 2] | 0), Pe)) {
            if (
              ((Ie = (f + 8) | 0),
              (Z[Ie >> 3] = 17976931348623157e292),
              (Qe = (f + 24) | 0),
              (Z[Qe >> 3] = 17976931348623157e292),
              (Z[f >> 3] = -17976931348623157e292),
              (st = (f + 16) | 0),
              (Z[st >> 3] = -17976931348623157e292),
              (Pe | 0) > 0)
            ) {
              for (
                v = u[(l + 4) >> 2] | 0,
                  fe = 17976931348623157e292,
                  me = -17976931348623157e292,
                  g = 0,
                  h = -1,
                  I = 17976931348623157e292,
                  U = 17976931348623157e292,
                  re = -17976931348623157e292,
                  b = -17976931348623157e292,
                  we = 0;
                (w = +Z[(v + (we << 4)) >> 3]),
                  (H = +Z[(v + (we << 4) + 8) >> 3]),
                  (ct = (h + 2) | 0),
                  (E =
                    +Z[(v + (((ct | 0) == (Pe | 0) ? 0 : ct) << 4) + 8) >> 3]),
                  w < I && ((Z[Ie >> 3] = w), (I = w)),
                  H < U && ((Z[Qe >> 3] = H), (U = H)),
                  w > re ? (Z[f >> 3] = w) : (w = re),
                  H > b && ((Z[st >> 3] = H), (b = H)),
                  (fe = (H > 0) & (H < fe) ? H : fe),
                  (me = (H < 0) & (H > me) ? H : me),
                  (g = g | (+lt(+(H - E)) > 3.141592653589793)),
                  (h = (we + 1) | 0),
                  (h | 0) != (Pe | 0);

              )
                (ct = we), (re = w), (we = h), (h = ct)
              g && ((Z[st >> 3] = me), (Z[Qe >> 3] = fe))
            }
          } else
            (u[f >> 2] = 0),
              (u[(f + 4) >> 2] = 0),
              (u[(f + 8) >> 2] = 0),
              (u[(f + 12) >> 2] = 0),
              (u[(f + 16) >> 2] = 0),
              (u[(f + 20) >> 2] = 0),
              (u[(f + 24) >> 2] = 0),
              (u[(f + 28) >> 2] = 0)
          if (((ct = (l + 8) | 0), (h = u[ct >> 2] | 0), !((h | 0) <= 0))) {
            ;(ot = (l + 12) | 0), (he = 0)
            do
              if (
                ((v = u[ot >> 2] | 0),
                (g = he),
                (he = (he + 1) | 0),
                (Qe = (f + (he << 5)) | 0),
                (st = u[(v + (g << 3)) >> 2] | 0),
                st)
              ) {
                if (
                  ((we = (f + (he << 5) + 8) | 0),
                  (Z[we >> 3] = 17976931348623157e292),
                  (l = (f + (he << 5) + 24) | 0),
                  (Z[l >> 3] = 17976931348623157e292),
                  (Z[Qe >> 3] = -17976931348623157e292),
                  (He = (f + (he << 5) + 16) | 0),
                  (Z[He >> 3] = -17976931348623157e292),
                  (st | 0) > 0)
                ) {
                  for (
                    Pe = u[(v + (g << 3) + 4) >> 2] | 0,
                      fe = 17976931348623157e292,
                      me = -17976931348623157e292,
                      v = 0,
                      g = -1,
                      Ie = 0,
                      I = 17976931348623157e292,
                      U = 17976931348623157e292,
                      H = -17976931348623157e292,
                      b = -17976931348623157e292;
                    (w = +Z[(Pe + (Ie << 4)) >> 3]),
                      (re = +Z[(Pe + (Ie << 4) + 8) >> 3]),
                      (g = (g + 2) | 0),
                      (E =
                        +Z[
                          (Pe + (((g | 0) == (st | 0) ? 0 : g) << 4) + 8) >> 3
                        ]),
                      w < I && ((Z[we >> 3] = w), (I = w)),
                      re < U && ((Z[l >> 3] = re), (U = re)),
                      w > H ? (Z[Qe >> 3] = w) : (w = H),
                      re > b && ((Z[He >> 3] = re), (b = re)),
                      (fe = (re > 0) & (re < fe) ? re : fe),
                      (me = (re < 0) & (re > me) ? re : me),
                      (v = v | (+lt(+(re - E)) > 3.141592653589793)),
                      (g = (Ie + 1) | 0),
                      (g | 0) != (st | 0);

                  )
                    (Je = Ie), (Ie = g), (H = w), (g = Je)
                  v && ((Z[He >> 3] = me), (Z[l >> 3] = fe))
                }
              } else
                (u[Qe >> 2] = 0),
                  (u[(Qe + 4) >> 2] = 0),
                  (u[(Qe + 8) >> 2] = 0),
                  (u[(Qe + 12) >> 2] = 0),
                  (u[(Qe + 16) >> 2] = 0),
                  (u[(Qe + 20) >> 2] = 0),
                  (u[(Qe + 24) >> 2] = 0),
                  (u[(Qe + 28) >> 2] = 0),
                  (h = u[ct >> 2] | 0)
            while ((he | 0) < (h | 0))
          }
        }
        function CS(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0
          if (!(qy(l, f, h) | 0)) return (v = 0), v | 0
          if (((v = (l + 8) | 0), (u[v >> 2] | 0) <= 0)) return (v = 1), v | 0
          for (g = (l + 12) | 0, l = 0; ; ) {
            if (
              ((w = l),
              (l = (l + 1) | 0),
              qy(((u[g >> 2] | 0) + (w << 3)) | 0, (f + (l << 5)) | 0, h) | 0)
            ) {
              ;(l = 0), (g = 6)
              break
            }
            if ((l | 0) >= (u[v >> 2] | 0)) {
              ;(l = 1), (g = 6)
              break
            }
          }
          return (g | 0) == 6 ? l | 0 : 0
        }
        function RS() {
          return 8
        }
        function PS() {
          return 16
        }
        function LS() {
          return 168
        }
        function DS() {
          return 8
        }
        function IS() {
          return 16
        }
        function BS() {
          return 12
        }
        function kS() {
          return 8
        }
        function OS(l) {
          l = l | 0
          var f = 0,
            h = 0
          return (
            (h = +Z[l >> 3]), (f = +Z[(l + 8) >> 3]), +(+_t(+(h * h + f * f)))
          )
        }
        function Fy(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0
          ;(U = +Z[l >> 3]),
            (I = +Z[f >> 3] - U),
            (E = +Z[(l + 8) >> 3]),
            (b = +Z[(f + 8) >> 3] - E),
            (re = +Z[h >> 3]),
            (w = +Z[g >> 3] - re),
            (fe = +Z[(h + 8) >> 3]),
            (H = +Z[(g + 8) >> 3] - fe),
            (w = (w * (E - fe) - (U - re) * H) / (I * H - b * w)),
            (Z[v >> 3] = U + I * w),
            (Z[(v + 8) >> 3] = E + b * w)
        }
        function Ny(l, f) {
          return (
            (l = l | 0),
            (f = f | 0),
            +Z[l >> 3] != +Z[f >> 3]
              ? ((f = 0), f | 0)
              : ((f = +Z[(l + 8) >> 3] == +Z[(f + 8) >> 3]), f | 0)
          )
        }
        function zn(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0
          return (
            (v = +Z[l >> 3] - +Z[f >> 3]),
            (g = +Z[(l + 8) >> 3] - +Z[(f + 8) >> 3]),
            (h = +Z[(l + 16) >> 3] - +Z[(f + 16) >> 3]),
            +(v * v + g * g + h * h)
          )
        }
        function qS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0
          ;(h = +Z[l >> 3]),
            (g = +Nt(+h)),
            (h = +dt(+h)),
            (Z[(f + 16) >> 3] = h),
            (h = +Z[(l + 8) >> 3]),
            (v = g * +Nt(+h)),
            (Z[f >> 3] = v),
            (h = g * +dt(+h)),
            (Z[(f + 8) >> 3] = h)
        }
        function FS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0
          if (
            ((U = ie),
            (ie = (ie + 32) | 0),
            (v = (U + 16) | 0),
            (w = U),
            Zc(l, f, v),
            (b = Ry(l, f) | 0),
            (I = Bi(l, f) | 0),
            TM(b, w),
            (f = CM(b, u[v >> 2] | 0) | 0),
            !(vn(b) | 0))
          )
            return (I = f), (ie = U), I | 0
          do
            switch (b | 0) {
              case 4: {
                ;(l = 0), (h = 14)
                break
              }
              case 14: {
                ;(l = 1), (h = 14)
                break
              }
              case 24: {
                ;(l = 2), (h = 14)
                break
              }
              case 38: {
                ;(l = 3), (h = 14)
                break
              }
              case 49: {
                ;(l = 4), (h = 14)
                break
              }
              case 58: {
                ;(l = 5), (h = 14)
                break
              }
              case 63: {
                ;(l = 6), (h = 14)
                break
              }
              case 72: {
                ;(l = 7), (h = 14)
                break
              }
              case 83: {
                ;(l = 8), (h = 14)
                break
              }
              case 97: {
                ;(l = 9), (h = 14)
                break
              }
              case 107: {
                ;(l = 10), (h = 14)
                break
              }
              case 117: {
                ;(l = 11), (h = 14)
                break
              }
              default:
                ;(E = 0), (g = 0)
            }
          while (0)
          return (
            (h | 0) == 14 &&
              ((E = u[(22096 + ((l * 24) | 0) + 8) >> 2] | 0),
              (g = u[(22096 + ((l * 24) | 0) + 16) >> 2] | 0)),
            (l = u[v >> 2] | 0),
            (l | 0) != (u[w >> 2] | 0) &&
              ((b = tp(b) | 0),
              (l = u[v >> 2] | 0),
              b | ((l | 0) == (g | 0)) && (f = ((f + 1) | 0) % 6 | 0)),
            ((I | 0) == 3) & ((l | 0) == (g | 0))
              ? ((I = ((f + 5) | 0) % 6 | 0), (ie = U), I | 0)
              : ((I | 0) == 5) & ((l | 0) == (E | 0))
              ? ((I = ((f + 1) | 0) % 6 | 0), (ie = U), I | 0)
              : ((I = f), (ie = U), I | 0)
          )
        }
        function NS(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0
          return (
            (g = jn(l, f) | 0),
            ((h + -1) | 0) >>> 0 > 5 || ((v = (g | 0) != 0), ((h | 0) == 1) & v)
              ? ((h = -1), h | 0)
              : ((g = FS(l, f) | 0),
                v
                  ? ((h =
                      ((5 - g + (u[(22384 + (h << 2)) >> 2] | 0)) | 0) % 5 | 0),
                    h | 0)
                  : ((h =
                      ((6 - g + (u[(22416 + (h << 2)) >> 2] | 0)) | 0) % 6 | 0),
                    h | 0))
          )
        }
        function Uy(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0
          ;(f | 0) > 0
            ? ((g = Tr(f, 4) | 0),
              (u[l >> 2] = g),
              g || Yt(23230, 23253, 40, 23267))
            : (u[l >> 2] = 0),
            (u[(l + 4) >> 2] = f),
            (u[(l + 8) >> 2] = 0),
            (u[(l + 12) >> 2] = h)
        }
        function zy(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0
          ;(v = (l + 4) | 0), (w = (l + 12) | 0), (b = (l + 8) | 0)
          e: for (;;) {
            for (h = u[v >> 2] | 0, f = 0; ; ) {
              if ((f | 0) >= (h | 0)) break e
              if (((g = u[l >> 2] | 0), (E = u[(g + (f << 2)) >> 2] | 0), !E))
                f = (f + 1) | 0
              else break
            }
            ;(f =
              (g +
                ((~~(
                  +lt(
                    +(
                      +ln(10, +(+((15 - (u[w >> 2] | 0)) | 0))) *
                      (+Z[E >> 3] + +Z[(E + 8) >> 3])
                    )
                  ) % +(h | 0)
                ) >>>
                  0) <<
                  2)) |
              0),
              (h = u[f >> 2] | 0)
            t: do
              if (h | 0) {
                if (((g = (E + 32) | 0), (h | 0) == (E | 0)))
                  u[f >> 2] = u[g >> 2]
                else {
                  if (((h = (h + 32) | 0), (f = u[h >> 2] | 0), !f)) break
                  for (; (f | 0) != (E | 0); )
                    if (((h = (f + 32) | 0), (f = u[h >> 2] | 0), !f)) break t
                  u[h >> 2] = u[g >> 2]
                }
                Lt(E), (u[b >> 2] = (u[b >> 2] | 0) + -1)
              }
            while (0)
          }
          Lt(u[l >> 2] | 0)
        }
        function Hy(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0
          for (g = u[(l + 4) >> 2] | 0, h = 0; ; ) {
            if ((h | 0) >= (g | 0)) {
              ;(f = 0), (h = 4)
              break
            }
            if (((f = u[((u[l >> 2] | 0) + (h << 2)) >> 2] | 0), !f))
              h = (h + 1) | 0
            else {
              h = 4
              break
            }
          }
          return (h | 0) == 4 ? f | 0 : 0
        }
        function Gy(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0,
            g = 0,
            v = 0,
            w = 0
          if (
            ((h =
              ~~(
                +lt(
                  +(
                    +ln(10, +(+((15 - (u[(l + 12) >> 2] | 0)) | 0))) *
                    (+Z[f >> 3] + +Z[(f + 8) >> 3])
                  )
                ) % +(u[(l + 4) >> 2] | 0)
              ) >>> 0),
            (h = ((u[l >> 2] | 0) + (h << 2)) | 0),
            (g = u[h >> 2] | 0),
            !g)
          )
            return (w = 1), w | 0
          w = (f + 32) | 0
          do
            if ((g | 0) != (f | 0)) {
              if (((h = u[(g + 32) >> 2] | 0), !h)) return (w = 1), w | 0
              for (v = h; ; ) {
                if ((v | 0) == (f | 0)) {
                  v = 8
                  break
                }
                if (((h = u[(v + 32) >> 2] | 0), h)) (g = v), (v = h)
                else {
                  ;(h = 1), (v = 10)
                  break
                }
              }
              if ((v | 0) == 8) {
                u[(g + 32) >> 2] = u[w >> 2]
                break
              } else if ((v | 0) == 10) return h | 0
            } else u[h >> 2] = u[w >> 2]
          while (0)
          return (
            Lt(f),
            (w = (l + 8) | 0),
            (u[w >> 2] = (u[w >> 2] | 0) + -1),
            (w = 0),
            w | 0
          )
        }
        function US(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0
          ;(w = Vr(40) | 0),
            w || Yt(23283, 23253, 98, 23296),
            (u[w >> 2] = u[f >> 2]),
            (u[(w + 4) >> 2] = u[(f + 4) >> 2]),
            (u[(w + 8) >> 2] = u[(f + 8) >> 2]),
            (u[(w + 12) >> 2] = u[(f + 12) >> 2]),
            (v = (w + 16) | 0),
            (u[v >> 2] = u[h >> 2]),
            (u[(v + 4) >> 2] = u[(h + 4) >> 2]),
            (u[(v + 8) >> 2] = u[(h + 8) >> 2]),
            (u[(v + 12) >> 2] = u[(h + 12) >> 2]),
            (u[(w + 32) >> 2] = 0),
            (v =
              ~~(
                +lt(
                  +(
                    +ln(10, +(+((15 - (u[(l + 12) >> 2] | 0)) | 0))) *
                    (+Z[f >> 3] + +Z[(f + 8) >> 3])
                  )
                ) % +(u[(l + 4) >> 2] | 0)
              ) >>> 0),
            (v = ((u[l >> 2] | 0) + (v << 2)) | 0),
            (g = u[v >> 2] | 0)
          do
            if (!g) u[v >> 2] = w
            else {
              for (; !(cl(g, f) | 0 && cl((g + 16) | 0, h) | 0); )
                if (
                  ((v = u[(g + 32) >> 2] | 0),
                  (g = (v | 0) == 0 ? g : v),
                  !(u[(g + 32) >> 2] | 0))
                ) {
                  b = 10
                  break
                }
              if ((b | 0) == 10) {
                u[(g + 32) >> 2] = w
                break
              }
              return Lt(w), (b = g), b | 0
            }
          while (0)
          return (
            (b = (l + 8) | 0), (u[b >> 2] = (u[b >> 2] | 0) + 1), (b = w), b | 0
          )
        }
        function zS(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0
          if (
            ((v =
              ~~(
                +lt(
                  +(
                    +ln(10, +(+((15 - (u[(l + 12) >> 2] | 0)) | 0))) *
                    (+Z[f >> 3] + +Z[(f + 8) >> 3])
                  )
                ) % +(u[(l + 4) >> 2] | 0)
              ) >>> 0),
            (v = u[((u[l >> 2] | 0) + (v << 2)) >> 2] | 0),
            !v)
          )
            return (h = 0), h | 0
          if (!h) {
            for (l = v; ; ) {
              if (cl(l, f) | 0) {
                g = 10
                break
              }
              if (((l = u[(l + 32) >> 2] | 0), !l)) {
                ;(l = 0), (g = 10)
                break
              }
            }
            if ((g | 0) == 10) return l | 0
          }
          for (l = v; ; ) {
            if (cl(l, f) | 0 && cl((l + 16) | 0, h) | 0) {
              g = 10
              break
            }
            if (((l = u[(l + 32) >> 2] | 0), !l)) {
              ;(l = 0), (g = 10)
              break
            }
          }
          return (g | 0) == 10 ? l | 0 : 0
        }
        function HS(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0
          if (
            ((h =
              ~~(
                +lt(
                  +(
                    +ln(10, +(+((15 - (u[(l + 12) >> 2] | 0)) | 0))) *
                    (+Z[f >> 3] + +Z[(f + 8) >> 3])
                  )
                ) % +(u[(l + 4) >> 2] | 0)
              ) >>> 0),
            (l = u[((u[l >> 2] | 0) + (h << 2)) >> 2] | 0),
            !l)
          )
            return (h = 0), h | 0
          for (;;) {
            if (cl(l, f) | 0) {
              f = 5
              break
            }
            if (((l = u[(l + 32) >> 2] | 0), !l)) {
              ;(l = 0), (f = 5)
              break
            }
          }
          return (f | 0) == 5 ? l | 0 : 0
        }
        function GS() {
          return 23312
        }
        function VS(l) {
          return (l = +l), +(+jy(+l))
        }
        function of(l) {
          return (l = +l), ~~+VS(l) | 0
        }
        function Vr(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0,
            Ie = 0,
            Qe = 0,
            st = 0,
            we = 0,
            He = 0,
            he = 0,
            ot = 0
          ;(ot = ie), (ie = (ie + 16) | 0), (fe = ot)
          do
            if (l >>> 0 < 245) {
              if (
                ((U = l >>> 0 < 11 ? 16 : (l + 11) & -8),
                (l = U >>> 3),
                (re = u[5829] | 0),
                (h = re >>> l),
                (h & 3) | 0)
              )
                return (
                  (f = (((h & 1) ^ 1) + l) | 0),
                  (l = (23356 + ((f << 1) << 2)) | 0),
                  (h = (l + 8) | 0),
                  (g = u[h >> 2] | 0),
                  (v = (g + 8) | 0),
                  (w = u[v >> 2] | 0),
                  (w | 0) == (l | 0)
                    ? (u[5829] = re & ~(1 << f))
                    : ((u[(w + 12) >> 2] = l), (u[h >> 2] = w)),
                  (he = f << 3),
                  (u[(g + 4) >> 2] = he | 3),
                  (he = (g + he + 4) | 0),
                  (u[he >> 2] = u[he >> 2] | 1),
                  (he = v),
                  (ie = ot),
                  he | 0
                )
              if (((H = u[5831] | 0), U >>> 0 > H >>> 0)) {
                if (h | 0)
                  return (
                    (f = 2 << l),
                    (f = (h << l) & (f | (0 - f))),
                    (f = ((f & (0 - f)) + -1) | 0),
                    (E = (f >>> 12) & 16),
                    (f = f >>> E),
                    (h = (f >>> 5) & 8),
                    (f = f >>> h),
                    (w = (f >>> 2) & 4),
                    (f = f >>> w),
                    (l = (f >>> 1) & 2),
                    (f = f >>> l),
                    (g = (f >>> 1) & 1),
                    (g = ((h | E | w | l | g) + (f >>> g)) | 0),
                    (f = (23356 + ((g << 1) << 2)) | 0),
                    (l = (f + 8) | 0),
                    (w = u[l >> 2] | 0),
                    (E = (w + 8) | 0),
                    (h = u[E >> 2] | 0),
                    (h | 0) == (f | 0)
                      ? ((l = re & ~(1 << g)), (u[5829] = l))
                      : ((u[(h + 12) >> 2] = f), (u[l >> 2] = h), (l = re)),
                    (he = g << 3),
                    (b = (he - U) | 0),
                    (u[(w + 4) >> 2] = U | 3),
                    (v = (w + U) | 0),
                    (u[(v + 4) >> 2] = b | 1),
                    (u[(w + he) >> 2] = b),
                    H | 0 &&
                      ((g = u[5834] | 0),
                      (f = H >>> 3),
                      (h = (23356 + ((f << 1) << 2)) | 0),
                      (f = 1 << f),
                      l & f
                        ? ((l = (h + 8) | 0), (f = u[l >> 2] | 0))
                        : ((u[5829] = l | f), (f = h), (l = (h + 8) | 0)),
                      (u[l >> 2] = g),
                      (u[(f + 12) >> 2] = g),
                      (u[(g + 8) >> 2] = f),
                      (u[(g + 12) >> 2] = h)),
                    (u[5831] = b),
                    (u[5834] = v),
                    (he = E),
                    (ie = ot),
                    he | 0
                  )
                if (((w = u[5830] | 0), w)) {
                  for (
                    h = ((w & (0 - w)) + -1) | 0,
                      v = (h >>> 12) & 16,
                      h = h >>> v,
                      g = (h >>> 5) & 8,
                      h = h >>> g,
                      b = (h >>> 2) & 4,
                      h = h >>> b,
                      E = (h >>> 1) & 2,
                      h = h >>> E,
                      I = (h >>> 1) & 1,
                      I =
                        u[
                          (23620 + (((g | v | b | E | I) + (h >>> I)) << 2)) >>
                            2
                        ] | 0,
                      h = I,
                      E = I,
                      I = ((u[(I + 4) >> 2] & -8) - U) | 0;
                    (l = u[(h + 16) >> 2] | 0),
                      !(!l && ((l = u[(h + 20) >> 2] | 0), !l));

                  )
                    (b = ((u[(l + 4) >> 2] & -8) - U) | 0),
                      (v = b >>> 0 < I >>> 0),
                      (h = l),
                      (E = v ? l : E),
                      (I = v ? b : I)
                  if (((b = (E + U) | 0), b >>> 0 > E >>> 0)) {
                    ;(v = u[(E + 24) >> 2] | 0), (f = u[(E + 12) >> 2] | 0)
                    do
                      if ((f | 0) == (E | 0)) {
                        if (
                          ((l = (E + 20) | 0),
                          (f = u[l >> 2] | 0),
                          !f && ((l = (E + 16) | 0), (f = u[l >> 2] | 0), !f))
                        ) {
                          h = 0
                          break
                        }
                        for (;;)
                          if (((g = (f + 20) | 0), (h = u[g >> 2] | 0), h))
                            (f = h), (l = g)
                          else if (((g = (f + 16) | 0), (h = u[g >> 2] | 0), h))
                            (f = h), (l = g)
                          else break
                        ;(u[l >> 2] = 0), (h = f)
                      } else
                        (h = u[(E + 8) >> 2] | 0),
                          (u[(h + 12) >> 2] = f),
                          (u[(f + 8) >> 2] = h),
                          (h = f)
                    while (0)
                    do
                      if (v | 0) {
                        if (
                          ((f = u[(E + 28) >> 2] | 0),
                          (l = (23620 + (f << 2)) | 0),
                          (E | 0) == (u[l >> 2] | 0))
                        ) {
                          if (((u[l >> 2] = h), !h)) {
                            u[5830] = w & ~(1 << f)
                            break
                          }
                        } else if (
                          ((he = (v + 16) | 0),
                          (u[
                            ((u[he >> 2] | 0) == (E | 0) ? he : (v + 20) | 0) >>
                              2
                          ] = h),
                          !h)
                        )
                          break
                        ;(u[(h + 24) >> 2] = v),
                          (f = u[(E + 16) >> 2] | 0),
                          f | 0 &&
                            ((u[(h + 16) >> 2] = f), (u[(f + 24) >> 2] = h)),
                          (f = u[(E + 20) >> 2] | 0),
                          f | 0 &&
                            ((u[(h + 20) >> 2] = f), (u[(f + 24) >> 2] = h))
                      }
                    while (0)
                    return (
                      I >>> 0 < 16
                        ? ((he = (I + U) | 0),
                          (u[(E + 4) >> 2] = he | 3),
                          (he = (E + he + 4) | 0),
                          (u[he >> 2] = u[he >> 2] | 1))
                        : ((u[(E + 4) >> 2] = U | 3),
                          (u[(b + 4) >> 2] = I | 1),
                          (u[(b + I) >> 2] = I),
                          H | 0 &&
                            ((g = u[5834] | 0),
                            (f = H >>> 3),
                            (h = (23356 + ((f << 1) << 2)) | 0),
                            (f = 1 << f),
                            f & re
                              ? ((l = (h + 8) | 0), (f = u[l >> 2] | 0))
                              : ((u[5829] = f | re),
                                (f = h),
                                (l = (h + 8) | 0)),
                            (u[l >> 2] = g),
                            (u[(f + 12) >> 2] = g),
                            (u[(g + 8) >> 2] = f),
                            (u[(g + 12) >> 2] = h)),
                          (u[5831] = I),
                          (u[5834] = b)),
                      (he = (E + 8) | 0),
                      (ie = ot),
                      he | 0
                    )
                  } else re = U
                } else re = U
              } else re = U
            } else if (l >>> 0 <= 4294967231)
              if (((l = (l + 11) | 0), (U = l & -8), (g = u[5830] | 0), g)) {
                ;(v = (0 - U) | 0),
                  (l = l >>> 8),
                  l
                    ? U >>> 0 > 16777215
                      ? (I = 31)
                      : ((re = (((l + 1048320) | 0) >>> 16) & 8),
                        (Ie = l << re),
                        (E = (((Ie + 520192) | 0) >>> 16) & 4),
                        (Ie = Ie << E),
                        (I = (((Ie + 245760) | 0) >>> 16) & 2),
                        (I = (14 - (E | re | I) + ((Ie << I) >>> 15)) | 0),
                        (I = ((U >>> ((I + 7) | 0)) & 1) | (I << 1)))
                    : (I = 0),
                  (h = u[(23620 + (I << 2)) >> 2] | 0)
                e: do
                  if (!h) (h = 0), (l = 0), (Ie = 61)
                  else
                    for (
                      l = 0,
                        E = U << ((I | 0) == 31 ? 0 : (25 - (I >>> 1)) | 0),
                        w = 0;
                      ;

                    ) {
                      if (
                        ((b = ((u[(h + 4) >> 2] & -8) - U) | 0),
                        b >>> 0 < v >>> 0)
                      )
                        if (b) (l = h), (v = b)
                        else {
                          ;(l = h), (v = 0), (Ie = 65)
                          break e
                        }
                      if (
                        ((Ie = u[(h + 20) >> 2] | 0),
                        (h = u[(h + 16 + ((E >>> 31) << 2)) >> 2] | 0),
                        (w = ((Ie | 0) == 0) | ((Ie | 0) == (h | 0)) ? w : Ie),
                        h)
                      )
                        E = E << 1
                      else {
                        ;(h = w), (Ie = 61)
                        break
                      }
                    }
                while (0)
                if ((Ie | 0) == 61) {
                  if (((h | 0) == 0) & ((l | 0) == 0)) {
                    if (((l = 2 << I), (l = (l | (0 - l)) & g), !l)) {
                      re = U
                      break
                    }
                    ;(re = ((l & (0 - l)) + -1) | 0),
                      (b = (re >>> 12) & 16),
                      (re = re >>> b),
                      (w = (re >>> 5) & 8),
                      (re = re >>> w),
                      (E = (re >>> 2) & 4),
                      (re = re >>> E),
                      (I = (re >>> 1) & 2),
                      (re = re >>> I),
                      (h = (re >>> 1) & 1),
                      (l = 0),
                      (h =
                        u[
                          (23620 + (((w | b | E | I | h) + (re >>> h)) << 2)) >>
                            2
                        ] | 0)
                  }
                  h ? (Ie = 65) : ((E = l), (b = v))
                }
                if ((Ie | 0) == 65)
                  for (w = h; ; )
                    if (
                      ((re = ((u[(w + 4) >> 2] & -8) - U) | 0),
                      (h = re >>> 0 < v >>> 0),
                      (v = h ? re : v),
                      (l = h ? w : l),
                      (h = u[(w + 16) >> 2] | 0),
                      h || (h = u[(w + 20) >> 2] | 0),
                      h)
                    )
                      w = h
                    else {
                      ;(E = l), (b = v)
                      break
                    }
                if (
                  (E | 0) != 0 &&
                  b >>> 0 < (((u[5831] | 0) - U) | 0) >>> 0 &&
                  ((H = (E + U) | 0), H >>> 0 > E >>> 0)
                ) {
                  ;(w = u[(E + 24) >> 2] | 0), (f = u[(E + 12) >> 2] | 0)
                  do
                    if ((f | 0) == (E | 0)) {
                      if (
                        ((l = (E + 20) | 0),
                        (f = u[l >> 2] | 0),
                        !f && ((l = (E + 16) | 0), (f = u[l >> 2] | 0), !f))
                      ) {
                        f = 0
                        break
                      }
                      for (;;)
                        if (((v = (f + 20) | 0), (h = u[v >> 2] | 0), h))
                          (f = h), (l = v)
                        else if (((v = (f + 16) | 0), (h = u[v >> 2] | 0), h))
                          (f = h), (l = v)
                        else break
                      u[l >> 2] = 0
                    } else
                      (he = u[(E + 8) >> 2] | 0),
                        (u[(he + 12) >> 2] = f),
                        (u[(f + 8) >> 2] = he)
                  while (0)
                  do
                    if (w) {
                      if (
                        ((l = u[(E + 28) >> 2] | 0),
                        (h = (23620 + (l << 2)) | 0),
                        (E | 0) == (u[h >> 2] | 0))
                      ) {
                        if (((u[h >> 2] = f), !f)) {
                          ;(g = g & ~(1 << l)), (u[5830] = g)
                          break
                        }
                      } else if (
                        ((he = (w + 16) | 0),
                        (u[
                          ((u[he >> 2] | 0) == (E | 0) ? he : (w + 20) | 0) >> 2
                        ] = f),
                        !f)
                      )
                        break
                      ;(u[(f + 24) >> 2] = w),
                        (l = u[(E + 16) >> 2] | 0),
                        l | 0 &&
                          ((u[(f + 16) >> 2] = l), (u[(l + 24) >> 2] = f)),
                        (l = u[(E + 20) >> 2] | 0),
                        l && ((u[(f + 20) >> 2] = l), (u[(l + 24) >> 2] = f))
                    }
                  while (0)
                  e: do
                    if (b >>> 0 < 16)
                      (he = (b + U) | 0),
                        (u[(E + 4) >> 2] = he | 3),
                        (he = (E + he + 4) | 0),
                        (u[he >> 2] = u[he >> 2] | 1)
                    else {
                      if (
                        ((u[(E + 4) >> 2] = U | 3),
                        (u[(H + 4) >> 2] = b | 1),
                        (u[(H + b) >> 2] = b),
                        (f = b >>> 3),
                        b >>> 0 < 256)
                      ) {
                        ;(h = (23356 + ((f << 1) << 2)) | 0),
                          (l = u[5829] | 0),
                          (f = 1 << f),
                          l & f
                            ? ((l = (h + 8) | 0), (f = u[l >> 2] | 0))
                            : ((u[5829] = l | f), (f = h), (l = (h + 8) | 0)),
                          (u[l >> 2] = H),
                          (u[(f + 12) >> 2] = H),
                          (u[(H + 8) >> 2] = f),
                          (u[(H + 12) >> 2] = h)
                        break
                      }
                      if (
                        ((f = b >>> 8),
                        f
                          ? b >>> 0 > 16777215
                            ? (h = 31)
                            : ((He = (((f + 1048320) | 0) >>> 16) & 8),
                              (he = f << He),
                              (we = (((he + 520192) | 0) >>> 16) & 4),
                              (he = he << we),
                              (h = (((he + 245760) | 0) >>> 16) & 2),
                              (h =
                                (14 - (we | He | h) + ((he << h) >>> 15)) | 0),
                              (h = ((b >>> ((h + 7) | 0)) & 1) | (h << 1)))
                          : (h = 0),
                        (f = (23620 + (h << 2)) | 0),
                        (u[(H + 28) >> 2] = h),
                        (l = (H + 16) | 0),
                        (u[(l + 4) >> 2] = 0),
                        (u[l >> 2] = 0),
                        (l = 1 << h),
                        !(g & l))
                      ) {
                        ;(u[5830] = g | l),
                          (u[f >> 2] = H),
                          (u[(H + 24) >> 2] = f),
                          (u[(H + 12) >> 2] = H),
                          (u[(H + 8) >> 2] = H)
                        break
                      }
                      f = u[f >> 2] | 0
                      t: do
                        if (((u[(f + 4) >> 2] & -8) | 0) != (b | 0)) {
                          for (
                            g = b << ((h | 0) == 31 ? 0 : (25 - (h >>> 1)) | 0);
                            (h = (f + 16 + ((g >>> 31) << 2)) | 0),
                              (l = u[h >> 2] | 0),
                              !!l;

                          )
                            if (((u[(l + 4) >> 2] & -8) | 0) == (b | 0)) {
                              f = l
                              break t
                            } else (g = g << 1), (f = l)
                          ;(u[h >> 2] = H),
                            (u[(H + 24) >> 2] = f),
                            (u[(H + 12) >> 2] = H),
                            (u[(H + 8) >> 2] = H)
                          break e
                        }
                      while (0)
                      ;(He = (f + 8) | 0),
                        (he = u[He >> 2] | 0),
                        (u[(he + 12) >> 2] = H),
                        (u[He >> 2] = H),
                        (u[(H + 8) >> 2] = he),
                        (u[(H + 12) >> 2] = f),
                        (u[(H + 24) >> 2] = 0)
                    }
                  while (0)
                  return (he = (E + 8) | 0), (ie = ot), he | 0
                } else re = U
              } else re = U
            else re = -1
          while (0)
          if (((h = u[5831] | 0), h >>> 0 >= re >>> 0))
            return (
              (f = (h - re) | 0),
              (l = u[5834] | 0),
              f >>> 0 > 15
                ? ((he = (l + re) | 0),
                  (u[5834] = he),
                  (u[5831] = f),
                  (u[(he + 4) >> 2] = f | 1),
                  (u[(l + h) >> 2] = f),
                  (u[(l + 4) >> 2] = re | 3))
                : ((u[5831] = 0),
                  (u[5834] = 0),
                  (u[(l + 4) >> 2] = h | 3),
                  (he = (l + h + 4) | 0),
                  (u[he >> 2] = u[he >> 2] | 1)),
              (he = (l + 8) | 0),
              (ie = ot),
              he | 0
            )
          if (((b = u[5832] | 0), b >>> 0 > re >>> 0))
            return (
              (we = (b - re) | 0),
              (u[5832] = we),
              (he = u[5835] | 0),
              (He = (he + re) | 0),
              (u[5835] = He),
              (u[(He + 4) >> 2] = we | 1),
              (u[(he + 4) >> 2] = re | 3),
              (he = (he + 8) | 0),
              (ie = ot),
              he | 0
            )
          if (
            (u[5947] | 0
              ? (l = u[5949] | 0)
              : ((u[5949] = 4096),
                (u[5948] = 4096),
                (u[5950] = -1),
                (u[5951] = -1),
                (u[5952] = 0),
                (u[5940] = 0),
                (u[5947] = (fe & -16) ^ 1431655768),
                (l = 4096)),
            (E = (re + 48) | 0),
            (I = (re + 47) | 0),
            (w = (l + I) | 0),
            (v = (0 - l) | 0),
            (U = w & v),
            U >>> 0 <= re >>> 0 ||
              ((l = u[5939] | 0),
              l | 0 &&
                ((H = u[5937] | 0),
                (fe = (H + U) | 0),
                (fe >>> 0 <= H >>> 0) | (fe >>> 0 > l >>> 0))))
          )
            return (he = 0), (ie = ot), he | 0
          e: do
            if (u[5940] & 4) (f = 0), (Ie = 143)
            else {
              h = u[5835] | 0
              t: do
                if (h) {
                  for (
                    g = 23764;
                    (fe = u[g >> 2] | 0),
                      !(
                        fe >>> 0 <= h >>> 0 &&
                        ((fe + (u[(g + 4) >> 2] | 0)) | 0) >>> 0 > h >>> 0
                      );

                  )
                    if (((l = u[(g + 8) >> 2] | 0), l)) g = l
                    else {
                      Ie = 128
                      break t
                    }
                  if (((f = (w - b) & v), f >>> 0 < 2147483647))
                    if (
                      ((l = no(f | 0) | 0),
                      (l | 0) ==
                        (((u[g >> 2] | 0) + (u[(g + 4) >> 2] | 0)) | 0))
                    ) {
                      if ((l | 0) != -1) {
                        ;(b = f), (w = l), (Ie = 145)
                        break e
                      }
                    } else (g = l), (Ie = 136)
                  else f = 0
                } else Ie = 128
              while (0)
              do
                if ((Ie | 0) == 128)
                  if (
                    ((h = no(0) | 0),
                    (h | 0) != -1 &&
                      ((f = h),
                      (me = u[5948] | 0),
                      (Pe = (me + -1) | 0),
                      (f =
                        ((((Pe & f) | 0) == 0
                          ? 0
                          : (((Pe + f) & (0 - me)) - f) | 0) +
                          U) |
                        0),
                      (me = u[5937] | 0),
                      (Pe = (f + me) | 0),
                      (f >>> 0 > re >>> 0) & (f >>> 0 < 2147483647)))
                  ) {
                    if (
                      ((fe = u[5939] | 0),
                      fe | 0 && (Pe >>> 0 <= me >>> 0) | (Pe >>> 0 > fe >>> 0))
                    ) {
                      f = 0
                      break
                    }
                    if (((l = no(f | 0) | 0), (l | 0) == (h | 0))) {
                      ;(b = f), (w = h), (Ie = 145)
                      break e
                    } else (g = l), (Ie = 136)
                  } else f = 0
              while (0)
              do
                if ((Ie | 0) == 136) {
                  if (
                    ((h = (0 - f) | 0),
                    !(
                      (E >>> 0 > f >>> 0) &
                      ((f >>> 0 < 2147483647) & ((g | 0) != -1))
                    ))
                  )
                    if ((g | 0) == -1) {
                      f = 0
                      break
                    } else {
                      ;(b = f), (w = g), (Ie = 145)
                      break e
                    }
                  if (
                    ((l = u[5949] | 0),
                    (l = (I - f + l) & (0 - l)),
                    l >>> 0 >= 2147483647)
                  ) {
                    ;(b = f), (w = g), (Ie = 145)
                    break e
                  }
                  if ((no(l | 0) | 0) == -1) {
                    no(h | 0) | 0, (f = 0)
                    break
                  } else {
                    ;(b = (l + f) | 0), (w = g), (Ie = 145)
                    break e
                  }
                }
              while (0)
              ;(u[5940] = u[5940] | 4), (Ie = 143)
            }
          while (0)
          if (
            ((Ie | 0) == 143 &&
              U >>> 0 < 2147483647 &&
              ((we = no(U | 0) | 0),
              (Pe = no(0) | 0),
              (Qe = (Pe - we) | 0),
              (st = Qe >>> 0 > ((re + 40) | 0) >>> 0),
              !(
                ((we | 0) == -1) |
                (st ^ 1) |
                (((we >>> 0 < Pe >>> 0) &
                  (((we | 0) != -1) & ((Pe | 0) != -1))) ^
                  1)
              )) &&
              ((b = st ? Qe : f), (w = we), (Ie = 145)),
            (Ie | 0) == 145)
          ) {
            ;(f = ((u[5937] | 0) + b) | 0),
              (u[5937] = f),
              f >>> 0 > (u[5938] | 0) >>> 0 && (u[5938] = f),
              (I = u[5835] | 0)
            e: do
              if (I) {
                for (f = 23764; ; ) {
                  if (
                    ((l = u[f >> 2] | 0),
                    (h = u[(f + 4) >> 2] | 0),
                    (w | 0) == ((l + h) | 0))
                  ) {
                    Ie = 154
                    break
                  }
                  if (((g = u[(f + 8) >> 2] | 0), g)) f = g
                  else break
                }
                if (
                  (Ie | 0) == 154 &&
                  ((He = (f + 4) | 0), ((u[(f + 12) >> 2] & 8) | 0) == 0) &&
                  (w >>> 0 > I >>> 0) & (l >>> 0 <= I >>> 0)
                ) {
                  ;(u[He >> 2] = h + b),
                    (he = ((u[5832] | 0) + b) | 0),
                    (we = (I + 8) | 0),
                    (we = ((we & 7) | 0) == 0 ? 0 : (0 - we) & 7),
                    (He = (I + we) | 0),
                    (we = (he - we) | 0),
                    (u[5835] = He),
                    (u[5832] = we),
                    (u[(He + 4) >> 2] = we | 1),
                    (u[(I + he + 4) >> 2] = 40),
                    (u[5836] = u[5951])
                  break
                }
                for (
                  w >>> 0 < (u[5833] | 0) >>> 0 && (u[5833] = w),
                    h = (w + b) | 0,
                    f = 23764;
                  ;

                ) {
                  if ((u[f >> 2] | 0) == (h | 0)) {
                    Ie = 162
                    break
                  }
                  if (((l = u[(f + 8) >> 2] | 0), l)) f = l
                  else break
                }
                if ((Ie | 0) == 162 && ((u[(f + 12) >> 2] & 8) | 0) == 0) {
                  ;(u[f >> 2] = w),
                    (H = (f + 4) | 0),
                    (u[H >> 2] = (u[H >> 2] | 0) + b),
                    (H = (w + 8) | 0),
                    (H = (w + (((H & 7) | 0) == 0 ? 0 : (0 - H) & 7)) | 0),
                    (f = (h + 8) | 0),
                    (f = (h + (((f & 7) | 0) == 0 ? 0 : (0 - f) & 7)) | 0),
                    (U = (H + re) | 0),
                    (E = (f - H - re) | 0),
                    (u[(H + 4) >> 2] = re | 3)
                  t: do
                    if ((I | 0) == (f | 0))
                      (he = ((u[5832] | 0) + E) | 0),
                        (u[5832] = he),
                        (u[5835] = U),
                        (u[(U + 4) >> 2] = he | 1)
                    else {
                      if ((u[5834] | 0) == (f | 0)) {
                        ;(he = ((u[5831] | 0) + E) | 0),
                          (u[5831] = he),
                          (u[5834] = U),
                          (u[(U + 4) >> 2] = he | 1),
                          (u[(U + he) >> 2] = he)
                        break
                      }
                      if (((l = u[(f + 4) >> 2] | 0), ((l & 3) | 0) == 1)) {
                        ;(b = l & -8), (g = l >>> 3)
                        n: do
                          if (l >>> 0 < 256)
                            if (
                              ((l = u[(f + 8) >> 2] | 0),
                              (h = u[(f + 12) >> 2] | 0),
                              (h | 0) == (l | 0))
                            ) {
                              u[5829] = u[5829] & ~(1 << g)
                              break
                            } else {
                              ;(u[(l + 12) >> 2] = h), (u[(h + 8) >> 2] = l)
                              break
                            }
                          else {
                            ;(w = u[(f + 24) >> 2] | 0),
                              (l = u[(f + 12) >> 2] | 0)
                            do
                              if ((l | 0) == (f | 0)) {
                                if (
                                  ((h = (f + 16) | 0),
                                  (g = (h + 4) | 0),
                                  (l = u[g >> 2] | 0),
                                  l)
                                )
                                  h = g
                                else if (((l = u[h >> 2] | 0), !l)) {
                                  l = 0
                                  break
                                }
                                for (;;)
                                  if (
                                    ((v = (l + 20) | 0), (g = u[v >> 2] | 0), g)
                                  )
                                    (l = g), (h = v)
                                  else if (
                                    ((v = (l + 16) | 0), (g = u[v >> 2] | 0), g)
                                  )
                                    (l = g), (h = v)
                                  else break
                                u[h >> 2] = 0
                              } else
                                (he = u[(f + 8) >> 2] | 0),
                                  (u[(he + 12) >> 2] = l),
                                  (u[(l + 8) >> 2] = he)
                            while (0)
                            if (!w) break
                            ;(h = u[(f + 28) >> 2] | 0),
                              (g = (23620 + (h << 2)) | 0)
                            do
                              if ((u[g >> 2] | 0) != (f | 0)) {
                                if (
                                  ((he = (w + 16) | 0),
                                  (u[
                                    ((u[he >> 2] | 0) == (f | 0)
                                      ? he
                                      : (w + 20) | 0) >> 2
                                  ] = l),
                                  !l)
                                )
                                  break n
                              } else {
                                if (((u[g >> 2] = l), l | 0)) break
                                u[5830] = u[5830] & ~(1 << h)
                                break n
                              }
                            while (0)
                            if (
                              ((u[(l + 24) >> 2] = w),
                              (h = (f + 16) | 0),
                              (g = u[h >> 2] | 0),
                              g | 0 &&
                                ((u[(l + 16) >> 2] = g),
                                (u[(g + 24) >> 2] = l)),
                              (h = u[(h + 4) >> 2] | 0),
                              !h)
                            )
                              break
                            ;(u[(l + 20) >> 2] = h), (u[(h + 24) >> 2] = l)
                          }
                        while (0)
                        ;(f = (f + b) | 0), (v = (b + E) | 0)
                      } else v = E
                      if (
                        ((f = (f + 4) | 0),
                        (u[f >> 2] = u[f >> 2] & -2),
                        (u[(U + 4) >> 2] = v | 1),
                        (u[(U + v) >> 2] = v),
                        (f = v >>> 3),
                        v >>> 0 < 256)
                      ) {
                        ;(h = (23356 + ((f << 1) << 2)) | 0),
                          (l = u[5829] | 0),
                          (f = 1 << f),
                          l & f
                            ? ((l = (h + 8) | 0), (f = u[l >> 2] | 0))
                            : ((u[5829] = l | f), (f = h), (l = (h + 8) | 0)),
                          (u[l >> 2] = U),
                          (u[(f + 12) >> 2] = U),
                          (u[(U + 8) >> 2] = f),
                          (u[(U + 12) >> 2] = h)
                        break
                      }
                      f = v >>> 8
                      do
                        if (!f) g = 0
                        else {
                          if (v >>> 0 > 16777215) {
                            g = 31
                            break
                          }
                          ;(He = (((f + 1048320) | 0) >>> 16) & 8),
                            (he = f << He),
                            (we = (((he + 520192) | 0) >>> 16) & 4),
                            (he = he << we),
                            (g = (((he + 245760) | 0) >>> 16) & 2),
                            (g = (14 - (we | He | g) + ((he << g) >>> 15)) | 0),
                            (g = ((v >>> ((g + 7) | 0)) & 1) | (g << 1))
                        }
                      while (0)
                      if (
                        ((f = (23620 + (g << 2)) | 0),
                        (u[(U + 28) >> 2] = g),
                        (l = (U + 16) | 0),
                        (u[(l + 4) >> 2] = 0),
                        (u[l >> 2] = 0),
                        (l = u[5830] | 0),
                        (h = 1 << g),
                        !(l & h))
                      ) {
                        ;(u[5830] = l | h),
                          (u[f >> 2] = U),
                          (u[(U + 24) >> 2] = f),
                          (u[(U + 12) >> 2] = U),
                          (u[(U + 8) >> 2] = U)
                        break
                      }
                      f = u[f >> 2] | 0
                      n: do
                        if (((u[(f + 4) >> 2] & -8) | 0) != (v | 0)) {
                          for (
                            g = v << ((g | 0) == 31 ? 0 : (25 - (g >>> 1)) | 0);
                            (h = (f + 16 + ((g >>> 31) << 2)) | 0),
                              (l = u[h >> 2] | 0),
                              !!l;

                          )
                            if (((u[(l + 4) >> 2] & -8) | 0) == (v | 0)) {
                              f = l
                              break n
                            } else (g = g << 1), (f = l)
                          ;(u[h >> 2] = U),
                            (u[(U + 24) >> 2] = f),
                            (u[(U + 12) >> 2] = U),
                            (u[(U + 8) >> 2] = U)
                          break t
                        }
                      while (0)
                      ;(He = (f + 8) | 0),
                        (he = u[He >> 2] | 0),
                        (u[(he + 12) >> 2] = U),
                        (u[He >> 2] = U),
                        (u[(U + 8) >> 2] = he),
                        (u[(U + 12) >> 2] = f),
                        (u[(U + 24) >> 2] = 0)
                    }
                  while (0)
                  return (he = (H + 8) | 0), (ie = ot), he | 0
                }
                for (
                  f = 23764;
                  (l = u[f >> 2] | 0),
                    !(
                      l >>> 0 <= I >>> 0 &&
                      ((he = (l + (u[(f + 4) >> 2] | 0)) | 0),
                      he >>> 0 > I >>> 0)
                    );

                )
                  f = u[(f + 8) >> 2] | 0
                ;(v = (he + -47) | 0),
                  (l = (v + 8) | 0),
                  (l = (v + (((l & 7) | 0) == 0 ? 0 : (0 - l) & 7)) | 0),
                  (v = (I + 16) | 0),
                  (l = l >>> 0 < v >>> 0 ? I : l),
                  (f = (l + 8) | 0),
                  (h = (b + -40) | 0),
                  (we = (w + 8) | 0),
                  (we = ((we & 7) | 0) == 0 ? 0 : (0 - we) & 7),
                  (He = (w + we) | 0),
                  (we = (h - we) | 0),
                  (u[5835] = He),
                  (u[5832] = we),
                  (u[(He + 4) >> 2] = we | 1),
                  (u[(w + h + 4) >> 2] = 40),
                  (u[5836] = u[5951]),
                  (h = (l + 4) | 0),
                  (u[h >> 2] = 27),
                  (u[f >> 2] = u[5941]),
                  (u[(f + 4) >> 2] = u[5942]),
                  (u[(f + 8) >> 2] = u[5943]),
                  (u[(f + 12) >> 2] = u[5944]),
                  (u[5941] = w),
                  (u[5942] = b),
                  (u[5944] = 0),
                  (u[5943] = f),
                  (f = (l + 24) | 0)
                do (He = f), (f = (f + 4) | 0), (u[f >> 2] = 7)
                while (((He + 8) | 0) >>> 0 < he >>> 0)
                if ((l | 0) != (I | 0)) {
                  if (
                    ((w = (l - I) | 0),
                    (u[h >> 2] = u[h >> 2] & -2),
                    (u[(I + 4) >> 2] = w | 1),
                    (u[l >> 2] = w),
                    (f = w >>> 3),
                    w >>> 0 < 256)
                  ) {
                    ;(h = (23356 + ((f << 1) << 2)) | 0),
                      (l = u[5829] | 0),
                      (f = 1 << f),
                      l & f
                        ? ((l = (h + 8) | 0), (f = u[l >> 2] | 0))
                        : ((u[5829] = l | f), (f = h), (l = (h + 8) | 0)),
                      (u[l >> 2] = I),
                      (u[(f + 12) >> 2] = I),
                      (u[(I + 8) >> 2] = f),
                      (u[(I + 12) >> 2] = h)
                    break
                  }
                  if (
                    ((f = w >>> 8),
                    f
                      ? w >>> 0 > 16777215
                        ? (g = 31)
                        : ((He = (((f + 1048320) | 0) >>> 16) & 8),
                          (he = f << He),
                          (we = (((he + 520192) | 0) >>> 16) & 4),
                          (he = he << we),
                          (g = (((he + 245760) | 0) >>> 16) & 2),
                          (g = (14 - (we | He | g) + ((he << g) >>> 15)) | 0),
                          (g = ((w >>> ((g + 7) | 0)) & 1) | (g << 1)))
                      : (g = 0),
                    (h = (23620 + (g << 2)) | 0),
                    (u[(I + 28) >> 2] = g),
                    (u[(I + 20) >> 2] = 0),
                    (u[v >> 2] = 0),
                    (f = u[5830] | 0),
                    (l = 1 << g),
                    !(f & l))
                  ) {
                    ;(u[5830] = f | l),
                      (u[h >> 2] = I),
                      (u[(I + 24) >> 2] = h),
                      (u[(I + 12) >> 2] = I),
                      (u[(I + 8) >> 2] = I)
                    break
                  }
                  f = u[h >> 2] | 0
                  t: do
                    if (((u[(f + 4) >> 2] & -8) | 0) != (w | 0)) {
                      for (
                        g = w << ((g | 0) == 31 ? 0 : (25 - (g >>> 1)) | 0);
                        (h = (f + 16 + ((g >>> 31) << 2)) | 0),
                          (l = u[h >> 2] | 0),
                          !!l;

                      )
                        if (((u[(l + 4) >> 2] & -8) | 0) == (w | 0)) {
                          f = l
                          break t
                        } else (g = g << 1), (f = l)
                      ;(u[h >> 2] = I),
                        (u[(I + 24) >> 2] = f),
                        (u[(I + 12) >> 2] = I),
                        (u[(I + 8) >> 2] = I)
                      break e
                    }
                  while (0)
                  ;(He = (f + 8) | 0),
                    (he = u[He >> 2] | 0),
                    (u[(he + 12) >> 2] = I),
                    (u[He >> 2] = I),
                    (u[(I + 8) >> 2] = he),
                    (u[(I + 12) >> 2] = f),
                    (u[(I + 24) >> 2] = 0)
                }
              } else
                (he = u[5833] | 0),
                  ((he | 0) == 0) | (w >>> 0 < he >>> 0) && (u[5833] = w),
                  (u[5941] = w),
                  (u[5942] = b),
                  (u[5944] = 0),
                  (u[5838] = u[5947]),
                  (u[5837] = -1),
                  (u[5842] = 23356),
                  (u[5841] = 23356),
                  (u[5844] = 23364),
                  (u[5843] = 23364),
                  (u[5846] = 23372),
                  (u[5845] = 23372),
                  (u[5848] = 23380),
                  (u[5847] = 23380),
                  (u[5850] = 23388),
                  (u[5849] = 23388),
                  (u[5852] = 23396),
                  (u[5851] = 23396),
                  (u[5854] = 23404),
                  (u[5853] = 23404),
                  (u[5856] = 23412),
                  (u[5855] = 23412),
                  (u[5858] = 23420),
                  (u[5857] = 23420),
                  (u[5860] = 23428),
                  (u[5859] = 23428),
                  (u[5862] = 23436),
                  (u[5861] = 23436),
                  (u[5864] = 23444),
                  (u[5863] = 23444),
                  (u[5866] = 23452),
                  (u[5865] = 23452),
                  (u[5868] = 23460),
                  (u[5867] = 23460),
                  (u[5870] = 23468),
                  (u[5869] = 23468),
                  (u[5872] = 23476),
                  (u[5871] = 23476),
                  (u[5874] = 23484),
                  (u[5873] = 23484),
                  (u[5876] = 23492),
                  (u[5875] = 23492),
                  (u[5878] = 23500),
                  (u[5877] = 23500),
                  (u[5880] = 23508),
                  (u[5879] = 23508),
                  (u[5882] = 23516),
                  (u[5881] = 23516),
                  (u[5884] = 23524),
                  (u[5883] = 23524),
                  (u[5886] = 23532),
                  (u[5885] = 23532),
                  (u[5888] = 23540),
                  (u[5887] = 23540),
                  (u[5890] = 23548),
                  (u[5889] = 23548),
                  (u[5892] = 23556),
                  (u[5891] = 23556),
                  (u[5894] = 23564),
                  (u[5893] = 23564),
                  (u[5896] = 23572),
                  (u[5895] = 23572),
                  (u[5898] = 23580),
                  (u[5897] = 23580),
                  (u[5900] = 23588),
                  (u[5899] = 23588),
                  (u[5902] = 23596),
                  (u[5901] = 23596),
                  (u[5904] = 23604),
                  (u[5903] = 23604),
                  (he = (b + -40) | 0),
                  (we = (w + 8) | 0),
                  (we = ((we & 7) | 0) == 0 ? 0 : (0 - we) & 7),
                  (He = (w + we) | 0),
                  (we = (he - we) | 0),
                  (u[5835] = He),
                  (u[5832] = we),
                  (u[(He + 4) >> 2] = we | 1),
                  (u[(w + he + 4) >> 2] = 40),
                  (u[5836] = u[5951])
            while (0)
            if (((f = u[5832] | 0), f >>> 0 > re >>> 0))
              return (
                (we = (f - re) | 0),
                (u[5832] = we),
                (he = u[5835] | 0),
                (He = (he + re) | 0),
                (u[5835] = He),
                (u[(He + 4) >> 2] = we | 1),
                (u[(he + 4) >> 2] = re | 3),
                (he = (he + 8) | 0),
                (ie = ot),
                he | 0
              )
          }
          return (he = GS() | 0), (u[he >> 2] = 12), (he = 0), (ie = ot), he | 0
        }
        function Lt(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0,
            v = 0,
            w = 0,
            b = 0,
            E = 0,
            I = 0
          if (!l) return
          ;(h = (l + -8) | 0),
            (v = u[5833] | 0),
            (l = u[(l + -4) >> 2] | 0),
            (f = l & -8),
            (I = (h + f) | 0)
          do
            if (l & 1) (E = h), (b = h)
            else {
              if (
                ((g = u[h >> 2] | 0),
                !(l & 3) ||
                  ((b = (h + (0 - g)) | 0),
                  (w = (g + f) | 0),
                  b >>> 0 < v >>> 0))
              )
                return
              if ((u[5834] | 0) == (b | 0)) {
                if (
                  ((l = (I + 4) | 0), (f = u[l >> 2] | 0), ((f & 3) | 0) != 3)
                ) {
                  ;(E = b), (f = w)
                  break
                }
                ;(u[5831] = w),
                  (u[l >> 2] = f & -2),
                  (u[(b + 4) >> 2] = w | 1),
                  (u[(b + w) >> 2] = w)
                return
              }
              if (((h = g >>> 3), g >>> 0 < 256))
                if (
                  ((l = u[(b + 8) >> 2] | 0),
                  (f = u[(b + 12) >> 2] | 0),
                  (f | 0) == (l | 0))
                ) {
                  ;(u[5829] = u[5829] & ~(1 << h)), (E = b), (f = w)
                  break
                } else {
                  ;(u[(l + 12) >> 2] = f),
                    (u[(f + 8) >> 2] = l),
                    (E = b),
                    (f = w)
                  break
                }
              ;(v = u[(b + 24) >> 2] | 0), (l = u[(b + 12) >> 2] | 0)
              do
                if ((l | 0) == (b | 0)) {
                  if (
                    ((f = (b + 16) | 0),
                    (h = (f + 4) | 0),
                    (l = u[h >> 2] | 0),
                    l)
                  )
                    f = h
                  else if (((l = u[f >> 2] | 0), !l)) {
                    l = 0
                    break
                  }
                  for (;;)
                    if (((g = (l + 20) | 0), (h = u[g >> 2] | 0), h))
                      (l = h), (f = g)
                    else if (((g = (l + 16) | 0), (h = u[g >> 2] | 0), h))
                      (l = h), (f = g)
                    else break
                  u[f >> 2] = 0
                } else
                  (E = u[(b + 8) >> 2] | 0),
                    (u[(E + 12) >> 2] = l),
                    (u[(l + 8) >> 2] = E)
              while (0)
              if (v) {
                if (
                  ((f = u[(b + 28) >> 2] | 0),
                  (h = (23620 + (f << 2)) | 0),
                  (u[h >> 2] | 0) == (b | 0))
                ) {
                  if (((u[h >> 2] = l), !l)) {
                    ;(u[5830] = u[5830] & ~(1 << f)), (E = b), (f = w)
                    break
                  }
                } else if (
                  ((E = (v + 16) | 0),
                  (u[((u[E >> 2] | 0) == (b | 0) ? E : (v + 20) | 0) >> 2] = l),
                  !l)
                ) {
                  ;(E = b), (f = w)
                  break
                }
                ;(u[(l + 24) >> 2] = v),
                  (f = (b + 16) | 0),
                  (h = u[f >> 2] | 0),
                  h | 0 && ((u[(l + 16) >> 2] = h), (u[(h + 24) >> 2] = l)),
                  (f = u[(f + 4) >> 2] | 0),
                  f
                    ? ((u[(l + 20) >> 2] = f),
                      (u[(f + 24) >> 2] = l),
                      (E = b),
                      (f = w))
                    : ((E = b), (f = w))
              } else (E = b), (f = w)
            }
          while (0)
          if (
            b >>> 0 >= I >>> 0 ||
            ((l = (I + 4) | 0), (g = u[l >> 2] | 0), !(g & 1))
          )
            return
          if (g & 2)
            (u[l >> 2] = g & -2),
              (u[(E + 4) >> 2] = f | 1),
              (u[(b + f) >> 2] = f),
              (v = f)
          else {
            if ((u[5835] | 0) == (I | 0)) {
              if (
                ((I = ((u[5832] | 0) + f) | 0),
                (u[5832] = I),
                (u[5835] = E),
                (u[(E + 4) >> 2] = I | 1),
                (E | 0) != (u[5834] | 0))
              )
                return
              ;(u[5834] = 0), (u[5831] = 0)
              return
            }
            if ((u[5834] | 0) == (I | 0)) {
              ;(I = ((u[5831] | 0) + f) | 0),
                (u[5831] = I),
                (u[5834] = b),
                (u[(E + 4) >> 2] = I | 1),
                (u[(b + I) >> 2] = I)
              return
            }
            ;(v = ((g & -8) + f) | 0), (h = g >>> 3)
            do
              if (g >>> 0 < 256)
                if (
                  ((f = u[(I + 8) >> 2] | 0),
                  (l = u[(I + 12) >> 2] | 0),
                  (l | 0) == (f | 0))
                ) {
                  u[5829] = u[5829] & ~(1 << h)
                  break
                } else {
                  ;(u[(f + 12) >> 2] = l), (u[(l + 8) >> 2] = f)
                  break
                }
              else {
                ;(w = u[(I + 24) >> 2] | 0), (l = u[(I + 12) >> 2] | 0)
                do
                  if ((l | 0) == (I | 0)) {
                    if (
                      ((f = (I + 16) | 0),
                      (h = (f + 4) | 0),
                      (l = u[h >> 2] | 0),
                      l)
                    )
                      f = h
                    else if (((l = u[f >> 2] | 0), !l)) {
                      h = 0
                      break
                    }
                    for (;;)
                      if (((g = (l + 20) | 0), (h = u[g >> 2] | 0), h))
                        (l = h), (f = g)
                      else if (((g = (l + 16) | 0), (h = u[g >> 2] | 0), h))
                        (l = h), (f = g)
                      else break
                    ;(u[f >> 2] = 0), (h = l)
                  } else
                    (h = u[(I + 8) >> 2] | 0),
                      (u[(h + 12) >> 2] = l),
                      (u[(l + 8) >> 2] = h),
                      (h = l)
                while (0)
                if (w | 0) {
                  if (
                    ((l = u[(I + 28) >> 2] | 0),
                    (f = (23620 + (l << 2)) | 0),
                    (u[f >> 2] | 0) == (I | 0))
                  ) {
                    if (((u[f >> 2] = h), !h)) {
                      u[5830] = u[5830] & ~(1 << l)
                      break
                    }
                  } else if (
                    ((g = (w + 16) | 0),
                    (u[((u[g >> 2] | 0) == (I | 0) ? g : (w + 20) | 0) >> 2] =
                      h),
                    !h)
                  )
                    break
                  ;(u[(h + 24) >> 2] = w),
                    (l = (I + 16) | 0),
                    (f = u[l >> 2] | 0),
                    f | 0 && ((u[(h + 16) >> 2] = f), (u[(f + 24) >> 2] = h)),
                    (l = u[(l + 4) >> 2] | 0),
                    l | 0 && ((u[(h + 20) >> 2] = l), (u[(l + 24) >> 2] = h))
                }
              }
            while (0)
            if (
              ((u[(E + 4) >> 2] = v | 1),
              (u[(b + v) >> 2] = v),
              (E | 0) == (u[5834] | 0))
            ) {
              u[5831] = v
              return
            }
          }
          if (((l = v >>> 3), v >>> 0 < 256)) {
            ;(h = (23356 + ((l << 1) << 2)) | 0),
              (f = u[5829] | 0),
              (l = 1 << l),
              f & l
                ? ((f = (h + 8) | 0), (l = u[f >> 2] | 0))
                : ((u[5829] = f | l), (l = h), (f = (h + 8) | 0)),
              (u[f >> 2] = E),
              (u[(l + 12) >> 2] = E),
              (u[(E + 8) >> 2] = l),
              (u[(E + 12) >> 2] = h)
            return
          }
          ;(l = v >>> 8),
            l
              ? v >>> 0 > 16777215
                ? (g = 31)
                : ((b = (((l + 1048320) | 0) >>> 16) & 8),
                  (I = l << b),
                  (w = (((I + 520192) | 0) >>> 16) & 4),
                  (I = I << w),
                  (g = (((I + 245760) | 0) >>> 16) & 2),
                  (g = (14 - (w | b | g) + ((I << g) >>> 15)) | 0),
                  (g = ((v >>> ((g + 7) | 0)) & 1) | (g << 1)))
              : (g = 0),
            (l = (23620 + (g << 2)) | 0),
            (u[(E + 28) >> 2] = g),
            (u[(E + 20) >> 2] = 0),
            (u[(E + 16) >> 2] = 0),
            (f = u[5830] | 0),
            (h = 1 << g)
          e: do
            if (!(f & h))
              (u[5830] = f | h),
                (u[l >> 2] = E),
                (u[(E + 24) >> 2] = l),
                (u[(E + 12) >> 2] = E),
                (u[(E + 8) >> 2] = E)
            else {
              l = u[l >> 2] | 0
              t: do
                if (((u[(l + 4) >> 2] & -8) | 0) != (v | 0)) {
                  for (
                    g = v << ((g | 0) == 31 ? 0 : (25 - (g >>> 1)) | 0);
                    (h = (l + 16 + ((g >>> 31) << 2)) | 0),
                      (f = u[h >> 2] | 0),
                      !!f;

                  )
                    if (((u[(f + 4) >> 2] & -8) | 0) == (v | 0)) {
                      l = f
                      break t
                    } else (g = g << 1), (l = f)
                  ;(u[h >> 2] = E),
                    (u[(E + 24) >> 2] = l),
                    (u[(E + 12) >> 2] = E),
                    (u[(E + 8) >> 2] = E)
                  break e
                }
              while (0)
              ;(b = (l + 8) | 0),
                (I = u[b >> 2] | 0),
                (u[(I + 12) >> 2] = E),
                (u[b >> 2] = E),
                (u[(E + 8) >> 2] = I),
                (u[(E + 12) >> 2] = l),
                (u[(E + 24) >> 2] = 0)
            }
          while (0)
          if (((I = ((u[5837] | 0) + -1) | 0), (u[5837] = I), !(I | 0))) {
            for (l = 23772; (l = u[l >> 2] | 0), l; ) l = (l + 8) | 0
            u[5837] = -1
          }
        }
        function Tr(l, f) {
          ;(l = l | 0), (f = f | 0)
          var h = 0
          return (
            l
              ? ((h = un(f, l) | 0),
                (f | l) >>> 0 > 65535 &&
                  (h = (((h >>> 0) / (l >>> 0)) | 0 | 0) == (f | 0) ? h : -1))
              : (h = 0),
            (l = Vr(h) | 0),
            !l || !(u[(l + -4) >> 2] & 3) || Cr(l | 0, 0, h | 0) | 0,
            l | 0
          )
        }
        function WS(l, f, h, g) {
          return (
            (l = l | 0),
            (f = f | 0),
            (h = h | 0),
            (g = g | 0),
            (h = (l + h) >>> 0),
            Ct(((f + g + ((h >>> 0 < l >>> 0) | 0)) >>> 0) | 0),
            h | 0 | 0
          )
        }
        function Jc(l, f, h, g) {
          return (
            (l = l | 0),
            (f = f | 0),
            (h = h | 0),
            (g = g | 0),
            (g = (f - g - ((h >>> 0 > l >>> 0) | 0)) >>> 0),
            Ct(g | 0),
            ((l - h) >>> 0) | 0 | 0
          )
        }
        function Vy(l) {
          return (l = l | 0), (l ? (31 - (Wn(l ^ (l - 1)) | 0)) | 0 : 32) | 0
        }
        function jS(l, f, h, g, v) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0), (v = v | 0)
          var w = 0,
            b = 0,
            E = 0,
            I = 0,
            U = 0,
            H = 0,
            re = 0,
            fe = 0,
            me = 0,
            Pe = 0
          if (((H = l), (I = f), (U = I), (b = h), (fe = g), (E = fe), !U))
            return (
              (w = (v | 0) != 0),
              E
                ? w
                  ? ((u[v >> 2] = l | 0),
                    (u[(v + 4) >> 2] = f & 0),
                    (fe = 0),
                    (v = 0),
                    Ct(fe | 0),
                    v | 0)
                  : ((fe = 0), (v = 0), Ct(fe | 0), v | 0)
                : (w &&
                    ((u[v >> 2] = (H >>> 0) % (b >>> 0)),
                    (u[(v + 4) >> 2] = 0)),
                  (fe = 0),
                  (v = ((H >>> 0) / (b >>> 0)) >>> 0),
                  Ct(fe | 0),
                  v | 0)
            )
          w = (E | 0) == 0
          do
            if (b) {
              if (!w) {
                if (
                  ((w = ((Wn(E | 0) | 0) - (Wn(U | 0) | 0)) | 0), w >>> 0 <= 31)
                ) {
                  ;(re = (w + 1) | 0),
                    (E = (31 - w) | 0),
                    (f = (w - 31) >> 31),
                    (b = re),
                    (l = ((H >>> (re >>> 0)) & f) | (U << E)),
                    (f = (U >>> (re >>> 0)) & f),
                    (w = 0),
                    (E = H << E)
                  break
                }
                return v
                  ? ((u[v >> 2] = l | 0),
                    (u[(v + 4) >> 2] = I | (f & 0)),
                    (fe = 0),
                    (v = 0),
                    Ct(fe | 0),
                    v | 0)
                  : ((fe = 0), (v = 0), Ct(fe | 0), v | 0)
              }
              if (((w = (b - 1) | 0), (w & b) | 0)) {
                ;(E = ((Wn(b | 0) | 0) + 33 - (Wn(U | 0) | 0)) | 0),
                  (Pe = (64 - E) | 0),
                  (re = (32 - E) | 0),
                  (I = re >> 31),
                  (me = (E - 32) | 0),
                  (f = me >> 31),
                  (b = E),
                  (l =
                    (((re - 1) >> 31) & (U >>> (me >>> 0))) |
                    (((U << re) | (H >>> (E >>> 0))) & f)),
                  (f = f & (U >>> (E >>> 0))),
                  (w = (H << Pe) & I),
                  (E =
                    (((U << Pe) | (H >>> (me >>> 0))) & I) |
                    ((H << re) & ((E - 33) >> 31)))
                break
              }
              return (
                v | 0 && ((u[v >> 2] = w & H), (u[(v + 4) >> 2] = 0)),
                (b | 0) == 1
                  ? ((me = I | (f & 0)), (Pe = l | 0 | 0), Ct(me | 0), Pe | 0)
                  : ((Pe = Vy(b | 0) | 0),
                    (me = (U >>> (Pe >>> 0)) | 0),
                    (Pe = (U << (32 - Pe)) | (H >>> (Pe >>> 0)) | 0),
                    Ct(me | 0),
                    Pe | 0)
              )
            } else {
              if (w)
                return (
                  v | 0 &&
                    ((u[v >> 2] = (U >>> 0) % (b >>> 0)),
                    (u[(v + 4) >> 2] = 0)),
                  (me = 0),
                  (Pe = ((U >>> 0) / (b >>> 0)) >>> 0),
                  Ct(me | 0),
                  Pe | 0
                )
              if (!H)
                return (
                  v | 0 &&
                    ((u[v >> 2] = 0),
                    (u[(v + 4) >> 2] = (U >>> 0) % (E >>> 0))),
                  (me = 0),
                  (Pe = ((U >>> 0) / (E >>> 0)) >>> 0),
                  Ct(me | 0),
                  Pe | 0
                )
              if (((w = (E - 1) | 0), !(w & E)))
                return (
                  v | 0 &&
                    ((u[v >> 2] = l | 0),
                    (u[(v + 4) >> 2] = (w & U) | (f & 0))),
                  (me = 0),
                  (Pe = U >>> ((Vy(E | 0) | 0) >>> 0)),
                  Ct(me | 0),
                  Pe | 0
                )
              if (
                ((w = ((Wn(E | 0) | 0) - (Wn(U | 0) | 0)) | 0), w >>> 0 <= 30)
              ) {
                ;(f = (w + 1) | 0),
                  (E = (31 - w) | 0),
                  (b = f),
                  (l = (U << E) | (H >>> (f >>> 0))),
                  (f = U >>> (f >>> 0)),
                  (w = 0),
                  (E = H << E)
                break
              }
              return v
                ? ((u[v >> 2] = l | 0),
                  (u[(v + 4) >> 2] = I | (f & 0)),
                  (me = 0),
                  (Pe = 0),
                  Ct(me | 0),
                  Pe | 0)
                : ((me = 0), (Pe = 0), Ct(me | 0), Pe | 0)
            }
          while (0)
          if (!b) (U = E), (I = 0), (E = 0)
          else {
            ;(re = h | 0 | 0),
              (H = fe | (g & 0)),
              (U = WS(re | 0, H | 0, -1, -1) | 0),
              (h = ce() | 0),
              (I = E),
              (E = 0)
            do
              (g = I),
                (I = (w >>> 31) | (I << 1)),
                (w = E | (w << 1)),
                (g = (l << 1) | (g >>> 31) | 0),
                (fe = (l >>> 31) | (f << 1) | 0),
                Jc(U | 0, h | 0, g | 0, fe | 0) | 0,
                (Pe = ce() | 0),
                (me = (Pe >> 31) | (((Pe | 0) < 0 ? -1 : 0) << 1)),
                (E = me & 1),
                (l =
                  Jc(
                    g | 0,
                    fe | 0,
                    (me & re) | 0,
                    (((((Pe | 0) < 0 ? -1 : 0) >> 31) |
                      (((Pe | 0) < 0 ? -1 : 0) << 1)) &
                      H) |
                      0
                  ) | 0),
                (f = ce() | 0),
                (b = (b - 1) | 0)
            while ((b | 0) != 0)
            ;(U = I), (I = 0)
          }
          return (
            (b = 0),
            v | 0 && ((u[v >> 2] = l), (u[(v + 4) >> 2] = f)),
            (me =
              ((w | 0) >>> 31) |
              ((U | b) << 1) |
              (((b << 1) | (w >>> 31)) & 0) |
              I),
            (Pe = (((w << 1) | (0 >>> 31)) & -2) | E),
            Ct(me | 0),
            Pe | 0
          )
        }
        function to(l, f, h, g) {
          ;(l = l | 0), (f = f | 0), (h = h | 0), (g = g | 0)
          var v = 0,
            w = 0
          return (
            (w = ie),
            (ie = (ie + 16) | 0),
            (v = w | 0),
            jS(l, f, h, g, v) | 0,
            (ie = w),
            Ct(u[(v + 4) >> 2] | 0),
            u[v >> 2] | 0 | 0
          )
        }
        function $e(l, f, h) {
          return (
            (l = l | 0),
            (f = f | 0),
            (h = h | 0),
            (h | 0) < 32
              ? (Ct((f >>> h) | 0),
                (l >>> h) | ((f & ((1 << h) - 1)) << (32 - h)))
              : (Ct(0), (f >>> (h - 32)) | 0)
          )
        }
        function rt(l, f, h) {
          return (
            (l = l | 0),
            (f = f | 0),
            (h = h | 0),
            (h | 0) < 32
              ? (Ct(
                  (f << h) |
                    ((l & (((1 << h) - 1) << (32 - h))) >>> (32 - h)) |
                    0
                ),
                l << h)
              : (Ct((l << (h - 32)) | 0), 0)
          )
        }
        function Wy(l, f) {
          return (l = +l), (f = +f), l != l ? +f : f != f ? +l : +Yo(+l, +f)
        }
        function af(l) {
          return (l = +l), l >= 0 ? +pt(l + 0.5) : +Di(l - 0.5)
        }
        function lf(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0
          if ((h | 0) >= 8192) return AM(l | 0, f | 0, h | 0) | 0, l | 0
          if (((w = l | 0), (v = (l + h) | 0), (l & 3) == (f & 3))) {
            for (; l & 3; ) {
              if (!h) return w | 0
              ;(Ve[l >> 0] = Ve[f >> 0] | 0),
                (l = (l + 1) | 0),
                (f = (f + 1) | 0),
                (h = (h - 1) | 0)
            }
            for (h = (v & -4) | 0, g = (h - 64) | 0; (l | 0) <= (g | 0); )
              (u[l >> 2] = u[f >> 2]),
                (u[(l + 4) >> 2] = u[(f + 4) >> 2]),
                (u[(l + 8) >> 2] = u[(f + 8) >> 2]),
                (u[(l + 12) >> 2] = u[(f + 12) >> 2]),
                (u[(l + 16) >> 2] = u[(f + 16) >> 2]),
                (u[(l + 20) >> 2] = u[(f + 20) >> 2]),
                (u[(l + 24) >> 2] = u[(f + 24) >> 2]),
                (u[(l + 28) >> 2] = u[(f + 28) >> 2]),
                (u[(l + 32) >> 2] = u[(f + 32) >> 2]),
                (u[(l + 36) >> 2] = u[(f + 36) >> 2]),
                (u[(l + 40) >> 2] = u[(f + 40) >> 2]),
                (u[(l + 44) >> 2] = u[(f + 44) >> 2]),
                (u[(l + 48) >> 2] = u[(f + 48) >> 2]),
                (u[(l + 52) >> 2] = u[(f + 52) >> 2]),
                (u[(l + 56) >> 2] = u[(f + 56) >> 2]),
                (u[(l + 60) >> 2] = u[(f + 60) >> 2]),
                (l = (l + 64) | 0),
                (f = (f + 64) | 0)
            for (; (l | 0) < (h | 0); )
              (u[l >> 2] = u[f >> 2]), (l = (l + 4) | 0), (f = (f + 4) | 0)
          } else
            for (h = (v - 4) | 0; (l | 0) < (h | 0); )
              (Ve[l >> 0] = Ve[f >> 0] | 0),
                (Ve[(l + 1) >> 0] = Ve[(f + 1) >> 0] | 0),
                (Ve[(l + 2) >> 0] = Ve[(f + 2) >> 0] | 0),
                (Ve[(l + 3) >> 0] = Ve[(f + 3) >> 0] | 0),
                (l = (l + 4) | 0),
                (f = (f + 4) | 0)
          for (; (l | 0) < (v | 0); )
            (Ve[l >> 0] = Ve[f >> 0] | 0), (l = (l + 1) | 0), (f = (f + 1) | 0)
          return w | 0
        }
        function Cr(l, f, h) {
          ;(l = l | 0), (f = f | 0), (h = h | 0)
          var g = 0,
            v = 0,
            w = 0,
            b = 0
          if (((w = (l + h) | 0), (f = f & 255), (h | 0) >= 67)) {
            for (; l & 3; ) (Ve[l >> 0] = f), (l = (l + 1) | 0)
            for (
              g = (w & -4) | 0,
                b = f | (f << 8) | (f << 16) | (f << 24),
                v = (g - 64) | 0;
              (l | 0) <= (v | 0);

            )
              (u[l >> 2] = b),
                (u[(l + 4) >> 2] = b),
                (u[(l + 8) >> 2] = b),
                (u[(l + 12) >> 2] = b),
                (u[(l + 16) >> 2] = b),
                (u[(l + 20) >> 2] = b),
                (u[(l + 24) >> 2] = b),
                (u[(l + 28) >> 2] = b),
                (u[(l + 32) >> 2] = b),
                (u[(l + 36) >> 2] = b),
                (u[(l + 40) >> 2] = b),
                (u[(l + 44) >> 2] = b),
                (u[(l + 48) >> 2] = b),
                (u[(l + 52) >> 2] = b),
                (u[(l + 56) >> 2] = b),
                (u[(l + 60) >> 2] = b),
                (l = (l + 64) | 0)
            for (; (l | 0) < (g | 0); ) (u[l >> 2] = b), (l = (l + 4) | 0)
          }
          for (; (l | 0) < (w | 0); ) (Ve[l >> 0] = f), (l = (l + 1) | 0)
          return (w - h) | 0
        }
        function jy(l) {
          return (l = +l), l >= 0 ? +pt(l + 0.5) : +Di(l - 0.5)
        }
        function no(l) {
          l = l | 0
          var f = 0,
            h = 0,
            g = 0
          return (
            (g = cM() | 0),
            (h = u[gt >> 2] | 0),
            (f = (h + l) | 0),
            (((l | 0) > 0) & ((f | 0) < (h | 0))) | ((f | 0) < 0)
              ? (fM(f | 0) | 0, uy(12), -1)
              : (f | 0) > (g | 0) && !(uM(f | 0) | 0)
              ? (uy(12), -1)
              : ((u[gt >> 2] = f), h | 0)
          )
        }
        return {
          ___uremdi3: to,
          _bitshift64Lshr: $e,
          _bitshift64Shl: rt,
          _calloc: Tr,
          _cellAreaKm2: ZM,
          _cellAreaM2: JM,
          _cellAreaRads2: YM,
          _compact: sS,
          _destroyLinkedPolygon: xS,
          _edgeLengthKm: $M,
          _edgeLengthM: QM,
          _emscripten_replace_memory: hM,
          _exactEdgeLengthKm: eS,
          _exactEdgeLengthM: tS,
          _exactEdgeLengthRads: KM,
          _experimentalH3ToLocalIj: bS,
          _experimentalLocalIjToH3: wS,
          _free: Lt,
          _geoToH3: Ly,
          _getDestinationH3IndexFromUnidirectionalEdge: pS,
          _getH3IndexesFromUnidirectionalEdge: gS,
          _getH3UnidirectionalEdge: hS,
          _getH3UnidirectionalEdgeBoundary: rf,
          _getH3UnidirectionalEdgesFromHexagon: yS,
          _getOriginH3IndexFromUnidirectionalEdge: dS,
          _getPentagonIndexes: fp,
          _getRes0Indexes: PM,
          _h3Distance: MS,
          _h3GetBaseCell: Ry,
          _h3GetFaces: Dy,
          _h3GetResolution: nS,
          _h3IndexesAreNeighbors: Iy,
          _h3IsPentagon: jn,
          _h3IsResClassIII: lS,
          _h3IsValid: Py,
          _h3Line: ES,
          _h3LineSize: SS,
          _h3SetToLinkedGeo: SM,
          _h3ToCenterChild: rS,
          _h3ToChildren: Ii,
          _h3ToGeo: ea,
          _h3ToGeoBoundary: ta,
          _h3ToParent: lp,
          _h3UnidirectionalEdgeIsValid: mS,
          _hexAreaKm2: WM,
          _hexAreaM2: jM,
          _hexRing: _M,
          _i64Subtract: Jc,
          _kRing: fy,
          _kRingDistances: vM,
          _llvm_minnum_f64: Wy,
          _llvm_round_f64: af,
          _malloc: Vr,
          _maxFaceCount: uS,
          _maxH3ToChildrenSize: iS,
          _maxKringSize: yM,
          _maxPolyfillSize: xM,
          _maxUncompactSize: aS,
          _memcpy: lf,
          _memset: Cr,
          _numHexagons: XM,
          _pentagonIndexCount: fS,
          _pointDistKm: Yc,
          _pointDistM: HM,
          _pointDistRads: zM,
          _polyfill: bM,
          _res0IndexCount: RM,
          _round: jy,
          _sbrk: no,
          _sizeOfCoordIJ: kS,
          _sizeOfGeoBoundary: LS,
          _sizeOfGeoCoord: PS,
          _sizeOfGeoPolygon: IS,
          _sizeOfGeofence: DS,
          _sizeOfH3Index: RS,
          _sizeOfLinkedGeoPolygon: BS,
          _uncompact: oS,
          establishStackSpace: gM,
          stackAlloc: dM,
          stackRestore: mM,
          stackSave: pM,
        }
      })(vi, yn, P)
    ;(e.___uremdi3 = We.___uremdi3),
      (e._bitshift64Lshr = We._bitshift64Lshr),
      (e._bitshift64Shl = We._bitshift64Shl),
      (e._calloc = We._calloc),
      (e._cellAreaKm2 = We._cellAreaKm2),
      (e._cellAreaM2 = We._cellAreaM2),
      (e._cellAreaRads2 = We._cellAreaRads2),
      (e._compact = We._compact),
      (e._destroyLinkedPolygon = We._destroyLinkedPolygon),
      (e._edgeLengthKm = We._edgeLengthKm),
      (e._edgeLengthM = We._edgeLengthM)
    var Er = (e._emscripten_replace_memory = We._emscripten_replace_memory)
    ;(e._exactEdgeLengthKm = We._exactEdgeLengthKm),
      (e._exactEdgeLengthM = We._exactEdgeLengthM),
      (e._exactEdgeLengthRads = We._exactEdgeLengthRads),
      (e._experimentalH3ToLocalIj = We._experimentalH3ToLocalIj),
      (e._experimentalLocalIjToH3 = We._experimentalLocalIjToH3),
      (e._free = We._free),
      (e._geoToH3 = We._geoToH3),
      (e._getDestinationH3IndexFromUnidirectionalEdge =
        We._getDestinationH3IndexFromUnidirectionalEdge),
      (e._getH3IndexesFromUnidirectionalEdge =
        We._getH3IndexesFromUnidirectionalEdge),
      (e._getH3UnidirectionalEdge = We._getH3UnidirectionalEdge),
      (e._getH3UnidirectionalEdgeBoundary =
        We._getH3UnidirectionalEdgeBoundary),
      (e._getH3UnidirectionalEdgesFromHexagon =
        We._getH3UnidirectionalEdgesFromHexagon),
      (e._getOriginH3IndexFromUnidirectionalEdge =
        We._getOriginH3IndexFromUnidirectionalEdge),
      (e._getPentagonIndexes = We._getPentagonIndexes),
      (e._getRes0Indexes = We._getRes0Indexes),
      (e._h3Distance = We._h3Distance),
      (e._h3GetBaseCell = We._h3GetBaseCell),
      (e._h3GetFaces = We._h3GetFaces),
      (e._h3GetResolution = We._h3GetResolution),
      (e._h3IndexesAreNeighbors = We._h3IndexesAreNeighbors),
      (e._h3IsPentagon = We._h3IsPentagon),
      (e._h3IsResClassIII = We._h3IsResClassIII),
      (e._h3IsValid = We._h3IsValid),
      (e._h3Line = We._h3Line),
      (e._h3LineSize = We._h3LineSize),
      (e._h3SetToLinkedGeo = We._h3SetToLinkedGeo),
      (e._h3ToCenterChild = We._h3ToCenterChild),
      (e._h3ToChildren = We._h3ToChildren),
      (e._h3ToGeo = We._h3ToGeo),
      (e._h3ToGeoBoundary = We._h3ToGeoBoundary),
      (e._h3ToParent = We._h3ToParent),
      (e._h3UnidirectionalEdgeIsValid = We._h3UnidirectionalEdgeIsValid),
      (e._hexAreaKm2 = We._hexAreaKm2),
      (e._hexAreaM2 = We._hexAreaM2),
      (e._hexRing = We._hexRing),
      (e._i64Subtract = We._i64Subtract),
      (e._kRing = We._kRing),
      (e._kRingDistances = We._kRingDistances),
      (e._llvm_minnum_f64 = We._llvm_minnum_f64),
      (e._llvm_round_f64 = We._llvm_round_f64),
      (e._malloc = We._malloc),
      (e._maxFaceCount = We._maxFaceCount),
      (e._maxH3ToChildrenSize = We._maxH3ToChildrenSize),
      (e._maxKringSize = We._maxKringSize),
      (e._maxPolyfillSize = We._maxPolyfillSize),
      (e._maxUncompactSize = We._maxUncompactSize),
      (e._memcpy = We._memcpy),
      (e._memset = We._memset),
      (e._numHexagons = We._numHexagons),
      (e._pentagonIndexCount = We._pentagonIndexCount),
      (e._pointDistKm = We._pointDistKm),
      (e._pointDistM = We._pointDistM),
      (e._pointDistRads = We._pointDistRads),
      (e._polyfill = We._polyfill),
      (e._res0IndexCount = We._res0IndexCount),
      (e._round = We._round),
      (e._sbrk = We._sbrk),
      (e._sizeOfCoordIJ = We._sizeOfCoordIJ),
      (e._sizeOfGeoBoundary = We._sizeOfGeoBoundary),
      (e._sizeOfGeoCoord = We._sizeOfGeoCoord),
      (e._sizeOfGeoPolygon = We._sizeOfGeoPolygon),
      (e._sizeOfGeofence = We._sizeOfGeofence),
      (e._sizeOfH3Index = We._sizeOfH3Index),
      (e._sizeOfLinkedGeoPolygon = We._sizeOfLinkedGeoPolygon),
      (e._uncompact = We._uncompact),
      (e.establishStackSpace = We.establishStackSpace)
    var Xo = (e.stackAlloc = We.stackAlloc),
      Kd = (e.stackRestore = We.stackRestore),
      $c = (e.stackSave = We.stackSave)
    if (
      ((e.asm = We),
      (e.cwrap = R),
      (e.setValue = y),
      (e.getValue = x),
      (e.getTempRet0 = p),
      Se)
    ) {
      Q(Se) || (Se = s(Se))
      {
        Ee()
        var al = function (J) {
            J.byteLength && (J = new Uint8Array(J)),
              G.set(J, m),
              e.memoryInitializerRequest &&
                delete e.memoryInitializerRequest.response,
              Ce()
          },
          Zu = function () {
            o(Se, al, function () {
              throw "could not load memory initializer " + Se
            })
          },
          Ju = an(Se)
        if (Ju) al(Ju.buffer)
        else if (e.memoryInitializerRequest) {
          var Ku = function () {
            var J = e.memoryInitializerRequest,
              ae = J.response
            if (J.status !== 200 && J.status !== 0) {
              var ke = an(e.memoryInitializerRequestURL)
              if (ke) ae = ke.buffer
              else {
                console.warn(
                  "a problem seems to have happened with Module.memoryInitializerRequest, status: " +
                    J.status +
                    ", retrying " +
                    Se
                ),
                  Zu()
                return
              }
            }
            al(ae)
          }
          e.memoryInitializerRequest.response
            ? setTimeout(Ku, 0)
            : e.memoryInitializerRequest.addEventListener("load", Ku)
        } else Zu()
      }
    }
    var ee
    ue = function J() {
      ee || xe(), ee || (ue = J)
    }
    function xe(J) {
      if (oe > 0 || (ve(), oe > 0)) return
      function ae() {
        ee ||
          ((ee = !0),
          !S &&
            (Be(),
            Fe(),
            e.onRuntimeInitialized && e.onRuntimeInitialized(),
            je()))
      }
      e.setStatus
        ? (e.setStatus("Running..."),
          setTimeout(function () {
            setTimeout(function () {
              e.setStatus("")
            }, 1),
              ae()
          }, 1))
        : ae()
    }
    e.run = xe
    function Le(J) {
      throw (
        (e.onAbort && e.onAbort(J),
        (J += ""),
        a(J),
        A(J),
        (S = !0),
        "abort(" + J + "). Build with -s ASSERTIONS=1 for more info.")
      )
    }
    if (((e.abort = Le), e.preInit))
      for (
        typeof e.preInit == "function" && (e.preInit = [e.preInit]);
        e.preInit.length > 0;

      )
        e.preInit.pop()()
    return xe(), n
  })(typeof $t == "object" ? $t : {}),
  xt = "number",
  dA = xt,
  St = xt,
  Dt = xt,
  ki = xt,
  Ht = xt,
  WH = [
    ["sizeOfH3Index", xt],
    ["sizeOfGeoCoord", xt],
    ["sizeOfGeoBoundary", xt],
    ["sizeOfGeoPolygon", xt],
    ["sizeOfGeofence", xt],
    ["sizeOfLinkedGeoPolygon", xt],
    ["sizeOfCoordIJ", xt],
    ["h3IsValid", dA, [St, Dt]],
    ["geoToH3", St, [xt, xt, ki]],
    ["h3ToGeo", null, [St, Dt, Ht]],
    ["h3ToGeoBoundary", null, [St, Dt, Ht]],
    ["maxKringSize", xt, [xt]],
    ["kRing", null, [St, Dt, xt, Ht]],
    ["kRingDistances", null, [St, Dt, xt, Ht, Ht]],
    ["hexRing", null, [St, Dt, xt, Ht]],
    ["maxPolyfillSize", xt, [Ht, ki]],
    ["polyfill", null, [Ht, ki, Ht]],
    ["h3SetToLinkedGeo", null, [Ht, xt, Ht]],
    ["destroyLinkedPolygon", null, [Ht]],
    ["compact", xt, [Ht, Ht, xt]],
    ["uncompact", xt, [Ht, xt, Ht, xt, ki]],
    ["maxUncompactSize", xt, [Ht, xt, ki]],
    ["h3IsPentagon", dA, [St, Dt]],
    ["h3IsResClassIII", dA, [St, Dt]],
    ["h3GetBaseCell", xt, [St, Dt]],
    ["h3GetResolution", xt, [St, Dt]],
    ["maxFaceCount", xt, [St, Dt]],
    ["h3GetFaces", null, [St, Dt, Ht]],
    ["h3ToParent", St, [St, Dt, ki]],
    ["h3ToChildren", null, [St, Dt, ki, Ht]],
    ["h3ToCenterChild", St, [St, Dt, ki]],
    ["maxH3ToChildrenSize", xt, [St, Dt, ki]],
    ["h3IndexesAreNeighbors", dA, [St, Dt, St, Dt]],
    ["getH3UnidirectionalEdge", St, [St, Dt, St, Dt]],
    ["getOriginH3IndexFromUnidirectionalEdge", St, [St, Dt]],
    ["getDestinationH3IndexFromUnidirectionalEdge", St, [St, Dt]],
    ["h3UnidirectionalEdgeIsValid", dA, [St, Dt]],
    ["getH3IndexesFromUnidirectionalEdge", null, [St, Dt, Ht]],
    ["getH3UnidirectionalEdgesFromHexagon", null, [St, Dt, Ht]],
    ["getH3UnidirectionalEdgeBoundary", null, [St, Dt, Ht]],
    ["h3Distance", xt, [St, Dt, St, Dt]],
    ["h3Line", xt, [St, Dt, St, Dt, Ht]],
    ["h3LineSize", xt, [St, Dt, St, Dt]],
    ["experimentalH3ToLocalIj", xt, [St, Dt, St, Dt, Ht]],
    ["experimentalLocalIjToH3", xt, [St, Dt, Ht, Ht]],
    ["hexAreaM2", xt, [ki]],
    ["hexAreaKm2", xt, [ki]],
    ["edgeLengthM", xt, [ki]],
    ["edgeLengthKm", xt, [ki]],
    ["pointDistM", xt, [Ht, Ht]],
    ["pointDistKm", xt, [Ht, Ht]],
    ["pointDistRads", xt, [Ht, Ht]],
    ["cellAreaM2", xt, [St, Dt]],
    ["cellAreaKm2", xt, [St, Dt]],
    ["cellAreaRads2", xt, [St, Dt]],
    ["exactEdgeLengthM", xt, [St, Dt]],
    ["exactEdgeLengthKm", xt, [St, Dt]],
    ["exactEdgeLengthRads", xt, [St, Dt]],
    ["numHexagons", xt, [ki]],
    ["getRes0Indexes", null, [Ht]],
    ["res0IndexCount", xt],
    ["getPentagonIndexes", null, [xt, Ht]],
    ["pentagonIndexCount", xt],
  ],
  cr = {}
WH.forEach(function (e) {
  cr[e[0]] = $t.cwrap.apply($t, e)
})
var Ql = 16,
  Bc = 4,
  kc = 8,
  jH = cr.sizeOfH3Index(),
  sy = cr.sizeOfGeoCoord(),
  $H = cr.sizeOfGeoBoundary(),
  QH = cr.sizeOfGeoPolygon(),
  UA = cr.sizeOfGeofence()
cr.sizeOfLinkedGeoPolygon()
cr.sizeOfCoordIJ()
function XH(n) {
  if (typeof n != "number" || n < 0 || n > 15 || Math.floor(n) !== n)
    throw new Error("Invalid resolution: " + n)
}
var YH = /[^0-9a-fA-F]/
function R8(n) {
  if (
    Array.isArray(n) &&
    n.length === 2 &&
    Number.isInteger(n[0]) &&
    Number.isInteger(n[1])
  )
    return n
  if (typeof n != "string" || YH.test(n)) return [0, 0]
  var e = parseInt(n.substring(0, n.length - 8), Ql),
    t = parseInt(n.substring(n.length - 8), Ql)
  return [t, e]
}
function Qx(n) {
  if (n >= 0) return n.toString(Ql)
  n = n & 2147483647
  var e = L8(8, n.toString(Ql)),
    t = (parseInt(e[0], Ql) + 8).toString(Ql)
  return (e = t + e.substring(1)), e
}
function P8(n, e) {
  return Qx(e) + L8(8, Qx(n))
}
function L8(n, e) {
  for (var t = n - e.length, i = "", r = 0; r < t; r++) i += "0"
  return (i = i + e), i
}
function Xx(n, e, t) {
  for (
    var i = n.length,
      r = $t._calloc(i, sy),
      s = t ? 1 : 0,
      o = t ? 0 : 1,
      a = 0;
    a < i * 2;
    a += 2
  )
    $t.HEAPF64.set([n[a / 2][s], n[a / 2][o]].map(k8), r / kc + a)
  return $t.HEAPU32.set([i, r], e / Bc), e
}
function ZH(n, e) {
  var t = n.length - 1,
    i = $t._calloc(QH),
    r = 0,
    s = r + UA,
    o = s + Bc
  Xx(n[0], i + r, e)
  var a
  if (t > 0) {
    a = $t._calloc(t, UA)
    for (var A = 0; A < t; A++) Xx(n[A + 1], a + UA * A, e)
  }
  return $t.setValue(i + s, t, "i32"), $t.setValue(i + o, a, "i32"), i
}
function JH(n) {
  var e = 0,
    t = e + UA,
    i = t + Bc,
    r = Bc
  $t._free($t.getValue(n + e + r, "i8*"))
  var s = $t.getValue(n + t, "i32")
  if (s > 0) {
    for (var o = $t.getValue(n + i, "i32"), a = 0; a < s; a++)
      $t._free($t.getValue(o + UA * a + r, "i8*"))
    $t._free(o)
  }
  $t._free(n)
}
function KH(n) {
  var e = $t.getTempRet0()
  return [n, e]
}
function eG(n) {
  var e = KH(n),
    t = e[0],
    i = e[1]
  return i ? P8(t, i) : null
}
function tG(n, e) {
  e === void 0 && (e = 0)
  var t = $t.getValue(n + Bc * e * 2, "i32"),
    i = $t.getValue(n + Bc * (e * 2 + 1), "i32")
  return i ? P8(t, i) : null
}
function nG(n, e) {
  for (var t = [], i = 0; i < e; i++) {
    var r = tG(n, i)
    r !== null && t.push(r)
  }
  return t
}
function Y0(n) {
  return oG($t.getValue(n, "double"))
}
function D8(n) {
  return [Y0(n), Y0(n + kc)]
}
function iG(n) {
  return [Y0(n + kc), Y0(n)]
}
function rG(n, e, t) {
  for (
    var i = $t.getValue(n, "i32"), r = n + kc, s = [], o = e ? iG : D8, a = 0;
    a < i * 2;
    a += 2
  )
    s.push(o(r + kc * a))
  return t && s.push(s[0]), s
}
function sG(n, e, t) {
  var i = $t._malloc(sy)
  $t.HEAPF64.set([n, e].map(k8), i / kc)
  var r = eG(cr.geoToH3(i, t))
  return $t._free(i), r
}
function I8(n) {
  var e = $t._malloc(sy),
    t = R8(n),
    i = t[0],
    r = t[1]
  cr.h3ToGeo(i, r, e)
  var s = D8(e)
  return $t._free(e), s
}
function B8(n, e) {
  var t = $t._malloc($H),
    i = R8(n),
    r = i[0],
    s = i[1]
  cr.h3ToGeoBoundary(r, s, t)
  var o = rG(t, e, e)
  return $t._free(t), o
}
function Yx(n, e, t) {
  if ((XH(e), (t = Boolean(t)), n.length === 0 || n[0].length === 0)) return []
  typeof n[0][0] == "number" && (n = [n])
  var i = ZH(n, t),
    r = cr.maxPolyfillSize(i, e),
    s = $t._calloc(r, jH)
  cr.polyfill(i, e, s)
  var o = nG(s, r)
  return $t._free(s), JH(i), o
}
function k8(n) {
  return (n * Math.PI) / 180
}
function oG(n) {
  return (n * 180) / Math.PI
}
const Mi = window.THREE
  ? window.THREE
  : {
      Box3: Ri,
      BufferGeometry: yt,
      Float32BufferAttribute: ut,
      InstancedBufferGeometry: Wd,
      InstancedInterleavedBuffer: $d,
      InterleavedBufferAttribute: Fr,
      Sphere: ds,
      Vector3: X,
      WireframeGeometry: Hd,
    }
var Il = new Mi.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute"
const Zx = new Mi.Box3(),
  Dh = new Mi.Vector3()
class oy extends Mi.InstancedBufferGeometry {
  constructor() {
    super(), (this.type = "LineSegmentsGeometry")
    const e = [
        -1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1,
        -1, 0,
      ],
      t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2],
      i = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]
    this.setIndex(i),
      this[Il]("position", new Mi.Float32BufferAttribute(e, 3)),
      this[Il]("uv", new Mi.Float32BufferAttribute(t, 2))
  }
  applyMatrix4(e) {
    const t = this.attributes.instanceStart,
      i = this.attributes.instanceEnd
    return (
      t !== void 0 &&
        (t.applyMatrix4(e), i.applyMatrix4(e), (t.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    )
  }
  setPositions(e) {
    let t
    e instanceof Float32Array
      ? (t = e)
      : Array.isArray(e) && (t = new Float32Array(e))
    const i = new Mi.InstancedInterleavedBuffer(t, 6, 1)
    return (
      this[Il]("instanceStart", new Mi.InterleavedBufferAttribute(i, 3, 0)),
      this[Il]("instanceEnd", new Mi.InterleavedBufferAttribute(i, 3, 3)),
      this.computeBoundingBox(),
      this.computeBoundingSphere(),
      this
    )
  }
  setColors(e) {
    let t
    e instanceof Float32Array
      ? (t = e)
      : Array.isArray(e) && (t = new Float32Array(e))
    const i = new Mi.InstancedInterleavedBuffer(t, 6, 1)
    return (
      this[Il](
        "instanceColorStart",
        new Mi.InterleavedBufferAttribute(i, 3, 0)
      ),
      this[Il]("instanceColorEnd", new Mi.InterleavedBufferAttribute(i, 3, 3)),
      this
    )
  }
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this
  }
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this
  }
  fromMesh(e) {
    return (
      this.fromWireframeGeometry(new Mi.WireframeGeometry(e.geometry)), this
    )
  }
  fromLineSegments(e) {
    const t = e.geometry
    if (t.isGeometry) {
      console.error(
        "LineSegmentsGeometry no longer supports Geometry. Use THREE.BufferGeometry instead."
      )
      return
    } else t.isBufferGeometry && this.setPositions(t.attributes.position.array)
    return this
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Mi.Box3())
    const e = this.attributes.instanceStart,
      t = this.attributes.instanceEnd
    e !== void 0 &&
      t !== void 0 &&
      (this.boundingBox.setFromBufferAttribute(e),
      Zx.setFromBufferAttribute(t),
      this.boundingBox.union(Zx))
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Mi.Sphere()),
      this.boundingBox === null && this.computeBoundingBox()
    const e = this.attributes.instanceStart,
      t = this.attributes.instanceEnd
    if (e !== void 0 && t !== void 0) {
      const i = this.boundingSphere.center
      this.boundingBox.getCenter(i)
      let r = 0
      for (let s = 0, o = e.count; s < o; s++)
        Dh.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(Dh))),
          Dh.fromBufferAttribute(t, s),
          (r = Math.max(r, i.distanceToSquared(Dh)))
      ;(this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            "THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",
            this
          )
    }
  }
  toJSON() {}
  applyMatrix(e) {
    return (
      console.warn(
        "THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."
      ),
      this.applyMatrix4(e)
    )
  }
}
oy.prototype.isLineSegmentsGeometry = !0
const gr = window.THREE
  ? window.THREE
  : {
      ShaderLib: mr,
      ShaderMaterial: ar,
      UniformsLib: et,
      UniformsUtils: s2,
      Vector2: qe,
    }
gr.UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new gr.Vector2(1, 1) },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  dashOffset: { value: 0 },
  gapSize: { value: 1 },
}
gr.ShaderLib.line = {
  uniforms: gr.UniformsUtils.merge([
    gr.UniformsLib.common,
    gr.UniformsLib.fog,
    gr.UniformsLib.line,
  ]),
  vertexShader: `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		varying vec2 vUv;
		varying vec4 worldPos;
		varying vec3 worldStart;
		varying vec3 worldEnd;

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;

			#endif

			float aspect = resolution.x / resolution.y;

			vUv = uv;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			worldStart = start.xyz;
			worldEnd = end.xyz;

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segements overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

			vec2 offset = vec2( dir.y, - dir.x );
			// undo aspect ratio adjustment
			dir.x /= aspect;
			offset.x /= aspect;

			// sign flip
			if ( position.x < 0.0 ) offset *= - 1.0;

			// endcaps
			if ( position.y < 0.0 ) {

				offset += - dir;

			} else if ( position.y > 1.0 ) {

				offset += dir;

			}

			// adjust for linewidth
			offset *= linewidth;

			// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
			offset /= resolution.y;

			// select end
			vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

			// back to clip space
			offset *= clip.w;

			clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,
  fragmentShader: `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;
		varying vec4 worldPos;
		varying vec3 worldStart;
		varying vec3 worldEnd;

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		varying vec2 vUv;

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

			#endif

			#else

				#ifdef ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

			if ( abs( vUv.y ) > 1.0 ) {

				float a = vUv.x;
				float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
				float len2 = a * a + b * b;

				if ( len2 > 1.0 ) discard;

			}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`,
}
class Zd extends gr.ShaderMaterial {
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: gr.UniformsUtils.clone(gr.ShaderLib.line.uniforms),
      vertexShader: gr.ShaderLib.line.vertexShader,
      fragmentShader: gr.ShaderLib.line.fragmentShader,
      clipping: !0,
    }),
      Object.defineProperties(this, {
        color: {
          enumerable: !0,
          get: function () {
            return this.uniforms.diffuse.value
          },
          set: function (t) {
            this.uniforms.diffuse.value = t
          },
        },
        worldUnits: {
          enumerable: !0,
          get: function () {
            return "WORLD_UNITS" in this.defines
          },
          set: function (t) {
            t === !0
              ? (this.defines.WORLD_UNITS = "")
              : delete this.defines.WORLD_UNITS
          },
        },
        linewidth: {
          enumerable: !0,
          get: function () {
            return this.uniforms.linewidth.value
          },
          set: function (t) {
            this.uniforms.linewidth.value = t
          },
        },
        dashed: {
          enumerable: !0,
          get: function () {
            return Boolean("USE_DASH" in this.defines)
          },
          set(t) {
            Boolean(t) !== Boolean("USE_DASH" in this.defines) &&
              (this.needsUpdate = !0),
              t === !0
                ? (this.defines.USE_DASH = "")
                : delete this.defines.USE_DASH
          },
        },
        dashScale: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashScale.value
          },
          set: function (t) {
            this.uniforms.dashScale.value = t
          },
        },
        dashSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashSize.value
          },
          set: function (t) {
            this.uniforms.dashSize.value = t
          },
        },
        dashOffset: {
          enumerable: !0,
          get: function () {
            return this.uniforms.dashOffset.value
          },
          set: function (t) {
            this.uniforms.dashOffset.value = t
          },
        },
        gapSize: {
          enumerable: !0,
          get: function () {
            return this.uniforms.gapSize.value
          },
          set: function (t) {
            this.uniforms.gapSize.value = t
          },
        },
        opacity: {
          enumerable: !0,
          get: function () {
            return this.uniforms.opacity.value
          },
          set: function (t) {
            this.uniforms.opacity.value = t
          },
        },
        resolution: {
          enumerable: !0,
          get: function () {
            return this.uniforms.resolution.value
          },
          set: function (t) {
            this.uniforms.resolution.value.copy(t)
          },
        },
        alphaToCoverage: {
          enumerable: !0,
          get: function () {
            return Boolean("ALPHA_TO_COVERAGE" in this.defines)
          },
          set: function (t) {
            Boolean(t) !== Boolean("ALPHA_TO_COVERAGE" in this.defines) &&
              (this.needsUpdate = !0),
              t === !0
                ? ((this.defines.ALPHA_TO_COVERAGE = ""),
                  (this.extensions.derivatives = !0))
                : (delete this.defines.ALPHA_TO_COVERAGE,
                  (this.extensions.derivatives = !1))
          },
        },
      }),
      this.setValues(e)
  }
}
Zd.prototype.isLineMaterial = !0
const Hn = window.THREE
  ? window.THREE
  : {
      Box3: Ri,
      BufferGeometry: yt,
      InstancedInterleavedBuffer: $d,
      InterleavedBufferAttribute: Fr,
      Line3: N2,
      MathUtils: T1,
      Matrix4: mt,
      Mesh: Xt,
      Sphere: ds,
      Vector3: X,
      Vector4: en,
    }
var Jx = new Hn.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute"
const Kx = new Hn.Vector3(),
  eb = new Hn.Vector3(),
  ri = new Hn.Vector4(),
  si = new Hn.Vector4(),
  Wr = new Hn.Vector4(),
  xm = new Hn.Vector3(),
  bm = new Hn.Matrix4(),
  dr = new Hn.Line3(),
  tb = new Hn.Vector3(),
  ws = new Hn.Box3(),
  Ih = new Hn.Sphere(),
  jr = new Hn.Vector4()
class O8 extends Hn.Mesh {
  constructor(e = new oy(), t = new Zd({ color: Math.random() * 16777215 })) {
    super(e, t), (this.type = "LineSegments2")
  }
  computeLineDistances() {
    const e = this.geometry,
      t = e.attributes.instanceStart,
      i = e.attributes.instanceEnd,
      r = new Float32Array(2 * t.count)
    for (let o = 0, a = 0, A = t.count; o < A; o++, a += 2)
      Kx.fromBufferAttribute(t, o),
        eb.fromBufferAttribute(i, o),
        (r[a] = a === 0 ? 0 : r[a - 1]),
        (r[a + 1] = r[a] + Kx.distanceTo(eb))
    const s = new Hn.InstancedInterleavedBuffer(r, 2, 1)
    return (
      e[Jx](
        "instanceDistanceStart",
        new Hn.InterleavedBufferAttribute(s, 1, 0)
      ),
      e[Jx]("instanceDistanceEnd", new Hn.InterleavedBufferAttribute(s, 1, 1)),
      this
    )
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.'
      )
    const i = (e.params.Line2 !== void 0 && e.params.Line2.threshold) || 0,
      r = e.ray,
      s = e.camera,
      o = s.projectionMatrix,
      a = this.matrixWorld,
      A = this.geometry,
      c = this.material,
      d = c.resolution,
      p = c.linewidth + i,
      m = A.attributes.instanceStart,
      y = A.attributes.instanceEnd,
      x = -s.near,
      S = 2 * Math.max(p / d.width, p / d.height)
    A.boundingSphere === null && A.computeBoundingSphere(),
      Ih.copy(A.boundingSphere).applyMatrix4(a)
    const C = Math.max(s.near, Ih.distanceToPoint(r.origin))
    jr.set(0, 0, -C, 1).applyMatrix4(s.projectionMatrix),
      jr.multiplyScalar(1 / jr.w),
      jr.applyMatrix4(s.projectionMatrixInverse)
    const M = Math.abs(S / jr.w) * 0.5
    if (((Ih.radius += M), e.ray.intersectsSphere(Ih) === !1)) return
    A.boundingBox === null && A.computeBoundingBox(),
      ws.copy(A.boundingBox).applyMatrix4(a)
    const _ = Math.max(s.near, ws.distanceToPoint(r.origin))
    jr.set(0, 0, -_, 1).applyMatrix4(s.projectionMatrix),
      jr.multiplyScalar(1 / jr.w),
      jr.applyMatrix4(s.projectionMatrixInverse)
    const R = Math.abs(S / jr.w) * 0.5
    if (
      ((ws.max.x += R),
      (ws.max.y += R),
      (ws.max.z += R),
      (ws.min.x -= R),
      (ws.min.y -= R),
      (ws.min.z -= R),
      e.ray.intersectsBox(ws) !== !1)
    ) {
      r.at(1, Wr),
        (Wr.w = 1),
        Wr.applyMatrix4(s.matrixWorldInverse),
        Wr.applyMatrix4(o),
        Wr.multiplyScalar(1 / Wr.w),
        (Wr.x *= d.x / 2),
        (Wr.y *= d.y / 2),
        (Wr.z = 0),
        xm.copy(Wr),
        bm.multiplyMatrices(s.matrixWorldInverse, a)
      for (let L = 0, B = m.count; L < B; L++) {
        ri.fromBufferAttribute(m, L),
          si.fromBufferAttribute(y, L),
          (ri.w = 1),
          (si.w = 1),
          ri.applyMatrix4(bm),
          si.applyMatrix4(bm)
        var T = ri.z > x && si.z > x
        if (T) continue
        if (ri.z > x) {
          const P = ri.z - si.z,
            N = (ri.z - x) / P
          ri.lerp(si, N)
        } else if (si.z > x) {
          const P = si.z - ri.z,
            N = (si.z - x) / P
          si.lerp(ri, N)
        }
        ri.applyMatrix4(o),
          si.applyMatrix4(o),
          ri.multiplyScalar(1 / ri.w),
          si.multiplyScalar(1 / si.w),
          (ri.x *= d.x / 2),
          (ri.y *= d.y / 2),
          (si.x *= d.x / 2),
          (si.y *= d.y / 2),
          dr.start.copy(ri),
          (dr.start.z = 0),
          dr.end.copy(si),
          (dr.end.z = 0)
        const k = dr.closestPointToPointParameter(xm, !0)
        dr.at(k, tb)
        const O = Hn.MathUtils.lerp(ri.z, si.z, k),
          W = O >= -1 && O <= 1,
          z = xm.distanceTo(tb) < p * 0.5
        if (W && z) {
          dr.start.fromBufferAttribute(m, L),
            dr.end.fromBufferAttribute(y, L),
            dr.start.applyMatrix4(a),
            dr.end.applyMatrix4(a)
          const P = new Hn.Vector3(),
            N = new Hn.Vector3()
          r.distanceSqToSegment(dr.start, dr.end, N, P),
            t.push({
              point: N,
              pointOnLine: P,
              distance: r.origin.distanceTo(N),
              object: this,
              face: null,
              faceIndex: L,
              uv: null,
              uv2: null,
            })
        }
      }
    }
  }
}
O8.prototype.LineSegments2 = !0
class ay extends oy {
  constructor() {
    super(), (this.type = "LineGeometry")
  }
  setPositions(e) {
    for (
      var t = e.length - 3, i = new Float32Array(2 * t), r = 0;
      r < t;
      r += 3
    )
      (i[2 * r] = e[r]),
        (i[2 * r + 1] = e[r + 1]),
        (i[2 * r + 2] = e[r + 2]),
        (i[2 * r + 3] = e[r + 3]),
        (i[2 * r + 4] = e[r + 4]),
        (i[2 * r + 5] = e[r + 5])
    return super.setPositions(i), this
  }
  setColors(e) {
    for (
      var t = e.length - 3, i = new Float32Array(2 * t), r = 0;
      r < t;
      r += 3
    )
      (i[2 * r] = e[r]),
        (i[2 * r + 1] = e[r + 1]),
        (i[2 * r + 2] = e[r + 2]),
        (i[2 * r + 3] = e[r + 3]),
        (i[2 * r + 4] = e[r + 4]),
        (i[2 * r + 5] = e[r + 5])
    return super.setColors(i), this
  }
  fromLine(e) {
    var t = e.geometry
    if (t.isGeometry) {
      console.error(
        "THREE.LineGeometry no longer supports Geometry. Use THREE.BufferGeometry instead."
      )
      return
    } else t.isBufferGeometry && this.setPositions(t.attributes.position.array)
    return this
  }
}
ay.prototype.isLineGeometry = !0
class q8 extends O8 {
  constructor(e = new ay(), t = new Zd({ color: Math.random() * 16777215 })) {
    super(e, t), (this.type = "Line2")
  }
}
q8.prototype.isLine2 = !0
class nb extends Nr {
  constructor(e, t = {}) {
    const i = t.font
    if (i === void 0) super()
    else {
      const r = i.generateShapes(e, t.size)
      ;(t.depth = t.height !== void 0 ? t.height : 50),
        t.bevelThickness === void 0 && (t.bevelThickness = 10),
        t.bevelSize === void 0 && (t.bevelSize = 8),
        t.bevelEnabled === void 0 && (t.bevelEnabled = !1),
        super(r, t)
    }
    this.type = "TextGeometry"
  }
}
class F8 {
  constructor(e) {
    ;(this.type = "Font"), (this.data = e)
  }
  generateShapes(e, t = 100) {
    const i = [],
      r = aG(e, t, this.data)
    for (let s = 0, o = r.length; s < o; s++)
      Array.prototype.push.apply(i, r[s].toShapes())
    return i
  }
}
function aG(n, e, t) {
  const i = Array.from(n),
    r = e / t.resolution,
    s = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * r,
    o = []
  let a = 0,
    A = 0
  for (let c = 0; c < i.length; c++) {
    const d = i[c]
    if (
      d ===
      `
`
    )
      (a = 0), (A -= s)
    else {
      const p = lG(d, r, a, A, t)
      ;(a += p.offsetX), o.push(p.path)
    }
  }
  return o
}
function lG(n, e, t, i, r) {
  const s = r.glyphs[n] || r.glyphs["?"]
  if (!s) {
    console.error(
      'THREE.Font: character "' +
        n +
        '" does not exists in font family ' +
        r.familyName +
        "."
    )
    return
  }
  const o = new T6()
  let a, A, c, d, p, m, y, x
  if (s.o) {
    const S = s._cachedOutline || (s._cachedOutline = s.o.split(" "))
    for (let C = 0, M = S.length; C < M; )
      switch (S[C++]) {
        case "m":
          ;(a = S[C++] * e + t), (A = S[C++] * e + i), o.moveTo(a, A)
          break
        case "l":
          ;(a = S[C++] * e + t), (A = S[C++] * e + i), o.lineTo(a, A)
          break
        case "q":
          ;(c = S[C++] * e + t),
            (d = S[C++] * e + i),
            (p = S[C++] * e + t),
            (m = S[C++] * e + i),
            o.quadraticCurveTo(p, m, c, d)
          break
        case "b":
          ;(c = S[C++] * e + t),
            (d = S[C++] * e + i),
            (p = S[C++] * e + t),
            (m = S[C++] * e + i),
            (y = S[C++] * e + t),
            (x = S[C++] * e + i),
            o.bezierCurveTo(p, m, y, x, c, d)
          break
      }
  }
  return { offsetX: s.ha * e, path: o }
}
F8.prototype.isFont = !0
class N8 extends kt {
  constructor(e = document.createElement("div")) {
    super(),
      (this.element = e),
      (this.element.style.position = "absolute"),
      (this.element.style.userSelect = "none"),
      this.element.setAttribute("draggable", !1),
      this.addEventListener("removed", function () {
        this.traverse(function (t) {
          t.element instanceof Element &&
            t.element.parentNode !== null &&
            t.element.parentNode.removeChild(t.element)
        })
      })
  }
  copy(e, t) {
    return super.copy(e, t), (this.element = e.element.cloneNode(!0)), this
  }
}
N8.prototype.isCSS2DObject = !0
new X()
new mt()
new mt()
new X()
new X()
function ib(n, e) {
  var t = Object.keys(n)
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n)
    e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable
      })),
      t.push.apply(t, i)
  }
  return t
}
function nn(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? ib(Object(t), !0).forEach(function (i) {
          Li(n, i, t[i])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : ib(Object(t)).forEach(function (i) {
          Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
        })
  }
  return n
}
function U8(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function")
}
function rb(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t]
    ;(i.enumerable = i.enumerable || !1),
      (i.configurable = !0),
      "value" in i && (i.writable = !0),
      Object.defineProperty(n, i.key, i)
  }
}
function z8(n, e, t) {
  return (
    e && rb(n.prototype, e),
    t && rb(n, t),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    n
  )
}
function Li(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  )
}
function H8(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function")
  ;(n.prototype = Object.create(e && e.prototype, {
    constructor: { value: n, writable: !0, configurable: !0 },
  })),
    Object.defineProperty(n, "prototype", { writable: !1 }),
    e && J0(n, e)
}
function Z0(n) {
  return (
    (Z0 = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t)
        }),
    Z0(n)
  )
}
function J0(n, e) {
  return (
    (J0 = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (i, r) {
          return (i.__proto__ = r), i
        }),
    J0(n, e)
  )
}
function G8() {
  if (
    typeof Reflect == "undefined" ||
    !Reflect.construct ||
    Reflect.construct.sham
  )
    return !1
  if (typeof Proxy == "function") return !0
  try {
    return (
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      ),
      !0
    )
  } catch {
    return !1
  }
}
function Kh(n, e, t) {
  return (
    G8()
      ? (Kh = Reflect.construct.bind())
      : (Kh = function (r, s, o) {
          var a = [null]
          a.push.apply(a, s)
          var A = Function.bind.apply(r, a),
            c = new A()
          return o && J0(c, o.prototype), c
        }),
    Kh.apply(null, arguments)
  )
}
function cG(n, e) {
  if (n == null) return {}
  var t = {},
    i = Object.keys(n),
    r,
    s
  for (s = 0; s < i.length; s++)
    (r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r])
  return t
}
function AG(n, e) {
  if (n == null) return {}
  var t = cG(n, e),
    i,
    r
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n)
    for (r = 0; r < s.length; r++)
      (i = s[r]),
        !(e.indexOf(i) >= 0) &&
          (!Object.prototype.propertyIsEnumerable.call(n, i) || (t[i] = n[i]))
  }
  return t
}
function V8(n) {
  if (n === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return n
}
function uG(n, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e
  if (e !== void 0)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    )
  return V8(n)
}
function W8(n) {
  var e = G8()
  return function () {
    var i = Z0(n),
      r
    if (e) {
      var s = Z0(this).constructor
      r = Reflect.construct(i, arguments, s)
    } else r = i.apply(this, arguments)
    return uG(this, r)
  }
}
function Gi(n, e) {
  return hG(n) || pG(n, e) || j8(n, e) || gG()
}
function gn(n) {
  return fG(n) || dG(n) || j8(n) || mG()
}
function fG(n) {
  if (Array.isArray(n)) return gg(n)
}
function hG(n) {
  if (Array.isArray(n)) return n
}
function dG(n) {
  if (
    (typeof Symbol != "undefined" && n[Symbol.iterator] != null) ||
    n["@@iterator"] != null
  )
    return Array.from(n)
}
function pG(n, e) {
  var t =
    n == null
      ? null
      : (typeof Symbol != "undefined" && n[Symbol.iterator]) || n["@@iterator"]
  if (t != null) {
    var i = [],
      r = !0,
      s = !1,
      o,
      a
    try {
      for (
        t = t.call(n);
        !(r = (o = t.next()).done) && (i.push(o.value), !(e && i.length === e));
        r = !0
      );
    } catch (A) {
      ;(s = !0), (a = A)
    } finally {
      try {
        !r && t.return != null && t.return()
      } finally {
        if (s) throw a
      }
    }
    return i
  }
}
function j8(n, e) {
  if (!!n) {
    if (typeof n == "string") return gg(n, e)
    var t = Object.prototype.toString.call(n).slice(8, -1)
    if (
      (t === "Object" && n.constructor && (t = n.constructor.name),
      t === "Map" || t === "Set")
    )
      return Array.from(n)
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return gg(n, e)
  }
}
function gg(n, e) {
  ;(e == null || e > n.length) && (e = n.length)
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t]
  return i
}
function mG() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function gG() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var yG = function n(e) {
    e instanceof Array ? e.forEach(n) : (e.map && e.map.dispose(), e.dispose())
  },
  $8 = function n(e) {
    e.geometry && e.geometry.dispose(),
      e.material && yG(e.material),
      e.texture && e.texture.dispose(),
      e.children && e.children.forEach(n)
  },
  Fn = function (e) {
    if (e && e.children)
      for (; e.children.length; ) {
        var t = e.children[0]
        e.remove(t), $8(t)
      }
  }
function Ar(n, e) {
  var t = new e()
  return {
    linkProp: function (r) {
      return {
        default: t[r](),
        onChange: function (o, a) {
          a[n][r](o)
        },
        triggerUpdate: !1,
      }
    },
    linkMethod: function (r) {
      return function (s) {
        for (
          var o = s[n],
            a = arguments.length,
            A = new Array(a > 1 ? a - 1 : 0),
            c = 1;
          c < a;
          c++
        )
          A[c - 1] = arguments[c]
        var d = o[r].apply(o, A)
        return d === o ? this : d
      }
    },
  }
}
var ti = 100
function sb() {
  return ti
}
function Qo(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
    i = ((90 - n) * Math.PI) / 180,
    r = ((90 - e) * Math.PI) / 180,
    s = ti * (1 + t)
  return {
    x: s * Math.sin(i) * Math.cos(r),
    y: s * Math.cos(i),
    z: s * Math.sin(i) * Math.sin(r),
  }
}
function vG(n) {
  var e = n.x,
    t = n.y,
    i = n.z,
    r = Math.sqrt(e * e + t * t + i * i),
    s = Math.acos(t / r),
    o = Math.atan2(i, e)
  return {
    lat: 90 - (s * 180) / Math.PI,
    lng: 90 - (o * 180) / Math.PI - (o < -Math.PI / 2 ? 360 : 0),
    altitude: r / ti - 1,
  }
}
var wu = window.THREE
    ? window.THREE
    : {
        BackSide: Pn,
        BufferAttribute: Bt,
        Color: Ke,
        Mesh: Xt,
        ShaderMaterial: ar,
      },
  _G = `
uniform vec3 color;
uniform float coefficient;
uniform float power;
varying vec3 vVertexNormal;
varying vec3 vVertexWorldPosition;
void main() {
  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;
  vec3 viewCameraToVertex	= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;
  viewCameraToVertex = normalize(viewCameraToVertex);
  float intensity	= pow(
    coefficient + dot(vVertexNormal, viewCameraToVertex),
    power
  );
  gl_FragColor = vec4(color, intensity);
}`,
  xG = `
varying vec3 vVertexWorldPosition;
varying vec3 vVertexNormal;
void main() {
  vVertexNormal	= normalize(normalMatrix * normal);
  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
  gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
  bG = { backside: !0, coefficient: 0.5, color: "gold", size: 2, power: 1 }
function wG(n, e, t) {
  return new wu.ShaderMaterial({
    depthWrite: !1,
    fragmentShader: _G,
    transparent: !0,
    uniforms: {
      coefficient: { value: n },
      color: { value: new wu.Color(e) },
      power: { value: t },
    },
    vertexShader: xG,
  })
}
function MG(n, e) {
  for (
    var t = n.clone(),
      i = new Float32Array(n.attributes.position.count * 3),
      r = 0,
      s = i.length;
    r < s;
    r++
  ) {
    var o = n.attributes.normal.array[r],
      a = n.attributes.position.array[r]
    i[r] = a + o * e
  }
  return t.setAttribute("position", new wu.BufferAttribute(i, 3)), t
}
function SG(n) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : bG,
    t = e.backside,
    i = e.coefficient,
    r = e.color,
    s = e.size,
    o = e.power,
    a = MG(n, s),
    A = wG(i, r, o)
  return t && (A.side = wu.BackSide), new wu.Mesh(a, A)
}
var yo = window.THREE
    ? window.THREE
    : {
        Color: Ke,
        LineBasicMaterial: Nn,
        LineSegments: yi,
        Mesh: Xt,
        MeshPhongMaterial: Vd,
        SphereBufferGeometry: As,
        TextureLoader: E2,
      },
  Q8 = Wi({
    props: {
      globeImageUrl: {},
      bumpImageUrl: {},
      showGlobe: {
        default: !0,
        onChange: function (e, t) {
          t.globeObj.visible = !!e
        },
        triggerUpdate: !1,
      },
      showGraticules: {
        default: !1,
        onChange: function (e, t) {
          t.graticulesObj.visible = !!e
        },
        triggerUpdate: !1,
      },
      showAtmosphere: {
        default: !0,
        onChange: function (e, t) {
          t.atmosphereObj && (t.atmosphereObj.visible = !!e)
        },
        triggerUpdate: !1,
      },
      atmosphereColor: { default: "lightskyblue" },
      atmosphereAltitude: { default: 0.15 },
      onReady: { default: function () {}, triggerUpdate: !1 },
    },
    methods: {
      globeMaterial: function (e, t) {
        return t !== void 0
          ? ((e.globeObj.material = t || e.defaultGlobeMaterial), this)
          : e.globeObj.material
      },
    },
    stateInit: function () {
      var e = new yo.SphereBufferGeometry(ti, 75, 75),
        t = new yo.MeshPhongMaterial({ color: 0, transparent: !0 }),
        i = new yo.Mesh(e, t)
      ;(i.rotation.y = -Math.PI / 2), (i.__globeObjType = "globe")
      var r = new yo.LineSegments(
        new A8(jN(), ti, 2),
        new yo.LineBasicMaterial({
          color: "lightgrey",
          transparent: !0,
          opacity: 0.1,
        })
      )
      return { globeObj: i, graticulesObj: r, defaultGlobeMaterial: t }
    },
    init: function (e, t) {
      Fn(e),
        (t.scene = e),
        t.scene.add(t.globeObj),
        t.scene.add(t.graticulesObj),
        (t.ready = !1)
    },
    update: function (e, t) {
      var i = e.globeObj.material
      if (
        (t.hasOwnProperty("globeImageUrl") &&
          (e.globeImageUrl
            ? new yo.TextureLoader().load(e.globeImageUrl, function (s) {
                ;(i.map = s),
                  (i.color = null),
                  (i.needsUpdate = !0),
                  !e.ready && (e.ready = !0) && setTimeout(e.onReady)
              })
            : !i.color && (i.color = new yo.Color(0))),
        t.hasOwnProperty("bumpImageUrl") &&
          (e.bumpImageUrl
            ? e.bumpImageUrl &&
              new yo.TextureLoader().load(e.bumpImageUrl, function (s) {
                ;(i.bumpMap = s), (i.needsUpdate = !0)
              })
            : ((i.bumpMap = null), (i.needsUpdate = !0))),
        (t.hasOwnProperty("atmosphereColor") ||
          t.hasOwnProperty("atmosphereAltitude")) &&
          (e.atmosphereObj &&
            (e.scene.remove(e.atmosphereObj), Fn(e.atmosphereObj)),
          e.atmosphereColor && e.atmosphereAltitude))
      ) {
        var r = (e.atmosphereObj = SG(e.globeObj.geometry, {
          backside: !0,
          color: e.atmosphereColor,
          size: ti * e.atmosphereAltitude,
          power: 3.5,
          coefficient: 0.1,
        }))
        ;(r.visible = !!e.showAtmosphere),
          (r.__globeObjType = "atmosphere"),
          e.scene.add(r)
      }
      !e.ready && !e.globeImageUrl && ((e.ready = !0), e.onReady())
    },
  }),
  Qs = function (e) {
    return isNaN(e) ? parseInt(Q2(e).toHex(), 16) : e
  },
  os = function (e) {
    return isNaN(e) ? Q2(e).getAlpha() : 1
  },
  K0 = function (e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0,
      i = Q2(e).toRgb(),
      r = ["r", "g", "b"].map(function (s) {
        return i[s] / 255
      })
    return t ? [].concat(gn(r), [i.a]) : r
  }
function EG(n, e, t) {
  return (
    (n.opacity = e),
    (n.transparent = e < 1),
    (n.depthWrite = t === void 0 ? e >= 1 : t),
    n
  )
}
function Sr(n, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
    r = i.removeDelay,
    s = r === void 0 ? 0 : r
  return XU(
    n,
    e.children,
    function (o) {
      return e.add(o)
    },
    function (o) {
      var a = function () {
        e.remove(o),
          Fn(o),
          o && o.hasOwnProperty("__data") && delete o.__data.__currentTargetD
      }
      s ? setTimeout(a, s) : a()
    },
    nn({ objBindAttr: "__threeObj" }, t)
  )
}
var Oi = window.THREE
    ? window.THREE
    : {
        BufferAttribute: Bt,
        BufferGeometry: yt,
        Color: Ke,
        CylinderBufferGeometry: zs,
        Matrix4: mt,
        Mesh: Xt,
        MeshBasicMaterial: Mr,
        MeshLambertMaterial: Zs,
        Object3D: kt,
        Vector3: X,
      },
  ob = Object.assign({}, $2),
  TG = ob.BufferGeometryUtils || ob,
  wm = new Oi.BufferGeometry().applyMatrix4 ? "applyMatrix4" : "applyMatrix",
  X8 = Wi({
    props: {
      pointsData: { default: [] },
      pointLat: { default: "lat" },
      pointLng: { default: "lng" },
      pointColor: {
        default: function () {
          return "#ffffaa"
        },
      },
      pointAltitude: { default: 0.1 },
      pointRadius: { default: 0.25 },
      pointResolution: { default: 12, triggerUpdate: !1 },
      pointsMerge: { default: !1 },
      pointsTransitionDuration: { default: 1e3, triggerUpdate: !1 },
    },
    init: function (e, t) {
      Fn(e), (t.scene = e)
    },
    update: function (e) {
      var t = Ye(e.pointLat),
        i = Ye(e.pointLng),
        r = Ye(e.pointAltitude),
        s = Ye(e.pointRadius),
        o = Ye(e.pointColor),
        a = new Oi.CylinderBufferGeometry(1, 1, 1, e.pointResolution)
      a[wm](new Oi.Matrix4().makeRotationX(Math.PI / 2)),
        a[wm](new Oi.Matrix4().makeTranslation(0, 0, -0.5))
      var A = (2 * Math.PI * ti) / 360,
        c = {},
        d = e.pointsMerge ? new Oi.Object3D() : e.scene
      if (
        (Sr(e.pointsData, d, { createObj: y, updateObj: x }), e.pointsMerge)
      ) {
        var p = e.pointsData.length
            ? TG.mergeBufferGeometries(
                e.pointsData.map(function (S) {
                  var C = S.__threeObj
                  S.__threeObj = void 0
                  var M = C.geometry.clone()
                  C.updateMatrix(), M[wm](C.matrix)
                  for (
                    var _ = new Oi.Color(o(S)),
                      R = M.attributes.position.count,
                      T = new Float32Array(R * 3),
                      L = 0,
                      B = R;
                    L < B;
                    L++
                  ) {
                    var k = L * 3
                    ;(T[k] = _.r), (T[k + 1] = _.g), (T[k + 2] = _.b)
                  }
                  return (
                    M.setAttribute("color", new Oi.BufferAttribute(T, 3)), M
                  )
                })
              )
            : new Oi.BufferGeometry(),
          m = new Oi.Mesh(
            p,
            new Oi.MeshBasicMaterial({ color: 16777215, vertexColors: !0 })
          )
        ;(m.__globeObjType = "points"),
          (m.__data = e.pointsData),
          Fn(e.scene),
          e.scene.add(m)
      }
      function y() {
        var S = new Oi.Mesh(a)
        return (S.__globeObjType = "point"), S
      }
      function x(S, C) {
        var M = function (O) {
            var W = (S.__currentTargetD = O),
              z = W.r,
              P = W.alt,
              N = W.lat,
              G = W.lng
            Object.assign(S.position, Qo(N, G))
            var j = e.pointsMerge
              ? new Oi.Vector3(0, 0, 0)
              : e.scene.localToWorld(new Oi.Vector3(0, 0, 0))
            S.lookAt(j),
              (S.scale.x = S.scale.y = Math.min(30, z) * A),
              (S.scale.z = Math.max(P * ti, 0.1))
          },
          _ = { alt: +r(C), r: +s(C), lat: +t(C), lng: +i(C) },
          R = S.__currentTargetD || Object.assign({}, _, { alt: -0.001 })
        if (
          (Object.keys(_).some(function (k) {
            return R[k] !== _[k]
          }) &&
            (e.pointsMerge ||
            !e.pointsTransitionDuration ||
            e.pointsTransitionDuration < 0
              ? M(_)
              : new xn.Tween(R)
                  .to(_, e.pointsTransitionDuration)
                  .easing(xn.Easing.Quadratic.InOut)
                  .onUpdate(M)
                  .start()),
          !e.pointsMerge)
        ) {
          var T = o(C),
            L = T ? os(T) : 0,
            B = !!L
          ;(S.visible = B),
            B &&
              (c.hasOwnProperty(T) ||
                (c[T] = new Oi.MeshLambertMaterial({
                  color: Qs(T),
                  transparent: L < 1,
                  opacity: L,
                })),
              (S.material = c[T]))
        }
      }
    },
  }),
  CG = ["stroke"],
  qi = window.THREE
    ? window.THREE
    : {
        BufferGeometry: yt,
        CubicBezierCurve3: Fd,
        Curve: Vi,
        Float32BufferAttribute: ut,
        Group: zi,
        Line: br,
        Mesh: Xt,
        NormalBlending: Ro,
        QuadraticBezierCurve3: Wu,
        ShaderMaterial: ar,
        TubeBufferGeometry: ja,
        Vector3: X,
      },
  Bh = new qi.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute",
  RG = {
    uniforms: {
      dashOffset: { value: 0 },
      dashSize: { value: 1 },
      gapSize: { value: 0 },
      dashTranslate: { value: 0 },
    },
    vertexShader: `
    uniform float dashTranslate; 

    attribute vec4 vertexColor;
    varying vec4 vColor;
    
    attribute float vertexRelDistance;
    varying float vRelDistance;

    void main() {
      // pass through colors and distances
      vColor = vertexColor;
      vRelDistance = vertexRelDistance + dashTranslate;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
    fragmentShader: `
    uniform float dashOffset; 
    uniform float dashSize;
    uniform float gapSize; 
    
    varying vec4 vColor;
    varying float vRelDistance;
    
    void main() {
      // ignore pixels in the gap
      if (vRelDistance < dashOffset) discard;
      if (mod(vRelDistance - dashOffset, dashSize + gapSize) > dashSize) discard;
    
      // set px color: [r, g, b, a], interpolated between vertices 
      gl_FragColor = vColor; 
    }
  `,
  },
  Y8 = Wi({
    props: {
      arcsData: { default: [] },
      arcStartLat: { default: "startLat" },
      arcStartLng: { default: "startLng" },
      arcEndLat: { default: "endLat" },
      arcEndLng: { default: "endLng" },
      arcColor: {
        default: function () {
          return "#ffffaa"
        },
      },
      arcAltitude: {},
      arcAltitudeAutoScale: { default: 0.5 },
      arcStroke: {},
      arcCurveResolution: { default: 64, triggerUpdate: !1 },
      arcCircularResolution: { default: 6, triggerUpdate: !1 },
      arcDashLength: { default: 1 },
      arcDashGap: { default: 0 },
      arcDashInitialGap: { default: 0 },
      arcDashAnimateTime: { default: 0 },
      arcsTransitionDuration: { default: 1e3, triggerUpdate: !1 },
    },
    init: function (e, t) {
      Fn(e),
        (t.scene = e),
        new X2().onTick.add(function (i, r) {
          t.arcsData
            .filter(function (s) {
              return (
                s.__threeObj &&
                s.__threeObj.children.length &&
                s.__threeObj.children[0].material &&
                s.__threeObj.children[0].__dashAnimateStep
              )
            })
            .forEach(function (s) {
              var o = s.__threeObj.children[0],
                a = o.__dashAnimateStep * r,
                A = o.material.uniforms.dashTranslate.value % 1e9
              o.material.uniforms.dashTranslate.value = A + a
            })
        })
    },
    update: function (e) {
      var t = Ye(e.arcStartLat),
        i = Ye(e.arcStartLng),
        r = Ye(e.arcEndLat),
        s = Ye(e.arcEndLng),
        o = Ye(e.arcAltitude),
        a = Ye(e.arcAltitudeAutoScale),
        A = Ye(e.arcStroke),
        c = Ye(e.arcColor),
        d = Ye(e.arcDashLength),
        p = Ye(e.arcDashGap),
        m = Ye(e.arcDashInitialGap),
        y = Ye(e.arcDashAnimateTime),
        x = new qi.ShaderMaterial(
          nn(nn({}, RG), {}, { transparent: !0, blending: qi.NormalBlending })
        )
      Sr(e.arcsData, e.scene, {
        createObj: function () {
          var R = new qi.Group()
          return (R.__globeObjType = "arc"), R
        },
        updateObj: function (R, T) {
          var L = A(T),
            B = L != null
          if (!R.children.length || B !== (R.children[0].type === "Mesh")) {
            Fn(R)
            var k = B ? new qi.Mesh() : new qi.Line(new qi.BufferGeometry())
            ;(k.material = x.clone()), R.add(k)
          }
          var O = R.children[0]
          Object.assign(O.material.uniforms, {
            dashSize: { value: d(T) },
            gapSize: { value: p(T) },
            dashOffset: { value: m(T) },
          })
          var W = y(T)
          O.__dashAnimateStep = W > 0 ? 1e3 / W : 0
          var z = C(
              c(T),
              e.arcCurveResolution,
              B ? e.arcCircularResolution + 1 : 1
            ),
            P = M(e.arcCurveResolution, B ? e.arcCircularResolution + 1 : 1, !0)
          O.geometry[Bh]("vertexColor", z),
            O.geometry[Bh]("vertexRelDistance", P)
          var N = function (Y) {
              var ne = (T.__currentTargetD = Y),
                le = ne.stroke,
                Te = AG(ne, CG),
                Ae = S(Te)
              B
                ? (O.geometry && O.geometry.dispose(),
                  (O.geometry = new qi.TubeBufferGeometry(
                    Ae,
                    e.arcCurveResolution,
                    le / 2,
                    e.arcCircularResolution
                  )),
                  O.geometry[Bh]("vertexColor", z),
                  O.geometry[Bh]("vertexRelDistance", P))
                : O.geometry.setFromPoints(Ae.getPoints(e.arcCurveResolution))
            },
            G = {
              stroke: L,
              alt: o(T),
              altAutoScale: +a(T),
              startLat: +t(T),
              startLng: +i(T),
              endLat: +r(T),
              endLng: +s(T),
            },
            j =
              T.__currentTargetD ||
              Object.assign({}, G, { altAutoScale: -0.001 })
          Object.keys(G).some(function (V) {
            return j[V] !== G[V]
          }) &&
            (!e.arcsTransitionDuration || e.arcsTransitionDuration < 0
              ? N(G)
              : new xn.Tween(j)
                  .to(G, e.arcsTransitionDuration)
                  .easing(xn.Easing.Quadratic.InOut)
                  .onUpdate(N)
                  .start())
        },
      })
      function S(_) {
        var R = _.alt,
          T = _.altAutoScale,
          L = _.startLat,
          B = _.startLng,
          k = _.endLat,
          O = _.endLng,
          W = function (Me) {
            var Ne = Gi(Me, 3),
              Ze = Ne[0],
              K = Ne[1],
              Oe = Ne[2],
              ve = Qo(K, Ze, Oe),
              Be = ve.x,
              Fe = ve.y,
              je = ve.z
            return new qi.Vector3(Be, Fe, je)
          },
          z = [B, L],
          P = [O, k],
          N = R
        if ((N == null && (N = (Ho(z, P) / 2) * T), N)) {
          var G = V2(z, P),
            j = [0.25, 0.75].map(function (ge) {
              return [].concat(gn(G(ge)), [N * 1.5])
            }),
            V = Gi(j, 2),
            Y = V[0],
            ne = V[1],
            le = Kh(qi.CubicBezierCurve3, gn([z, Y, ne, P].map(W)))
          return le
        } else {
          var Te = 0.001
          return Ae.apply(
            void 0,
            gn([[].concat(z, [Te]), [].concat(P, [Te])].map(W))
          )
        }
        function Ae(ge, Me) {
          var Ne = ge.angleTo(Me),
            Ze =
              Ne === 0
                ? function () {
                    return ge.clone()
                  }
                : function (Oe) {
                    return new qi.Vector3()
                      .addVectors(
                        ge.clone().multiplyScalar(Math.sin((1 - Oe) * Ne)),
                        Me.clone().multiplyScalar(Math.sin(Oe * Ne))
                      )
                      .divideScalar(Math.sin(Ne))
                  },
            K = new qi.Curve()
          return (K.getPoint = Ze), K
        }
      }
      function C(_, R) {
        var T =
            arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
          L = R + 1,
          B
        if (_ instanceof Array || _ instanceof Function) {
          var k =
            _ instanceof Array
              ? Ic()
                  .domain(
                    _.map(function (j, V) {
                      return V / (_.length - 1)
                    })
                  )
                  .range(_)
              : _
          B = function (V) {
            return K0(k(V))
          }
        } else {
          var O = K0(_)
          B = function () {
            return O
          }
        }
        for (
          var W = new qi.Float32BufferAttribute(L * 4 * T, 4), z = 0, P = L;
          z < P;
          z++
        )
          for (var N = B(z / (P - 1)), G = 0; G < T; G++)
            W.set(N, (z * T + G) * 4)
        return W
      }
      function M(_) {
        for (
          var R =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : 1,
            T =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : !1,
            L = _ + 1,
            B = L * R,
            k = new qi.Float32BufferAttribute(B, 1),
            O = 0,
            W = L;
          O < W;
          O++
        )
          for (var z = O / (W - 1), P = 0; P < R; P++) {
            var N = O * R + P,
              G = T ? B - 1 - N : N
            k.setX(G, z)
          }
        return k
      }
    },
  }),
  pr = window.THREE
    ? window.THREE
    : {
        BufferAttribute: Bt,
        BufferGeometry: yt,
        Color: Ke,
        DoubleSide: ls,
        Mesh: Xt,
        MeshBasicMaterial: Mr,
        MeshLambertMaterial: Zs,
        Object3D: kt,
      },
  ab = Object.assign({}, $2),
  PG = ab.BufferGeometryUtils || ab,
  LG = new pr.BufferGeometry().applyMatrix4 ? "applyMatrix4" : "applyMatrix",
  Z8 = Wi({
    props: {
      hexBinPointsData: { default: [] },
      hexBinPointLat: { default: "lat" },
      hexBinPointLng: { default: "lng" },
      hexBinPointWeight: { default: 1 },
      hexBinResolution: { default: 4 },
      hexMargin: { default: 0.2 },
      hexTopCurvatureResolution: { default: 5 },
      hexTopColor: {
        default: function () {
          return "#ffffaa"
        },
      },
      hexSideColor: {
        default: function () {
          return "#ffffaa"
        },
      },
      hexAltitude: {
        default: function (e) {
          var t = e.sumWeight
          return t * 0.01
        },
      },
      hexBinMerge: { default: !1 },
      hexTransitionDuration: { default: 1e3, triggerUpdate: !1 },
    },
    init: function (e, t) {
      Fn(e), (t.scene = e)
    },
    update: function (e) {
      var t = Ye(e.hexBinPointLat),
        i = Ye(e.hexBinPointLng),
        r = Ye(e.hexBinPointWeight),
        s = Ye(e.hexAltitude),
        o = Ye(e.hexTopColor),
        a = Ye(e.hexSideColor),
        A = Ye(e.hexMargin),
        c = lg(
          e.hexBinPointsData.map(function (M) {
            return nn(
              nn({}, M),
              {},
              { h3Idx: sG(t(M), i(M), e.hexBinResolution) }
            )
          }),
          "h3Idx"
        ),
        d = Object.entries(c).map(function (M) {
          var _ = Gi(M, 2),
            R = _[0],
            T = _[1]
          return {
            h3Idx: R,
            points: T,
            sumWeight: T.reduce(function (L, B) {
              return L + +r(B)
            }, 0),
          }
        }),
        p = {},
        m = e.hexBinMerge ? new pr.Object3D() : e.scene
      if (
        (Sr(d, m, {
          createObj: S,
          updateObj: C,
          idAccessor: function (_) {
            return _.h3Idx
          },
        }),
        e.hexBinMerge)
      ) {
        var y = d.length
            ? PG.mergeBufferGeometries(
                d.map(function (M) {
                  var _ = M.__threeObj
                  M.__threeObj = void 0
                  var R = _.geometry.toNonIndexed()
                  _.updateMatrix(), R[LG](_.matrix)
                  for (
                    var T = new pr.Color(o(M)),
                      L = new pr.Color(a(M)),
                      B = R.attributes.position.count,
                      k = R.groups[0].count,
                      O = new Float32Array(B * 3),
                      W = 0,
                      z = B;
                    W < z;
                    W++
                  ) {
                    var P = W * 3,
                      N = W >= k ? T : L
                    ;(O[P] = N.r), (O[P + 1] = N.g), (O[P + 2] = N.b)
                  }
                  return (
                    R.setAttribute("color", new pr.BufferAttribute(O, 3)), R
                  )
                })
              )
            : new pr.BufferGeometry(),
          x = new pr.Mesh(
            y,
            new pr.MeshBasicMaterial({
              color: 16777215,
              vertexColors: !0,
              side: pr.DoubleSide,
            })
          )
        ;(x.__globeObjType = "hexBinPoints"),
          (x.__data = d),
          Fn(e.scene),
          e.scene.add(x)
      }
      function S(M) {
        var _ = new pr.Mesh()
        ;(_.__hexCenter = I8(M.h3Idx)),
          (_.__hexGeoJson = B8(M.h3Idx, !0).reverse())
        var R = _.__hexCenter[1]
        return (
          _.__hexGeoJson.forEach(function (T) {
            var L = T[0]
            Math.abs(R - L) > 170 && (T[0] += R > L ? 360 : -360)
          }),
          (_.__globeObjType = "hexbin"),
          _
        )
      }
      function C(M, _) {
        var R = function (Y, ne, le) {
            return Y - (Y - ne) * le
          },
          T = Math.max(0, Math.min(1, +A(_))),
          L = Gi(M.__hexCenter, 2),
          B = L[0],
          k = L[1],
          O =
            T === 0
              ? M.__hexGeoJson
              : M.__hexGeoJson.map(function (V) {
                  var Y = Gi(V, 2),
                    ne = Y[0],
                    le = Y[1]
                  return [
                    [ne, k],
                    [le, B],
                  ].map(function (Te) {
                    var Ae = Gi(Te, 2),
                      ge = Ae[0],
                      Me = Ae[1]
                    return R(ge, Me, T)
                  })
                }),
          W = e.hexTopCurvatureResolution
        M.geometry = new ry([O], 0, ti, !1, !0, !0, W)
        var z = { alt: +s(_) },
          P = function (Y) {
            var ne = (M.__currentTargetD = Y),
              le = ne.alt
            M.scale.x = M.scale.y = M.scale.z = 1 + le
          },
          N = M.__currentTargetD || Object.assign({}, z, { alt: -0.001 })
        if (
          (Object.keys(z).some(function (V) {
            return N[V] !== z[V]
          }) &&
            (e.hexBinMerge ||
            !e.hexTransitionDuration ||
            e.hexTransitionDuration < 0
              ? P(z)
              : new xn.Tween(N)
                  .to(z, e.hexTransitionDuration)
                  .easing(xn.Easing.Quadratic.InOut)
                  .onUpdate(P)
                  .start()),
          !e.hexBinMerge)
        ) {
          var G = a(_),
            j = o(_)
          ;[G, j].forEach(function (V) {
            if (!p.hasOwnProperty(V)) {
              var Y = os(V)
              p[V] = new pr.MeshLambertMaterial({
                color: Qs(V),
                transparent: Y < 1,
                opacity: Y,
                side: pr.DoubleSide,
              })
            }
          }),
            (M.material = [G, j].map(function (V) {
              return p[V]
            }))
        }
      }
    },
  }),
  vo = window.THREE
    ? window.THREE
    : {
        DoubleSide: ls,
        Group: zi,
        LineBasicMaterial: Nn,
        LineSegments: yi,
        Mesh: Xt,
        MeshBasicMaterial: Mr,
      },
  J8 = Wi({
    props: {
      polygonsData: { default: [] },
      polygonGeoJsonGeometry: { default: "geometry" },
      polygonSideColor: {
        default: function () {
          return "#ffffaa"
        },
      },
      polygonSideMaterial: {},
      polygonCapColor: {
        default: function () {
          return "#ffffaa"
        },
      },
      polygonCapMaterial: {},
      polygonStrokeColor: {},
      polygonAltitude: { default: 0.01 },
      polygonCapCurvatureResolution: { default: 5 },
      polygonsTransitionDuration: { default: 1e3, triggerUpdate: !1 },
    },
    init: function (e, t) {
      Fn(e), (t.scene = e)
    },
    update: function (e) {
      var t = Ye(e.polygonGeoJsonGeometry),
        i = Ye(e.polygonAltitude),
        r = Ye(e.polygonCapCurvatureResolution),
        s = Ye(e.polygonCapColor),
        o = Ye(e.polygonCapMaterial),
        a = Ye(e.polygonSideColor),
        A = Ye(e.polygonSideMaterial),
        c = Ye(e.polygonStrokeColor),
        d = []
      e.polygonsData.forEach(function (p) {
        var m = {
            data: p,
            capColor: s(p),
            capMaterial: o(p),
            sideColor: a(p),
            sideMaterial: A(p),
            strokeColor: c(p),
            altitude: +i(p),
            capCurvatureResolution: +r(p),
          },
          y = t(p),
          x = p.__id || "".concat(Math.round(Math.random() * 1e9))
        ;(p.__id = x),
          y.type === "Polygon"
            ? d.push(nn({ id: "".concat(x, "_0"), coords: y.coordinates }, m))
            : y.type === "MultiPolygon"
            ? d.push.apply(
                d,
                gn(
                  y.coordinates.map(function (S, C) {
                    return nn({ id: "".concat(x, "_").concat(C), coords: S }, m)
                  })
                )
              )
            : console.warn(
                "Unsupported GeoJson geometry type: ".concat(
                  y.type,
                  ". Skipping geometry..."
                )
              )
      }),
        Sr(d, e.scene, {
          idAccessor: function (m) {
            return m.id
          },
          createObj: function () {
            var m = new vo.Group()
            return (
              (m.__defaultSideMaterial = new vo.MeshBasicMaterial({
                side: vo.DoubleSide,
                depthWrite: !0,
              })),
              (m.__defaultCapMaterial = new vo.MeshBasicMaterial({
                side: vo.DoubleSide,
                depthWrite: !0,
              })),
              m.add(
                new vo.Mesh(void 0, [
                  m.__defaultSideMaterial,
                  m.__defaultCapMaterial,
                ])
              ),
              m.add(new vo.LineSegments(void 0, new vo.LineBasicMaterial())),
              (m.__globeObjType = "polygon"),
              m
            )
          },
          updateObj: function (m, y) {
            var x = y.coords,
              S = y.capColor,
              C = y.capMaterial,
              M = y.sideColor,
              _ = y.sideMaterial,
              R = y.strokeColor,
              T = y.altitude,
              L = y.capCurvatureResolution,
              B = Gi(m.children, 2),
              k = B[0],
              O = B[1],
              W = !!R
            if (
              ((O.visible = W),
              !DG(k.geometry.parameters || {}, {
                polygonGeoJson: x,
                curvatureResolution: L,
              }) && (k.geometry = new ry(x, 0, ti, !1, !0, !0, L)),
              W &&
                (!O.geometry.parameters ||
                  O.geometry.parameters.geoJson.coordinates !== x ||
                  O.geometry.parameters.resolution !== L) &&
                (O.geometry = new A8(
                  { type: "Polygon", coordinates: x },
                  ti,
                  L
                )),
              (k.material[0] = _ || m.__defaultSideMaterial),
              (k.material[1] = C || m.__defaultCapMaterial),
              [!_ && M, !C && S].forEach(function (V, Y) {
                if (!!V) {
                  var ne = k.material[Y],
                    le = os(V)
                  ne.color.set(Qs(V)),
                    (ne.transparent = le < 1),
                    (ne.opacity = le)
                }
              }),
              W)
            ) {
              var z = O.material,
                P = os(R)
              z.color.set(Qs(R)), (z.transparent = P < 1), (z.opacity = P)
            }
            var N = { alt: T },
              G = function (Y) {
                var ne = (m.__currentTargetD = Y),
                  le = ne.alt
                ;(k.scale.x = k.scale.y = k.scale.z = 1 + le),
                  W && (O.scale.x = O.scale.y = O.scale.z = 1 + le + 1e-4)
              },
              j = m.__currentTargetD || Object.assign({}, N, { alt: -0.001 })
            Object.keys(N).some(function (V) {
              return j[V] !== N[V]
            }) &&
              (!e.polygonsTransitionDuration ||
              e.polygonsTransitionDuration < 0 ||
              j.alt === N.alt
                ? G(N)
                : new xn.Tween(j)
                    .to(N, e.polygonsTransitionDuration)
                    .easing(xn.Easing.Quadratic.InOut)
                    .onUpdate(G)
                    .start())
          },
        })
    },
  })
function DG(n, e) {
  var t =
    arguments.length > 2 && arguments[2] !== void 0
      ? arguments[2]
      : function () {
          return function (i, r) {
            return i === r
          }
        }
  return Object.entries(e).every(function (i) {
    var r = Gi(i, 2),
      s = r[0],
      o = r[1]
    return n.hasOwnProperty(s) && t(s)(n[s], o)
  })
}
var kh = window.THREE
    ? window.THREE
    : { BufferGeometry: yt, DoubleSide: ls, Mesh: Xt, MeshLambertMaterial: Zs },
  lb = Object.assign({}, $2),
  IG = lb.BufferGeometryUtils || lb,
  K8 = Wi({
    props: {
      hexPolygonsData: { default: [] },
      hexPolygonGeoJsonGeometry: { default: "geometry" },
      hexPolygonColor: {
        default: function () {
          return "#ffffaa"
        },
      },
      hexPolygonAltitude: { default: 0.001 },
      hexPolygonResolution: { default: 3 },
      hexPolygonMargin: { default: 0.2 },
      hexPolygonCurvatureResolution: { default: 5 },
      hexPolygonsTransitionDuration: { default: 0, triggerUpdate: !1 },
    },
    init: function (e, t) {
      Fn(e), (t.scene = e)
    },
    update: function (e) {
      var t = Ye(e.hexPolygonGeoJsonGeometry),
        i = Ye(e.hexPolygonColor),
        r = Ye(e.hexPolygonAltitude),
        s = Ye(e.hexPolygonResolution),
        o = Ye(e.hexPolygonMargin),
        a = Ye(e.hexPolygonCurvatureResolution)
      Sr(e.hexPolygonsData, e.scene, {
        createObj: function (c) {
          var d = new kh.Mesh(
            void 0,
            new kh.MeshLambertMaterial({ side: kh.DoubleSide })
          )
          return (d.__globeObjType = "hexPolygon"), d
        },
        updateObj: function (c, d) {
          var p = t(d),
            m = s(d),
            y = r(d),
            x = Math.max(0, Math.min(1, +o(d))),
            S = a(d),
            C = i(d),
            M = os(C)
          c.material.color.set(Qs(C)),
            (c.material.transparent = M < 1),
            (c.material.opacity = M)
          var _ = []
          p.type === "Polygon"
            ? Yx(p.coordinates, m, !0).forEach(function (k) {
                return _.push(k)
              })
            : p.type === "MultiPolygon"
            ? p.coordinates.forEach(function (k) {
                return Yx(k, m, !0).forEach(function (O) {
                  return _.push(O)
                })
              })
            : console.warn(
                "Unsupported GeoJson geometry type: ".concat(
                  p.type,
                  ". Skipping geometry..."
                )
              )
          var R = _.map(function (k) {
              var O = I8(k),
                W = B8(k, !0).reverse(),
                z = O[1]
              return (
                W.forEach(function (P) {
                  var N = P[0]
                  Math.abs(z - N) > 170 && (P[0] += z > N ? 360 : -360)
                }),
                { h3Idx: k, hexCenter: O, hexGeoJson: W }
              )
            }),
            T = { alt: y, margin: x, curvatureResolution: S },
            L = function (O) {
              var W = (c.__currentTargetD = O),
                z = W.alt,
                P = W.margin,
                N = W.curvatureResolution
              c.geometry && c.geometry.dispose(),
                (c.geometry = R.length
                  ? IG.mergeBufferGeometries(
                      R.map(function (G) {
                        var j = function (Ae, ge, Me) {
                            return Ae - (Ae - ge) * Me
                          },
                          V = Gi(G.hexCenter, 2),
                          Y = V[0],
                          ne = V[1],
                          le =
                            P === 0
                              ? G.hexGeoJson
                              : G.hexGeoJson.map(function (Te) {
                                  var Ae = Gi(Te, 2),
                                    ge = Ae[0],
                                    Me = Ae[1]
                                  return [
                                    [ge, ne],
                                    [Me, Y],
                                  ].map(function (Ne) {
                                    var Ze = Gi(Ne, 2),
                                      K = Ze[0],
                                      Oe = Ze[1]
                                    return j(K, Oe, P)
                                  })
                                })
                        return new ry([le], ti, ti * (1 + z), !1, !0, !1, N)
                      })
                    )
                  : new kh.BufferGeometry())
            },
            B = c.__currentTargetD || Object.assign({}, T, { alt: -0.001 })
          Object.keys(T).some(function (k) {
            return B[k] !== T[k]
          }) &&
            (!e.hexPolygonsTransitionDuration ||
            e.hexPolygonsTransitionDuration < 0
              ? L(T)
              : new xn.Tween(B)
                  .to(T, e.hexPolygonsTransitionDuration)
                  .easing(xn.Easing.Quadratic.InOut)
                  .onUpdate(L)
                  .start())
        },
      })
    },
  }),
  BG = window.THREE ? window.THREE : { Vector3: X }
function kG(n, e) {
  var t = function (o, a) {
      var A = o[o.length - 1]
      return [].concat(
        gn(o),
        gn(
          gn(new Array(a - o.length)).map(function () {
            return A
          })
        )
      )
    },
    i = Math.max(n.length, e.length),
    r = fz.apply(
      void 0,
      gn(
        [n, e]
          .map(function (s) {
            return s.map(function (o) {
              var a = o.x,
                A = o.y,
                c = o.z
              return [a, A, c]
            })
          })
          .map(function (s) {
            return t(s, i)
          })
      )
    )
  return function (s) {
    return s === 0
      ? n
      : s === 1
      ? e
      : r(s).map(function (o) {
          var a = Gi(o, 3),
            A = a[0],
            c = a[1],
            d = a[2]
          return new BG.Vector3(A, c, d)
        })
  }
}
var $r = window.THREE
    ? window.THREE
    : {
        BufferGeometry: yt,
        Color: Ke,
        Float32BufferAttribute: ut,
        Group: zi,
        Line: br,
        NormalBlending: Ro,
        ShaderMaterial: ar,
        Vector3: X,
      },
  cb = new $r.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute",
  OG = {
    uniforms: {
      dashOffset: { value: 0 },
      dashSize: { value: 1 },
      gapSize: { value: 0 },
      dashTranslate: { value: 0 },
    },
    vertexShader: `
    uniform float dashTranslate;

    attribute vec4 vertexColor;
    varying vec4 vColor;

    attribute float vertexRelDistance;
    varying float vRelDistance;

    void main() {
      // pass through colors and distances
      vColor = vertexColor;
      vRelDistance = vertexRelDistance + dashTranslate;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
    fragmentShader: `
    uniform float dashOffset;
    uniform float dashSize;
    uniform float gapSize;

    varying vec4 vColor;
    varying float vRelDistance;

    void main() {
      // ignore pixels in the gap
      if (vRelDistance < dashOffset) discard;
      if (mod(vRelDistance - dashOffset, dashSize + gapSize) > dashSize) discard;

      // set px color: [r, g, b, a], interpolated between vertices
      gl_FragColor = vColor;
    }
  `,
  },
  eM = Wi({
    props: {
      pathsData: { default: [] },
      pathPoints: {
        default: function (e) {
          return e
        },
      },
      pathPointLat: {
        default: function (e) {
          return e[0]
        },
      },
      pathPointLng: {
        default: function (e) {
          return e[1]
        },
      },
      pathPointAlt: { default: 0.001 },
      pathResolution: { default: 2 },
      pathColor: {
        default: function () {
          return "#ffffaa"
        },
      },
      pathStroke: {},
      pathDashLength: { default: 1 },
      pathDashGap: { default: 0 },
      pathDashInitialGap: { default: 0 },
      pathDashAnimateTime: { default: 0 },
      pathTransitionDuration: { default: 1e3, triggerUpdate: !1 },
      rendererSize: {},
    },
    init: function (e, t) {
      Fn(e),
        (t.scene = e),
        new X2().onTick.add(function (i, r) {
          t.pathsData
            .filter(function (s) {
              return (
                s.__threeObj &&
                s.__threeObj.children.length &&
                s.__threeObj.children[0].material &&
                s.__threeObj.children[0].__dashAnimateStep
              )
            })
            .forEach(function (s) {
              var o = s.__threeObj.children[0],
                a = o.__dashAnimateStep * r
              if (o.type === "Line") {
                var A = o.material.uniforms.dashTranslate.value % 1e9
                o.material.uniforms.dashTranslate.value = A + a
              } else if (o.type === "Line2") {
                for (
                  var c = o.material.dashOffset - a,
                    d = o.material.dashSize + o.material.gapSize;
                  c <= -d;

                )
                  c += d
                o.material.dashOffset = c
              }
            })
        })
    },
    update: function (e) {
      var t = Ye(e.pathPoints),
        i = Ye(e.pathPointLat),
        r = Ye(e.pathPointLng),
        s = Ye(e.pathPointAlt),
        o = Ye(e.pathStroke),
        a = Ye(e.pathColor),
        A = Ye(e.pathDashLength),
        c = Ye(e.pathDashGap),
        d = Ye(e.pathDashInitialGap),
        p = Ye(e.pathDashAnimateTime),
        m = new $r.ShaderMaterial(
          nn(nn({}, OG), {}, { transparent: !0, blending: $r.NormalBlending })
        )
      Sr(e.pathsData, e.scene, {
        createObj: function () {
          var _ = new $r.Group()
          return (_.__globeObjType = "path"), _
        },
        updateObj: function (_, R) {
          var T = o(R),
            L = T != null
          if (!_.children.length || L === (_.children[0].type === "Line")) {
            Fn(_)
            var B = L
              ? new q8(new ay(), new Zd())
              : new $r.Line(new $r.BufferGeometry(), m.clone())
            _.add(B)
          }
          var k = _.children[0],
            O = x(t(R), i, r, s, e.pathResolution),
            W = p(R)
          if (((k.__dashAnimateStep = W > 0 ? 1e3 / W : 0), L)) {
            k.material.resolution = e.rendererSize
            {
              var N = A(R),
                G = c(R),
                j = d(R)
              ;(k.material.dashed = G > 0),
                k.material.dashed
                  ? (k.material.defines.USE_DASH = "")
                  : delete k.material.defines.USE_DASH,
                k.material.dashed &&
                  ((k.material.dashScale = 1 / y(O)),
                  (k.material.dashSize = N),
                  (k.material.gapSize = G),
                  (k.material.dashOffset = -j))
            }
            {
              var V = a(R)
              if (V instanceof Array) {
                var Y = S(a(R), O.length - 1, 1, !1)
                k.geometry.setColors(Y.array), (k.material.vertexColors = !0)
              } else {
                var ne = V,
                  le = os(ne)
                ;(k.material.color = new $r.Color(Qs(ne))),
                  (k.material.transparent = le < 1),
                  (k.material.opacity = le),
                  (k.material.vertexColors = !1)
              }
            }
            k.material.needsUpdate = !0
          } else {
            Object.assign(k.material.uniforms, {
              dashSize: { value: A(R) },
              gapSize: { value: c(R) },
              dashOffset: { value: d(R) },
            })
            var z = S(a(R), O.length),
              P = C(O.length, 1, !0)
            k.geometry[cb]("vertexColor", z),
              k.geometry[cb]("vertexRelDistance", P)
          }
          var Te = kG(
              (R.__currentTargetD && R.__currentTargetD.points) || [O[0]],
              O
            ),
            Ae = function (Ze) {
              var K = (R.__currentTargetD = Ze),
                Oe = K.stroke,
                ve = K.interpolK,
                Be = (R.__currentTargetD.points = Te(ve))
              if (L) {
                var Fe
                k.geometry.setPositions(
                  (Fe = []).concat.apply(
                    Fe,
                    gn(
                      Be.map(function (je) {
                        var Ge = je.x,
                          ye = je.y,
                          D = je.z
                        return [Ge, ye, D]
                      })
                    )
                  )
                ),
                  (k.material.linewidth = Oe),
                  k.material.dashed && k.computeLineDistances()
              } else
                k.geometry.setFromPoints(Be), k.geometry.computeBoundingSphere()
            },
            ge = { stroke: T, interpolK: 1 },
            Me = Object.assign({}, R.__currentTargetD || ge, { interpolK: 0 })
          Object.keys(ge).some(function (Ne) {
            return Me[Ne] !== ge[Ne]
          }) &&
            (!e.pathTransitionDuration || e.pathTransitionDuration < 0
              ? Ae(ge)
              : new xn.Tween(Me)
                  .to(ge, e.pathTransitionDuration)
                  .easing(xn.Easing.Quadratic.InOut)
                  .onUpdate(Ae)
                  .start())
        },
      })
      function y(M) {
        var _ = 0,
          R
        return (
          M.forEach(function (T) {
            R && (_ += R.distanceTo(T)), (R = T)
          }),
          _
        )
      }
      function x(M, _, R, T, L) {
        var B = function (z, P, N) {
            for (var G = [], j = 1; j <= N; j++)
              G.push(z + ((P - z) * j) / (N + 1))
            return G
          },
          k = function () {
            var z =
                arguments.length > 0 && arguments[0] !== void 0
                  ? arguments[0]
                  : [],
              P =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : 1,
              N = [],
              G = null
            return (
              z.forEach(function (j) {
                if (G) {
                  for (; Math.abs(G[1] - j[1]) > 180; )
                    G[1] += 360 * (G[1] < j[1] ? 1 : -1)
                  var V = Math.sqrt(
                    Math.pow(j[0] - G[0], 2) + Math.pow(j[1] - G[1], 2)
                  )
                  if (V > P)
                    for (
                      var Y = Math.floor(V / P),
                        ne = B(G[0], j[0], Y),
                        le = B(G[1], j[1], Y),
                        Te = B(G[2], j[2], Y),
                        Ae = 0,
                        ge = ne.length;
                      Ae < ge;
                      Ae++
                    )
                      N.push([ne[Ae], le[Ae], Te[Ae]])
                }
                N.push((G = j))
              }),
              N
            )
          },
          O = function (z) {
            var P = Gi(z, 3),
              N = P[0],
              G = P[1],
              j = P[2],
              V = Qo(N, G, j),
              Y = V.x,
              ne = V.y,
              le = V.z
            return new $r.Vector3(Y, ne, le)
          }
        return k(
          M.map(function (W) {
            return [_(W), R(W), T(W)]
          }),
          L
        ).map(O)
      }
      function S(M, _) {
        var R =
            arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
          T =
            arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0,
          L = _ + 1,
          B
        if (M instanceof Array || M instanceof Function) {
          var k =
            M instanceof Array
              ? Ic()
                  .domain(
                    M.map(function (V, Y) {
                      return Y / (M.length - 1)
                    })
                  )
                  .range(M)
              : M
          B = function (Y) {
            return K0(k(Y), T)
          }
        } else {
          var O = K0(M, T)
          B = function () {
            return O
          }
        }
        for (
          var W = T ? 4 : 3,
            z = new $r.Float32BufferAttribute(L * W * R, W),
            P = 0,
            N = L;
          P < N;
          P++
        )
          for (var G = B(P / (N - 1)), j = 0; j < R; j++)
            z.set(G, (P * R + j) * W)
        return z
      }
      function C(M) {
        for (
          var _ =
              arguments.length > 1 && arguments[1] !== void 0
                ? arguments[1]
                : 1,
            R =
              arguments.length > 2 && arguments[2] !== void 0
                ? arguments[2]
                : !1,
            T = M + 1,
            L = T * _,
            B = new $r.Float32BufferAttribute(L, 1),
            k = 0,
            O = T;
          k < O;
          k++
        )
          for (var W = k / (O - 1), z = 0; z < _; z++) {
            var P = k * _ + z,
              N = R ? L - 1 - P : P
            B.setX(N, W)
          }
        return B
      }
    },
  }),
  Oh = window.THREE
    ? window.THREE
    : {
        Euler: jo,
        Mesh: Xt,
        MeshLambertMaterial: Zs,
        SphereBufferGeometry: As,
      },
  tM = Wi({
    props: {
      tilesData: { default: [] },
      tileLat: { default: "lat" },
      tileLng: { default: "lng" },
      tileAltitude: { default: 0.01 },
      tileWidth: { default: 1 },
      tileHeight: { default: 1 },
      tileUseGlobeProjection: { default: !0 },
      tileMaterial: {
        default: function () {
          return new Oh.MeshLambertMaterial({
            color: "#ffbb88",
            opacity: 0.4,
            transparent: !0,
          })
        },
      },
      tileCurvatureResolution: { default: 5 },
      tilesTransitionDuration: { default: 1e3, triggerUpdate: !1 },
    },
    init: function (e, t) {
      Fn(e), (t.scene = e)
    },
    update: function (e) {
      var t = Ye(e.tileLat),
        i = Ye(e.tileLng),
        r = Ye(e.tileAltitude),
        s = Ye(e.tileWidth),
        o = Ye(e.tileHeight),
        a = Ye(e.tileUseGlobeProjection),
        A = Ye(e.tileMaterial),
        c = Ye(e.tileCurvatureResolution)
      Sr(e.tilesData, e.scene, {
        createObj: function () {
          var p = new Oh.Mesh()
          return (p.__globeObjType = "tile"), p
        },
        updateObj: function (p, m) {
          p.material = A(m)
          var y = a(m),
            x = c(m),
            S = function (R) {
              var T = (p.__currentTargetD = R),
                L = T.lat,
                B = T.lng,
                k = T.alt,
                O = T.width,
                W = T.height,
                z = Bl(B),
                P = Bl(-L)
              p.geometry && p.geometry.dispose(),
                (p.geometry = new Oh.SphereBufferGeometry(
                  ti * (1 + k),
                  Math.ceil(O / (x || -1)),
                  Math.ceil(W / (x || -1)),
                  Bl(90 - O / 2) + (y ? z : 0),
                  Bl(O),
                  Bl(90 - W / 2) + (y ? P : 0),
                  Bl(W)
                )),
                y || p.setRotationFromEuler(new Oh.Euler(P, z, 0, "YXZ"))
            },
            C = {
              lat: +t(m),
              lng: +i(m),
              alt: +r(m),
              width: +s(m),
              height: +o(m),
            },
            M =
              p.__currentTargetD ||
              Object.assign({}, C, { width: 0, height: 0 })
          Object.keys(C).some(function (_) {
            return M[_] !== C[_]
          }) &&
            (!e.tilesTransitionDuration || e.tilesTransitionDuration < 0
              ? S(C)
              : new xn.Tween(M)
                  .to(C, e.tilesTransitionDuration)
                  .easing(xn.Easing.Quadratic.InOut)
                  .onUpdate(S)
                  .start())
        },
      })
    },
  }),
  Bl = function (e) {
    return (e * Math.PI) / 180
  },
  qG = {
    0: {
      x_min: 73,
      x_max: 715,
      ha: 792,
      o: "m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 ",
    },
    1: {
      x_min: 215.671875,
      x_max: 574,
      ha: 792,
      o: "m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 ",
    },
    2: {
      x_min: 59,
      x_max: 731,
      ha: 792,
      o: "m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 ",
    },
    3: {
      x_min: 54,
      x_max: 737,
      ha: 792,
      o: "m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 ",
    },
    4: {
      x_min: 48,
      x_max: 742.453125,
      ha: 792,
      o: "m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 ",
    },
    5: {
      x_min: 54.171875,
      x_max: 738,
      ha: 792,
      o: "m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 ",
    },
    6: {
      x_min: 53,
      x_max: 739,
      ha: 792,
      o: "m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 ",
    },
    7: {
      x_min: 58.71875,
      x_max: 730.953125,
      ha: 792,
      o: "m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 ",
    },
    8: {
      x_min: 55,
      x_max: 736,
      ha: 792,
      o: "m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 ",
    },
    9: {
      x_min: 53,
      x_max: 739,
      ha: 792,
      o: "m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 ",
    },
    : {
      x_min: 0,
      x_max: 712,
      ha: 815,
      o: "m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 ",
    },
    S: {
      x_min: 0,
      x_max: 788,
      ha: 890,
      o: "m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 ",
    },
    "\xA6": {
      x_min: 343,
      x_max: 449,
      ha: 792,
      o: "m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 ",
    },
    "/": {
      x_min: 183.25,
      x_max: 608.328125,
      ha: 792,
      o: "m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 ",
    },
    : {
      x_min: -0.4375,
      x_max: 777.453125,
      ha: 839,
      o: "m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 ",
    },
    y: {
      x_min: 0,
      x_max: 684.78125,
      ha: 771,
      o: "m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 ",
    },
    : {
      x_min: 0,
      x_max: 803,
      ha: 917,
      o: "m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 ",
    },
    : {
      x_min: -111,
      x_max: 339,
      ha: 361,
      o: "m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 ",
    },
    g: {
      x_min: 0,
      x_max: 686,
      ha: 838,
      o: "m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 ",
    },
    "\xB2": {
      x_min: 0,
      x_max: 442,
      ha: 539,
      o: "m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 ",
    },
    "\u2013": {
      x_min: 0,
      x_max: 705.5625,
      ha: 803,
      o: "m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 ",
    },
    : {
      x_min: 0,
      x_max: 819.5625,
      ha: 893,
      o: "m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 ",
    },
    : {
      x_min: -46.265625,
      x_max: 392,
      ha: 513,
      o: "m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 ",
    },
    e: {
      x_min: 0,
      x_max: 714,
      ha: 813,
      o: "m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 ",
    },
    : {
      x_min: 0,
      x_max: 712,
      ha: 815,
      o: "m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 ",
    },
    J: {
      x_min: 0,
      x_max: 588,
      ha: 699,
      o: "m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 ",
    },
    "\xBB": {
      x_min: -1,
      x_max: 503,
      ha: 601,
      o: "m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 ",
    },
    "\xA9": {
      x_min: -3,
      x_max: 1008,
      ha: 1106,
      o: "m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 ",
    },
    : {
      x_min: 0,
      x_max: 922,
      ha: 1030,
      o: "m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 ",
    },
    "^": {
      x_min: 193.0625,
      x_max: 598.609375,
      ha: 792,
      o: "m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 ",
    },
    "\xAB": {
      x_min: 0,
      x_max: 507.203125,
      ha: 604,
      o: "m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 ",
    },
    D: {
      x_min: 0,
      x_max: 828,
      ha: 935,
      o: "m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 ",
    },
    "\u2219": {
      x_min: 0,
      x_max: 142,
      ha: 239,
      o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 ",
    },
    : {
      x_min: 0,
      x_max: 47,
      ha: 125,
      o: "m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 ",
    },
    w: {
      x_min: 0,
      x_max: 1009.71875,
      ha: 1100,
      o: "m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 ",
    },
    $: {
      x_min: 0,
      x_max: 700,
      ha: 793,
      o: "m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 ",
    },
    "\\": {
      x_min: -0.015625,
      x_max: 425.0625,
      ha: 522,
      o: "m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 ",
    },
    : {
      x_min: 0,
      x_max: 697.21875,
      ha: 747,
      o: "m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 ",
    },
    : {
      x_min: 42,
      x_max: 181,
      ha: 297,
      o: "m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 ",
    },
    : {
      x_min: 0,
      x_max: 1144.5,
      ha: 1214,
      o: "m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 ",
    },
    "\u2019": {
      x_min: 0,
      x_max: 139,
      ha: 236,
      o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 ",
    },
    : {
      x_min: 0,
      x_max: 801,
      ha: 915,
      o: "m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 ",
    },
    "-": {
      x_min: 8.71875,
      x_max: 350.390625,
      ha: 478,
      o: "m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 ",
    },
    Q: {
      x_min: 0,
      x_max: 968,
      ha: 1072,
      o: "m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 ",
    },
    : {
      x_min: 1,
      x_max: 676.28125,
      ha: 740,
      o: "m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 ",
    },
    M: {
      x_min: 0,
      x_max: 954,
      ha: 1067,
      o: "m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 ",
    },
    : {
      x_min: 0,
      x_max: 1006,
      ha: 1094,
      o: "m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 ",
    },
    C: {
      x_min: 0,
      x_max: 886,
      ha: 944,
      o: "m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 ",
    },
    "!": {
      x_min: 0,
      x_max: 138,
      ha: 236,
      o: "m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 ",
    },
    "{": {
      x_min: 0,
      x_max: 480.5625,
      ha: 578,
      o: "m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 ",
    },
    X: {
      x_min: -0.015625,
      x_max: 854.15625,
      ha: 940,
      o: "m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 ",
    },
    "#": {
      x_min: 0,
      x_max: 963.890625,
      ha: 1061,
      o: "m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 ",
    },
    : {
      x_min: 42,
      x_max: 284,
      ha: 361,
      o: "m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 ",
    },
    : {
      x_min: 0,
      x_max: 906.953125,
      ha: 982,
      o: "m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 ",
    },
    ")": {
      x_min: 0,
      x_max: 318,
      ha: 415,
      o: "m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 ",
    },
    : {
      x_min: 0,
      x_max: 634.71875,
      ha: 714,
      o: "m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 ",
    },
    : {
      x_min: 0,
      x_max: 952.78125,
      ha: 1028,
      o: "m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 ",
    },
    "}": {
      x_min: 0,
      x_max: 481,
      ha: 578,
      o: "m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 ",
    },
    "\u2030": {
      x_min: -3,
      x_max: 1672,
      ha: 1821,
      o: "m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 ",
    },
    a: {
      x_min: 0,
      x_max: 698.609375,
      ha: 794,
      o: "m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 ",
    },
    "\u2014": {
      x_min: 0,
      x_max: 941.671875,
      ha: 1039,
      o: "m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 ",
    },
    "=": {
      x_min: 8.71875,
      x_max: 780.953125,
      ha: 792,
      o: "m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 ",
    },
    N: {
      x_min: 0,
      x_max: 801,
      ha: 914,
      o: "m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 ",
    },
    : {
      x_min: 0,
      x_max: 712,
      ha: 797,
      o: "m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 ",
    },
    "\xAF": {
      x_min: 0,
      x_max: 941.671875,
      ha: 938,
      o: "m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 ",
    },
    Z: {
      x_min: 0,
      x_max: 779,
      ha: 849,
      o: "m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 ",
    },
    u: {
      x_min: 0,
      x_max: 617,
      ha: 729,
      o: "m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 ",
    },
    k: {
      x_min: 0,
      x_max: 612.484375,
      ha: 697,
      o: "m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 ",
    },
    : {
      x_min: 0,
      x_max: 803,
      ha: 917,
      o: "m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 ",
    },
    : {
      x_min: 0,
      x_max: 906.953125,
      ha: 985,
      o: "m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 ",
    },
    s: {
      x_min: 0,
      x_max: 604,
      ha: 697,
      o: "m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 ",
    },
    B: {
      x_min: 0,
      x_max: 778,
      ha: 876,
      o: "m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 ",
    },
    "\u2026": {
      x_min: 0,
      x_max: 614,
      ha: 708,
      o: "m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 ",
    },
    "?": {
      x_min: 0,
      x_max: 607,
      ha: 704,
      o: "m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 ",
    },
    H: {
      x_min: 0,
      x_max: 803,
      ha: 915,
      o: "m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 ",
    },
    : {
      x_min: 0,
      x_max: 675,
      ha: 761,
      o: "m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 ",
    },
    c: {
      x_min: 1,
      x_max: 701.390625,
      ha: 775,
      o: "m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 ",
    },
    "\xB6": {
      x_min: 0,
      x_max: 566.671875,
      ha: 678,
      o: "m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 ",
    },
    : {
      x_min: 0,
      x_max: 660,
      ha: 745,
      o: "m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 ",
    },
    : {
      x_min: 0,
      x_max: 954,
      ha: 1068,
      o: "m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 ",
    },
    : {
      x_min: 0.109375,
      x_max: 1120,
      ha: 1217,
      o: "m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 ",
    },
    : {
      x_min: 0,
      x_max: 1158,
      ha: 1275,
      o: "m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 ",
    },
    "\u2022": {
      x_min: 0,
      x_max: 663.890625,
      ha: 775,
      o: "m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 ",
    },
    "\xA5": {
      x_min: 0.1875,
      x_max: 819.546875,
      ha: 886,
      o: "m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 ",
    },
    "(": {
      x_min: 0,
      x_max: 318.0625,
      ha: 415,
      o: "m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 ",
    },
    U: {
      x_min: 0,
      x_max: 796,
      ha: 904,
      o: "m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 ",
    },
    : {
      x_min: 0.5,
      x_max: 744.953125,
      ha: 822,
      o: "m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 ",
    },
    : {
      x_min: 0,
      x_max: 765.5625,
      ha: 809,
      o: "m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 ",
    },
    F: {
      x_min: 0,
      x_max: 683.328125,
      ha: 717,
      o: "m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 ",
    },
    "\xAD": {
      x_min: 0,
      x_max: 705.5625,
      ha: 803,
      o: "m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 ",
    },
    ":": {
      x_min: 0,
      x_max: 142,
      ha: 239,
      o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 ",
    },
    : {
      x_min: 0,
      x_max: 854.171875,
      ha: 935,
      o: "m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 ",
    },
    "*": {
      x_min: 116,
      x_max: 674,
      ha: 792,
      o: "m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 ",
    },
    "\u2020": {
      x_min: 0,
      x_max: 777,
      ha: 835,
      o: "m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 ",
    },
    "\xB0": {
      x_min: 0,
      x_max: 347,
      ha: 444,
      o: "m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 ",
    },
    V: {
      x_min: 0,
      x_max: 862.71875,
      ha: 940,
      o: "m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 ",
    },
    : {
      x_min: 0,
      x_max: 734.71875,
      ha: 763,
      o: "m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 ",
    },
    "\xA0": { x_min: 0, x_max: 0, ha: 853 },
    : {
      x_min: 0.328125,
      x_max: 819.515625,
      ha: 889,
      o: "m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 ",
    },
    "\u201D": {
      x_min: 0,
      x_max: 347,
      ha: 454,
      o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 ",
    },
    "@": {
      x_min: 0,
      x_max: 1260,
      ha: 1357,
      o: "m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 ",
    },
    : {
      x_min: 0,
      x_max: 499,
      ha: 613,
      o: "m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 ",
    },
    i: {
      x_min: 14,
      x_max: 136,
      ha: 275,
      o: "m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 ",
    },
    : {
      x_min: 0,
      x_max: 778,
      ha: 877,
      o: "m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 ",
    },
    : {
      x_min: 0,
      x_max: 617,
      ha: 725,
      o: "m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 ",
    },
    "]": {
      x_min: 0,
      x_max: 275,
      ha: 372,
      o: "m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 ",
    },
    m: {
      x_min: 0,
      x_max: 1019,
      ha: 1128,
      o: "m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 ",
    },
    : {
      x_min: 8.328125,
      x_max: 780.5625,
      ha: 815,
      o: "m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 ",
    },
    : {
      x_min: 42,
      x_max: 326.71875,
      ha: 361,
      o: "m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 ",
    },
    : {
      x_min: 0,
      x_max: 779.171875,
      ha: 850,
      o: "m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 ",
    },
    R: {
      x_min: 0,
      x_max: 781.953125,
      ha: 907,
      o: "m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 ",
    },
    o: {
      x_min: 0,
      x_max: 713,
      ha: 821,
      o: "m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 ",
    },
    K: {
      x_min: 0,
      x_max: 819.46875,
      ha: 906,
      o: "m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 ",
    },
    ",": {
      x_min: 0,
      x_max: 142,
      ha: 239,
      o: "m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 ",
    },
    d: {
      x_min: 0,
      x_max: 683,
      ha: 796,
      o: "m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 ",
    },
    "\xA8": {
      x_min: -109,
      x_max: 247,
      ha: 232,
      o: "m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 ",
    },
    E: {
      x_min: 0,
      x_max: 736.109375,
      ha: 789,
      o: "m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 ",
    },
    Y: {
      x_min: 0,
      x_max: 820,
      ha: 886,
      o: "m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 ",
    },
    '"': {
      x_min: 0,
      x_max: 299,
      ha: 396,
      o: "m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 ",
    },
    "\u2039": {
      x_min: 17.984375,
      x_max: 773.609375,
      ha: 792,
      o: "m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 ",
    },
    "\u201E": {
      x_min: 0,
      x_max: 364,
      ha: 467,
      o: "m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 ",
    },
    : {
      x_min: 1,
      x_max: 710,
      ha: 810,
      o: "m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 ",
    },
    : {
      x_min: 0,
      x_max: 634.71875,
      ha: 714,
      o: "m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 ",
    },
    : {
      x_min: 0,
      x_max: 922,
      ha: 1031,
      o: "m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 ",
    },
    "\xB4": {
      x_min: 0,
      x_max: 96,
      ha: 251,
      o: "m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 ",
    },
    "\xB1": {
      x_min: 11,
      x_max: 781,
      ha: 792,
      o: "m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 ",
    },
    "|": {
      x_min: 343,
      x_max: 449,
      ha: 792,
      o: "m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 ",
    },
    : {
      x_min: 0,
      x_max: 617,
      ha: 725,
      o: "m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 ",
    },
    "\xA7": {
      x_min: 0,
      x_max: 593,
      ha: 690,
      o: "m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 ",
    },
    b: {
      x_min: 0,
      x_max: 685,
      ha: 783,
      o: "m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 ",
    },
    q: {
      x_min: 0,
      x_max: 683,
      ha: 876,
      o: "m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 ",
    },
    : {
      x_min: -0.171875,
      x_max: 969.5625,
      ha: 1068,
      o: "m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 ",
    },
    : {
      x_min: 0,
      x_max: 617,
      ha: 725,
      o: "m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 ",
    },
    z: {
      x_min: -0.015625,
      x_max: 613.890625,
      ha: 697,
      o: "m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 ",
    },
    "\u2122": {
      x_min: 0,
      x_max: 894,
      ha: 1e3,
      o: "m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 ",
    },
    : {
      x_min: 0.78125,
      x_max: 697,
      ha: 810,
      o: "m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 ",
    },
    : {
      x_min: 0,
      x_max: 960,
      ha: 1056,
      o: "m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 ",
    },
    "\xAE": {
      x_min: -3,
      x_max: 1008,
      ha: 1106,
      o: "m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 ",
    },
    "~": {
      x_min: 0,
      x_max: 833,
      ha: 931,
      o: "m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 ",
    },
    : {
      x_min: 0,
      x_max: 736.21875,
      ha: 778,
      o: "m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 ",
    },
    "\xB3": {
      x_min: 0,
      x_max: 450,
      ha: 547,
      o: "m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 ",
    },
    "[": {
      x_min: 0,
      x_max: 273.609375,
      ha: 371,
      o: "m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 ",
    },
    L: {
      x_min: 0,
      x_max: 645.828125,
      ha: 696,
      o: "m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 ",
    },
    : {
      x_min: 0,
      x_max: 803.390625,
      ha: 894,
      o: "m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 ",
    },
    : {
      x_min: 0,
      x_max: 573,
      ha: 642,
      o: "m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 ",
    },
    : {
      x_min: 0,
      x_max: 674,
      ha: 778,
      o: "m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 ",
    },
    : {
      x_min: 0,
      x_max: 958,
      ha: 1054,
      o: "m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 ",
    },
    : {
      x_min: 0,
      x_max: 705.28125,
      ha: 749,
      o: "m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 ",
    },
    " ": { x_min: 0, x_max: 0, ha: 375 },
    "%": {
      x_min: -3,
      x_max: 1089,
      ha: 1186,
      o: "m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 ",
    },
    P: {
      x_min: 0,
      x_max: 726,
      ha: 806,
      o: "m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 ",
    },
    : {
      x_min: 0,
      x_max: 1078.21875,
      ha: 1118,
      o: "m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 ",
    },
    : {
      x_min: 0.125,
      x_max: 1136.546875,
      ha: 1235,
      o: "m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 ",
    },
    _: {
      x_min: 0,
      x_max: 705.5625,
      ha: 803,
      o: "m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 ",
    },
    : {
      x_min: -110,
      x_max: 246,
      ha: 275,
      o: "m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 ",
    },
    "+": {
      x_min: 23,
      x_max: 768,
      ha: 792,
      o: "m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 ",
    },
    "\xBD": {
      x_min: 0,
      x_max: 1050,
      ha: 1149,
      o: "m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 ",
    },
    : {
      x_min: 0,
      x_max: 720,
      ha: 783,
      o: "m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 ",
    },
    "'": {
      x_min: 0,
      x_max: 139,
      ha: 236,
      o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 ",
    },
    : {
      x_min: 0,
      x_max: 350,
      ha: 397,
      o: "m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 ",
    },
    "\u0385": {
      x_min: 0,
      x_max: 450,
      ha: 553,
      o: "m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 ",
    },
    T: {
      x_min: 0,
      x_max: 777,
      ha: 835,
      o: "m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 ",
    },
    : {
      x_min: 0,
      x_max: 915,
      ha: 997,
      o: "m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 ",
    },
    "\u204B": { x_min: 0, x_max: 0, ha: 694 },
    j: {
      x_min: -77.78125,
      x_max: 167,
      ha: 349,
      o: "m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 ",
    },
    : {
      x_min: 0,
      x_max: 756.953125,
      ha: 819,
      o: "m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 ",
    },
    "\u203A": {
      x_min: 18.0625,
      x_max: 774,
      ha: 792,
      o: "m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 ",
    },
    "<": {
      x_min: 17.984375,
      x_max: 773.609375,
      ha: 792,
      o: "m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 ",
    },
    "\xA3": {
      x_min: 0,
      x_max: 704.484375,
      ha: 801,
      o: "m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 ",
    },
    t: {
      x_min: 0,
      x_max: 367,
      ha: 458,
      o: "m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 ",
    },
    "\xAC": {
      x_min: 0,
      x_max: 706,
      ha: 803,
      o: "m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 ",
    },
    : {
      x_min: 0,
      x_max: 750,
      ha: 803,
      o: "m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 ",
    },
    W: {
      x_min: 0,
      x_max: 1263.890625,
      ha: 1351,
      o: "m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 ",
    },
    ">": {
      x_min: 18.0625,
      x_max: 774,
      ha: 792,
      o: "m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 ",
    },
    v: {
      x_min: 0,
      x_max: 675.15625,
      ha: 761,
      o: "m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 ",
    },
    : {
      x_min: 0.28125,
      x_max: 644.5,
      ha: 703,
      o: "m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 ",
    },
    : {
      x_min: 0,
      x_max: 624.9375,
      ha: 699,
      o: "m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 ",
    },
    "&": {
      x_min: -3,
      x_max: 894.25,
      ha: 992,
      o: "m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 ",
    },
    : {
      x_min: 0,
      x_max: 862.5,
      ha: 942,
      o: "m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 ",
    },
    I: {
      x_min: 41,
      x_max: 180,
      ha: 293,
      o: "m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 ",
    },
    G: {
      x_min: 0,
      x_max: 921,
      ha: 1011,
      o: "m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 ",
    },
    : {
      x_min: 0,
      x_max: 617,
      ha: 725,
      o: "m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 ",
    },
    "`": {
      x_min: 0,
      x_max: 138.890625,
      ha: 236,
      o: "m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 ",
    },
    "\xB7": {
      x_min: 0,
      x_max: 142,
      ha: 239,
      o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 ",
    },
    : {
      x_min: 0.328125,
      x_max: 819.515625,
      ha: 889,
      o: "m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 ",
    },
    r: {
      x_min: 0,
      x_max: 355.5625,
      ha: 432,
      o: "m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 ",
    },
    x: {
      x_min: 0,
      x_max: 675,
      ha: 764,
      o: "m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 ",
    },
    : {
      x_min: 0,
      x_max: 696.609375,
      ha: 747,
      o: "m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 ",
    },
    h: {
      x_min: 0,
      x_max: 615,
      ha: 724,
      o: "m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 ",
    },
    ".": {
      x_min: 0,
      x_max: 142,
      ha: 239,
      o: "m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 ",
    },
    : {
      x_min: -2,
      x_max: 878,
      ha: 974,
      o: "m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 ",
    },
    ";": {
      x_min: 0,
      x_max: 142,
      ha: 239,
      o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 ",
    },
    f: {
      x_min: 0,
      x_max: 378,
      ha: 472,
      o: "m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 ",
    },
    "\u201C": {
      x_min: 1,
      x_max: 348.21875,
      ha: 454,
      o: "m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 ",
    },
    A: {
      x_min: 0.03125,
      x_max: 906.953125,
      ha: 1008,
      o: "m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 ",
    },
    "\u2018": {
      x_min: 1,
      x_max: 139.890625,
      ha: 236,
      o: "m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 ",
    },
    : {
      x_min: -70,
      x_max: 283,
      ha: 361,
      o: "m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 ",
    },
    : {
      x_min: -0.21875,
      x_max: 773.21875,
      ha: 857,
      o: "m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 ",
    },
    : {
      x_min: 0,
      x_max: 765.5625,
      ha: 809,
      o: "m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 ",
    },
    O: {
      x_min: 0,
      x_max: 958,
      ha: 1057,
      o: "m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 ",
    },
    n: {
      x_min: 0,
      x_max: 615,
      ha: 724,
      o: "m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 ",
    },
    l: {
      x_min: 41,
      x_max: 166,
      ha: 279,
      o: "m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 ",
    },
    "\xA4": {
      x_min: 40.09375,
      x_max: 728.796875,
      ha: 825,
      o: "m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 ",
    },
    : {
      x_min: 0,
      x_max: 632.328125,
      ha: 679,
      o: "m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 ",
    },
    p: {
      x_min: 0,
      x_max: 685,
      ha: 786,
      o: "m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 ",
    },
    "\u2021": {
      x_min: 0,
      x_max: 777,
      ha: 835,
      o: "m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 ",
    },
    : {
      x_min: 0,
      x_max: 808,
      ha: 907,
      o: "m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 ",
    },
    : {
      x_min: 0.78125,
      x_max: 697,
      ha: 810,
      o: "m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 ",
    },
  },
  FG = "normal",
  NG = 1189,
  UG = -100,
  zG = "normal",
  HG = { yMin: -334, xMin: -111, yMax: 1189, xMax: 1672 },
  GG = 1e3,
  VG = {
    postscript_name: "Helvetiker-Regular",
    version_string: "Version 1.00 2004 initial release",
    vendor_url: "http://www.magenta.gr/",
    full_font_name: "Helvetiker",
    font_family_name: "Helvetiker",
    copyright: "Copyright (c) \u039Cagenta ltd, 2004",
    description: "",
    trademark: "",
    designer: "",
    designer_url: "",
    unique_font_identifier: "\u039Cagenta ltd:Helvetiker:22-10-104",
    license_url: "http://www.ellak.gr/fonts/MgOpen/license.html",
    license_description: `Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\r
\r
Permission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license ("Fonts") and associated documentation files (the "Font Software"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \r
\r
The above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\r
\r
The Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word "MgOpen", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\r
\r
This License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the "MgOpen" name.\r
\r
The Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \r
\r
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.`,
    manufacturer_name: "\u039Cagenta ltd",
    font_sub_family_name: "Regular",
  },
  WG = -334,
  jG = "Helvetiker",
  $G = 1522,
  QG = 50,
  XG = {
    glyphs: qG,
    cssFontWeight: FG,
    ascender: NG,
    underlinePosition: UG,
    cssFontStyle: zG,
    boundingBox: HG,
    resolution: GG,
    original_font_information: VG,
    descender: WG,
    familyName: jG,
    lineHeight: $G,
    underlineThickness: QG,
  },
  _o = nn(
    nn(
      {},
      window.THREE
        ? window.THREE
        : {
            CircleBufferGeometry: Ga,
            Group: zi,
            Mesh: Xt,
            MeshLambertMaterial: Zs,
            TextGeometry: nb,
            Vector3: X,
          }
    ),
    {},
    { Font: F8, TextGeometry: nb }
  ),
  nM = Wi({
    props: {
      labelsData: { default: [] },
      labelLat: { default: "lat" },
      labelLng: { default: "lng" },
      labelAltitude: { default: 0 },
      labelText: { default: "text" },
      labelSize: { default: 0.5 },
      labelTypeFace: {
        default: XG,
        onChange: function (e, t) {
          t.font = new _o.Font(e)
        },
      },
      labelColor: {
        default: function () {
          return "lightgrey"
        },
      },
      labelRotation: { default: 0 },
      labelResolution: { default: 3 },
      labelIncludeDot: { default: !0 },
      labelDotRadius: { default: 0.1 },
      labelDotOrientation: {
        default: function () {
          return "bottom"
        },
      },
      labelsTransitionDuration: { default: 1e3, triggerUpdate: !1 },
    },
    init: function (e, t) {
      Fn(e), (t.scene = e)
    },
    update: function (e) {
      var t = Ye(e.labelLat),
        i = Ye(e.labelLng),
        r = Ye(e.labelAltitude),
        s = Ye(e.labelText),
        o = Ye(e.labelSize),
        a = Ye(e.labelRotation),
        A = Ye(e.labelColor),
        c = Ye(e.labelIncludeDot),
        d = Ye(e.labelDotRadius),
        p = Ye(e.labelDotOrientation),
        m = new Set(["right", "top", "bottom"]),
        y = (2 * Math.PI * ti) / 360,
        x = new _o.CircleBufferGeometry(1, 16)
      Sr(e.labelsData, e.scene, {
        createObj: function () {
          var C = new _o.MeshLambertMaterial(),
            M = new _o.Group()
          return (
            M.add(new _o.Mesh(x, C)),
            M.add(new _o.Mesh(void 0, C)),
            (M.__globeObjType = "label"),
            M
          )
        },
        updateObj: function (C, M) {
          var _ = Gi(C.children, 2),
            R = _[0],
            T = _[1],
            L = A(M),
            B = os(L)
          T.material.color.set(Qs(L)),
            (T.material.transparent = B < 1),
            (T.material.opacity = B)
          var k = c(M),
            O = p(M)
          !k || (!m.has(O) && (O = "bottom"))
          var W = k ? +d(M) * y : 1e-12
          R.scale.x = R.scale.y = W
          var z = +o(M) * y
          if (
            ((T.geometry = new _o.TextGeometry(s(M), {
              font: e.font,
              size: z,
              height: 0,
              curveSegments: e.labelResolution,
            })),
            O !== "right" && T.geometry.center(),
            k)
          ) {
            var P = W + z / 2
            O === "right" && (T.position.x = P),
              (T.position.y = {
                right: -z / 2,
                top: P + z / 2,
                bottom: -P - z / 2,
              }[O])
          }
          var N = function (Y) {
              var ne = (C.__currentTargetD = Y),
                le = ne.lat,
                Te = ne.lng,
                Ae = ne.alt,
                ge = ne.rot,
                Me = ne.scale
              Object.assign(C.position, Qo(le, Te, Ae)),
                C.lookAt(e.scene.localToWorld(new _o.Vector3(0, 0, 0))),
                C.rotateY(Math.PI),
                C.rotateZ((-ge * Math.PI) / 180),
                (C.scale.x = C.scale.y = C.scale.z = Me)
            },
            G = { lat: +t(M), lng: +i(M), alt: +r(M), rot: +a(M), scale: 1 },
            j = C.__currentTargetD || Object.assign({}, G, { scale: 1e-12 })
          Object.keys(G).some(function (V) {
            return j[V] !== G[V]
          }) &&
            (!e.labelsTransitionDuration || e.labelsTransitionDuration < 0
              ? N(G)
              : new xn.Tween(j)
                  .to(G, e.labelsTransitionDuration)
                  .easing(xn.Easing.Quadratic.InOut)
                  .onUpdate(N)
                  .start())
        },
      })
    },
  }),
  YG = window.THREE ? window.THREE : { BufferGeometry: yt },
  ZG = (function (n) {
    H8(t, n)
    var e = W8(t)
    function t() {
      var i,
        r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1,
        s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 32
      U8(this, t),
        (i = e.call(this)),
        (i.type = "CircleLineGeometry"),
        (i.parameters = { radius: r, segmentCount: s })
      for (var o = [], a = 0; a <= s; a++) {
        var A = (a / s - 0.25) * Math.PI * 2
        o.push({ x: Math.cos(A) * r, y: Math.sin(A) * r, z: 0 })
      }
      return i.setFromPoints(o), i
    }
    return z8(t)
  })(YG.BufferGeometry),
  kl = window.THREE
    ? window.THREE
    : { Color: Ke, Group: zi, Line: br, LineBasicMaterial: Nn, Vector3: X },
  iM = Wi({
    props: {
      ringsData: { default: [] },
      ringLat: { default: "lat" },
      ringLng: { default: "lng" },
      ringAltitude: { default: 0.0015 },
      ringColor: {
        default: function () {
          return "#ffffaa"
        },
        triggerUpdate: !1,
      },
      ringResolution: { default: 64, triggerUpdate: !1 },
      ringMaxRadius: { default: 2, triggerUpdate: !1 },
      ringPropagationSpeed: { default: 1, triggerUpdate: !1 },
      ringRepeatPeriod: { default: 700, triggerUpdate: !1 },
    },
    init: function (e, t) {
      Fn(e),
        (t.scene = e),
        new X2().onTick.add(function (i) {
          if (!!t.ringsData.length) {
            var r = Ye(t.ringColor),
              s = Ye(t.ringAltitude),
              o = Ye(t.ringMaxRadius),
              a = Ye(t.ringPropagationSpeed),
              A = Ye(t.ringRepeatPeriod)
            t.ringsData
              .filter(function (c) {
                return c.__threeObj
              })
              .forEach(function (c) {
                var d = c.__threeObj
                if ((d.__nextRingTime || 0) <= i) {
                  var p = A(c) / 1e3
                  d.__nextRingTime = i + (p <= 0 ? 1 / 0 : p)
                  var m = new kl.Line(
                      new ZG(1, t.ringResolution),
                      new kl.LineBasicMaterial()
                    ),
                    y = r(c),
                    x = y instanceof Array || y instanceof Function,
                    S
                  x
                    ? y instanceof Array
                      ? ((S = Ic()
                          .domain(
                            y.map(function (k, O) {
                              return O / (y.length - 1)
                            })
                          )
                          .range(y)),
                        (m.material.transparent = y.some(function (k) {
                          return os(k) < 1
                        })))
                      : ((S = y), (m.material.transparent = !0))
                    : ((m.material.color = new kl.Color(Qs(y))),
                      EG(m.material, os(y)))
                  var C = ti * (1 + s(c)),
                    M = o(c),
                    _ = (M * Math.PI) / 180,
                    R = a(c),
                    T = R <= 0,
                    L = function (O) {
                      var W = O.t,
                        z = (T ? 1 - W : W) * _
                      if (
                        ((m.scale.x = m.scale.y = C * Math.sin(z)),
                        (m.position.z = C * (1 - Math.cos(z))),
                        x)
                      ) {
                        var P = S(W)
                        ;(m.material.color = new kl.Color(Qs(P))),
                          m.material.transparent && (m.material.opacity = os(P))
                      }
                    }
                  if (R === 0) L({ t: 0 }), d.add(m)
                  else {
                    var B = Math.abs(M / R) * 1e3
                    new xn.Tween({ t: 0 })
                      .to({ t: 1 }, B)
                      .onUpdate(L)
                      .onStart(function () {
                        return d.add(m)
                      })
                      .onComplete(function () {
                        d.remove(m), $8(m)
                      })
                      .start()
                  }
                }
              })
          }
        })
    },
    update: function (e) {
      var t = Ye(e.ringLat),
        i = Ye(e.ringLng),
        r = Ye(e.ringAltitude),
        s = e.scene.localToWorld(new kl.Vector3(0, 0, 0))
      Sr(
        e.ringsData,
        e.scene,
        {
          createObj: function () {
            var a = new kl.Group()
            return (a.__globeObjType = "ring"), a
          },
          updateObj: function (a, A) {
            var c = t(A),
              d = i(A),
              p = r(A)
            Object.assign(a.position, Qo(c, d, p)), a.lookAt(s)
          },
        },
        { removeDelay: 3e4 }
      )
    },
  }),
  JG = nn(nn({}, window.THREE ? window.THREE : {}), {}, { CSS2DObject: N8 }),
  rM = Wi({
    props: {
      htmlElementsData: { default: [] },
      htmlLat: { default: "lat" },
      htmlLng: { default: "lng" },
      htmlAltitude: { default: 0 },
      htmlElement: {},
      htmlTransitionDuration: { default: 1e3, triggerUpdate: !1 },
      isBehindGlobe: {
        onChange: function () {
          this.updateObjVisibility()
        },
        triggerUpdate: !1,
      },
    },
    methods: {
      updateObjVisibility: function (e, t) {
        var i = t
          ? [t]
          : e.htmlElementsData
              .map(function (r) {
                return r.__threeObj
              })
              .filter(function (r) {
                return r
              })
        i.forEach(function (r) {
          return (r.visible = !e.isBehindGlobe || !e.isBehindGlobe(r.position))
        })
      },
    },
    init: function (e, t) {
      Fn(e), (t.scene = e)
    },
    update: function (e, t) {
      var i = this,
        r = Ye(e.htmlLat),
        s = Ye(e.htmlLng),
        o = Ye(e.htmlAltitude),
        a = Ye(e.htmlElement)
      Sr(e.htmlElementsData, e.scene, {
        purge: t.hasOwnProperty("htmlElement"),
        createObj: function (c) {
          var d = a(c),
            p = new JG.CSS2DObject(d)
          return (p.__globeObjType = "html"), p
        },
        updateObj: function (c, d) {
          var p = function (x) {
              var S = (c.__currentTargetD = x),
                C = S.alt,
                M = S.lat,
                _ = S.lng
              Object.assign(c.position, Qo(M, _, C)), i.updateObjVisibility(c)
            },
            m = { lat: +r(d), lng: +s(d), alt: +o(d) }
          !e.htmlTransitionDuration ||
          e.htmlTransitionDuration < 0 ||
          !c.__currentTargetD
            ? p(m)
            : new xn.Tween(c.__currentTargetD)
                .to(m, e.pointsTransitionDuration)
                .easing(xn.Easing.Quadratic.InOut)
                .onUpdate(p)
                .start()
        },
      })
    },
  }),
  Mm = window.THREE
    ? window.THREE
    : { Mesh: Xt, MeshLambertMaterial: Zs, SphereGeometry: As },
  sM = Wi({
    props: {
      objectsData: { default: [] },
      objectLat: { default: "lat" },
      objectLng: { default: "lng" },
      objectAltitude: { default: 0.01 },
      objectThreeObject: {
        default: new Mm.Mesh(
          new Mm.SphereGeometry(1, 16, 8),
          new Mm.MeshLambertMaterial({
            color: "#ffffaa",
            transparent: !0,
            opacity: 0.7,
          })
        ),
      },
    },
    init: function (e, t) {
      Fn(e), (t.scene = e)
    },
    update: function (e, t) {
      var i = Ye(e.objectLat),
        r = Ye(e.objectLng),
        s = Ye(e.objectAltitude),
        o = Ye(e.objectThreeObject)
      Sr(e.objectsData, e.scene, {
        purge: t.hasOwnProperty("objectThreeObject"),
        createObj: function (A) {
          var c = o(A)
          return (
            e.objectThreeObject === c && (c = c.clone()),
            (c.__globeObjType = "object"),
            c
          )
        },
        updateObj: function (A, c) {
          var d = +i(c),
            p = +r(c),
            m = +s(c)
          Object.assign(A.position, Qo(d, p, m))
        },
      })
    },
  }),
  oM = Wi({
    props: {
      customLayerData: { default: [] },
      customThreeObject: {},
      customThreeObjectUpdate: { triggerUpdate: !1 },
    },
    init: function (e, t) {
      Fn(e), (t.scene = e)
    },
    update: function (e, t) {
      e.customThreeObjectUpdate || Fn(e.scene)
      var i = Ye(e.customThreeObject),
        r = Ye(e.customThreeObjectUpdate)
      Sr(e.customLayerData, e.scene, {
        purge: t.hasOwnProperty("customThreeObject"),
        createObj: function (o) {
          var a = i(o, ti)
          return (
            a &&
              (e.customThreeObject === a && (a = a.clone()),
              (a.__globeObjType = "custom")),
            a
          )
        },
        updateObj: function (o, a) {
          return r(o, a, ti)
        },
      })
    },
  }),
  qh = window.THREE ? window.THREE : { Group: zi, Vector2: qe, Vector3: X },
  KG = [
    "globeLayer",
    "pointsLayer",
    "arcsLayer",
    "hexBinLayer",
    "polygonsLayer",
    "hexedPolygonsLayer",
    "pathsLayer",
    "tilesLayer",
    "labelsLayer",
    "ringsLayer",
    "htmlElementsLayer",
    "objectsLayer",
    "customLayer",
  ],
  aM = Ar("globeLayer", Q8),
  eV = Object.assign.apply(
    Object,
    gn(
      [
        "globeImageUrl",
        "bumpImageUrl",
        "showGlobe",
        "showGraticules",
        "showAtmosphere",
        "atmosphereColor",
        "atmosphereAltitude",
      ].map(function (n) {
        return Li({}, n, aM.linkProp(n))
      })
    )
  ),
  tV = Object.assign.apply(
    Object,
    gn(
      ["globeMaterial"].map(function (n) {
        return Li({}, n, aM.linkMethod(n))
      })
    )
  ),
  nV = Ar("pointsLayer", X8),
  iV = Object.assign.apply(
    Object,
    gn(
      [
        "pointsData",
        "pointLat",
        "pointLng",
        "pointColor",
        "pointAltitude",
        "pointRadius",
        "pointResolution",
        "pointsMerge",
        "pointsTransitionDuration",
      ].map(function (n) {
        return Li({}, n, nV.linkProp(n))
      })
    )
  ),
  rV = Ar("arcsLayer", Y8),
  sV = Object.assign.apply(
    Object,
    gn(
      [
        "arcsData",
        "arcStartLat",
        "arcStartLng",
        "arcEndLat",
        "arcEndLng",
        "arcColor",
        "arcAltitude",
        "arcAltitudeAutoScale",
        "arcStroke",
        "arcCurveResolution",
        "arcCircularResolution",
        "arcDashLength",
        "arcDashGap",
        "arcDashInitialGap",
        "arcDashAnimateTime",
        "arcsTransitionDuration",
      ].map(function (n) {
        return Li({}, n, rV.linkProp(n))
      })
    )
  ),
  oV = Ar("hexBinLayer", Z8),
  aV = Object.assign.apply(
    Object,
    gn(
      [
        "hexBinPointsData",
        "hexBinPointLat",
        "hexBinPointLng",
        "hexBinPointWeight",
        "hexBinResolution",
        "hexMargin",
        "hexTopCurvatureResolution",
        "hexTopColor",
        "hexSideColor",
        "hexAltitude",
        "hexBinMerge",
        "hexTransitionDuration",
      ].map(function (n) {
        return Li({}, n, oV.linkProp(n))
      })
    )
  ),
  lV = Ar("hexedPolygonsLayer", K8),
  cV = Object.assign.apply(
    Object,
    gn(
      [
        "hexPolygonsData",
        "hexPolygonGeoJsonGeometry",
        "hexPolygonColor",
        "hexPolygonAltitude",
        "hexPolygonResolution",
        "hexPolygonMargin",
        "hexPolygonCurvatureResolution",
        "hexPolygonsTransitionDuration",
      ].map(function (n) {
        return Li({}, n, lV.linkProp(n))
      })
    )
  ),
  AV = Ar("polygonsLayer", J8),
  uV = Object.assign.apply(
    Object,
    gn(
      [
        "polygonsData",
        "polygonGeoJsonGeometry",
        "polygonCapColor",
        "polygonCapMaterial",
        "polygonSideColor",
        "polygonSideMaterial",
        "polygonStrokeColor",
        "polygonAltitude",
        "polygonCapCurvatureResolution",
        "polygonsTransitionDuration",
      ].map(function (n) {
        return Li({}, n, AV.linkProp(n))
      })
    )
  ),
  fV = Ar("pathsLayer", eM),
  hV = Object.assign.apply(
    Object,
    gn(
      [
        "pathsData",
        "pathPoints",
        "pathPointLat",
        "pathPointLng",
        "pathPointAlt",
        "pathResolution",
        "pathColor",
        "pathStroke",
        "pathDashLength",
        "pathDashGap",
        "pathDashInitialGap",
        "pathDashAnimateTime",
        "pathTransitionDuration",
      ].map(function (n) {
        return Li({}, n, fV.linkProp(n))
      })
    )
  ),
  dV = Ar("tilesLayer", tM),
  pV = Object.assign.apply(
    Object,
    gn(
      [
        "tilesData",
        "tileLat",
        "tileLng",
        "tileAltitude",
        "tileWidth",
        "tileHeight",
        "tileUseGlobeProjection",
        "tileMaterial",
        "tileCurvatureResolution",
        "tilesTransitionDuration",
      ].map(function (n) {
        return Li({}, n, dV.linkProp(n))
      })
    )
  ),
  mV = Ar("labelsLayer", nM),
  gV = Object.assign.apply(
    Object,
    gn(
      [
        "labelsData",
        "labelLat",
        "labelLng",
        "labelAltitude",
        "labelRotation",
        "labelText",
        "labelSize",
        "labelTypeFace",
        "labelColor",
        "labelResolution",
        "labelIncludeDot",
        "labelDotRadius",
        "labelDotOrientation",
        "labelsTransitionDuration",
      ].map(function (n) {
        return Li({}, n, mV.linkProp(n))
      })
    )
  ),
  yV = Ar("ringsLayer", iM),
  vV = Object.assign.apply(
    Object,
    gn(
      [
        "ringsData",
        "ringLat",
        "ringLng",
        "ringAltitude",
        "ringColor",
        "ringResolution",
        "ringMaxRadius",
        "ringPropagationSpeed",
        "ringRepeatPeriod",
      ].map(function (n) {
        return Li({}, n, yV.linkProp(n))
      })
    )
  ),
  _V = Ar("htmlElementsLayer", rM),
  xV = Object.assign.apply(
    Object,
    gn(
      [
        "htmlElementsData",
        "htmlLat",
        "htmlLng",
        "htmlAltitude",
        "htmlElement",
        "htmlTransitionDuration",
      ].map(function (n) {
        return Li({}, n, _V.linkProp(n))
      })
    )
  ),
  bV = Ar("objectsLayer", sM),
  wV = Object.assign.apply(
    Object,
    gn(
      [
        "objectsData",
        "objectLat",
        "objectLng",
        "objectAltitude",
        "objectThreeObject",
      ].map(function (n) {
        return Li({}, n, bV.linkProp(n))
      })
    )
  ),
  MV = Ar("customLayer", oM),
  SV = Object.assign.apply(
    Object,
    gn(
      ["customLayerData", "customThreeObject", "customThreeObjectUpdate"].map(
        function (n) {
          return Li({}, n, MV.linkProp(n))
        }
      )
    )
  ),
  EV = Wi({
    props: nn(
      nn(
        nn(
          nn(
            nn(
              nn(
                nn(
                  nn(
                    nn(
                      nn(
                        nn(
                          nn(
                            nn(
                              {
                                onGlobeReady: { triggerUpdate: !1 },
                                rendererSize: {
                                  default: new qh.Vector2(
                                    window.innerWidth,
                                    window.innerHeight
                                  ),
                                  onChange: function (e, t) {
                                    t.pathsLayer.rendererSize(e)
                                  },
                                  triggerUpdate: !1,
                                },
                              },
                              eV
                            ),
                            iV
                          ),
                          sV
                        ),
                        aV
                      ),
                      uV
                    ),
                    cV
                  ),
                  hV
                ),
                pV
              ),
              gV
            ),
            vV
          ),
          xV
        ),
        wV
      ),
      SV
    ),
    methods: nn(
      {
        getGlobeRadius: sb,
        getCoords: function (e) {
          for (
            var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            i[r - 1] = arguments[r]
          return Qo.apply(void 0, i)
        },
        toGeoCoords: function (e) {
          for (
            var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1;
            r < t;
            r++
          )
            i[r - 1] = arguments[r]
          return vG.apply(void 0, i)
        },
        setPointOfView: function (e, t, i) {
          var r = void 0
          if (t) {
            var s = sb(),
              o = i ? t.clone().sub(i) : t,
              a,
              A,
              c
            r = function (p) {
              a === void 0 && (a = o.length()),
                A === void 0 &&
                  (A = Math.sqrt(Math.pow(a, 2) - Math.pow(s, 2))),
                c === void 0 && (c = Math.acos(A / a))
              var m = o.distanceTo(p)
              if (m < A) return !1
              var y = p.length(),
                x = Math.acos(
                  (Math.pow(a, 2) + Math.pow(m, 2) - Math.pow(y, 2)) /
                    (2 * a * m)
                )
              return x < c
            }
          }
          e.layersThatNeedBehindGlobeChecker.forEach(function (d) {
            return d.isBehindGlobe(r)
          })
        },
      },
      tV
    ),
    stateInit: function () {
      var e = {
        globeLayer: Q8(),
        pointsLayer: X8(),
        arcsLayer: Y8(),
        hexBinLayer: Z8(),
        polygonsLayer: J8(),
        hexedPolygonsLayer: K8(),
        pathsLayer: eM(),
        tilesLayer: tM(),
        labelsLayer: nM(),
        ringsLayer: iM(),
        htmlElementsLayer: rM(),
        objectsLayer: sM(),
        customLayer: oM(),
      }
      return nn(
        nn({}, e),
        {},
        {
          layersThatNeedBehindGlobeChecker: Object.values(e).filter(function (
            t
          ) {
            return t.hasOwnProperty("isBehindGlobe")
          }),
        }
      )
    },
    init: function (e, t, i) {
      var r = i.animateIn,
        s = r === void 0 ? !0 : r,
        o = i.waitForGlobeReady,
        a = o === void 0 ? !0 : o
      Fn(e),
        e.add((t.scene = new qh.Group())),
        (t.scene.visible = !1),
        KG.forEach(function (c) {
          var d = new qh.Group()
          t.scene.add(d), t[c](d)
        })
      var A = function () {
        if (s) {
          t.scene.scale.set(1e-6, 1e-6, 1e-6),
            new xn.Tween({ k: 1e-6 })
              .to({ k: 1 }, 600)
              .easing(xn.Easing.Quadratic.Out)
              .onUpdate(function (p) {
                var m = p.k
                return t.scene.scale.set(m, m, m)
              })
              .start()
          var d = new qh.Vector3(0, 1, 0)
          new xn.Tween({ rot: Math.PI * 2 })
            .to({ rot: 0 }, 1200)
            .easing(xn.Easing.Quintic.Out)
            .onUpdate(function (p) {
              var m = p.rot
              return t.scene.setRotationFromAxisAngle(d, m)
            })
            .start()
        }
        ;(t.scene.visible = !0), t.onGlobeReady && t.onGlobeReady()
      }
      a ? t.globeLayer.onReady(A) : A(),
        (function c() {
          requestAnimationFrame(c), xn.update()
        })()
    },
    update: function (e) {},
  })
function TV(n) {
  var e =
      arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object,
    t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
    i = (function (r) {
      H8(o, r)
      var s = W8(o)
      function o() {
        var a
        U8(this, o)
        for (var A = arguments.length, c = new Array(A), d = 0; d < A; d++)
          c[d] = arguments[d]
        return (
          (a = s.call.apply(s, [this].concat(c))),
          (a.__kapsuleInstance = n
            .apply(void 0, c)
            .apply(void 0, [].concat(gn(t ? [V8(a)] : []), c))),
          a
        )
      }
      return z8(o)
    })(e)
  return (
    Object.keys(n()).forEach(function (r) {
      return (i.prototype[r] = function () {
        var s,
          o = (s = this.__kapsuleInstance)[r].apply(s, arguments)
        return o === this.__kapsuleInstance ? this : o
      })
    }),
    i
  )
}
var CV = window.THREE ? window.THREE : { Group: zi },
  RV = TV(EV, CV.Group, !0),
  PV = Nc(() => ({ provide: { ThreeGlobe: RV } })),
  LV = [ER, zR, eP, vF, wF, MF, SF, PV]
const DV = {
    __name: "error-404",
    props: {
      appName: { type: String, default: "Nuxt" },
      version: { type: String, default: "" },
      statusCode: { type: String, default: "404" },
      statusMessage: { type: String, default: "Not Found" },
      description: {
        type: String,
        default: "Sorry, the page you are looking for could not be found.",
      },
      backHome: { type: String, default: "Go back home" },
    },
    setup(n, { expose: e }) {
      e()
      const t = n
      Fs({
        title: `${t.statusCode} - ${t.statusMessage} | ${t.appName}`,
        script: [],
        style: [
          {
            children:
              '*,:before,:after{-webkit-box-sizing:border-box;box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}*{--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(14, 165, 233, .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000}:root{-moz-tab-size:4;-o-tab-size:4;tab-size:4}a{color:inherit;text-decoration:inherit}body{margin:0;font-family:inherit;line-height:inherit}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";line-height:1.5}h1,p{margin:0}h1{font-size:inherit;font-weight:inherit}',
          },
        ],
      })
      const i = { props: t, useHead: Fs }
      return (
        Object.defineProperty(i, "__isScriptSetup", {
          enumerable: !1,
          value: !0,
        }),
        i
      )
    },
  },
  IV = n => (Oc("data-v-011aae6d"), (n = n()), qc(), n),
  BV = {
    class:
      "font-sans antialiased bg-white dark:bg-black text-black dark:text-white grid min-h-screen place-content-center overflow-hidden",
  },
  kV = IV(() =>
    bt("div", { class: "fixed left-0 right-0 spotlight z-10" }, null, -1)
  ),
  OV = { class: "max-w-520px text-center z-20" },
  qV = ["textContent"],
  FV = ["textContent"],
  NV = { class: "w-full flex items-center justify-center" }
function UV(n, e, t, i, r, s) {
  const o = pc
  return (
    It(),
    qr("div", BV, [
      kV,
      bt("div", OV, [
        bt(
          "h1",
          {
            class: "text-8xl sm:text-10xl font-medium mb-8",
            textContent: vr(t.statusCode),
          },
          null,
          8,
          qV
        ),
        bt(
          "p",
          {
            class:
              "text-xl px-8 sm:px-0 sm:text-4xl font-light mb-16 leading-tight",
            textContent: vr(t.description),
          },
          null,
          8,
          FV
        ),
        bt("div", NV, [
          At(
            o,
            {
              to: "/",
              class:
                "gradient-border text-md sm:text-xl py-2 px-4 sm:py-3 sm:px-6 cursor-pointer",
            },
            { default: Xn(() => [hs(vr(t.backHome), 1)]), _: 1 }
          ),
        ]),
      ]),
    ])
  )
}
var Ab = ps(DV, [
  ["render", UV],
  ["__scopeId", "data-v-011aae6d"],
])
const zV = {
    __name: "error-500",
    props: {
      appName: { type: String, default: "Nuxt" },
      version: { type: String, default: "" },
      statusCode: { type: String, default: "500" },
      statusMessage: { type: String, default: "Server error" },
      description: {
        type: String,
        default: "This page is temporarily unavailable.",
      },
    },
    setup(n, { expose: e }) {
      e()
      const t = n
      Fs({
        title: `${t.statusCode} - ${t.statusMessage} | ${t.appName}`,
        script: [],
        style: [
          {
            children:
              '*,:before,:after{-webkit-box-sizing:border-box;box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}*{--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(14, 165, 233, .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000}:root{-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{margin:0;font-family:inherit;line-height:inherit}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";line-height:1.5}h1,p{margin:0}h1{font-size:inherit;font-weight:inherit}',
          },
        ],
      })
      const i = { props: t, useHead: Fs }
      return (
        Object.defineProperty(i, "__isScriptSetup", {
          enumerable: !1,
          value: !0,
        }),
        i
      )
    },
  },
  HV = n => (Oc("data-v-6aee6495"), (n = n()), qc(), n),
  GV = {
    class:
      "font-sans antialiased bg-white dark:bg-black text-black dark:text-white grid min-h-screen place-content-center overflow-hidden",
  },
  VV = HV(() =>
    bt(
      "div",
      { class: "fixed -bottom-1/2 left-0 right-0 h-1/2 spotlight" },
      null,
      -1
    )
  ),
  WV = { class: "max-w-520px text-center" },
  jV = ["textContent"],
  $V = ["textContent"]
function QV(n, e, t, i, r, s) {
  return (
    It(),
    qr("div", GV, [
      VV,
      bt("div", WV, [
        bt(
          "h1",
          {
            class: "text-8xl sm:text-10xl font-medium mb-8",
            textContent: vr(t.statusCode),
          },
          null,
          8,
          jV
        ),
        bt(
          "p",
          {
            class:
              "text-xl px-8 sm:px-0 sm:text-4xl font-light mb-16 leading-tight",
            textContent: vr(t.description),
          },
          null,
          8,
          $V
        ),
      ]),
    ])
  )
}
var ub = ps(zV, [
  ["render", QV],
  ["__scopeId", "data-v-6aee6495"],
])
const XV = {
    __name: "error-dev",
    props: {
      appName: { type: String, default: "Nuxt" },
      version: { type: String, default: "" },
      statusCode: { type: String, default: "500" },
      statusMessage: { type: String, default: "Server error" },
      description: {
        type: String,
        default:
          "An error occurred in the application and the page could not be served. If you are the application owner, check your server logs for details.",
      },
      stack: { type: String, default: "" },
    },
    setup(n, { expose: e }) {
      e()
      const t = n
      Fs({
        title: `${t.statusCode} - ${t.statusMessage} | ${t.appName}`,
        script: [],
        style: [
          {
            children:
              '*,:before,:after{-webkit-box-sizing:border-box;box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}*{--tw-ring-inset:var(--tw-empty, );--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(14, 165, 233, .5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000}:root{-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{margin:0;font-family:inherit;line-height:inherit}html{-webkit-text-size-adjust:100%;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";line-height:1.5}h1,p,pre{margin:0}h1{font-size:inherit;font-weight:inherit}pre{font-size:1em;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}',
          },
        ],
      })
      const i = { props: t, useHead: Fs }
      return (
        Object.defineProperty(i, "__isScriptSetup", {
          enumerable: !1,
          value: !0,
        }),
        i
      )
    },
  },
  YV = n => (Oc("data-v-693cabb2"), (n = n()), qc(), n),
  ZV = {
    class:
      "font-sans antialiased bg-white px-10 pt-14 dark:bg-black text-black dark:text-white min-h-screen flex flex-col",
  },
  JV = YV(() =>
    bt("div", { class: "fixed left-0 right-0 spotlight" }, null, -1)
  ),
  KV = ["textContent"],
  eW = ["textContent"],
  tW = {
    class:
      "bg-white rounded-t-md bg-black/5 dark:bg-white/10 flex-1 overflow-y-auto h-auto",
  },
  nW = ["innerHTML"]
function iW(n, e, t, i, r, s) {
  return (
    It(),
    qr("div", ZV, [
      JV,
      bt(
        "h1",
        {
          class: "text-6xl sm:text-8xl font-medium mb-6",
          textContent: vr(t.statusCode),
        },
        null,
        8,
        KV
      ),
      bt(
        "p",
        {
          class: "text-xl sm:text-2xl font-light mb-8 leading-tight",
          textContent: vr(t.description),
        },
        null,
        8,
        eW
      ),
      bt("div", tW, [
        bt(
          "pre",
          {
            class: "text-xl font-light leading-tight z-10 p-8",
            innerHTML: t.stack,
          },
          null,
          8,
          nW
        ),
      ]),
    ])
  )
}
var rW = ps(XV, [
  ["render", iW],
  ["__scopeId", "data-v-693cabb2"],
])
const sW = {
  __name: "nuxt-error-page",
  props: { error: Object },
  setup(n, { expose: e }) {
    var m
    e()
    const t = n,
      i = t.error,
      r = (i.stack || "")
        .split(
          `
`
        )
        .splice(1)
        .map(y => ({
          text: y.replace("webpack:/", "").replace(".vue", ".js").trim(),
          internal:
            (y.includes("node_modules") && !y.includes(".cache")) ||
            y.includes("internal") ||
            y.includes("new Promise"),
        }))
        .map(
          y =>
            `<span class="stack${y.internal ? " internal" : ""}">${
              y.text
            }</span>`
        ).join(`
`),
      s = String(i.statusCode || 500),
      o = s === "404",
      a =
        (m = i.statusMessage) != null
          ? m
          : o
          ? "Page Not Found"
          : "Internal Server Error",
      A = i.message || i.toString(),
      p = {
        props: t,
        error: i,
        stacktrace: r,
        statusCode: s,
        is404: o,
        statusMessage: a,
        description: A,
        stack: void 0,
        ErrorTemplate: o ? Ab : ub,
        Error404: Ab,
        Error500: ub,
        ErrorDev: rW,
      }
    return (
      Object.defineProperty(p, "__isScriptSetup", {
        enumerable: !1,
        value: !0,
      }),
      p
    )
  },
}
function oW(n, e, t, i, r, s) {
  return (
    It(),
    Kt(
      i.ErrorTemplate,
      pb(
        Vg({
          statusCode: i.statusCode,
          statusMessage: i.statusMessage,
          description: i.description,
          stack: i.stack,
        })
      ),
      null,
      16
    )
  )
}
var aW = ps(sW, [["render", oW]])
const lW = {
  __name: "nuxt-root",
  setup(n, { expose: e }) {
    e()
    const t = xr(),
      i = () => t.callHook("app:suspense:resolve"),
      r = t.hooks.callHookWith(a => a.map(A => A()), "vue:setup"),
      s = QA()
    o0((a, A, c) => {
      t.hooks
        .callHook("vue:error", a, A, c)
        .catch(d => console.error("[nuxt] Error in `vue:error` hook", d))
    })
    const o = {
      nuxtApp: t,
      onResolve: i,
      results: r,
      error: s,
      onErrorCaptured: o0,
      callWithNuxt: ya,
      throwError: Uh,
      useError: QA,
      useNuxtApp: xr,
      ErrorComponent: aW,
    }
    return (
      Object.defineProperty(o, "__isScriptSetup", {
        enumerable: !1,
        value: !0,
      }),
      o
    )
  },
}
function cW(n, e, t, i, r, s) {
  const o = Bu("App")
  return (
    It(),
    Kt(
      kg,
      { onResolve: i.onResolve },
      {
        default: Xn(() => [
          i.error
            ? (It(),
              Kt(i.ErrorComponent, { key: 0, error: i.error }, null, 8, [
                "error",
              ]))
            : (It(), Kt(o, { key: 1 })),
        ]),
        _: 1,
      }
    )
  )
}
var fb = ps(lW, [["render", cW]]),
  AW = zt(
    "/__NUXT_BASE__/twitter-icon.9ed5ba96.svg".replace("/__NUXT_BASE__", "")
  ),
  uW = zt(
    "/__NUXT_BASE__/facebook-icon.7dae577b.svg".replace("/__NUXT_BASE__", "")
  ),
  fW = zt(
    "/__NUXT_BASE__/telegram-icon.25c7b087.svg".replace("/__NUXT_BASE__", "")
  )
const hW = {},
  dW = { class: "flex w-full justify-center space-x-5" },
  pW = bt("img", { src: AW }, null, -1),
  mW = bt("img", { src: uW }, null, -1),
  gW = bt("img", { src: fW }, null, -1)
function yW(n, e) {
  const t = pc
  return (
    It(),
    qr("div", dW, [
      At(
        t,
        { target: "_blank", to: "https://twitter.com/heliumproio" },
        { default: Xn(() => [pW]), _: 1 }
      ),
      At(
        t,
        { target: "_blank", to: "https://www.facebook.com/heliumproapp" },
        { default: Xn(() => [mW]), _: 1 }
      ),
      At(
        t,
        { target: "_blank", to: "https://t.me/HeliumProApp" },
        { default: Xn(() => [gW]), _: 1 }
      ),
    ])
  )
}
var ly = ps(hW, [["render", yW]])
function vW(n, e) {
  return (
    It(),
    Kt(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        "aria-hidden": "true",
      },
      [
        At("path", {
          "fill-rule": "evenodd",
          d: "M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h6a1 1 0 110 2H4a1 1 0 01-1-1z",
          "clip-rule": "evenodd",
        }),
      ]
    )
  )
}
function _W(n, e) {
  return (
    It(),
    Kt(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        "aria-hidden": "true",
      },
      [
        At("path", {
          d: "M8 9a3 3 0 100-6 3 3 0 000 6zM8 11a6 6 0 016 6H2a6 6 0 016-6zM16 7a1 1 0 10-2 0v1h-1a1 1 0 100 2h1v1a1 1 0 102 0v-1h1a1 1 0 100-2h-1V7z",
        }),
      ]
    )
  )
}
function xW(n, e) {
  return (
    It(),
    Kt(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20",
        fill: "currentColor",
        "aria-hidden": "true",
      },
      [
        At("path", {
          "fill-rule": "evenodd",
          d: "M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z",
          "clip-rule": "evenodd",
        }),
      ]
    )
  )
}
function bW(n, e) {
  return (
    It(),
    Kt(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "2",
        stroke: "currentColor",
        "aria-hidden": "true",
      },
      [
        At("path", {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "M18 9v3m0 0v3m0-3h3m-3 0h-3m-2-5a4 4 0 11-8 0 4 4 0 018 0zM3 20a6 6 0 0112 0v1H3v-1z",
        }),
      ]
    )
  )
}
function wW(n, e) {
  return (
    It(),
    Kt(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "2",
        stroke: "currentColor",
        "aria-hidden": "true",
      },
      [
        At("path", {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z",
        }),
      ]
    )
  )
}
function MW(n, e) {
  return (
    It(),
    Kt(
      "svg",
      {
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24",
        "stroke-width": "2",
        stroke: "currentColor",
        "aria-hidden": "true",
      },
      [
        At("path", {
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          d: "M6 18L18 6M6 6l12 12",
        }),
      ]
    )
  )
}
var lM = [
    { name: "Home", link: "/" },
    { name: "Overview", link: "/overview" },
    { name: "Affiliate", link: "/affiliate" },
    { name: "HNT", link: "/hnt" },
    { name: "Store", link: "https://store.heliumpro.io/", target: "_blank" },
    { name: "Contact", link: "/contact" },
  ],
  cy = zt(
    "/__NUXT_BASE__/helium-logo-white.ffc9141a.svg".replace(
      "/__NUXT_BASE__",
      ""
    )
  )
const SW = {
    __name: "MobileDrawer",
    setup(n, { expose: e }) {
      e()
      const t = _r("drawerActive"),
        i = () => {
          t.value = !t.value
        },
        r = _n(() => window.location.origin),
        s = {
          drawerActive: t,
          toggleDrawer: i,
          locationOrigin: r,
          UserAddIcon: bW,
          UserIcon: wW,
          XIcon: MW,
          navItems: lM,
        }
      return (
        Object.defineProperty(s, "__isScriptSetup", {
          enumerable: !1,
          value: !0,
        }),
        s
      )
    },
  },
  Jd = n => (Oc("data-v-c24621f0"), (n = n()), qc(), n),
  EW = { class: "z-60 fixed left-0 h-screen w-full bg-[#1d1d1d]" },
  TW = { class: "flex h-full flex-col space-y-3 px-12 pt-24" },
  CW = ["href"],
  RW = Jd(() =>
    bt("span", { class: "font-semibold tracking-wide" }, "Login", -1)
  ),
  PW = Jd(() =>
    bt(
      "div",
      {
        class:
          "rounded-full bg-white bg-opacity-20 py-[3px] px-2 text-xs font-semibold tracking-wider",
      },
      " Pro Dashboard ",
      -1
    )
  ),
  LW = ["href"],
  DW = Jd(() =>
    bt("span", { class: "font-semibold tracking-wide" }, "Register", -1)
  ),
  IW = {
    class:
      "absolute top-0 left-0 flex w-full items-center justify-between pl-3 pr-5 pt-3",
  },
  BW = Jd(() => bt("img", { class: "w-36", src: cy }, null, -1))
function kW(n, e, t, i, r, s) {
  const o = pc,
    a = ly
  return (
    It(),
    qr("div", EW, [
      bt("div", TW, [
        (It(!0),
        qr(
          Qn,
          null,
          zg(
            i.navItems,
            (A, c) => (
              It(),
              Kt(
                o,
                {
                  key: c,
                  class: Ps([
                    "relative inline text-lg font-semibold capitalize duration-700",
                    A.link === n.$route.path ? "lineBefore" : "lineBeforeShort",
                  ]),
                  to: A.link,
                  onClick: i.toggleDrawer,
                },
                { default: Xn(() => [hs(vr(A.name), 1)]), _: 2 },
                1032,
                ["class", "to"]
              )
            )
          ),
          128
        )),
        bt(
          "a",
          {
            class: "flex items-center space-x-2",
            href: `${i.locationOrigin}/panel/login`,
          },
          [
            RW,
            At(i.UserIcon, { class: "h-5 w-5 text-white hover:opacity-75" }),
            PW,
          ],
          8,
          CW
        ),
        bt(
          "a",
          {
            class: "flex items-center space-x-1",
            href: `${i.locationOrigin}/panel/register`,
          },
          [
            DW,
            At(i.UserAddIcon, { class: "h-5 w-5 text-white hover:opacity-75" }),
          ],
          8,
          LW
        ),
        At(a, { class: "!justify-start" }),
      ]),
      bt("div", IW, [
        At(
          o,
          { to: "/", onClick: i.toggleDrawer },
          { default: Xn(() => [BW]), _: 1 }
        ),
        At(i.XIcon, { class: "h-8 w-8", onClick: i.toggleDrawer }),
      ]),
    ])
  )
}
var OW = ps(SW, [
  ["render", kW],
  ["__scopeId", "data-v-c24621f0"],
])
const qW = {
    __name: "Header",
    setup(n, { expose: e }) {
      e()
      const t = Xm("isOnTop", () => !0),
        i = Xm("drawerActive", () => !1),
        r = _n(() => window.location.origin)
      Ca("drawerActive", i)
      const s = () => {
          i.value = !i.value
        },
        o = () => {
          t.value = document.documentElement.scrollTop < 50
        }
      Ls(() => {
        window.addEventListener("scroll", o)
      }),
        Oo(() => {
          window.removeEventListener("scroll", o)
        })
      const a = {
        isOnTop: t,
        drawerActive: i,
        locationOrigin: r,
        toggleDrawer: s,
        handleScroll: o,
        MenuAlt2Icon: vW,
        UserAddIcon: _W,
        UserIcon: xW,
        MobileDrawer: OW,
        navItems: lM,
      }
      return (
        Object.defineProperty(a, "__isScriptSetup", {
          enumerable: !1,
          value: !0,
        }),
        a
      )
    },
  },
  Ay = n => (Oc("data-v-56afff47"), (n = n()), qc(), n),
  FW = { class: "flex items-center space-x-10" },
  NW = { class: "hidden space-x-7 lg:block" },
  UW = { class: "hidden items-center space-x-6 lg:flex" },
  zW = ["href"],
  HW = Ay(() =>
    bt("span", { class: "font-semibold tracking-wide" }, "Login", -1)
  ),
  GW = Ay(() =>
    bt(
      "div",
      {
        class:
          "rounded-full bg-white bg-opacity-20 py-[3px] px-2 text-xs font-semibold tracking-wider",
      },
      " Pro Dashboard ",
      -1
    )
  ),
  VW = ["href"],
  WW = Ay(() =>
    bt("span", { class: "font-semibold tracking-wide" }, "Register", -1)
  )
function jW(n, e, t, i, r, s) {
  const o = pc,
    a = ly
  return (
    It(),
    qr(
      "div",
      {
        class: Ps([
          "fixed left-0 top-0 z-50 flex w-full items-center justify-between bg-black bg-opacity-40 py-[10px] px-5 backdrop-blur-sm duration-500 lg:py-[20px] lg:pl-5 lg:pr-8",
          i.isOnTop ? "" : "lg:py-[10px]",
        ]),
      },
      [
        bt("div", FW, [
          At(
            o,
            { to: "/" },
            {
              default: Xn(() => [
                bt(
                  "img",
                  {
                    class: Ps([
                      "w-[154px] duration-500 lg:w-[150px]",
                      i.isOnTop ? "" : "lg:w-[140px]",
                    ]),
                    src: cy,
                  },
                  null,
                  2
                ),
              ]),
              _: 1,
            }
          ),
          bt("div", NW, [
            (It(!0),
            qr(
              Qn,
              null,
              zg(
                i.navItems,
                (A, c) => (
                  It(),
                  Kt(
                    o,
                    {
                      key: c,
                      class: Ps([
                        "font-semibold capitalize tracking-wide hover:opacity-75",
                        A.link === n.$route.path ? " opacity-75" : "",
                      ]),
                      target: A.target,
                      to: A.link,
                    },
                    { default: Xn(() => [hs(vr(A.name), 1)]), _: 2 },
                    1032,
                    ["class", "target", "to"]
                  )
                )
              ),
              128
            )),
          ]),
        ]),
        At(a, { class: "w-[200px]" }),
        bt("div", UW, [
          bt(
            "a",
            {
              class: "flex items-center space-x-2",
              href: `${i.locationOrigin}/panel/login`,
            },
            [
              At(i.UserIcon, { class: "h-5 w-5 text-white hover:opacity-75" }),
              HW,
              GW,
            ],
            8,
            zW
          ),
          bt(
            "a",
            {
              class: "flex items-center space-x-1",
              href: `${i.locationOrigin}/panel/register`,
            },
            [
              At(i.UserAddIcon, {
                class: "h-5 w-5 text-white hover:opacity-75",
              }),
              WW,
            ],
            8,
            VW
          ),
        ]),
        At(i.MenuAlt2Icon, {
          class: "block h-8 w-8 lg:hidden",
          onClick: i.toggleDrawer,
        }),
        At(
          Fc,
          { name: "slide-fade" },
          {
            default: Xn(() => [
              i.drawerActive
                ? (It(), Kt(i.MobileDrawer, { key: 0, class: "top-0" }))
                : Ss("", !0),
            ]),
            _: 1,
          }
        ),
      ],
      2
    )
  )
}
var $W = ps(qW, [
    ["render", jW],
    ["__scopeId", "data-v-56afff47"],
  ]),
  QW = zt(
    "/__NUXT_BASE__/googleplay.a58bd4e3.svg".replace("/__NUXT_BASE__", "")
  ),
  XW = zt("/__NUXT_BASE__/appstore.da75cc2c.svg".replace("/__NUXT_BASE__", ""))
const YW = {
    __name: "Footer",
    setup(n, { expose: e }) {
      e()
      const t = { SocialMedia: ly }
      return (
        Object.defineProperty(t, "__isScriptSetup", {
          enumerable: !1,
          value: !0,
        }),
        t
      )
    },
  },
  ZW = { class: "bg-primary-background py-7" },
  JW = {
    class:
      "container flex w-full flex-col items-center justify-center space-y-6",
  },
  KW = bt("div", null, [bt("img", { class: "w-40", src: cy })], -1),
  ej = {
    class:
      "flex flex-wrap justify-center space-y-3 space-x-4 space-y-reverse text-sm text-primary-text-color lg:space-x-8 lg:space-y-0",
  },
  tj = hs("Contact"),
  nj = hs("Privacy Policy"),
  ij = hs("Terms & Conditions"),
  rj = {
    class:
      "flex flex-col space-y-5 text-center text-sm text-primary-text-color",
  },
  sj = bt(
    "span",
    null,
    [hs(" Download "), bt("strong", null, "HNT WALLET APP")],
    -1
  ),
  oj = { class: "flex justify-center space-x-2" },
  aj = bt("img", { src: QW }, null, -1),
  lj = bt("img", { src: XW }, null, -1),
  cj = bt(
    "div",
    { class: "text-center text-sm text-primary-text-color" },
    [
      bt(
        "span",
        null,
        " Helium PRO | Copyright \xA92022 | All Rights Reserved"
      ),
    ],
    -1
  )
function Aj(n, e, t, i, r, s) {
  const o = pc,
    a = pc
  return (
    It(),
    qr("div", ZW, [
      bt("div", JW, [
        KW,
        bt("div", ej, [
          At(
            o,
            { class: "hover:opacity-80", to: "/contact" },
            { default: Xn(() => [tj]), _: 1 }
          ),
          At(
            o,
            { class: "hover:opacity-80", to: "/privacy" },
            { default: Xn(() => [nj]), _: 1 }
          ),
          At(
            o,
            { class: "hover:opacity-80", to: "/terms" },
            { default: Xn(() => [ij]), _: 1 }
          ),
        ]),
        At(i.SocialMedia),
        bt("div", rj, [
          sj,
          bt("div", oj, [
            At(
              a,
              {
                class: "w-44",
                target: "_blank",
                to: "https://play.google.com/store/apps/details?id=com.helium.wallet.app",
              },
              { default: Xn(() => [aj]), _: 1 }
            ),
            At(
              a,
              {
                class: "w-44",
                target: "_blank",
                to: "https://apps.apple.com/us/app/helium-hnt-wallet/id1609525848",
              },
              { default: Xn(() => [lj]), _: 1 }
            ),
          ]),
        ]),
        cj,
      ]),
    ])
  )
}
var uj = ps(YW, [["render", Aj]])
const fj = {}
function hj(n, e) {
  const t = $W,
    i = Bu("NuxtPage"),
    r = uj
  return It(), qr("div", null, [At(t), At(i), At(r)])
}
var dj = ps(fj, [["render", hj]])
globalThis.$fetch || (globalThis.$fetch = $9.create({ baseURL: X9() }))
let hb
const pj = pC(LV)
;(hb = async function () {
  var r
  const t = Boolean((r = window.__NUXT__) == null ? void 0 : r.serverRendered)
    ? Xw(fb)
    : Qw(fb)
  t.component("App", dj)
  const i = fC({ vueApp: t })
  i.hooks.hookOnce("app:suspense:resolve", () => {
    i.isHydrating = !1
  })
  try {
    await dC(i, pj)
  } catch (s) {
    await i.callHook("app:error", s), (i.payload.error = i.payload.error || s)
  }
  try {
    await i.hooks.callHook("app:created", t),
      await i.hooks.callHook("app:beforeMount", t),
      t.mount("#__nuxt"),
      await i.hooks.callHook("app:mounted", t),
      await Pu()
  } catch (s) {
    await i.callHook("app:error", s), (i.payload.error = i.payload.error || s)
  }
}),
  hb().catch(n => {
    console.error("Error while mounting app:", n)
  })
export {
  Pj as $,
  D2 as A,
  KT as B,
  Ke as C,
  L2 as D,
  vE as E,
  f0 as F,
  Mj as G,
  Sj as H,
  Ej as I,
  Xn as J,
  hs as K,
  pc as L,
  Gd as M,
  Tj as N,
  vj as O,
  ei as P,
  Cj as Q,
  ZA as R,
  Ld as S,
  E2 as T,
  Rj as U,
  kq as V,
  rn as W,
  Gw as X,
  Oc as Y,
  qc as Z,
  ps as _,
  bt as a,
  Lj as a0,
  Dj as a1,
  Ij as a2,
  Bj as a3,
  kj as a4,
  Oj as a5,
  qj as a6,
  Fj as a7,
  Nj as a8,
  Uj as a9,
  zj as aa,
  Hj as ab,
  Gj as ac,
  Vj as ad,
  Wj as ae,
  jj as af,
  $j as ag,
  Qj as ah,
  Kt as ai,
  mj as aj,
  gj as ak,
  At as b,
  qr as c,
  jE as d,
  _j as e,
  xj as f,
  bj as g,
  wj as h,
  Xm as i,
  Ls as j,
  Q4 as k,
  Iu as l,
  yj as m,
  Gn as n,
  It as o,
  Jb as p,
  Oo as q,
  $n as r,
  pn as s,
  zr as t,
  xr as u,
  Jl as v,
  ec as w,
  _n as x,
  a4 as y,
  Iq as z,
}
